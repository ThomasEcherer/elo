Ext.data.JsonP.pEFE7A0EF_91BC_4B57_9E2A_F8E29745A194({"guide":"<h1 id='pEFE7A0EF_91BC_4B57_9E2A_F8E29745A194-section-js-performance'>JS-Performance</h1>\n<div class='toc'>\n<p><strong>Contents</strong></p>\n<ul>\n<li>1. <a href='#!/guide/pEFE7A0EF_91BC_4B57_9E2A_F8E29745A194-section-schleifen-optimier%E2%80%8Ben'>Schleifen optimier​en</a>\n </li>\n<li>2. <a href='#!/guide/pEFE7A0EF_91BC_4B57_9E2A_F8E29745A194-section-vermeiden-von-eval-%28%29'>Vermeiden von eval ()</a>\n </li>\n<li>3. <a href='#!/guide/pEFE7A0EF_91BC_4B57_9E2A_F8E29745A194-section-iteration-%C3%BCber-cache-elemente'>Iteration über Cache-Elemente</a>\n </li>\n<li>4. <a href='#!/guide/pEFE7A0EF_91BC_4B57_9E2A_F8E29745A194-section-iteration-%C3%BCber-objekt-attribute'>Iteration über Objekt-Attribute</a>\n </li>\n<li>5. <a href='#!/guide/pEFE7A0EF_91BC_4B57_9E2A_F8E29745A194-section-konvertieren-von-nummern'>Konvertieren von Nummern</a>\n </li>\n</ul></div>\n\n<h2 id='pEFE7A0EF_91BC_4B57_9E2A_F8E29745A194-section-schleifen-optimier%E2%80%8Ben'>Schleifen optimier​en</h2>\n\n<p>JS berechnet beim Durchlaufen von Schleifen zu jedem Iterationsschritt die Länge des Arrays. Bei größeren Arrays sollte daher die maximal Anzahl in einer Variablen gespeichert werden.</p>\n\n<p>Teure Berechnungen und DOM-Operationen sollten zudem außerhalb von Schleifen erfolgen:</p>\n\n<pre><code>var names = ['George', 'Ringo', 'Paul', 'John', ………]; \n\nfor(var i=0, var length = names.length; i &lt; length; i++){ \n   doSomethingWith(names[i]); \n}\n</code></pre>\n\n<h2 id='pEFE7A0EF_91BC_4B57_9E2A_F8E29745A194-section-vermeiden-von-eval-%28%29'>Vermeiden von eval ()</h2>\n\n<p><span class=\"tag_warning\">Der Einsatz der JavaScript-Funktion <code>eval()</code> sollte vermieden werden, da dieser Aufruf zur Laufzeit kompiliert werden muss. Dies ist teuer und beinhaltet zusätzliche Sicherheitsrisiken.</span></p>\n\n<h2 id='pEFE7A0EF_91BC_4B57_9E2A_F8E29745A194-section-iteration-%C3%BCber-cache-elemente'>Iteration über Cache-Elemente</h2>\n\n<p>​\nIterieren über Objektattribute ist um ca. Faktor 6 langsamer als das Iterieren über ein einfaches Array. Werden Maps zum Zwischenspeichern von Objekten verwendet, sollte daher zwangsläufig parallel ein Array aufgebaut werden, falls später auf alle Elemente zugegriffen werden soll:</p>\n\n<p><span\nstyle='font-weight:bold'>Schlecht <code>for/in</code>: </span></p>\n\n<pre><code>for (var guid in sordMap) {\n    if (!sordMap.hasOwnProperty(guid)) continue;\n\n    // do something with sordMap[guid];\n}\n</code></pre>\n\n<p><span\nstyle='font-weight:bold'>Besser <code>for/i</code>:</span></p>\n\n<pre><code>var length;\nfor(var i=0, length=sordList.length; i &lt; j; i++){ \n   var sord = sordList[i]; \n}\n</code></pre>\n\n<h2 id='pEFE7A0EF_91BC_4B57_9E2A_F8E29745A194-section-iteration-%C3%BCber-objekt-attribute'>Iteration über Objekt-Attribute</h2>\n\n<p>Wird regelmäßig über alle Attribute eines dynamisch erzeugten Objekts iteriert empfiehlt es sich anstelle von <code>for (attName in obj)</code> beim Anlegen des Objekts eine Liste mit hinzugefügten Attributen zu pflegen. Iteriert wird anschließend über die Liste von Attributen:</p>\n\n<pre><code>var obj = {\n  _attrs = ['name', 'ort'],\n  name: 'Max',\n  ort: 'Stuttgart'\n};\n\nvar length;\nfor(var i=0, length=obj._attrs.length; i &lt; j; i++){ \n   var attr = obj._attrs[i];\n   var val = obj[attr]; \n}\n</code></pre>\n\n<h2 id='pEFE7A0EF_91BC_4B57_9E2A_F8E29745A194-section-konvertieren-von-nummern'>Konvertieren von Nummern</h2>\n\n<p>Werden JS-Strings in Nummern konvertiert, konnte kein großer Performance-Unterschied zwischen <code>parseInt()</code>, <code>parseFloat()</code> oder <code>Number()</code> identifiziert werden. Hier kann die Funktion eingesetzt werden, die das gewünschte Ergebnis liefert.</p>\n","title":"JS-Performance"});