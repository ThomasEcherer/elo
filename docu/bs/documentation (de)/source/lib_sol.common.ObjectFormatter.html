<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">
importPackage(Packages.de.elo.ix.client.feed);

//@include lib_Class.js

<span id='sol-common-ObjectFormatter'>/**
</span> * This class helps in creating simplified instances of de.elo.ix.client.*-objects like `Sord`. Simplified objects are
 * mostly used by sol.common.Template or sol.common.ix.functions.JsonDataCollector. Formatters are used by solutions if large
 * amounts of data are loaded from ELO or if properties needs to be accessible in templating environments.
 *
 * There are several formatter implementations for formatting objects e.g. `sol.common.ObjectFormatter.TemplateSord`.
 * Core formatting operations like objKey filtering, etc. is done by a base class
 * e.g. `sol.common.ObjectFormatter.BaseSord` which is the superclass of `TemplateSord` implementation.
 *
 *     var formattedObject = sol.common.ObjectFormatter.format({
 *       sord: {
 *         formatter: &#39;sol.common.ObjectFormatter.{FORMATTER CLASS NAME}&#39;,
 *         // original object returned by ix
 *         data: {IX OBJECT},
 *         config: {
 *           // formatter configuration as defined by the formatters base class
 *         }
 *     });
 *
 * Following list of Base classes can be used in order to process `Sords`, `Tasks` and keyword lists.
 *
 * - sol.common.ObjectFormatter.BaseSord
 * - sol.common.ObjectFormatter.BaseTask
 *
 * # Example usage by templates
 *
 * Templates can&#39;t access objKeys stored in array values in an easy way.
 *
 *     var data = sol.common.ObjectFormatter.format({
 *       sord: {
 *         formatter: &#39;sol.common.ObjectFormatter.TemplateSord&#39;,
 *         // instance of de.elo.ix.client.Sord
 *         data: sord
 *       }
 *     });
 *
 * The transformed object results as followed.
 *
 *     data = {
 *       &quot;id&quot;: &quot;7572&quot;,
 *       &quot;maskName&quot;: &quot;Incoming invoice&quot;,
 *       &quot;name&quot;: &quot;Invoice 0000&quot;,
 *       &quot;IDateIso&quot;: &quot;20150720142400&quot;,
 *       &quot;XDateIso&quot;: &quot;&quot;,
 *       &quot;objKeys&quot;: {
 *         &quot;VENDOR_NAME&quot;: &quot;Weiler KG&quot;,
 *         &quot;INVOICE_DATE&quot;: &quot;20150601162415&quot;,
 *         &quot;INVOICE_CASH_DISCOUNT_AMOUNT&quot;: 554
 *       }
 *     }
 *
 * # Example usage for statistical processing
 *
 * If working with large amounts of data it is mandatory to define the properties required for the data analys in order
 * to reduce the amount of data loaded from the client. IndexServer Sord-Objects contain a lot of information that might
 * not be required for the analysis. sol.common.ObjectFormatter.StatisticSord allows defining the sord keys, objKeys,
 * ... information that is required.
 *
 * Please note that using map keys is more expensive than storing values in objKeys since accessing these values requires
 * additional ix checkout calls. Furthermore objKeys can be converted to numeric values automatically.
 *
 * This functionality is used by services while collecting data for dashboard apps
 * developed in angular js.
 *
 *     var data = sol.common.ObjectFormatter.format({
 *       sord: {
 *         formatter: &#39;sol.common.ObjectFormatter.StatisticSord&#39;,
 *         // instance of de.elo.ix.client.Sord
 *         data: sord,
 *         config: {
 *           sordKeys: [&#39;id&#39;, &#39;maskName&#39;, &#39;name&#39;, &#39;IDateIso&#39;, &#39;XDateIso&#39;],
 *           objKeys: [&#39;VENDOR_NAME&#39;, &#39;INVOICE_DATE&#39;, &#39;INVOICE_CASH_DISCOUNT_AMOUNT&#39;]
 *         }
 *     });
 *
 * The transformed object results as followed.
 *
 *     data = {
 *       &quot;id&quot;: &quot;7572&quot;,
 *       &quot;maskName&quot;: &quot;Incoming invoice&quot;,
 *       &quot;name&quot;: &quot;Invoice 0000&quot;,
 *       &quot;IDateIso&quot;: &quot;20150720142400&quot;,
 *       &quot;XDateIso&quot;: &quot;&quot;,
 *       &quot;O_VENDOR_NAME&quot;: &quot;Weiler KG&quot;,
 *       &quot;O_INVOICE_DATE&quot;: &quot;20150601162415&quot;,
 *       &quot;O_INVOICE_CASH_DISCOUNT_AMOUNT&quot;: 554,
 *     }
 *
 *
 *
 * @author Michael Weiler, ELO Digital Office GmbH
 * @version 1.0
 *
 * @eloix
 * @elojc
 * @eloas
 */
sol.define(&quot;sol.common.ObjectFormatter&quot;, {

  singleton: true,

<span id='sol-common-ObjectFormatter-method-format'>  format: function (config) {
</span>    var me = this, result = {},
        partName;
    config = config || {};
    for (partName in config) {
      me.formatPart(partName, config[partName], result);
    }
    return result;
  },

<span id='sol-common-ObjectFormatter-method-formatPart'>  /**
</span>   * @private
   * @param {String} partName
   * @param {Object} configPart
   * @param {Object} result
   */
  formatPart: function (partName, configPart, result) {
    var formatter,
        data = configPart.data;

    if (data.getClass &amp;&amp; data.getClass().isArray()) {
      data = Array.prototype.slice.call(data);
    }

    if (Array.isArray(data)) {
      result[partName] = [];
      data.forEach(function (dataPart) {
        formatter = sol.create(configPart.formatter, { data: dataPart, config: configPart.config });
        result[partName].push(formatter.build());
      });
    } else {
      formatter = sol.create(configPart.formatter, { data: configPart.data, config: configPart.config });
      result[partName] = formatter.build();
    }
  }
});

<span id='sol-common-ObjectFormatter-BaseSord'>/**
</span> * Represents limited data of an de.elo.ix.client.Sord object.
 *
 * This class implements limiting objKeys, sord keys and map keys. Please refer to sub classes for more information on the
 * usage.
 *
 * @author Michael Weiler, ELO Digital Office GmbH
 * @author Nils Mosbach, ELO Digital Office GmbH
 * @version 1.0
 *
 * @eloix
 * @elojc
 * @eloas
 */
sol.define(&quot;sol.common.ObjectFormatter.BaseSord&quot;, {

<span id='sol-common-ObjectFormatter-BaseSord-cfg-sordKeys'>  /**
</span>   * @cfg {Array} sordKeys
   * Names of the properties that should be included.
   * The ID and the mask name are included by default.
   */
  sordKeys: [&quot;guid&quot;, &quot;id&quot;, &quot;maskName&quot;],

<span id='sol-common-ObjectFormatter-BaseSord-cfg-descMaxLen'>  /**
</span>   * @cfg {Number} descMaxLen
   * Maximum length of the sord description
   */
  descMaxLen: undefined,

<span id='sol-common-ObjectFormatter-BaseSord-cfg-objKeys'>  /**
</span>   * @cfg {Array} objKeys
   * Key names of the object keys that should be included.
   */
  objKeys: [],

<span id='sol-common-ObjectFormatter-BaseSord-cfg-mapKeys'>  /**
</span>   * @cfg {Array} mapKeys
   * Map field names of the map fields that should be included.
   */
  mapKeys: undefined,

<span id='sol-common-ObjectFormatter-BaseSord-cfg-formBlobs'>  /**
</span>   * @cfg {Array} formBlobs
   * Form-Blob field names of the Form-Blob-fields that should be included.
   */
  formBlobs: undefined,

<span id='sol-common-ObjectFormatter-BaseSord-cfg-allObjKeys'>  /**
</span>   * @cfg {Boolean} allObjKeys
   * Set to true if all objKeys should be included. objKeys[] configuration is ignored in this case.
   */
  allObjKeys: false,

<span id='sol-common-ObjectFormatter-BaseSord-cfg-allMapFields'>  /**
</span>   * @cfg {Boolean} allMapFields
   * Set to true if all map fields should be included. mapKeys[] configuration is ignored in this case.
   */
  allMapFields: false,

<span id='sol-common-ObjectFormatter-BaseSord-cfg-allFormBlobFields'>  /**
</span>   * @cfg {Boolean} allFormBlobFields
   * Set to true if all Form-Blob fields should be included. formBlobs[] configuration is ignored in this case.
   */
  allFormBlobFields: false,

<span id='sol-common-ObjectFormatter-BaseSord-cfg-objKeyPrefix'>  /**
</span>   * @cfg {String} objKeyPrefix
   * Defines a prefix for objKey field names.
   */
  objKeyPrefix: &quot;&quot;,

<span id='sol-common-ObjectFormatter-BaseSord-cfg-objKeyPrefix'>  /**
</span>   * @cfg {String} objKeyPrefix
   * Defines a prefix for mapKey field names.
   */
  mapKeyPrefix: &quot;&quot;,

<span id='sol-common-ObjectFormatter-BaseSord-cfg-feedActions'>  /**
</span>   * @private
   * @cfg {String} feedActions
   * This is an experimental feature. Don&#39;t rely on its existance.
   * Set to true if feed actions of this sord should be collected as well.
   */
  feedActions: false,

<span id='sol-common-ObjectFormatter-BaseSord-cfg-list'>  /**
</span>   * @private
   * @cfg {de.elo.ix.client.feed.EActionType[]} list of feed action types
   * This is an experimental feature. Don&#39;t rely on its existance.
   * Define a list of Feed Action types that should be returned.
   */
  feedActionTypes: [],

<span id='sol-common-ObjectFormatter-BaseSord-cfg-maximum'>  /**
</span>   * @private
   * @cfg {Number} maximum amount of actions that are read
   * This is an experimental feature. Don&#39;t rely on its existance.
   * The amount of feed actions that is returned by FindFirstActions.
   */
  feedActionsMax: 500,

<span id='sol-common-ObjectFormatter-BaseSord-property-flatObjStructure'>  /**
</span>   * @property {Boolean} flatObjStructure
   * Use a flat object structure. If true, objKeyPrefix and mapKeyPrefix must be set in order to prevent overriding sord keys.
   *
   * Default. flatObjStructure = false, objKeyPrefix &quot;&quot;
   *
   *     {
   *       name: &quot;my invoice&quot;,
   *       objKeys: {
   *         INVOICE_NUMBER: &quot;1234#2&quot;
   *       }
   *     }
   *
   * Flat structure with objKeyPrefix &quot;O_&quot;
   *
   *     {
   *       name: &quot;my invoice&quot;,
   *       O_INVOICE_NUMBER: &quot;1234#2&quot;
   *     }
   */
  flatObjStructure: false,

<span id='sol-common-ObjectFormatter-BaseSord-property-pilcrow'>  pilcrow: &quot;\u00b6&quot;,
</span>
<span id='sol-common-ObjectFormatter-BaseSord-property-actionTypeMappings'>  actionTypeMappings: {
</span>    AutoComment: EActionType.AutoComment,
    Released: EActionType.Released,
    SordCreated: EActionType.SordCreated,
    UserComment: EActionType.UserComment,
    VersionCreated: EActionType.VersionCreated,
    WorkVersionCreated: EActionType.WorkVersionCreated,
    WorkVersionSwitched: EActionType.WorkVersionSwitched
  },

<span id='sol-common-ObjectFormatter-BaseSord-method-initialize'>  initialize: function (params) {
</span>    var me = this;

    me._cacheMaskObjKeys = {};

    me.$super(&quot;sol.Base&quot;, &quot;initialize&quot;, [params.config]);

    if (me.sordKeys.length === 0) {
      me.sordKeys.push(&quot;id&quot;);
    }

    if (!me.objKeys) {
      me.objKeys = [];
    }

    me.sord = params.data;

    me.feedActionTypes = me.normalizeFeedActionTypes(me.feedActionTypes);
  },

<span id='sol-common-ObjectFormatter-BaseSord-method-build'>  /**
</span>   * Builds the base representation of the ELO object. This function is called by sol.common.ObjectFormatter#format
   * @param {de.elo.ix.client.Sord} originalSord
   * @return {Object} formattedSord
   */
  build: function (originalSord) {
    var me = this,
        sord, maskName, formattedSord;
    me.logger.enter(&quot;build&quot;, arguments);
    sord = originalSord || me.sord;
    maskName = String(sord.maskName);
    formattedSord = me.initialiseFormattedSord();

    // prepare cache for mask that allows fast iterations over required objKeys.
    me.buildCacheMaskObjKeys(maskName, sord.objKeys);

    me.applySordKeys(formattedSord, sord);
    me.applyObjKeys(formattedSord, maskName, sord.objKeys);
    me.applyMapData(formattedSord, sord);
    me.flowId &amp;&amp; me.applyWfMapData(formattedSord, sord, me.flowId);
    me.applyFormBlobData(formattedSord, sord, me.flowId);
    me.applyFeedActions(formattedSord, sord);

    me.logger.exit(&quot;build&quot;, formattedSord);
    return formattedSord;
  },

<span id='sol-common-ObjectFormatter-BaseSord-method-applySordKeys'>  /**
</span>   * @private
   * @param {Object} toObj
   * @param {de.elo.ix.client.Sord} sord
   */
  applySordKeys: function (toObj, sord) {
    var me = this,
        key, i, length;

    for (i = 0, length = me.sordKeys.length; i &lt; length; i++) {
      key = me.sordKeys[i];
      toObj[key] = String(sord[key]);
    }
  },

<span id='sol-common-ObjectFormatter-BaseSord-method-applyObjKeys'>  /**
</span>   * @private
   * @param {Object} toObj
   * @param {String} maskName
   * @param {de.elo.ix.client.ObjKey[]} objKeys
   */
  applyObjKeys: function (toObj, maskName, objKeys) {
    var me = this,
        objKeyCache = me._cacheMaskObjKeys[maskName],
        objKey, i, length, dataArr,
        cachePos;

    for (i = 0, length = objKeyCache.length; i &lt; length; i++) {
      cachePos = objKeyCache[i];
      if (cachePos &amp;&amp; cachePos.arrPos &lt; objKeys.length
          &amp;&amp; objKeys[cachePos.arrPos].id === cachePos.id) {
        objKey = objKeys[cachePos.arrPos];
      } else {
        continue;
      }

      if (objKey) {
        dataArr = Array.prototype.slice.call(objKey.data);
        me.applyObjKey(toObj, objKey.name, String(dataArr.join(me.pilcrow)));
      }
    }
  },

<span id='sol-common-ObjectFormatter-BaseSord-method-applyObjKey'>  /**
</span>   * @private
   * @param {Object} toObj
   * @param {String} key
   * @param {String} value
   */
  applyObjKey: function (toObj, key, value) {
    var me = this;
    if (me.flatObjStructure) {
      toObj[me.objKeyPrefix + key] = value;
    } else {
      toObj.objKeys[me.objKeyPrefix + key] = value;
    }
  },

<span id='sol-common-ObjectFormatter-BaseSord-method-applyMapData'>  /**
</span>   * @private
   * @param {Object} toObj
   * @param {de.elo.ix.client.Sord} sord
   */
  applyMapData: function (toObj, sord) {
    var me = this,
        keys = me.allMapFields ? null : me.mapKeys,
        mapItems, i, mapItem;

    if (me.allMapFields || me.mapKeys) {
      mapItems = ((me.asAdmin &amp;&amp; typeof ixConnectAdmin !== &quot;undefined&quot; &amp;&amp; ixConnectAdmin) || ixConnect).ix().checkoutMap(MapDomainC.DOMAIN_SORD, sord.id, keys, LockC.NO).items;
      for (i = 0; i &lt; mapItems.length; i++) {
        mapItem = mapItems[i];
        me.applyMapKey(toObj, String(mapItem.key), String(mapItem.value));
      }
    }
  },

<span id='sol-common-ObjectFormatter-BaseSord-method-applyWfMapData'>  /**
</span>   * @private
   * @param {Object} toObj
   * @param {de.elo.ix.client.Sord} sord
   * @param {String} flowId
   */
  applyWfMapData: function (toObj, sord, flowId) {
    var me = this,
        keys = me.allMapFields ? null : me.mapKeys,
        mapItems, i, mapItem;

    if (me.allMapFields || me.mapKeys) {
      mapItems = ((me.asAdmin &amp;&amp; typeof ixConnectAdmin !== &quot;undefined&quot; &amp;&amp; ixConnectAdmin) || ixConnect).ix().checkoutMap(MapDomainC.DOMAIN_WORKFLOW_ACTIVE, flowId, keys, LockC.NO).items;
      for (i = 0; i &lt; mapItems.length; i++) {
        mapItem = mapItems[i];
        me.applyWfMapKey(toObj, String(mapItem.key), String(mapItem.value));
      }
    }
  },

<span id='sol-common-ObjectFormatter-BaseSord-method-applyFormBlobData'>  /**
</span>   * @private
   * @param {Object} toObj
   * @param {de.elo.ix.client.Sord} sord
   * @param {String} flowId
   */
  applyFormBlobData: function (toObj, sord, flowId) {
    var me = this,
        keys = me.allFormBlobFields ? null : me.mapKeys,
        blobItems, i, blobItem;

    if (me.allFormBlobFields || me.mapKeys) {
      blobItems = ((me.asAdmin &amp;&amp; typeof ixConnectAdmin !== &quot;undefined&quot; &amp;&amp; ixConnectAdmin) || ixConnect).ix().checkoutMap(&quot;formdata&quot;, flowId, keys, LockC.NO).items;
      for (i = 0; i &lt; blobItems.length; i++) {
        blobItem = blobItems[i];
        me.applyWfMapKey(toObj, String(blobItem.key), String(blobItem.value));
      }
    }
  },

<span id='sol-common-ObjectFormatter-BaseSord-method-applyFeedActions'>  /**
</span>   * @private
   * @param {Object} toObj
   * @param {de.elo.ix.client.Sord} sord
   */
  applyFeedActions: function (toObj, sord) {
    var me = this;
    if (me.feedActions) {
      toObj.feedActions = JSON.parse(me.getFeedActionsJson(sord.guid));
    }
  },

<span id='sol-common-ObjectFormatter-BaseSord-method-applyMapKey'>  /**
</span>   * @private
   * @param {Object} toObj
   * @param {String} key
   * @param {String} value
   */
  applyMapKey: function (toObj, key, value) {
    var me = this;
    if (me.flatObjStructure) {
      toObj[me.mapKeyPrefix + key] = value;
    } else {
      toObj.mapKeys[me.mapKeyPrefix + key] = value;
    }
  },

<span id='sol-common-ObjectFormatter-BaseSord-method-applyWfMapKey'>  /**
</span>   * @private
   * @param {Object} toObj
   * @param {String} key
   * @param {String} value
   */
  applyWfMapKey: function (toObj, key, value) {
    var me = this;
    if (me.flatObjStructure) {
      toObj[me.mapKeyPrefix + key] = value;
    } else {
      toObj.wfMapKeys[me.mapKeyPrefix + key] = value;
    }
  },

<span id='sol-common-ObjectFormatter-BaseSord-method-applyFormBlobKey'>  /**
</span>   * @private
   * @param {Object} toObj
   * @param {String} key
   * @param {String} value
   */
  applyFormBlobKey: function (toObj, key, value) {
    var me = this;
    if (me.flatObjStructure) {
      toObj[me.mapKeyPrefix + key] = value;
    } else {
      toObj.formBlobs[me.mapKeyPrefix + key] = value;
    }
  },

<span id='sol-common-ObjectFormatter-BaseSord-method-buildCacheMaskObjKeys'>  /**
</span>   * Builds a cache for required objkeys. That allows reducing iteration times if thousands of sords are formatted.
   * @private
   * @param {String} maskName
   * @param {de.elo.ix.client.ObjKey[]} objKeys
   */
  buildCacheMaskObjKeys: function (maskName, objKeys) {
    var me = this,
        cache, i, objKey;
    if (!me._cacheMaskObjKeys.hasOwnProperty(maskName)) {
      cache = [];
      // iterate over all objKeys from the current sord
      for (i = 0; i &lt; objKeys.length; i++) {
        objKey = objKeys[i];
        if (me.isValidObjKey(objKey)) {
          cache.push({
            id: objKey.id,
            arrPos: i
          });
        }
      }
      me._cacheMaskObjKeys[maskName] = cache;
    }
  },

<span id='sol-common-ObjectFormatter-BaseSord-method-isValidObjKey'>  /**
</span>   * checks if objKey should be applied to the formatted object.
   * @private
   * @param {de.elo.ix.client.ObjKey} sordObjKey
   * @return {Boolean} result
   */
  isValidObjKey: function (sordObjKey) {
    var me = this,
        i, length;
    if (!me.allObjKeys) {
      for (i = 0, length = me.objKeys.length; i &lt; length; i++) {
        if (sordObjKey.name == me.objKeys[i]) {
          return true;
        }
      }
    } else {
      return true;
    }
  },

<span id='sol-common-ObjectFormatter-BaseSord-method-initialiseFormattedSord'>  /**
</span>   * @private
   * @return {Object} initial formattedSord
   */
  initialiseFormattedSord: function () {
    var me = this;

    return me.flatObjStructure ? {} : {
      objKeys: {},
      mapKeys: {},
      wfMapKeys: {},
      formBlobs: {}
    };
  },

<span id='sol-common-ObjectFormatter-BaseSord-method-buildJson'>  /**
</span>   * Build JSON Data Structure. This function should only be used by the ELO Business Solutions team,
   * since API calls might change due to performance improvements!
   *
   * This function was designed to reduce processing times if huge amounts of data are collected by services.
   * Creation of objects and properties is more than 50 times slower than building the json result with a string buffer.
   *
   * Due to performance reasons, no map data is collected.
   *
   * @param {de.elo.ix.client.Sord} originalSord Index Server Sord object
   * @param {Object} mask (optional) Mask object created by e.g. Children data collector. Pass if
   * @param {Object} params (optional)
   * @param {String[]} params.dataAsString (optional) Contains the names of the fields, for which all values (not just the first) should be returned as pilcrow separated string
   * @param {String[]} params.dataAsArray (optional) Contains the names of the fields, for which all values (not just the first) should be returned as an array
   * @return {Object}
   */
  buildJson: function (originalSord, mask, params) {
    var me = this,
        sord = originalSord || me.sord,
        maskName = sord.maskName,
        // generate json as string array
        formattedSord = [],
        key, i, length, lengthO, objKey,
        val, adjustFunction, objKeyPrefix, objKeyCache, addedObjKeys, value, cachePos,
        _result;

    // prepare cache for mask that allows fast iterations over required objKeys.
    me.buildCacheMaskObjKeys(maskName, sord.objKeys);

    formattedSord.push(&quot;{&quot;);

    // apply sordKeys
    for (i = 0, length = me.sordKeys.length; i &lt; length; i++) {
      key = me.sordKeys[i];
      formattedSord.push(&#39;&quot;&#39;);
      formattedSord.push(key);
      formattedSord.push(&#39;&quot;:&#39;);
      value = String(sord[key]);
      if ((key == &quot;desc&quot;) &amp;&amp; me.descMaxLen &amp;&amp; value &amp;&amp; (value.length &gt; me.descMaxLen)) {
        value = value.substr(0, me.descMaxLen);
      }
      formattedSord.push(
        // set undefined to null
        sord[key] === undefined ? &quot;null&quot;
          : (
          // else: escape strings
            JSON.stringify(value)
          ));
      if (i != length - 1) {
        formattedSord.push(&quot;,&quot;);
      }
    }
    // &lt; apply sordKeys

    // apply ObjKeys
    if (me.allObjKeys || (me.objKeys &amp;&amp; me.objKeys.length &gt; 0)) {

      adjustFunction = function (value) {
        var field = mask ? mask.fields[objKey.name] : null;
        if (value === undefined || value === &quot;&quot; || value === null) {
          value = &quot;null&quot;;
        } else if (field &amp;&amp; field.type &amp;&amp; (field.type.indexOf(&quot;NUMBER&quot;) === 0)) {
          if (value === &quot;&quot;) {
            value = &quot;null&quot;;
          }
          value = parseFloat(value.replace(&quot;,&quot;, &quot;.&quot;)) || &quot;null&quot;;
        } else {
          value = JSON.stringify(String(value));
        }
        return value;
      };

      objKeyPrefix = me.objKeyPrefix;
      objKeyCache = me._cacheMaskObjKeys[maskName];
      addedObjKeys = false;
      for (i = 0, lengthO = objKeyCache.length; i &lt; lengthO; i++) {
        cachePos = objKeyCache[i];
        if (cachePos &amp;&amp; cachePos.arrPos &lt; sord.objKeys.length
            &amp;&amp; sord.objKeys[cachePos.arrPos].id === cachePos.id) {
          objKey = sord.objKeys[cachePos.arrPos];
        } else {
          continue;
        }

        if (objKey) {
          if (addedObjKeys) {
            // add separators between objKeys
            formattedSord.push(&quot;,&quot;);
          } else {
          // add separators for objKey block
            formattedSord.push(&quot;,&quot;);
            if (!me.flatObjStructure) {
              formattedSord.push(&#39;&quot;objKeys&quot;: {&#39;);
            }
          }
          key = me.sordKeys[i];
          formattedSord.push(&#39;&quot;&#39;);
          formattedSord.push(objKeyPrefix + objKey.name);
          formattedSord.push(&#39;&quot;:&#39;);

          // adjust val
          if (params &amp;&amp; params.dataAsString &amp;&amp; (params.dataAsString.length &gt; 0) &amp;&amp; (params.dataAsString.indexOf(String(objKey.name)) !== -1)) {
            val = JSON.stringify(objKey.data.join(me.pilcrow));
          } else if (params &amp;&amp; params.dataAsArray &amp;&amp; (params.dataAsArray.length &gt; 0) &amp;&amp; (params.dataAsArray.indexOf(String(objKey.name)) !== -1)) {
            val = JSON.stringify(objKey.data.map(adjustFunction));
          } else {
            val = adjustFunction(objKey.data[0]);
          }
          // &lt; adjust val

          formattedSord.push(val);
          addedObjKeys = true;
        }
      }
      if (!me.flatObjStructure &amp;&amp; addedObjKeys) {
        formattedSord.push(&quot;}&quot;);
      }
    }
    // &lt; apply sordKeys
    if (me.feedActions) {
      formattedSord.push(&#39;, &quot;feedActions&quot;: &#39;);
      formattedSord.push(me.getFeedActionsJson(sord.guid));
    }

    formattedSord.push(&quot;}&quot;);
    _result = formattedSord.join(&quot;&quot;);
    return _result;
  },

<span id='sol-common-ObjectFormatter-BaseSord-method-getFeedActionsJson'>  /**
</span>   * Reads the list of all actions for a given post.
   *
   * This is an experimental feature. Don&#39;t rely on its existence.
   * This feature should be used with care since this leads to performance issues if used within large datasets.
   * @private
   * @param {String} guid GUID
   * @returns {String} json array that contains all actions pre formatted as json.
   */
  getFeedActionsJson: function (guid) {
    var me = this,
        findInfo, findResult, o, i, action;
    try {
      findInfo = new FindActionsInfo();
      findInfo.objId = guid;
      findInfo.sordZ = SordC.mbOnlyGuid;
      findInfo.actionTypes = me.feedActionTypes || [];
      findResult = ixConnect.getFeedService().findFirstActions(findInfo, me.feedActionsMax, ActionC.mbAll);

      // using a string builder in order to speed up system performance
      o = [&quot;[&quot;];
      for (i = 0; i &lt; findResult.actions.length; i += 1) {
        action = findResult.actions[i];
        if (findInfo.actionTypes.length === 0 || findInfo.actionTypes.indexOf(action.type) !== -1) {
          if (o.length !== 1) {
            o.push(&quot;,&quot;);
          }
          o.push(&quot;{&quot;);
          o.push(&#39;&quot;text&quot;: &#39;);
          o.push(JSON.stringify(String(action.text)));
          o.push(&#39;, &quot;userName&quot;: &#39;);
          o.push(JSON.stringify(String(action.userName)));
          o.push(&#39;, &quot;userId&quot;: &#39;);
          o.push(action.userId);
          o.push(&#39;, &quot;type&quot;: &quot;&#39;);
          o.push(action.type);
          o.push(&#39;&quot;, &quot;createDateIso&quot;: &quot;&#39;);
          o.push(action.createDateIso);
          o.push(&#39;&quot;, &quot;guid&quot;: &quot;&#39;);
          o.push(action.guid);
          o.push(&#39;&quot;, &quot;updateDateIso&quot;: &quot;&#39;);
          o.push(action.updateDateIso);
          o.push(&#39;&quot;&#39;);
          o.push(&quot;}&quot;);
        }
      }
      o.push(&quot;]&quot;);
      return o.join(&quot;&quot;);
    } catch (ex) {
      me.logger.error(&quot;reading feed comments failed.&quot;, ex);
      return &quot;[]&quot;;
    }
  },

<span id='sol-common-ObjectFormatter-BaseSord-method-normalizeFeedActionTypes'>  /**
</span>   * @private
   * If feed action types are defined as strings a mapping to EActionType is required.
   * @param {String[]|de.elo.ix.client.feed.EActionType[]} feedActionTypes
   * @return {de.elo.ix.client.feed.EActionType[]}
   */
  normalizeFeedActionTypes: function (feedActionTypes) {
    var me = this,
        normalizedTypes = [];

    if (feedActionTypes &amp;&amp; (feedActionTypes.length &gt; 0)) {
      feedActionTypes.forEach(function (type) {
        var typeEnum = (type instanceof EActionType) ? type : me.actionTypeMappings[type];
        if (typeEnum) {
          normalizedTypes.push(typeEnum);
        }
      });
    }

    return normalizedTypes;
  }

});

<span id='sol-common-ObjectFormatter-StatisticSord'>/**
</span> * Represents limited compact data of an ELO object for dashboards.
 *
 * If working with large amounts of data it is mandatory to define the properties required for the data analys in order
 * to reduce the amount of data loaded from the client. IndexServer Sord-Objects contain a lot of information that might
 * not be required for the analysis. sol.common.ObjectFormatter.StatisticSord allows defining the sord keys, objKeys,
 * ... information that is required.
 *
 * For more information on configuration properties please refer to sol.common.ObjectFormatter.BaseSord.
 *
 * This functionality is used by sol.common.ix.functions.ChildrenDataCollector while collecting data for dashboard apps
 * developed in angular js.
 *
 *     var data = sol.common.ObjectFormatter.format({
 *       sord: {
 *         formatter: &#39;sol.common.ObjectFormatter.StatisticSord&#39;,
 *         // instance of de.elo.ix.client.Sord
 *         data: sord,
 *         config: {
 *           sordKeys: [&#39;id&#39;, &#39;maskName&#39;, &#39;name&#39;, &#39;IDateIso&#39;, &#39;XDateIso&#39;],
 *           objKeys: [&#39;VENDOR_NAME&#39;, &#39;INVOICE_DATE&#39;, &#39;INVOICE_CASH_DISCOUNT_AMOUNT&#39;]
 *         }
 *       }
 *     });
 *
 * The transformed object results as followed.
 *
 *     data = {
 *       &quot;id&quot;: &quot;7572&quot;,
 *       &quot;maskName&quot;: &quot;Incoming invoice&quot;,
 *       &quot;name&quot;: &quot;Invoice 0000&quot;,
 *       &quot;IDateIso&quot;: &quot;20150720142400&quot;,
 *       &quot;XDateIso&quot;: &quot;&quot;,
 *       &quot;O_VENDOR_NAME&quot;: &quot;Weiler KG&quot;,
 *       &quot;O_INVOICE_DATE&quot;: &quot;20150601162415&quot;,
 *       &quot;O_INVOICE_CASH_DISCOUNT_AMOUNT&quot;: 554,
 *     }
 *
 * @author Michael Weiler, ELO Digital Office GmbH
 * @author Nils Mosbach, ELO Digital Office GmbH
 * @version 1.0
 *
 * @eloix
 * @elojc
 * @eloas
 */
sol.define(&quot;sol.common.ObjectFormatter.StatisticSord&quot;, {

  extend: &quot;sol.common.ObjectFormatter.BaseSord&quot;,
<span id='sol-common-ObjectFormatter-StatisticSord-property-requiredProperties'>  requiredProperties: [&quot;sord&quot;],
</span>
<span id='sol-common-ObjectFormatter-StatisticSord-property-flatObjStructure'>  flatObjStructure: true,
</span><span id='sol-common-ObjectFormatter-StatisticSord-cfg-objKeyPrefix'>  objKeyPrefix: &quot;O_&quot;,
</span><span id='sol-common-ObjectFormatter-StatisticSord-property-mapKeyPrefix'>  mapKeyPrefix: &quot;M_&quot;
</span>
});


<span id='sol-common-ObjectFormatter-TemplateSord'>/**
</span> * Represents limited compact data of an ELO object.
 *
 * This class includes all objKeys by default. For more information on configuration properties please refer to sol.common.ObjectFormatter.BaseSord.
 *
 * Templates can&#39;t access objKeys stored in array values in an easy way.
 *
 *     var data = sol.common.ObjectFormatter.format({
 *       sord: {
 *         formatter: &#39;sol.common.ObjectFormatter.TemplateSord&#39;,
 *         // instance of de.elo.ix.client.Sord
 *         data: sord
 *       }
 *     });
 *
 * The transformed object results as followed.
 *
 *     data = {
 *       &quot;id&quot;: &quot;7572&quot;,
 *       &quot;maskName&quot;: &quot;Incoming invoice&quot;,
 *       &quot;name&quot;: &quot;Invoice 0000&quot;,
 *       &quot;IDateIso&quot;: &quot;20150720142400&quot;,
 *       &quot;XDateIso&quot;: &quot;&quot;,
 *       &quot;objKeys&quot;: {
 *         &quot;VENDOR_NAME&quot;: &quot;ELO Inc.&quot;,
 *         &quot;INVOICE_DATE&quot;: &quot;20150601162415&quot;,
 *         &quot;INVOICE_CASH_DISCOUNT_AMOUNT&quot;: 554
 *       }
 *     }
 *
 * @author Michael Weiler, ELO Digital Office GmbH
 * @author Nils Mosbach, ELO Digital Office GmbH
 * @version 1.0
 *
 * @eloix
 * @elojc
 * @eloas
 */
sol.define(&quot;sol.common.ObjectFormatter.TemplateSord&quot;, {

  extend: &quot;sol.common.ObjectFormatter.BaseSord&quot;,
<span id='sol-common-ObjectFormatter-TemplateSord-property-requiredProperties'>  requiredProperties: [&quot;sord&quot;],
</span>
<span id='sol-common-ObjectFormatter-TemplateSord-cfg-sordKeys'>  sordKeys: [&quot;guid&quot;, &quot;id&quot;, &quot;name&quot;, &quot;maskName&quot;, &quot;desc&quot;],
</span><span id='sol-common-ObjectFormatter-TemplateSord-cfg-allObjKeys'>  allObjKeys: true,
</span><span id='sol-common-ObjectFormatter-TemplateSord-cfg-allMapFields'>  allMapFields: false,
</span><span id='sol-common-ObjectFormatter-TemplateSord-cfg-allFormBlobFields'>  allFormBlobFields: false,
</span>

<span id='sol-common-ObjectFormatter-TemplateSord-property-flatObjStructure'>  flatObjStructure: false,
</span><span id='sol-common-ObjectFormatter-TemplateSord-cfg-objKeyPrefix'>  objKeyPrefix: &quot;&quot;,
</span><span id='sol-common-ObjectFormatter-TemplateSord-property-mapKeyPrefix'>  mapKeyPrefix: &quot;&quot;
</span>
});

sol.define(&quot;sol.common.ObjectFormatter.WfMap&quot;, {

  extend: &quot;sol.common.ObjectFormatter.BaseSord&quot;,
  requiredProperties: [&quot;sord&quot;, &quot;flowId&quot;],

  sordKeys: [&quot;guid&quot;, &quot;id&quot;, &quot;name&quot;, &quot;maskName&quot;, &quot;desc&quot;],
  allObjKeys: true,
  allMapFields: false,
  allFormBlobFields: false,

  flatObjStructure: false,
  objKeyPrefix: &quot;&quot;,
  mapKeyPrefix: &quot;&quot;

});


<span id='sol-common-ObjectFormatter-BaseTask'>/**
</span> * Represents limited data of a task
 *
 * @author Michael Weiler, ELO Digital Office GmbH
 * @version 1.0
 *
 * @eloix
 * @elojc
 * @eloas
 */
sol.define(&quot;sol.common.ObjectFormatter.BaseTask&quot;, {

<span id='sol-common-ObjectFormatter-BaseTask-property-requiredProperties'>  requiredProperties: &quot;task&quot;,
</span>
<span id='sol-common-ObjectFormatter-BaseTask-cfg-formatter'>  /**
</span>   * @cfg {String} formatter
   * Class name of the task formatter
   */

<span id='sol-common-ObjectFormatter-BaseTask-cfg-limitToSordList'>  /**
</span>   * @cfg {Boolean} limitToSordList
   * True if the tasks should be limited to the Sord objects in the Sord list.
   */

<span id='sol-common-ObjectFormatter-BaseTask-cfg-wfKeys'>  /**
</span>   * @cfg {Array} wfKeys
   * Names of properties of the class WFCollectNode that should be included.
   */

  initialize: function (cfg) {
    var me = this;
    me.wfKeyMap = {};
    me.task = cfg.data;
    me.config = cfg.config || {};
  },

<span id='sol-common-ObjectFormatter-BaseTask-method-build'>  /**
</span>   * Builds the base representation of the task
   * @private
   * @param {Object} originalTask
   * @return {Object}
   */
  build: function (originalTask) {
    var me = this,
        key;
    if (originalTask) {
      me.task = originalTask;
    }
    me.getValues();
    me.element = { flowId: me.task.wfNode.flowId, nodeId: me.task.wfNode.nodeId };
    for (key in me.wfKeyMap) {
      me.element[key] = me.wfKeyMap[key].value;
    }
    return me.element;
  },

<span id='sol-common-ObjectFormatter-BaseTask-method-getValues'>  /**
</span>   * Retrieves the data of the ELO object from the original Java object
   * @private
   */
  getValues: function () {
    var me = this,
        key;
    me.prepareMaps();
    if (me.task.wfNode) {
      for (key in me.wfKeyMap) {
        me.wfKeyMap[key].value = String(me.task.wfNode[key]);
      }
    }
  },

<span id='sol-common-ObjectFormatter-BaseTask-method-prepareMaps'>  /**
</span>   * Prepares JavaScript objects to gather the ELO object data
   * @private
   */
  prepareMaps: function () {
    var me = this;
    if (me.config.wfKeys) {
      me.config.wfKeys.forEach(function (key) {
        me.wfKeyMap[key] = { value: &quot;&quot; };
      });
    }
  }
});

<span id='sol-common-ObjectFormatter-StatisticTask'>/**
</span> * Represents limited compact data of an ELO object
 * for dashboards
 *
 * @author Michael Weiler, ELO Digital Office GmbH
 * @version 1.0
 *
 * @eloix
 * @elojc
 * @eloas
 */
sol.define(&quot;sol.common.ObjectFormatter.StatisticTask&quot;, {

  extend: &quot;sol.common.ObjectFormatter.BaseTask&quot;
});

<span id='sol-common-ObjectFormatter-TemplateTask'>/**
</span> * Represents limited compact data of an ELO object
 * for dashboards
 *
 * @author Michael Weiler, ELO Digital Office GmbH
 * @version 1.0
 *
 * @eloix
 *
 */
sol.define(&quot;sol.common.ObjectFormatter.TemplateTask&quot;, {

  extend: &quot;sol.common.ObjectFormatter.BaseTask&quot;,

<span id='sol-common-ObjectFormatter-TemplateTask-method-initialize'>  initialize: function (cfg) {
</span>    var me = this;
    me.$super(&quot;sol.common.ObjectFormatter.BaseTask&quot;, &quot;initialize&quot;, [cfg]);
  },

<span id='sol-common-ObjectFormatter-TemplateTask-cfg-wfKeys'>  wfKeys: [&quot;flowId&quot;, &quot;flowName&quot;, &quot;nodeId&quot;, &quot;nodeName&quot;]
</span>});

<span id='sol-common-ObjectFormatter-BaseWfDiagramNode'>/**
</span> * Represents limited data of a workflow collect node
 *
 * @author MW, ELO Digital Office GmbH
 * @version 1.0
 *
 * @eloix
 * @elojc
 * @eloas
 */
sol.define(&quot;sol.common.ObjectFormatter.BaseWfDiagramNode&quot;, {

<span id='sol-common-ObjectFormatter-BaseWfDiagramNode-property-requiredProperties'>  requiredProperties: [&quot;flowId&quot;, &quot;nodeId&quot;],
</span>
<span id='sol-common-ObjectFormatter-BaseWfDiagramNode-cfg-formatter'>  /**
</span>   * @cfg {String} formatter
   * Class name of the task formatter
   */

<span id='sol-common-ObjectFormatter-BaseWfDiagramNode-cfg-wfKeys'>  /**
</span>   * @cfg {Array} wfKeys
   * Names of properties of the class WFDiagram that should be included.
   */

<span id='sol-common-ObjectFormatter-BaseWfDiagramNode-cfg-nodeKeys'>  /**
</span>   * @cfg {Array} nodeKeys
   * Names of properties of the class WFNode that should be included.
   */

  initialize: function (cfg) {
    var me = this;
    me.wfDiagram = cfg.data;
    me.config = cfg.config || {};
    me.node = sol.common.WfUtils.getNode(me.wfDiagram, cfg.config.nodeId);
  },

<span id='sol-common-ObjectFormatter-BaseWfDiagramNode-method-build'>  /**
</span>   * Builds the base representation of the task
   *
   * @private
   * @return {Object} Node object
   * @return {String} return.flowId Flow ID
   * @return {String} return.flowName Flow name
   * @return {String} return.id Node ID
   * @return {String} return.name Node name
   */
  build: function () {
    var me = this;

    me.element = { flowId: String(me.config.flowId), id: String(me.config.nodeId) };

    if (me.wfDiagram) {
      me.element.flowName = String(me.wfDiagram.name);
    }

    if (me.node) {
      me.element.name = String(me.node.name);
    }

    return me.element;
  }
});

<span id='sol-common-ObjectFormatter-TemplateWfDiagramNode'>/**
</span> * Represents limited compact data of an ELO workflow diagram node
 *
 * @author MW, ELO Digital Office GmbH
 * @version 1.0
 *
 * @eloix
 *
 */
sol.define(&quot;sol.common.ObjectFormatter.TemplateWfDiagramNode&quot;, {

  extend: &quot;sol.common.ObjectFormatter.BaseWfDiagramNode&quot;,

<span id='sol-common-ObjectFormatter-TemplateWfDiagramNode-method-initialize'>  initialize: function (cfg) {
</span>    var me = this;
    me.$super(&quot;sol.common.ObjectFormatter.BaseWfDiagramNode&quot;, &quot;initialize&quot;, [cfg]);
  }
});
</pre>
</body>
</html>
