#ifndef __Indexserver_api_H__
#define __Indexserver_api_H__

#include "Byps.h"

//--------------------------------------------------------
// Forward Definitions for Namespace byps
//--------------------------------------------------------

namespace byps {

	// byps.BValueClass
	class BValueClass; 
	typedef byps_ptr< BValueClass > PBValueClass; 
	
	// java.lang.Object
	class BSerializable; 
	typedef byps_ptr< BSerializable > PSerializable; 
	
	// java.lang.String[]
	typedef ::byps::BArray1< ::std::wstring >  BArrayString;
	typedef byps_ptr< BArrayString > PArrayString;
	
	// java.util.HashMap<java.lang.Integer,java.lang.Integer>
	typedef ::std::map< int32_t , int32_t > BMapIntegerInteger;
	typedef byps_ptr< BMapIntegerInteger > PMapIntegerInteger;
	
	// java.util.List<java.lang.Integer>
	typedef ::std::vector< int32_t > BVectorInteger;
	typedef byps_ptr< BVectorInteger > PVectorInteger;
	
	// java.util.List<java.lang.Object>
	typedef ::std::vector< PSerializable > BVectorObject;
	typedef byps_ptr< BVectorObject > PVectorObject;
	
	// java.util.List<java.lang.String>
	typedef ::std::vector< ::std::wstring > BVectorString;
	typedef byps_ptr< BVectorString > PVectorString;
	
	// java.util.Map<java.lang.Integer,java.lang.Integer>
	typedef ::std::map< int32_t , int32_t > BMapIntegerInteger;
	typedef byps_ptr< BMapIntegerInteger > PMapIntegerInteger;
	
	// java.util.Map<java.lang.Integer,java.lang.String>
	typedef ::std::map< int32_t , ::std::wstring > BMapIntegerString;
	typedef byps_ptr< BMapIntegerString > PMapIntegerString;
	
	// java.util.Map<java.lang.String,java.lang.String>
	typedef ::std::map< ::std::wstring , ::std::wstring > BMapStringString;
	typedef byps_ptr< BMapStringString > PMapStringString;
	
} // byps

//--------------------------------------------------------
// Forward Definitions for Namespace de::elo::ix::client
//--------------------------------------------------------

namespace de {

	namespace elo {
	
		namespace ix {
		
			namespace client {
			
				// de.elo.ix.client.AccessC
				class AccessC; 
				typedef byps_ptr< AccessC > PAccessC; 
				
				// de.elo.ix.client.AclAccessInfo
				class AclAccessInfo; 
				typedef byps_ptr< AclAccessInfo > PAclAccessInfo; 
				
				// de.elo.ix.client.AclAccessResult
				class AclAccessResult; 
				typedef byps_ptr< AclAccessResult > PAclAccessResult; 
				
				// de.elo.ix.client.AclItem
				class AclItem; 
				typedef byps_ptr< AclItem > PAclItem; 
				
				// de.elo.ix.client.AclItemC
				class AclItemC; 
				typedef byps_ptr< AclItemC > PAclItemC; 
				
				// de.elo.ix.client.Activity
				class Activity; 
				typedef byps_ptr< Activity > PActivity; 
				
				// de.elo.ix.client.ActivityC
				class ActivityC; 
				typedef byps_ptr< ActivityC > PActivityC; 
				
				// de.elo.ix.client.ActivityDataC
				class ActivityDataC; 
				typedef byps_ptr< ActivityDataC > PActivityDataC; 
				
				// de.elo.ix.client.ActivityOption
				class ActivityOption; 
				typedef byps_ptr< ActivityOption > PActivityOption; 
				
				// de.elo.ix.client.ActivityOptionC
				class ActivityOptionC; 
				typedef byps_ptr< ActivityOptionC > PActivityOptionC; 
				
				// de.elo.ix.client.ActivityProject
				class ActivityProject; 
				typedef byps_ptr< ActivityProject > PActivityProject; 
				
				// de.elo.ix.client.ActivityProjectC
				class ActivityProjectC; 
				typedef byps_ptr< ActivityProjectC > PActivityProjectC; 
				
				// de.elo.ix.client.ActivityProjectDataC
				class ActivityProjectDataC; 
				typedef byps_ptr< ActivityProjectDataC > PActivityProjectDataC; 
				
				// de.elo.ix.client.ActivityZ
				class ActivityZ; 
				typedef byps_ptr< ActivityZ > PActivityZ; 
				
				// de.elo.ix.client.AdminModeC
				class AdminModeC; 
				typedef byps_ptr< AdminModeC > PAdminModeC; 
				
				// de.elo.ix.client.Alert
				class Alert; 
				typedef byps_ptr< Alert > PAlert; 
				
				// de.elo.ix.client.AlertC
				class AlertC; 
				typedef byps_ptr< AlertC > PAlertC; 
				
				// de.elo.ix.client.AlertDataC
				class AlertDataC; 
				typedef byps_ptr< AlertDataC > PAlertDataC; 
				
				// de.elo.ix.client.Any
				class Any; 
				typedef byps_ptr< Any > PAny; 
				
				// de.elo.ix.client.AnyC
				class AnyC; 
				typedef byps_ptr< AnyC > PAnyC; 
				
				// de.elo.ix.client.ApplyForNotificationsInfo
				class ApplyForNotificationsInfo; 
				typedef byps_ptr< ApplyForNotificationsInfo > PApplyForNotificationsInfo; 
				
				// de.elo.ix.client.ArcPath
				class ArcPath; 
				typedef byps_ptr< ArcPath > PArcPath; 
				
				// de.elo.ix.client.ArchiveStatistics
				class ArchiveStatistics; 
				typedef byps_ptr< ArchiveStatistics > PArchiveStatistics; 
				
				// de.elo.ix.client.ArchiveStatisticsOptionsC
				class ArchiveStatisticsOptionsC; 
				typedef byps_ptr< ArchiveStatisticsOptionsC > PArchiveStatisticsOptionsC; 
				
				// de.elo.ix.client.ArchivingModeC
				class ArchivingModeC; 
				typedef byps_ptr< ArchivingModeC > PArchivingModeC; 
				
				// de.elo.ix.client.AutoFilingOptions
				class AutoFilingOptions; 
				typedef byps_ptr< AutoFilingOptions > PAutoFilingOptions; 
				
				// de.elo.ix.client.AutoFilingResult
				class AutoFilingResult; 
				typedef byps_ptr< AutoFilingResult > PAutoFilingResult; 
				
				// de.elo.ix.client.BStub_IXEventBusHandler
				class BStub_IXEventBusHandler; 
				typedef byps_ptr< BStub_IXEventBusHandler > PStub_IXEventBusHandler; 
				
				// de.elo.ix.client.BStub_IXServerEvents
				class BStub_IXServerEvents; 
				typedef byps_ptr< BStub_IXServerEvents > PStub_IXServerEvents; 
				
				// de.elo.ix.client.BStub_IXServicePortIF
				class BStub_IXServicePortIF; 
				typedef byps_ptr< BStub_IXServicePortIF > PStub_IXServicePortIF; 
				
				// de.elo.ix.client.BackupProfile
				class BackupProfile; 
				typedef byps_ptr< BackupProfile > PBackupProfile; 
				
				// de.elo.ix.client.BackupPurgeStatus
				class BackupPurgeStatus; 
				typedef byps_ptr< BackupPurgeStatus > PBackupPurgeStatus; 
				
				// de.elo.ix.client.BackupStatus
				class BackupStatus; 
				typedef byps_ptr< BackupStatus > PBackupStatus; 
				
				// de.elo.ix.client.BeginForwardWorkflowNodeInfo
				class BeginForwardWorkflowNodeInfo; 
				typedef byps_ptr< BeginForwardWorkflowNodeInfo > PBeginForwardWorkflowNodeInfo; 
				
				// de.elo.ix.client.Bitset
				class Bitset; 
				typedef byps_ptr< Bitset > PBitset; 
				
				// de.elo.ix.client.CheckAccessOptions
				class CheckAccessOptions; 
				typedef byps_ptr< CheckAccessOptions > PCheckAccessOptions; 
				
				// de.elo.ix.client.CheckInDocMaskLineTemplateOptions
				class CheckInDocMaskLineTemplateOptions; 
				typedef byps_ptr< CheckInDocMaskLineTemplateOptions > PCheckInDocMaskLineTemplateOptions; 
				
				// de.elo.ix.client.CheckinDocOptions
				class CheckinDocOptions; 
				typedef byps_ptr< CheckinDocOptions > PCheckinDocOptions; 
				
				// de.elo.ix.client.CheckinOrgUnitInfo
				class CheckinOrgUnitInfo; 
				typedef byps_ptr< CheckinOrgUnitInfo > PCheckinOrgUnitInfo; 
				
				// de.elo.ix.client.CheckinReportInfo
				class CheckinReportInfo; 
				typedef byps_ptr< CheckinReportInfo > PCheckinReportInfo; 
				
				// de.elo.ix.client.CheckinUsersC
				class CheckinUsersC; 
				typedef byps_ptr< CheckinUsersC > PCheckinUsersC; 
				
				// de.elo.ix.client.CheckinUsersZ
				class CheckinUsersZ; 
				typedef byps_ptr< CheckinUsersZ > PCheckinUsersZ; 
				
				// de.elo.ix.client.CheckoutOrgUnitInfo
				class CheckoutOrgUnitInfo; 
				typedef byps_ptr< CheckoutOrgUnitInfo > PCheckoutOrgUnitInfo; 
				
				// de.elo.ix.client.CheckoutSordPathInfo
				class CheckoutSordPathInfo; 
				typedef byps_ptr< CheckoutSordPathInfo > PCheckoutSordPathInfo; 
				
				// de.elo.ix.client.CheckoutUsersC
				class CheckoutUsersC; 
				typedef byps_ptr< CheckoutUsersC > PCheckoutUsersC; 
				
				// de.elo.ix.client.CheckoutUsersZ
				class CheckoutUsersZ; 
				typedef byps_ptr< CheckoutUsersZ > PCheckoutUsersZ; 
				
				// de.elo.ix.client.CheckoutWorkflowHistoryParams
				class CheckoutWorkflowHistoryParams; 
				typedef byps_ptr< CheckoutWorkflowHistoryParams > PCheckoutWorkflowHistoryParams; 
				
				// de.elo.ix.client.CheckoutWorkflowHistoryResult
				class CheckoutWorkflowHistoryResult; 
				typedef byps_ptr< CheckoutWorkflowHistoryResult > PCheckoutWorkflowHistoryResult; 
				
				// de.elo.ix.client.ClientInfo
				class ClientInfo; 
				typedef byps_ptr< ClientInfo > PClientInfo; 
				
				// de.elo.ix.client.ClientInfoC
				class ClientInfoC; 
				typedef byps_ptr< ClientInfoC > PClientInfoC; 
				
				// de.elo.ix.client.ColorData
				class ColorData; 
				typedef byps_ptr< ColorData > PColorData; 
				
				// de.elo.ix.client.ColorDataC
				class ColorDataC; 
				typedef byps_ptr< ColorDataC > PColorDataC; 
				
				// de.elo.ix.client.ColorDataInternC
				class ColorDataInternC; 
				typedef byps_ptr< ColorDataInternC > PColorDataInternC; 
				
				// de.elo.ix.client.CombineAclOptions
				class CombineAclOptions; 
				typedef byps_ptr< CombineAclOptions > PCombineAclOptions; 
				
				// de.elo.ix.client.CombineAclResult
				class CombineAclResult; 
				typedef byps_ptr< CombineAclResult > PCombineAclResult; 
				
				// de.elo.ix.client.ConfigFile
				class ConfigFile; 
				typedef byps_ptr< ConfigFile > PConfigFile; 
				
				// de.elo.ix.client.ConfigFileC
				class ConfigFileC; 
				typedef byps_ptr< ConfigFileC > PConfigFileC; 
				
				// de.elo.ix.client.ConfigFileZ
				class ConfigFileZ; 
				typedef byps_ptr< ConfigFileZ > PConfigFileZ; 
				
				// de.elo.ix.client.ContextTerm
				class ContextTerm; 
				typedef byps_ptr< ContextTerm > PContextTerm; 
				
				// de.elo.ix.client.ControlBackupInfo
				class ControlBackupInfo; 
				typedef byps_ptr< ControlBackupInfo > PControlBackupInfo; 
				
				// de.elo.ix.client.ControlBackupInfoC
				class ControlBackupInfoC; 
				typedef byps_ptr< ControlBackupInfoC > PControlBackupInfoC; 
				
				// de.elo.ix.client.CopyInfo
				class CopyInfo; 
				typedef byps_ptr< CopyInfo > PCopyInfo; 
				
				// de.elo.ix.client.CopyOptions
				class CopyOptions; 
				typedef byps_ptr< CopyOptions > PCopyOptions; 
				
				// de.elo.ix.client.CopyResult
				class CopyResult; 
				typedef byps_ptr< CopyResult > PCopyResult; 
				
				// de.elo.ix.client.CopySordC
				class CopySordC; 
				typedef byps_ptr< CopySordC > PCopySordC; 
				
				// de.elo.ix.client.CopySordZ
				class CopySordZ; 
				typedef byps_ptr< CopySordZ > PCopySordZ; 
				
				// de.elo.ix.client.CountResult
				class CountResult; 
				typedef byps_ptr< CountResult > PCountResult; 
				
				// de.elo.ix.client.CounterInfo
				class CounterInfo; 
				typedef byps_ptr< CounterInfo > PCounterInfo; 
				
				// de.elo.ix.client.CounterInfoC
				class CounterInfoC; 
				typedef byps_ptr< CounterInfoC > PCounterInfoC; 
				
				// de.elo.ix.client.CryptInfo
				class CryptInfo; 
				typedef byps_ptr< CryptInfo > PCryptInfo; 
				
				// de.elo.ix.client.DeleteActivityOptions
				class DeleteActivityOptions; 
				typedef byps_ptr< DeleteActivityOptions > PDeleteActivityOptions; 
				
				// de.elo.ix.client.DeleteOptions
				class DeleteOptions; 
				typedef byps_ptr< DeleteOptions > PDeleteOptions; 
				
				// de.elo.ix.client.DeleteOrgUnitInfo
				class DeleteOrgUnitInfo; 
				typedef byps_ptr< DeleteOrgUnitInfo > PDeleteOrgUnitInfo; 
				
				// de.elo.ix.client.DocHistory
				class DocHistory; 
				typedef byps_ptr< DocHistory > PDocHistory; 
				
				// de.elo.ix.client.DocHistoryC
				class DocHistoryC; 
				typedef byps_ptr< DocHistoryC > PDocHistoryC; 
				
				// de.elo.ix.client.DocInfoDM
				class DocInfoDM; 
				typedef byps_ptr< DocInfoDM > PDocInfoDM; 
				
				// de.elo.ix.client.DocInfoDMC
				class DocInfoDMC; 
				typedef byps_ptr< DocInfoDMC > PDocInfoDMC; 
				
				// de.elo.ix.client.DocMask
				class DocMask; 
				typedef byps_ptr< DocMask > PDocMask; 
				
				// de.elo.ix.client.DocMaskC
				class DocMaskC; 
				typedef byps_ptr< DocMaskC > PDocMaskC; 
				
				// de.elo.ix.client.DocMaskDataC
				class DocMaskDataC; 
				typedef byps_ptr< DocMaskDataC > PDocMaskDataC; 
				
				// de.elo.ix.client.DocMaskDetails
				class DocMaskDetails; 
				typedef byps_ptr< DocMaskDetails > PDocMaskDetails; 
				
				// de.elo.ix.client.DocMaskLine
				class DocMaskLine; 
				typedef byps_ptr< DocMaskLine > PDocMaskLine; 
				
				// de.elo.ix.client.DocMaskLineC
				class DocMaskLineC; 
				typedef byps_ptr< DocMaskLineC > PDocMaskLineC; 
				
				// de.elo.ix.client.DocMaskLineDataC
				class DocMaskLineDataC; 
				typedef byps_ptr< DocMaskLineDataC > PDocMaskLineDataC; 
				
				// de.elo.ix.client.DocMaskLineTemplate
				class DocMaskLineTemplate; 
				typedef byps_ptr< DocMaskLineTemplate > PDocMaskLineTemplate; 
				
				// de.elo.ix.client.DocMaskLineTemplateC
				class DocMaskLineTemplateC; 
				typedef byps_ptr< DocMaskLineTemplateC > PDocMaskLineTemplateC; 
				
				// de.elo.ix.client.DocMaskLineTemplateDataC
				class DocMaskLineTemplateDataC; 
				typedef byps_ptr< DocMaskLineTemplateDataC > PDocMaskLineTemplateDataC; 
				
				// de.elo.ix.client.DocMaskLineTemplateZ
				class DocMaskLineTemplateZ; 
				typedef byps_ptr< DocMaskLineTemplateZ > PDocMaskLineTemplateZ; 
				
				// de.elo.ix.client.DocMaskZ
				class DocMaskZ; 
				typedef byps_ptr< DocMaskZ > PDocMaskZ; 
				
				// de.elo.ix.client.DocVersion
				class DocVersion; 
				typedef byps_ptr< DocVersion > PDocVersion; 
				
				// de.elo.ix.client.DocVersionC
				class DocVersionC; 
				typedef byps_ptr< DocVersionC > PDocVersionC; 
				
				// de.elo.ix.client.Document
				class Document; 
				typedef byps_ptr< Document > PDocument; 
				
				// de.elo.ix.client.EditInfo
				class EditInfo; 
				typedef byps_ptr< EditInfo > PEditInfo; 
				
				// de.elo.ix.client.EditInfoC
				class EditInfoC; 
				typedef byps_ptr< EditInfoC > PEditInfoC; 
				
				// de.elo.ix.client.EditInfoEswOptions
				class EditInfoEswOptions; 
				typedef byps_ptr< EditInfoEswOptions > PEditInfoEswOptions; 
				
				// de.elo.ix.client.EditInfoZ
				class EditInfoZ; 
				typedef byps_ptr< EditInfoZ > PEditInfoZ; 
				
				// de.elo.ix.client.EloDmOpt
				class EloDmOpt; 
				typedef byps_ptr< EloDmOpt > PEloDmOpt; 
				
				// de.elo.ix.client.EloDmOptC
				class EloDmOptC; 
				typedef byps_ptr< EloDmOptC > PEloDmOptC; 
				
				// de.elo.ix.client.EloDmOptDataC
				class EloDmOptDataC; 
				typedef byps_ptr< EloDmOptDataC > PEloDmOptDataC; 
				
				// de.elo.ix.client.EloFtOpt
				class EloFtOpt; 
				typedef byps_ptr< EloFtOpt > PEloFtOpt; 
				
				// de.elo.ix.client.EloFtOptC
				class EloFtOptC; 
				typedef byps_ptr< EloFtOptC > PEloFtOptC; 
				
				// de.elo.ix.client.EloFtOptDataC
				class EloFtOptDataC; 
				typedef byps_ptr< EloFtOptDataC > PEloFtOptDataC; 
				
				// de.elo.ix.client.EloFtStop
				class EloFtStop; 
				typedef byps_ptr< EloFtStop > PEloFtStop; 
				
				// de.elo.ix.client.EloFtStopC
				class EloFtStopC; 
				typedef byps_ptr< EloFtStopC > PEloFtStopC; 
				
				// de.elo.ix.client.EloIxOpt
				class EloIxOpt; 
				typedef byps_ptr< EloIxOpt > PEloIxOpt; 
				
				// de.elo.ix.client.EloIxOptC
				class EloIxOptC; 
				typedef byps_ptr< EloIxOptC > PEloIxOptC; 
				
				// de.elo.ix.client.EloIxOptDataC
				class EloIxOptDataC; 
				typedef byps_ptr< EloIxOptDataC > PEloIxOptDataC; 
				
				// de.elo.ix.client.EloIxOpt_old
				class EloIxOpt_old; 
				typedef byps_ptr< EloIxOpt_old > PEloIxOpt_old; 
				
				// de.elo.ix.client.EloIxOpt_oldC
				class EloIxOpt_oldC; 
				typedef byps_ptr< EloIxOpt_oldC > PEloIxOpt_oldC; 
				
				// de.elo.ix.client.Event
				class Event; 
				typedef byps_ptr< Event > PEvent; 
				
				// de.elo.ix.client.EventBusC
				class EventBusC; 
				typedef byps_ptr< EventBusC > PEventBusC; 
				
				// de.elo.ix.client.EventBusParams
				class EventBusParams; 
				typedef byps_ptr< EventBusParams > PEventBusParams; 
				
				// de.elo.ix.client.EventFilter
				class EventFilter; 
				typedef byps_ptr< EventFilter > PEventFilter; 
				
				// de.elo.ix.client.EventListener
				class EventListener; 
				typedef byps_ptr< EventListener > PEventListener; 
				
				// de.elo.ix.client.ExecuteScriptParams
				class ExecuteScriptParams; 
				typedef byps_ptr< ExecuteScriptParams > PExecuteScriptParams; 
				
				// de.elo.ix.client.ExecuteScriptResult
				class ExecuteScriptResult; 
				typedef byps_ptr< ExecuteScriptResult > PExecuteScriptResult; 
				
				// de.elo.ix.client.ExportExtOptions
				class ExportExtOptions; 
				typedef byps_ptr< ExportExtOptions > PExportExtOptions; 
				
				// de.elo.ix.client.ExportExtOptionsC
				class ExportExtOptionsC; 
				typedef byps_ptr< ExportExtOptionsC > PExportExtOptionsC; 
				
				// de.elo.ix.client.ExportOptionsC
				class ExportOptionsC; 
				typedef byps_ptr< ExportOptionsC > PExportOptionsC; 
				
				// de.elo.ix.client.FileData
				class FileData; 
				typedef byps_ptr< FileData > PFileData; 
				
				// de.elo.ix.client.FileDataC
				class FileDataC; 
				typedef byps_ptr< FileDataC > PFileDataC; 
				
				// de.elo.ix.client.FileDataZ
				class FileDataZ; 
				typedef byps_ptr< FileDataZ > PFileDataZ; 
				
				// de.elo.ix.client.FindActivityInfo
				class FindActivityInfo; 
				typedef byps_ptr< FindActivityInfo > PFindActivityInfo; 
				
				// de.elo.ix.client.FindActivityProjectsInfo
				class FindActivityProjectsInfo; 
				typedef byps_ptr< FindActivityProjectsInfo > PFindActivityProjectsInfo; 
				
				// de.elo.ix.client.FindAlertInfo
				class FindAlertInfo; 
				typedef byps_ptr< FindAlertInfo > PFindAlertInfo; 
				
				// de.elo.ix.client.FindBackgroundThreadOptions
				class FindBackgroundThreadOptions; 
				typedef byps_ptr< FindBackgroundThreadOptions > PFindBackgroundThreadOptions; 
				
				// de.elo.ix.client.FindByAcl
				class FindByAcl; 
				typedef byps_ptr< FindByAcl > PFindByAcl; 
				
				// de.elo.ix.client.FindByFulltext
				class FindByFulltext; 
				typedef byps_ptr< FindByFulltext > PFindByFulltext; 
				
				// de.elo.ix.client.FindByFulltextCtrl
				class FindByFulltextCtrl; 
				typedef byps_ptr< FindByFulltextCtrl > PFindByFulltextCtrl; 
				
				// de.elo.ix.client.FindByFulltextCtrlResultItem
				class FindByFulltextCtrlResultItem; 
				typedef byps_ptr< FindByFulltextCtrlResultItem > PFindByFulltextCtrlResultItem; 
				
				// de.elo.ix.client.FindByFulltextResultItem
				class FindByFulltextResultItem; 
				typedef byps_ptr< FindByFulltextResultItem > PFindByFulltextResultItem; 
				
				// de.elo.ix.client.FindByIndex
				class FindByIndex; 
				typedef byps_ptr< FindByIndex > PFindByIndex; 
				
				// de.elo.ix.client.FindByNotes
				class FindByNotes; 
				typedef byps_ptr< FindByNotes > PFindByNotes; 
				
				// de.elo.ix.client.FindByPreviewCtrl
				class FindByPreviewCtrl; 
				typedef byps_ptr< FindByPreviewCtrl > PFindByPreviewCtrl; 
				
				// de.elo.ix.client.FindByRegisteredFunction
				class FindByRegisteredFunction; 
				typedef byps_ptr< FindByRegisteredFunction > PFindByRegisteredFunction; 
				
				// de.elo.ix.client.FindBySordHist
				class FindBySordHist; 
				typedef byps_ptr< FindBySordHist > PFindBySordHist; 
				
				// de.elo.ix.client.FindByType
				class FindByType; 
				typedef byps_ptr< FindByType > PFindByType; 
				
				// de.elo.ix.client.FindByVersion
				class FindByVersion; 
				typedef byps_ptr< FindByVersion > PFindByVersion; 
				
				// de.elo.ix.client.FindChildren
				class FindChildren; 
				typedef byps_ptr< FindChildren > PFindChildren; 
				
				// de.elo.ix.client.FindConfigFileInfo
				class FindConfigFileInfo; 
				typedef byps_ptr< FindConfigFileInfo > PFindConfigFileInfo; 
				
				// de.elo.ix.client.FindDirect
				class FindDirect; 
				typedef byps_ptr< FindDirect > PFindDirect; 
				
				// de.elo.ix.client.FindDirectC
				class FindDirectC; 
				typedef byps_ptr< FindDirectC > PFindDirectC; 
				
				// de.elo.ix.client.FindInfo
				class FindInfo; 
				typedef byps_ptr< FindInfo > PFindInfo; 
				
				// de.elo.ix.client.FindInfoAsInternalSQL
				class FindInfoAsInternalSQL; 
				typedef byps_ptr< FindInfoAsInternalSQL > PFindInfoAsInternalSQL; 
				
				// de.elo.ix.client.FindLinks
				class FindLinks; 
				typedef byps_ptr< FindLinks > PFindLinks; 
				
				// de.elo.ix.client.FindOptions
				class FindOptions; 
				typedef byps_ptr< FindOptions > PFindOptions; 
				
				// de.elo.ix.client.FindReportInfo
				class FindReportInfo; 
				typedef byps_ptr< FindReportInfo > PFindReportInfo; 
				
				// de.elo.ix.client.FindResult
				class FindResult; 
				typedef byps_ptr< FindResult > PFindResult; 
				
				// de.elo.ix.client.FindSubscriptionInfo
				class FindSubscriptionInfo; 
				typedef byps_ptr< FindSubscriptionInfo > PFindSubscriptionInfo; 
				
				// de.elo.ix.client.FindTasksInfo
				class FindTasksInfo; 
				typedef byps_ptr< FindTasksInfo > PFindTasksInfo; 
				
				// de.elo.ix.client.FindTranslateTermInfo
				class FindTranslateTermInfo; 
				typedef byps_ptr< FindTranslateTermInfo > PFindTranslateTermInfo; 
				
				// de.elo.ix.client.FindUserInfo
				class FindUserInfo; 
				typedef byps_ptr< FindUserInfo > PFindUserInfo; 
				
				// de.elo.ix.client.FindWorkflowInfo
				class FindWorkflowInfo; 
				typedef byps_ptr< FindWorkflowInfo > PFindWorkflowInfo; 
				
				// de.elo.ix.client.FontInfo
				class FontInfo; 
				typedef byps_ptr< FontInfo > PFontInfo; 
				
				// de.elo.ix.client.ForwardWorkflowNodeInfo
				class ForwardWorkflowNodeInfo; 
				typedef byps_ptr< ForwardWorkflowNodeInfo > PForwardWorkflowNodeInfo; 
				
				// de.elo.ix.client.ForwardWorkflowNodeResult
				class ForwardWorkflowNodeResult; 
				typedef byps_ptr< ForwardWorkflowNodeResult > PForwardWorkflowNodeResult; 
				
				// de.elo.ix.client.FulltextConfig
				class FulltextConfig; 
				typedef byps_ptr< FulltextConfig > PFulltextConfig; 
				
				// de.elo.ix.client.FulltextConfigC
				class FulltextConfigC; 
				typedef byps_ptr< FulltextConfigC > PFulltextConfigC; 
				
				// de.elo.ix.client.GetWebDAVPathOptions
				class GetWebDAVPathOptions; 
				typedef byps_ptr< GetWebDAVPathOptions > PGetWebDAVPathOptions; 
				
				// de.elo.ix.client.GetWebDAVPathResult
				class GetWebDAVPathResult; 
				typedef byps_ptr< GetWebDAVPathResult > PGetWebDAVPathResult; 
				
				// de.elo.ix.client.HttpRequestInfo
				class HttpRequestInfo; 
				typedef byps_ptr< HttpRequestInfo > PHttpRequestInfo; 
				
				// de.elo.ix.client.HttpResponseInfo
				class HttpResponseInfo; 
				typedef byps_ptr< HttpResponseInfo > PHttpResponseInfo; 
				
				// de.elo.ix.client.IXExceptionC
				class IXExceptionC; 
				typedef byps_ptr< IXExceptionC > PIXExceptionC; 
				
				// de.elo.ix.client.IXExceptionData
				class IXExceptionData; 
				typedef byps_ptr< IXExceptionData > PIXExceptionData; 
				
				// de.elo.ix.client.IXServerEventsC
				class IXServerEventsC; 
				typedef byps_ptr< IXServerEventsC > PIXServerEventsC; 
				
				// de.elo.ix.client.IXServerEventsContext
				class IXServerEventsContext; 
				typedef byps_ptr< IXServerEventsContext > PIXServerEventsContext; 
				
				// de.elo.ix.client.IXServicePortC
				class IXServicePortC; 
				typedef byps_ptr< IXServicePortC > PIXServicePortC; 
				
				// de.elo.ix.client.IdName
				class IdName; 
				typedef byps_ptr< IdName > PIdName; 
				
				// de.elo.ix.client.ImportOptionsC
				class ImportOptionsC; 
				typedef byps_ptr< ImportOptionsC > PImportOptionsC; 
				
				// de.elo.ix.client.IndexServerForArchive
				class IndexServerForArchive; 
				typedef byps_ptr< IndexServerForArchive > PIndexServerForArchive; 
				
				// de.elo.ix.client.InheritKeywordingResult
				enum InheritKeywordingResult : int32_t; 
				
				// de.elo.ix.client.InvalidateCacheC
				class InvalidateCacheC; 
				typedef byps_ptr< InvalidateCacheC > PInvalidateCacheC; 
				
				// de.elo.ix.client.InvalidateCacheInfo
				class InvalidateCacheInfo; 
				typedef byps_ptr< InvalidateCacheInfo > PInvalidateCacheInfo; 
				
				// de.elo.ix.client.InvalidateCacheInfoParam
				class InvalidateCacheInfoParam; 
				typedef byps_ptr< InvalidateCacheInfoParam > PInvalidateCacheInfoParam; 
				
				// de.elo.ix.client.InvalidateCacheResult
				class InvalidateCacheResult; 
				typedef byps_ptr< InvalidateCacheResult > PInvalidateCacheResult; 
				
				// de.elo.ix.client.JobState
				class JobState; 
				typedef byps_ptr< JobState > PJobState; 
				
				// de.elo.ix.client.KeyInfo
				class KeyInfo; 
				typedef byps_ptr< KeyInfo > PKeyInfo; 
				
				// de.elo.ix.client.KeyValue
				class KeyValue; 
				typedef byps_ptr< KeyValue > PKeyValue; 
				
				// de.elo.ix.client.Keyword
				class Keyword; 
				typedef byps_ptr< Keyword > PKeyword; 
				
				// de.elo.ix.client.KeywordC
				class KeywordC; 
				typedef byps_ptr< KeywordC > PKeywordC; 
				
				// de.elo.ix.client.KeywordList
				class KeywordList; 
				typedef byps_ptr< KeywordList > PKeywordList; 
				
				// de.elo.ix.client.KeywordListC
				class KeywordListC; 
				typedef byps_ptr< KeywordListC > PKeywordListC; 
				
				// de.elo.ix.client.KeywordZ
				class KeywordZ; 
				typedef byps_ptr< KeywordZ > PKeywordZ; 
				
				// de.elo.ix.client.KeywordsDynamicInfo
				class KeywordsDynamicInfo; 
				typedef byps_ptr< KeywordsDynamicInfo > PKeywordsDynamicInfo; 
				
				// de.elo.ix.client.KeywordsDynamicResult
				class KeywordsDynamicResult; 
				typedef byps_ptr< KeywordsDynamicResult > PKeywordsDynamicResult; 
				
				// de.elo.ix.client.License
				class License; 
				typedef byps_ptr< License > PLicense; 
				
				// de.elo.ix.client.LicenseInfo
				class LicenseInfo; 
				typedef byps_ptr< LicenseInfo > PLicenseInfo; 
				
				// de.elo.ix.client.LicenseResult
				class LicenseResult; 
				typedef byps_ptr< LicenseResult > PLicenseResult; 
				
				// de.elo.ix.client.LinkSordC
				class LinkSordC; 
				typedef byps_ptr< LinkSordC > PLinkSordC; 
				
				// de.elo.ix.client.LinkSordInfo
				class LinkSordInfo; 
				typedef byps_ptr< LinkSordInfo > PLinkSordInfo; 
				
				// de.elo.ix.client.LinkSordZ
				class LinkSordZ; 
				typedef byps_ptr< LinkSordZ > PLinkSordZ; 
				
				// de.elo.ix.client.LockC
				class LockC; 
				typedef byps_ptr< LockC > PLockC; 
				
				// de.elo.ix.client.LockZ
				class LockZ; 
				typedef byps_ptr< LockZ > PLockZ; 
				
				// de.elo.ix.client.LoginResult
				class LoginResult; 
				typedef byps_ptr< LoginResult > PLoginResult; 
				
				// de.elo.ix.client.LoginScriptOptions
				class LoginScriptOptions; 
				typedef byps_ptr< LoginScriptOptions > PLoginScriptOptions; 
				
				// de.elo.ix.client.LoginScriptOptionsC
				class LoginScriptOptionsC; 
				typedef byps_ptr< LoginScriptOptionsC > PLoginScriptOptionsC; 
				
				// de.elo.ix.client.MapData
				class MapData; 
				typedef byps_ptr< MapData > PMapData; 
				
				// de.elo.ix.client.MapDataC
				class MapDataC; 
				typedef byps_ptr< MapDataC > PMapDataC; 
				
				// de.elo.ix.client.MapDomain
				class MapDomain; 
				typedef byps_ptr< MapDomain > PMapDomain; 
				
				// de.elo.ix.client.MapDomainC
				class MapDomainC; 
				typedef byps_ptr< MapDomainC > PMapDomainC; 
				
				// de.elo.ix.client.MapDomainDataC
				class MapDomainDataC; 
				typedef byps_ptr< MapDomainDataC > PMapDomainDataC; 
				
				// de.elo.ix.client.MapHead
				class MapHead; 
				typedef byps_ptr< MapHead > PMapHead; 
				
				// de.elo.ix.client.MapHeadC
				class MapHeadC; 
				typedef byps_ptr< MapHeadC > PMapHeadC; 
				
				// de.elo.ix.client.MapHist
				class MapHist; 
				typedef byps_ptr< MapHist > PMapHist; 
				
				// de.elo.ix.client.MapHistC
				class MapHistC; 
				typedef byps_ptr< MapHistC > PMapHistC; 
				
				// de.elo.ix.client.MapHistHeadC
				class MapHistHeadC; 
				typedef byps_ptr< MapHistHeadC > PMapHistHeadC; 
				
				// de.elo.ix.client.MapHistItem
				class MapHistItem; 
				typedef byps_ptr< MapHistItem > PMapHistItem; 
				
				// de.elo.ix.client.MapHistItemC
				class MapHistItemC; 
				typedef byps_ptr< MapHistItemC > PMapHistItemC; 
				
				// de.elo.ix.client.MapHistZ
				class MapHistZ; 
				typedef byps_ptr< MapHistZ > PMapHistZ; 
				
				// de.elo.ix.client.MapItem
				class MapItem; 
				typedef byps_ptr< MapItem > PMapItem; 
				
				// de.elo.ix.client.MapItemC
				class MapItemC; 
				typedef byps_ptr< MapItemC > PMapItemC; 
				
				// de.elo.ix.client.MapValue
				class MapValue; 
				typedef byps_ptr< MapValue > PMapValue; 
				
				// de.elo.ix.client.MaskName
				class MaskName; 
				typedef byps_ptr< MaskName > PMaskName; 
				
				// de.elo.ix.client.MoveDocumentsInfo
				class MoveDocumentsInfo; 
				typedef byps_ptr< MoveDocumentsInfo > PMoveDocumentsInfo; 
				
				// de.elo.ix.client.NavigationInfo
				class NavigationInfo; 
				typedef byps_ptr< NavigationInfo > PNavigationInfo; 
				
				// de.elo.ix.client.NavigationInfoC
				class NavigationInfoC; 
				typedef byps_ptr< NavigationInfoC > PNavigationInfoC; 
				
				// de.elo.ix.client.Note
				class Note; 
				typedef byps_ptr< Note > PNote; 
				
				// de.elo.ix.client.NoteC
				class NoteC; 
				typedef byps_ptr< NoteC > PNoteC; 
				
				// de.elo.ix.client.NoteDataC
				class NoteDataC; 
				typedef byps_ptr< NoteDataC > PNoteDataC; 
				
				// de.elo.ix.client.NoteFreehand
				class NoteFreehand; 
				typedef byps_ptr< NoteFreehand > PNoteFreehand; 
				
				// de.elo.ix.client.NoteFreehandC
				class NoteFreehandC; 
				typedef byps_ptr< NoteFreehandC > PNoteFreehandC; 
				
				// de.elo.ix.client.NoteImage
				class NoteImage; 
				typedef byps_ptr< NoteImage > PNoteImage; 
				
				// de.elo.ix.client.NoteTemplate
				class NoteTemplate; 
				typedef byps_ptr< NoteTemplate > PNoteTemplate; 
				
				// de.elo.ix.client.NoteTemplateC
				class NoteTemplateC; 
				typedef byps_ptr< NoteTemplateC > PNoteTemplateC; 
				
				// de.elo.ix.client.NoteTemplateDataC
				class NoteTemplateDataC; 
				typedef byps_ptr< NoteTemplateDataC > PNoteTemplateDataC; 
				
				// de.elo.ix.client.NoteTemplateZ
				class NoteTemplateZ; 
				typedef byps_ptr< NoteTemplateZ > PNoteTemplateZ; 
				
				// de.elo.ix.client.NoteText
				class NoteText; 
				typedef byps_ptr< NoteText > PNoteText; 
				
				// de.elo.ix.client.NoteZ
				class NoteZ; 
				typedef byps_ptr< NoteZ > PNoteZ; 
				
				// de.elo.ix.client.Notification
				class Notification; 
				typedef byps_ptr< Notification > PNotification; 
				
				// de.elo.ix.client.NotificationC
				class NotificationC; 
				typedef byps_ptr< NotificationC > PNotificationC; 
				
				// de.elo.ix.client.NotificationDataC
				class NotificationDataC; 
				typedef byps_ptr< NotificationDataC > PNotificationDataC; 
				
				// de.elo.ix.client.NotificationZ
				class NotificationZ; 
				typedef byps_ptr< NotificationZ > PNotificationZ; 
				
				// de.elo.ix.client.NotifyServerInfo
				class NotifyServerInfo; 
				typedef byps_ptr< NotifyServerInfo > PNotifyServerInfo; 
				
				// de.elo.ix.client.NotifyServerResult
				class NotifyServerResult; 
				typedef byps_ptr< NotifyServerResult > PNotifyServerResult; 
				
				// de.elo.ix.client.ObjChange
				class ObjChange; 
				typedef byps_ptr< ObjChange > PObjChange; 
				
				// de.elo.ix.client.ObjChangeC
				class ObjChangeC; 
				typedef byps_ptr< ObjChangeC > PObjChangeC; 
				
				// de.elo.ix.client.ObjDataC
				class ObjDataC; 
				typedef byps_ptr< ObjDataC > PObjDataC; 
				
				// de.elo.ix.client.ObjHistC
				class ObjHistC; 
				typedef byps_ptr< ObjHistC > PObjHistC; 
				
				// de.elo.ix.client.ObjHistKeyC
				class ObjHistKeyC; 
				typedef byps_ptr< ObjHistKeyC > PObjHistKeyC; 
				
				// de.elo.ix.client.ObjKey
				class ObjKey; 
				typedef byps_ptr< ObjKey > PObjKey; 
				
				// de.elo.ix.client.ObjKeyC
				class ObjKeyC; 
				typedef byps_ptr< ObjKeyC > PObjKeyC; 
				
				// de.elo.ix.client.ObjKeyData
				class ObjKeyData; 
				typedef byps_ptr< ObjKeyData > PObjKeyData; 
				
				// de.elo.ix.client.ObjKeyDataC
				class ObjKeyDataC; 
				typedef byps_ptr< ObjKeyDataC > PObjKeyDataC; 
				
				// de.elo.ix.client.ObjLinkC
				class ObjLinkC; 
				typedef byps_ptr< ObjLinkC > PObjLinkC; 
				
				// de.elo.ix.client.OcrInfo
				class OcrInfo; 
				typedef byps_ptr< OcrInfo > POcrInfo; 
				
				// de.elo.ix.client.OcrInfoC
				class OcrInfoC; 
				typedef byps_ptr< OcrInfoC > POcrInfoC; 
				
				// de.elo.ix.client.OcrInfoQueryLanguages
				class OcrInfoQueryLanguages; 
				typedef byps_ptr< OcrInfoQueryLanguages > POcrInfoQueryLanguages; 
				
				// de.elo.ix.client.OcrInfoRecognizeFile
				class OcrInfoRecognizeFile; 
				typedef byps_ptr< OcrInfoRecognizeFile > POcrInfoRecognizeFile; 
				
				// de.elo.ix.client.OcrRect
				class OcrRect; 
				typedef byps_ptr< OcrRect > POcrRect; 
				
				// de.elo.ix.client.OcrResult
				class OcrResult; 
				typedef byps_ptr< OcrResult > POcrResult; 
				
				// de.elo.ix.client.OcrResultQueryLanguages
				class OcrResultQueryLanguages; 
				typedef byps_ptr< OcrResultQueryLanguages > POcrResultQueryLanguages; 
				
				// de.elo.ix.client.OcrResultRecognizeFile
				class OcrResultRecognizeFile; 
				typedef byps_ptr< OcrResultRecognizeFile > POcrResultRecognizeFile; 
				
				// de.elo.ix.client.OcrWorker
				class OcrWorker; 
				typedef byps_ptr< OcrWorker > POcrWorker; 
				
				// de.elo.ix.client.OcrWorkerC
				class OcrWorkerC; 
				typedef byps_ptr< OcrWorkerC > POcrWorkerC; 
				
				// de.elo.ix.client.OrgUnitInfo
				class OrgUnitInfo; 
				typedef byps_ptr< OrgUnitInfo > POrgUnitInfo; 
				
				// de.elo.ix.client.OrgUnitInfoC
				class OrgUnitInfoC; 
				typedef byps_ptr< OrgUnitInfoC > POrgUnitInfoC; 
				
				// de.elo.ix.client.OrgUnitName
				class OrgUnitName; 
				typedef byps_ptr< OrgUnitName > POrgUnitName; 
				
				// de.elo.ix.client.PhysDel
				class PhysDel; 
				typedef byps_ptr< PhysDel > PPhysDel; 
				
				// de.elo.ix.client.PhysDelC
				class PhysDelC; 
				typedef byps_ptr< PhysDelC > PPhysDelC; 
				
				// de.elo.ix.client.PhysDelDataC
				class PhysDelDataC; 
				typedef byps_ptr< PhysDelDataC > PPhysDelDataC; 
				
				// de.elo.ix.client.PhysDelDocs
				class PhysDelDocs; 
				typedef byps_ptr< PhysDelDocs > PPhysDelDocs; 
				
				// de.elo.ix.client.PhysDelDocsC
				class PhysDelDocsC; 
				typedef byps_ptr< PhysDelDocsC > PPhysDelDocsC; 
				
				// de.elo.ix.client.PointInfo
				class PointInfo; 
				typedef byps_ptr< PointInfo > PPointInfo; 
				
				// de.elo.ix.client.PreviewImageInfo
				class PreviewImageInfo; 
				typedef byps_ptr< PreviewImageInfo > PPreviewImageInfo; 
				
				// de.elo.ix.client.PreviewImageInfoC
				class PreviewImageInfoC; 
				typedef byps_ptr< PreviewImageInfoC > PPreviewImageInfoC; 
				
				// de.elo.ix.client.PreviewImageResult
				class PreviewImageResult; 
				typedef byps_ptr< PreviewImageResult > PPreviewImageResult; 
				
				// de.elo.ix.client.ProcessAcl
				class ProcessAcl; 
				typedef byps_ptr< ProcessAcl > PProcessAcl; 
				
				// de.elo.ix.client.ProcessCopyElements
				class ProcessCopyElements; 
				typedef byps_ptr< ProcessCopyElements > PProcessCopyElements; 
				
				// de.elo.ix.client.ProcessCountElements
				class ProcessCountElements; 
				typedef byps_ptr< ProcessCountElements > PProcessCountElements; 
				
				// de.elo.ix.client.ProcessFulltext
				class ProcessFulltext; 
				typedef byps_ptr< ProcessFulltext > PProcessFulltext; 
				
				// de.elo.ix.client.ProcessInfo
				class ProcessInfo; 
				typedef byps_ptr< ProcessInfo > PProcessInfo; 
				
				// de.elo.ix.client.ProcessInfoC
				class ProcessInfoC; 
				typedef byps_ptr< ProcessInfoC > PProcessInfoC; 
				
				// de.elo.ix.client.ProcessInheritKeywording
				class ProcessInheritKeywording; 
				typedef byps_ptr< ProcessInheritKeywording > PProcessInheritKeywording; 
				
				// de.elo.ix.client.ProcessMoveDocumentsToStoragePath
				class ProcessMoveDocumentsToStoragePath; 
				typedef byps_ptr< ProcessMoveDocumentsToStoragePath > PProcessMoveDocumentsToStoragePath; 
				
				// de.elo.ix.client.ProcessReleaseLock
				class ProcessReleaseLock; 
				typedef byps_ptr< ProcessReleaseLock > PProcessReleaseLock; 
				
				// de.elo.ix.client.ProcessReplSet
				class ProcessReplSet; 
				typedef byps_ptr< ProcessReplSet > PProcessReplSet; 
				
				// de.elo.ix.client.ProcessScript
				class ProcessScript; 
				typedef byps_ptr< ProcessScript > PProcessScript; 
				
				// de.elo.ix.client.PublicDownload
				class PublicDownload; 
				typedef byps_ptr< PublicDownload > PPublicDownload; 
				
				// de.elo.ix.client.PublicDownloadC
				class PublicDownloadC; 
				typedef byps_ptr< PublicDownloadC > PPublicDownloadC; 
				
				// de.elo.ix.client.PublicDownloadDataC
				class PublicDownloadDataC; 
				typedef byps_ptr< PublicDownloadDataC > PPublicDownloadDataC; 
				
				// de.elo.ix.client.PublicDownloadOptions
				class PublicDownloadOptions; 
				typedef byps_ptr< PublicDownloadOptions > PPublicDownloadOptions; 
				
				// de.elo.ix.client.PurgeSettings
				class PurgeSettings; 
				typedef byps_ptr< PurgeSettings > PPurgeSettings; 
				
				// de.elo.ix.client.PurgeSettingsC
				class PurgeSettingsC; 
				typedef byps_ptr< PurgeSettingsC > PPurgeSettingsC; 
				
				// de.elo.ix.client.PurgeStatus
				class PurgeStatus; 
				typedef byps_ptr< PurgeStatus > PPurgeStatus; 
				
				// de.elo.ix.client.QueryJobProtocolC
				class QueryJobProtocolC; 
				typedef byps_ptr< QueryJobProtocolC > PQueryJobProtocolC; 
				
				// de.elo.ix.client.QueryJobProtocolEvent
				class QueryJobProtocolEvent; 
				typedef byps_ptr< QueryJobProtocolEvent > PQueryJobProtocolEvent; 
				
				// de.elo.ix.client.QueryJobProtocolInfo
				class QueryJobProtocolInfo; 
				typedef byps_ptr< QueryJobProtocolInfo > PQueryJobProtocolInfo; 
				
				// de.elo.ix.client.QueryJobProtocolResult
				class QueryJobProtocolResult; 
				typedef byps_ptr< QueryJobProtocolResult > PQueryJobProtocolResult; 
				
				// de.elo.ix.client.Relation
				class Relation; 
				typedef byps_ptr< Relation > PRelation; 
				
				// de.elo.ix.client.RelationC
				class RelationC; 
				typedef byps_ptr< RelationC > PRelationC; 
				
				// de.elo.ix.client.Reminder
				class Reminder; 
				typedef byps_ptr< Reminder > PReminder; 
				
				// de.elo.ix.client.ReminderC
				class ReminderC; 
				typedef byps_ptr< ReminderC > PReminderC; 
				
				// de.elo.ix.client.ReminderDataC
				class ReminderDataC; 
				typedef byps_ptr< ReminderDataC > PReminderDataC; 
				
				// de.elo.ix.client.ReplCode
				class ReplCode; 
				typedef byps_ptr< ReplCode > PReplCode; 
				
				// de.elo.ix.client.ReplSet
				class ReplSet; 
				typedef byps_ptr< ReplSet > PReplSet; 
				
				// de.elo.ix.client.ReplSetCombination
				class ReplSetCombination; 
				typedef byps_ptr< ReplSetCombination > PReplSetCombination; 
				
				// de.elo.ix.client.ReplSetCombinationC
				class ReplSetCombinationC; 
				typedef byps_ptr< ReplSetCombinationC > PReplSetCombinationC; 
				
				// de.elo.ix.client.ReplSetName
				class ReplSetName; 
				typedef byps_ptr< ReplSetName > PReplSetName; 
				
				// de.elo.ix.client.ReplSetNameC
				class ReplSetNameC; 
				typedef byps_ptr< ReplSetNameC > PReplSetNameC; 
				
				// de.elo.ix.client.RepliHist
				class RepliHist; 
				typedef byps_ptr< RepliHist > PRepliHist; 
				
				// de.elo.ix.client.RepliHistC
				class RepliHistC; 
				typedef byps_ptr< RepliHistC > PRepliHistC; 
				
				// de.elo.ix.client.ReportC
				class ReportC; 
				typedef byps_ptr< ReportC > PReportC; 
				
				// de.elo.ix.client.ReportErpCode
				class ReportErpCode; 
				typedef byps_ptr< ReportErpCode > PReportErpCode; 
				
				// de.elo.ix.client.ReportInfo
				class ReportInfo; 
				typedef byps_ptr< ReportInfo > PReportInfo; 
				
				// de.elo.ix.client.ReportInfoC
				class ReportInfoC; 
				typedef byps_ptr< ReportInfoC > PReportInfoC; 
				
				// de.elo.ix.client.ReportInfoUserModified
				class ReportInfoUserModified; 
				typedef byps_ptr< ReportInfoUserModified > PReportInfoUserModified; 
				
				// de.elo.ix.client.ReportInfoUserProps
				class ReportInfoUserProps; 
				typedef byps_ptr< ReportInfoUserProps > PReportInfoUserProps; 
				
				// de.elo.ix.client.ReportModeC
				class ReportModeC; 
				typedef byps_ptr< ReportModeC > PReportModeC; 
				
				// de.elo.ix.client.ReportModeZ
				class ReportModeZ; 
				typedef byps_ptr< ReportModeZ > PReportModeZ; 
				
				// de.elo.ix.client.ReportOptions
				class ReportOptions; 
				typedef byps_ptr< ReportOptions > PReportOptions; 
				
				// de.elo.ix.client.ReportOptionsC
				class ReportOptionsC; 
				typedef byps_ptr< ReportOptionsC > PReportOptionsC; 
				
				// de.elo.ix.client.ResolveRightsInfo
				class ResolveRightsInfo; 
				typedef byps_ptr< ResolveRightsInfo > PResolveRightsInfo; 
				
				// de.elo.ix.client.ResolveRightsResult
				class ResolveRightsResult; 
				typedef byps_ptr< ResolveRightsResult > PResolveRightsResult; 
				
				// de.elo.ix.client.ResolveRightsResultC
				class ResolveRightsResultC; 
				typedef byps_ptr< ResolveRightsResultC > PResolveRightsResultC; 
				
				// de.elo.ix.client.RestoreOptions
				class RestoreOptions; 
				typedef byps_ptr< RestoreOptions > PRestoreOptions; 
				
				// de.elo.ix.client.SearchModeC
				class SearchModeC; 
				typedef byps_ptr< SearchModeC > PSearchModeC; 
				
				// de.elo.ix.client.SearchModeZ
				class SearchModeZ; 
				typedef byps_ptr< SearchModeZ > PSearchModeZ; 
				
				// de.elo.ix.client.SearchTermsC
				class SearchTermsC; 
				typedef byps_ptr< SearchTermsC > PSearchTermsC; 
				
				// de.elo.ix.client.ServerInfo
				class ServerInfo; 
				typedef byps_ptr< ServerInfo > PServerInfo; 
				
				// de.elo.ix.client.ServerInfoDM
				class ServerInfoDM; 
				typedef byps_ptr< ServerInfoDM > PServerInfoDM; 
				
				// de.elo.ix.client.ServerInfoDMC
				class ServerInfoDMC; 
				typedef byps_ptr< ServerInfoDMC > PServerInfoDMC; 
				
				// de.elo.ix.client.ServerState
				class ServerState; 
				typedef byps_ptr< ServerState > PServerState; 
				
				// de.elo.ix.client.ServerStateC
				class ServerStateC; 
				typedef byps_ptr< ServerStateC > PServerStateC; 
				
				// de.elo.ix.client.SessionInfo
				class SessionInfo; 
				typedef byps_ptr< SessionInfo > PSessionInfo; 
				
				// de.elo.ix.client.SessionInfoParams
				class SessionInfoParams; 
				typedef byps_ptr< SessionInfoParams > PSessionInfoParams; 
				
				// de.elo.ix.client.SessionOptions
				class SessionOptions; 
				typedef byps_ptr< SessionOptions > PSessionOptions; 
				
				// de.elo.ix.client.SessionOptionsC
				class SessionOptionsC; 
				typedef byps_ptr< SessionOptionsC > PSessionOptionsC; 
				
				// de.elo.ix.client.Sord
				class Sord; 
				typedef byps_ptr< Sord > PSord; 
				
				// de.elo.ix.client.SordC
				class SordC; 
				typedef byps_ptr< SordC > PSordC; 
				
				// de.elo.ix.client.SordDetails
				class SordDetails; 
				typedef byps_ptr< SordDetails > PSordDetails; 
				
				// de.elo.ix.client.SordHist
				class SordHist; 
				typedef byps_ptr< SordHist > PSordHist; 
				
				// de.elo.ix.client.SordHistC
				class SordHistC; 
				typedef byps_ptr< SordHistC > PSordHistC; 
				
				// de.elo.ix.client.SordHistKey
				class SordHistKey; 
				typedef byps_ptr< SordHistKey > PSordHistKey; 
				
				// de.elo.ix.client.SordHistKeyC
				class SordHistKeyC; 
				typedef byps_ptr< SordHistKeyC > PSordHistKeyC; 
				
				// de.elo.ix.client.SordLink
				class SordLink; 
				typedef byps_ptr< SordLink > PSordLink; 
				
				// de.elo.ix.client.SordLinkC
				class SordLinkC; 
				typedef byps_ptr< SordLinkC > PSordLinkC; 
				
				// de.elo.ix.client.SordPath
				class SordPath; 
				typedef byps_ptr< SordPath > PSordPath; 
				
				// de.elo.ix.client.SordPaths
				class SordPaths; 
				typedef byps_ptr< SordPaths > PSordPaths; 
				
				// de.elo.ix.client.SordType
				class SordType; 
				typedef byps_ptr< SordType > PSordType; 
				
				// de.elo.ix.client.SordTypeC
				class SordTypeC; 
				typedef byps_ptr< SordTypeC > PSordTypeC; 
				
				// de.elo.ix.client.SordTypeZ
				class SordTypeZ; 
				typedef byps_ptr< SordTypeZ > PSordTypeZ; 
				
				// de.elo.ix.client.SordZ
				class SordZ; 
				typedef byps_ptr< SordZ > PSordZ; 
				
				// de.elo.ix.client.SortOrderC
				class SortOrderC; 
				typedef byps_ptr< SortOrderC > PSortOrderC; 
				
				// de.elo.ix.client.StartAdHocWorkflowInfo
				class StartAdHocWorkflowInfo; 
				typedef byps_ptr< StartAdHocWorkflowInfo > PStartAdHocWorkflowInfo; 
				
				// de.elo.ix.client.StoreInfo
				class StoreInfo; 
				typedef byps_ptr< StoreInfo > PStoreInfo; 
				
				// de.elo.ix.client.StoreInfoC
				class StoreInfoC; 
				typedef byps_ptr< StoreInfoC > PStoreInfoC; 
				
				// de.elo.ix.client.SubsInfo
				class SubsInfo; 
				typedef byps_ptr< SubsInfo > PSubsInfo; 
				
				// de.elo.ix.client.Subscription
				class Subscription; 
				typedef byps_ptr< Subscription > PSubscription; 
				
				// de.elo.ix.client.SubscriptionC
				class SubscriptionC; 
				typedef byps_ptr< SubscriptionC > PSubscriptionC; 
				
				// de.elo.ix.client.SubscriptionDataC
				class SubscriptionDataC; 
				typedef byps_ptr< SubscriptionDataC > PSubscriptionDataC; 
				
				// de.elo.ix.client.SubscriptionZ
				class SubscriptionZ; 
				typedef byps_ptr< SubscriptionZ > PSubscriptionZ; 
				
				// de.elo.ix.client.Thesaurus
				class Thesaurus; 
				typedef byps_ptr< Thesaurus > PThesaurus; 
				
				// de.elo.ix.client.ThesaurusC
				class ThesaurusC; 
				typedef byps_ptr< ThesaurusC > PThesaurusC; 
				
				// de.elo.ix.client.TranslateTerm
				class TranslateTerm; 
				typedef byps_ptr< TranslateTerm > PTranslateTerm; 
				
				// de.elo.ix.client.TranslateTermC
				class TranslateTermC; 
				typedef byps_ptr< TranslateTermC > PTranslateTermC; 
				
				// de.elo.ix.client.TranslateTermData
				class TranslateTermData; 
				typedef byps_ptr< TranslateTermData > PTranslateTermData; 
				
				// de.elo.ix.client.TranslateTermDataC
				class TranslateTermDataC; 
				typedef byps_ptr< TranslateTermDataC > PTranslateTermDataC; 
				
				// de.elo.ix.client.UrlParams
				class UrlParams; 
				typedef byps_ptr< UrlParams > PUrlParams; 
				
				// de.elo.ix.client.UserInfo
				class UserInfo; 
				typedef byps_ptr< UserInfo > PUserInfo; 
				
				// de.elo.ix.client.UserInfoC
				class UserInfoC; 
				typedef byps_ptr< UserInfoC > PUserInfoC; 
				
				// de.elo.ix.client.UserName
				class UserName; 
				typedef byps_ptr< UserName > PUserName; 
				
				// de.elo.ix.client.UserNodeInfo
				class UserNodeInfo; 
				typedef byps_ptr< UserNodeInfo > PUserNodeInfo; 
				
				// de.elo.ix.client.UserProfile
				class UserProfile; 
				typedef byps_ptr< UserProfile > PUserProfile; 
				
				// de.elo.ix.client.UserProfileC
				class UserProfileC; 
				typedef byps_ptr< UserProfileC > PUserProfileC; 
				
				// de.elo.ix.client.UserProfileData
				class UserProfileData; 
				typedef byps_ptr< UserProfileData > PUserProfileData; 
				
				// de.elo.ix.client.UserProfileDataC
				class UserProfileDataC; 
				typedef byps_ptr< UserProfileDataC > PUserProfileDataC; 
				
				// de.elo.ix.client.UserTask
				class UserTask; 
				typedef byps_ptr< UserTask > PUserTask; 
				
				// de.elo.ix.client.UserTaskPriorityC
				class UserTaskPriorityC; 
				typedef byps_ptr< UserTaskPriorityC > PUserTaskPriorityC; 
				
				// de.elo.ix.client.UserTaskSortOrderC
				class UserTaskSortOrderC; 
				typedef byps_ptr< UserTaskSortOrderC > PUserTaskSortOrderC; 
				
				// de.elo.ix.client.UserTaskSortOrderZ
				class UserTaskSortOrderZ; 
				typedef byps_ptr< UserTaskSortOrderZ > PUserTaskSortOrderZ; 
				
				// de.elo.ix.client.ValueClass
				class ValueClass; 
				typedef byps_ptr< ValueClass > PValueClass; 
				
				// de.elo.ix.client.ValuesOfObjKey
				class ValuesOfObjKey; 
				typedef byps_ptr< ValuesOfObjKey > PValuesOfObjKey; 
				
				// de.elo.ix.client.ValuesOfObjKeyOptions
				class ValuesOfObjKeyOptions; 
				typedef byps_ptr< ValuesOfObjKeyOptions > PValuesOfObjKeyOptions; 
				
				// de.elo.ix.client.VtDoc
				class VtDoc; 
				typedef byps_ptr< VtDoc > PVtDoc; 
				
				// de.elo.ix.client.VtDocC
				class VtDocC; 
				typedef byps_ptr< VtDocC > PVtDocC; 
				
				// de.elo.ix.client.WFCollectNode
				class WFCollectNode; 
				typedef byps_ptr< WFCollectNode > PWFCollectNode; 
				
				// de.elo.ix.client.WFDelegateNodeInfo
				class WFDelegateNodeInfo; 
				typedef byps_ptr< WFDelegateNodeInfo > PWFDelegateNodeInfo; 
				
				// de.elo.ix.client.WFDiagram
				class WFDiagram; 
				typedef byps_ptr< WFDiagram > PWFDiagram; 
				
				// de.elo.ix.client.WFDiagramC
				class WFDiagramC; 
				typedef byps_ptr< WFDiagramC > PWFDiagramC; 
				
				// de.elo.ix.client.WFDiagramZ
				class WFDiagramZ; 
				typedef byps_ptr< WFDiagramZ > PWFDiagramZ; 
				
				// de.elo.ix.client.WFEditNode
				class WFEditNode; 
				typedef byps_ptr< WFEditNode > PWFEditNode; 
				
				// de.elo.ix.client.WFNode
				class WFNode; 
				typedef byps_ptr< WFNode > PWFNode; 
				
				// de.elo.ix.client.WFNodeAssoc
				class WFNodeAssoc; 
				typedef byps_ptr< WFNodeAssoc > PWFNodeAssoc; 
				
				// de.elo.ix.client.WFNodeC
				class WFNodeC; 
				typedef byps_ptr< WFNodeC > PWFNodeC; 
				
				// de.elo.ix.client.WFNodeHistory
				class WFNodeHistory; 
				typedef byps_ptr< WFNodeHistory > PWFNodeHistory; 
				
				// de.elo.ix.client.WFNodeHistoryC
				class WFNodeHistoryC; 
				typedef byps_ptr< WFNodeHistoryC > PWFNodeHistoryC; 
				
				// de.elo.ix.client.WFNodeMatrix
				class WFNodeMatrix; 
				typedef byps_ptr< WFNodeMatrix > PWFNodeMatrix; 
				
				// de.elo.ix.client.WFNodeMatrixC
				class WFNodeMatrixC; 
				typedef byps_ptr< WFNodeMatrixC > PWFNodeMatrixC; 
				
				// de.elo.ix.client.WFNodeZ
				class WFNodeZ; 
				typedef byps_ptr< WFNodeZ > PWFNodeZ; 
				
				// de.elo.ix.client.WFTakeNodeC
				class WFTakeNodeC; 
				typedef byps_ptr< WFTakeNodeC > PWFTakeNodeC; 
				
				// de.elo.ix.client.WFTimeLimit
				class WFTimeLimit; 
				typedef byps_ptr< WFTimeLimit > PWFTimeLimit; 
				
				// de.elo.ix.client.WFTypeC
				class WFTypeC; 
				typedef byps_ptr< WFTypeC > PWFTypeC; 
				
				// de.elo.ix.client.WFTypeZ
				class WFTypeZ; 
				typedef byps_ptr< WFTypeZ > PWFTypeZ; 
				
				// de.elo.ix.client.WFVersion
				class WFVersion; 
				typedef byps_ptr< WFVersion > PWFVersion; 
				
				// de.elo.ix.client.WFVersionC
				class WFVersionC; 
				typedef byps_ptr< WFVersionC > PWFVersionC; 
				
				// de.elo.ix.client.WorkFlowActiveDoc
				class WorkFlowActiveDoc; 
				typedef byps_ptr< WorkFlowActiveDoc > PWorkFlowActiveDoc; 
				
				// de.elo.ix.client.WorkFlowActiveDocC
				class WorkFlowActiveDocC; 
				typedef byps_ptr< WorkFlowActiveDocC > PWorkFlowActiveDocC; 
				
				// de.elo.ix.client.WorkFlowHead
				class WorkFlowHead; 
				typedef byps_ptr< WorkFlowHead > PWorkFlowHead; 
				
				// de.elo.ix.client.WorkFlowHeadC
				class WorkFlowHeadC; 
				typedef byps_ptr< WorkFlowHeadC > PWorkFlowHeadC; 
				
				// de.elo.ix.client.WorkFlowNodeMatrix
				class WorkFlowNodeMatrix; 
				typedef byps_ptr< WorkFlowNodeMatrix > PWorkFlowNodeMatrix; 
				
				// de.elo.ix.client.WorkFlowNodeMatrixC
				class WorkFlowNodeMatrixC; 
				typedef byps_ptr< WorkFlowNodeMatrixC > PWorkFlowNodeMatrixC; 
				
				// de.elo.ix.client.WorkflowExchangeInfo
				class WorkflowExchangeInfo; 
				typedef byps_ptr< WorkflowExchangeInfo > PWorkflowExchangeInfo; 
				
				// de.elo.ix.client.WorkflowExportOptions
				class WorkflowExportOptions; 
				typedef byps_ptr< WorkflowExportOptions > PWorkflowExportOptions; 
				
				// de.elo.ix.client.WorkflowExportOptionsC
				class WorkflowExportOptionsC; 
				typedef byps_ptr< WorkflowExportOptionsC > PWorkflowExportOptionsC; 
				
				// de.elo.ix.client.WorkflowImportOptions
				class WorkflowImportOptions; 
				typedef byps_ptr< WorkflowImportOptions > PWorkflowImportOptions; 
				
				// de.elo.ix.client.WorkflowNodeInfo
				class WorkflowNodeInfo; 
				typedef byps_ptr< WorkflowNodeInfo > PWorkflowNodeInfo; 
				
				// de.elo.ix.client.IXEventBusHandler
				class IXEventBusHandler; 
				typedef byps_ptr< IXEventBusHandler > PIXEventBusHandler; 
				
				// de.elo.ix.client.IXServerEvents
				class IXServerEvents; 
				typedef byps_ptr< IXServerEvents > PIXServerEvents; 
				
				// de.elo.ix.client.IXServicePortIF
				class IXServicePortIF; 
				typedef byps_ptr< IXServicePortIF > PIXServicePortIF; 
				
				// de.elo.ix.client.IXServicePortIFAuth
				class IXServicePortIFAuth; 
				typedef byps_ptr< IXServicePortIFAuth > PIXServicePortIFAuth; 
				
				// de.elo.ix.client.AclItem[]
				typedef ::byps::BArray1< de::elo::ix::client::PAclItem >  BArrayAclItem;
				typedef byps_ptr< BArrayAclItem > PArrayAclItem;
				
				// de.elo.ix.client.ActivityOption[]
				typedef ::byps::BArray1< de::elo::ix::client::PActivityOption >  BArrayActivityOption;
				typedef byps_ptr< BArrayActivityOption > PArrayActivityOption;
				
				// de.elo.ix.client.ActivityProject[]
				typedef ::byps::BArray1< de::elo::ix::client::PActivityProject >  BArrayActivityProject;
				typedef byps_ptr< BArrayActivityProject > PArrayActivityProject;
				
				// de.elo.ix.client.Any[]
				typedef ::byps::BArray1< de::elo::ix::client::PAny >  BArrayAny;
				typedef byps_ptr< BArrayAny > PArrayAny;
				
				// de.elo.ix.client.ArcPath[]
				typedef ::byps::BArray1< de::elo::ix::client::PArcPath >  BArrayArcPath;
				typedef byps_ptr< BArrayArcPath > PArrayArcPath;
				
				// de.elo.ix.client.BackupProfile[]
				typedef ::byps::BArray1< de::elo::ix::client::PBackupProfile >  BArrayBackupProfile;
				typedef byps_ptr< BArrayBackupProfile > PArrayBackupProfile;
				
				// de.elo.ix.client.ColorData[]
				typedef ::byps::BArray1< de::elo::ix::client::PColorData >  BArrayColorData;
				typedef byps_ptr< BArrayColorData > PArrayColorData;
				
				// de.elo.ix.client.ConfigFile[]
				typedef ::byps::BArray1< de::elo::ix::client::PConfigFile >  BArrayConfigFile;
				typedef byps_ptr< BArrayConfigFile > PArrayConfigFile;
				
				// de.elo.ix.client.ContextTerm[]
				typedef ::byps::BArray1< de::elo::ix::client::PContextTerm >  BArrayContextTerm;
				typedef byps_ptr< BArrayContextTerm > PArrayContextTerm;
				
				// de.elo.ix.client.CounterInfo[]
				typedef ::byps::BArray1< de::elo::ix::client::PCounterInfo >  BArrayCounterInfo;
				typedef byps_ptr< BArrayCounterInfo > PArrayCounterInfo;
				
				// de.elo.ix.client.CryptInfo[]
				typedef ::byps::BArray1< de::elo::ix::client::PCryptInfo >  BArrayCryptInfo;
				typedef byps_ptr< BArrayCryptInfo > PArrayCryptInfo;
				
				// de.elo.ix.client.DocMaskLineTemplate[]
				typedef ::byps::BArray1< de::elo::ix::client::PDocMaskLineTemplate >  BArrayDocMaskLineTemplate;
				typedef byps_ptr< BArrayDocMaskLineTemplate > PArrayDocMaskLineTemplate;
				
				// de.elo.ix.client.DocMaskLine[]
				typedef ::byps::BArray1< de::elo::ix::client::PDocMaskLine >  BArrayDocMaskLine;
				typedef byps_ptr< BArrayDocMaskLine > PArrayDocMaskLine;
				
				// de.elo.ix.client.DocVersion[]
				typedef ::byps::BArray1< de::elo::ix::client::PDocVersion >  BArrayDocVersion;
				typedef byps_ptr< BArrayDocVersion > PArrayDocVersion;
				
				// de.elo.ix.client.Document[]
				typedef ::byps::BArray1< de::elo::ix::client::PDocument >  BArrayDocument;
				typedef byps_ptr< BArrayDocument > PArrayDocument;
				
				// de.elo.ix.client.EditInfo[]
				typedef ::byps::BArray1< de::elo::ix::client::PEditInfo >  BArrayEditInfo;
				typedef byps_ptr< BArrayEditInfo > PArrayEditInfo;
				
				// de.elo.ix.client.EventFilter[]
				typedef ::byps::BArray1< de::elo::ix::client::PEventFilter >  BArrayEventFilter;
				typedef byps_ptr< BArrayEventFilter > PArrayEventFilter;
				
				// de.elo.ix.client.Event[]
				typedef ::byps::BArray1< de::elo::ix::client::PEvent >  BArrayEvent;
				typedef byps_ptr< BArrayEvent > PArrayEvent;
				
				// de.elo.ix.client.FileData[]
				typedef ::byps::BArray1< de::elo::ix::client::PFileData >  BArrayFileData;
				typedef byps_ptr< BArrayFileData > PArrayFileData;
				
				// de.elo.ix.client.FindByFulltextCtrlResultItem[]
				typedef ::byps::BArray1< de::elo::ix::client::PFindByFulltextCtrlResultItem >  BArrayFindByFulltextCtrlResultItem;
				typedef byps_ptr< BArrayFindByFulltextCtrlResultItem > PArrayFindByFulltextCtrlResultItem;
				
				// de.elo.ix.client.FindByFulltextResultItem[]
				typedef ::byps::BArray1< de::elo::ix::client::PFindByFulltextResultItem >  BArrayFindByFulltextResultItem;
				typedef byps_ptr< BArrayFindByFulltextResultItem > PArrayFindByFulltextResultItem;
				
				// de.elo.ix.client.IdName[]
				typedef ::byps::BArray1< de::elo::ix::client::PIdName >  BArrayIdName;
				typedef byps_ptr< BArrayIdName > PArrayIdName;
				
				// de.elo.ix.client.IndexServerForArchive[]
				typedef ::byps::BArray1< de::elo::ix::client::PIndexServerForArchive >  BArrayIndexServerForArchive;
				typedef byps_ptr< BArrayIndexServerForArchive > PArrayIndexServerForArchive;
				
				// de.elo.ix.client.JobState[]
				typedef ::byps::BArray1< de::elo::ix::client::PJobState >  BArrayJobState;
				typedef byps_ptr< BArrayJobState > PArrayJobState;
				
				// de.elo.ix.client.KeyInfo[]
				typedef ::byps::BArray1< de::elo::ix::client::PKeyInfo >  BArrayKeyInfo;
				typedef byps_ptr< BArrayKeyInfo > PArrayKeyInfo;
				
				// de.elo.ix.client.KeyValue[]
				typedef ::byps::BArray1< de::elo::ix::client::PKeyValue >  BArrayKeyValue;
				typedef byps_ptr< BArrayKeyValue > PArrayKeyValue;
				
				// de.elo.ix.client.Keyword[]
				typedef ::byps::BArray1< de::elo::ix::client::PKeyword >  BArrayKeyword;
				typedef byps_ptr< BArrayKeyword > PArrayKeyword;
				
				// de.elo.ix.client.MapDomain[]
				typedef ::byps::BArray1< de::elo::ix::client::PMapDomain >  BArrayMapDomain;
				typedef byps_ptr< BArrayMapDomain > PArrayMapDomain;
				
				// de.elo.ix.client.MapHistItem[]
				typedef ::byps::BArray1< de::elo::ix::client::PMapHistItem >  BArrayMapHistItem;
				typedef byps_ptr< BArrayMapHistItem > PArrayMapHistItem;
				
				// de.elo.ix.client.MapHist[]
				typedef ::byps::BArray1< de::elo::ix::client::PMapHist >  BArrayMapHist;
				typedef byps_ptr< BArrayMapHist > PArrayMapHist;
				
				// de.elo.ix.client.MaskName[]
				typedef ::byps::BArray1< de::elo::ix::client::PMaskName >  BArrayMaskName;
				typedef byps_ptr< BArrayMaskName > PArrayMaskName;
				
				// de.elo.ix.client.NoteTemplate[]
				typedef ::byps::BArray1< de::elo::ix::client::PNoteTemplate >  BArrayNoteTemplate;
				typedef byps_ptr< BArrayNoteTemplate > PArrayNoteTemplate;
				
				// de.elo.ix.client.Note[]
				typedef ::byps::BArray1< de::elo::ix::client::PNote >  BArrayNote;
				typedef byps_ptr< BArrayNote > PArrayNote;
				
				// de.elo.ix.client.ObjKey[]
				typedef ::byps::BArray1< de::elo::ix::client::PObjKey >  BArrayObjKey;
				typedef byps_ptr< BArrayObjKey > PArrayObjKey;
				
				// de.elo.ix.client.OcrRect[]
				typedef ::byps::BArray1< de::elo::ix::client::POcrRect >  BArrayOcrRect;
				typedef byps_ptr< BArrayOcrRect > PArrayOcrRect;
				
				// de.elo.ix.client.OrgUnitInfo[]
				typedef ::byps::BArray1< de::elo::ix::client::POrgUnitInfo >  BArrayOrgUnitInfo;
				typedef byps_ptr< BArrayOrgUnitInfo > PArrayOrgUnitInfo;
				
				// de.elo.ix.client.PointInfo[]
				typedef ::byps::BArray1< de::elo::ix::client::PPointInfo >  BArrayPointInfo;
				typedef byps_ptr< BArrayPointInfo > PArrayPointInfo;
				
				// de.elo.ix.client.QueryJobProtocolEvent[]
				typedef ::byps::BArray1< de::elo::ix::client::PQueryJobProtocolEvent >  BArrayQueryJobProtocolEvent;
				typedef byps_ptr< BArrayQueryJobProtocolEvent > PArrayQueryJobProtocolEvent;
				
				// de.elo.ix.client.Reminder[]
				typedef ::byps::BArray1< de::elo::ix::client::PReminder >  BArrayReminder;
				typedef byps_ptr< BArrayReminder > PArrayReminder;
				
				// de.elo.ix.client.ReplSetName[]
				typedef ::byps::BArray1< de::elo::ix::client::PReplSetName >  BArrayReplSetName;
				typedef byps_ptr< BArrayReplSetName > PArrayReplSetName;
				
				// de.elo.ix.client.ReportErpCode[]
				typedef ::byps::BArray1< de::elo::ix::client::PReportErpCode >  BArrayReportErpCode;
				typedef byps_ptr< BArrayReportErpCode > PArrayReportErpCode;
				
				// de.elo.ix.client.ReportInfo[]
				typedef ::byps::BArray1< de::elo::ix::client::PReportInfo >  BArrayReportInfo;
				typedef byps_ptr< BArrayReportInfo > PArrayReportInfo;
				
				// de.elo.ix.client.SessionInfo[]
				typedef ::byps::BArray1< de::elo::ix::client::PSessionInfo >  BArraySessionInfo;
				typedef byps_ptr< BArraySessionInfo > PArraySessionInfo;
				
				// de.elo.ix.client.SordHistKey[]
				typedef ::byps::BArray1< de::elo::ix::client::PSordHistKey >  BArraySordHistKey;
				typedef byps_ptr< BArraySordHistKey > PArraySordHistKey;
				
				// de.elo.ix.client.SordHist[]
				typedef ::byps::BArray1< de::elo::ix::client::PSordHist >  BArraySordHist;
				typedef byps_ptr< BArraySordHist > PArraySordHist;
				
				// de.elo.ix.client.SordLink[]
				typedef ::byps::BArray1< de::elo::ix::client::PSordLink >  BArraySordLink;
				typedef byps_ptr< BArraySordLink > PArraySordLink;
				
				// de.elo.ix.client.SordType[]
				typedef ::byps::BArray1< de::elo::ix::client::PSordType >  BArraySordType;
				typedef byps_ptr< BArraySordType > PArraySordType;
				
				// de.elo.ix.client.SordZ[]
				typedef ::byps::BArray1< de::elo::ix::client::PSordZ >  BArraySordZ;
				typedef byps_ptr< BArraySordZ > PArraySordZ;
				
				// de.elo.ix.client.Sord[]
				typedef ::byps::BArray1< de::elo::ix::client::PSord >  BArraySord;
				typedef byps_ptr< BArraySord > PArraySord;
				
				// de.elo.ix.client.StoreInfo[]
				typedef ::byps::BArray1< de::elo::ix::client::PStoreInfo >  BArrayStoreInfo;
				typedef byps_ptr< BArrayStoreInfo > PArrayStoreInfo;
				
				// de.elo.ix.client.SubsInfo[]
				typedef ::byps::BArray1< de::elo::ix::client::PSubsInfo >  BArraySubsInfo;
				typedef byps_ptr< BArraySubsInfo > PArraySubsInfo;
				
				// de.elo.ix.client.TranslateTerm[]
				typedef ::byps::BArray1< de::elo::ix::client::PTranslateTerm >  BArrayTranslateTerm;
				typedef byps_ptr< BArrayTranslateTerm > PArrayTranslateTerm;
				
				// de.elo.ix.client.UserInfo[]
				typedef ::byps::BArray1< de::elo::ix::client::PUserInfo >  BArrayUserInfo;
				typedef byps_ptr< BArrayUserInfo > PArrayUserInfo;
				
				// de.elo.ix.client.UserName[]
				typedef ::byps::BArray1< de::elo::ix::client::PUserName >  BArrayUserName;
				typedef byps_ptr< BArrayUserName > PArrayUserName;
				
				// de.elo.ix.client.UserNodeInfo[]
				typedef ::byps::BArray1< de::elo::ix::client::PUserNodeInfo >  BArrayUserNodeInfo;
				typedef byps_ptr< BArrayUserNodeInfo > PArrayUserNodeInfo;
				
				// de.elo.ix.client.UserTask[]
				typedef ::byps::BArray1< de::elo::ix::client::PUserTask >  BArrayUserTask;
				typedef byps_ptr< BArrayUserTask > PArrayUserTask;
				
				// de.elo.ix.client.WFCollectNode[]
				typedef ::byps::BArray1< de::elo::ix::client::PWFCollectNode >  BArrayWFCollectNode;
				typedef byps_ptr< BArrayWFCollectNode > PArrayWFCollectNode;
				
				// de.elo.ix.client.WFDiagram[]
				typedef ::byps::BArray1< de::elo::ix::client::PWFDiagram >  BArrayWFDiagram;
				typedef byps_ptr< BArrayWFDiagram > PArrayWFDiagram;
				
				// de.elo.ix.client.WFNodeAssoc[]
				typedef ::byps::BArray1< de::elo::ix::client::PWFNodeAssoc >  BArrayWFNodeAssoc;
				typedef byps_ptr< BArrayWFNodeAssoc > PArrayWFNodeAssoc;
				
				// de.elo.ix.client.WFNode[]
				typedef ::byps::BArray1< de::elo::ix::client::PWFNode >  BArrayWFNode;
				typedef byps_ptr< BArrayWFNode > PArrayWFNode;
				
				// de.elo.ix.client.WFTimeLimit[]
				typedef ::byps::BArray1< de::elo::ix::client::PWFTimeLimit >  BArrayWFTimeLimit;
				typedef byps_ptr< BArrayWFTimeLimit > PArrayWFTimeLimit;
				
				// de.elo.ix.client.WFVersion[]
				typedef ::byps::BArray1< de::elo::ix::client::PWFVersion >  BArrayWFVersion;
				typedef byps_ptr< BArrayWFVersion > PArrayWFVersion;
				
				// int[]
				typedef ::byps::BArray1< int32_t >  BArrayInt;
				typedef byps_ptr< BArrayInt > PArrayInt;
				
				// java.util.ArrayList<de.elo.ix.client.WFDiagram>
				typedef ::std::vector< de::elo::ix::client::PWFDiagram > BVectorWFDiagram;
				typedef byps_ptr< BVectorWFDiagram > PVectorWFDiagram;
				
				// java.util.ArrayList<de.elo.ix.client.WFNodeHistory>
				typedef ::std::vector< de::elo::ix::client::PWFNodeHistory > BVectorWFNodeHistory;
				typedef byps_ptr< BVectorWFNodeHistory > PVectorWFNodeHistory;
				
				// java.util.List<de.elo.ix.client.InvalidateCacheInfoParam>
				typedef ::std::vector< de::elo::ix::client::PInvalidateCacheInfoParam > BVectorInvalidateCacheInfoParam;
				typedef byps_ptr< BVectorInvalidateCacheInfoParam > PVectorInvalidateCacheInfoParam;
				
				// java.util.List<de.elo.ix.client.Note>
				typedef ::std::vector< de::elo::ix::client::PNote > BVectorNote;
				typedef byps_ptr< BVectorNote > PVectorNote;
				
				// java.util.List<de.elo.ix.client.PublicDownload>
				typedef ::std::vector< de::elo::ix::client::PPublicDownload > BVectorPublicDownload;
				typedef byps_ptr< BVectorPublicDownload > PVectorPublicDownload;
				
				// java.util.List<de.elo.ix.client.ResolveRightsResult>
				typedef ::std::vector< de::elo::ix::client::PResolveRightsResult > BVectorResolveRightsResult;
				typedef byps_ptr< BVectorResolveRightsResult > PVectorResolveRightsResult;
				
				// java.util.List<de.elo.ix.client.Sord>
				typedef ::std::vector< de::elo::ix::client::PSord > BVectorSord;
				typedef byps_ptr< BVectorSord > PVectorSord;
				
				// java.util.List<de.elo.ix.client.SordPath>
				typedef ::std::vector< de::elo::ix::client::PSordPath > BVectorSordPath;
				typedef byps_ptr< BVectorSordPath > PVectorSordPath;
				
				// java.util.List<de.elo.ix.client.SubsInfo>
				typedef ::std::vector< de::elo::ix::client::PSubsInfo > BVectorSubsInfo;
				typedef byps_ptr< BVectorSubsInfo > PVectorSubsInfo;
				
				// java.util.List<de.elo.ix.client.ValueClass>
				typedef ::std::vector< de::elo::ix::client::PValueClass > BVectorValueClass;
				typedef byps_ptr< BVectorValueClass > PVectorValueClass;
				
				// java.util.Map<java.lang.Integer,de.elo.ix.client.OrgUnitInfo>
				typedef ::std::map< int32_t , de::elo::ix::client::POrgUnitInfo > BMapIntegerOrgUnitInfo;
				typedef byps_ptr< BMapIntegerOrgUnitInfo > PMapIntegerOrgUnitInfo;
				
				// java.util.Map<java.lang.Integer,de.elo.ix.client.UserInfo>
				typedef ::std::map< int32_t , de::elo::ix::client::PUserInfo > BMapIntegerUserInfo;
				typedef byps_ptr< BMapIntegerUserInfo > PMapIntegerUserInfo;
				
				// java.util.Map<java.lang.Integer,de.elo.ix.client.UserName>
				typedef ::std::map< int32_t , de::elo::ix::client::PUserName > BMapIntegerUserName;
				typedef byps_ptr< BMapIntegerUserName > PMapIntegerUserName;
				
				// java.util.Map<java.lang.Integer,de.elo.ix.client.WFDiagram>
				typedef ::std::map< int32_t , de::elo::ix::client::PWFDiagram > BMapIntegerWFDiagram;
				typedef byps_ptr< BMapIntegerWFDiagram > PMapIntegerWFDiagram;
				
				// java.util.Map<java.lang.String,de.elo.ix.client.MapValue>
				typedef ::std::map< ::std::wstring , de::elo::ix::client::PMapValue > BMapStringMapValue;
				typedef byps_ptr< BMapStringMapValue > PMapStringMapValue;
				
				// java.util.Map<java.lang.String,de.elo.ix.client.Notification>
				typedef ::std::map< ::std::wstring , de::elo::ix::client::PNotification > BMapStringNotification;
				typedef byps_ptr< BMapStringNotification > PMapStringNotification;
				
				// java.util.Map<java.lang.String,de.elo.ix.client.Subscription>
				typedef ::std::map< ::std::wstring , de::elo::ix::client::PSubscription > BMapStringSubscription;
				typedef byps_ptr< BMapStringSubscription > PMapStringSubscription;
				
				
				//--------------------------------------------------------
				// Forward Definitions for Namespace de::elo::ix::client::compatibility
				//--------------------------------------------------------
				
				namespace compatibility {
				
					// de.elo.ix.client.compatibility.BStub_RawStreamService
					class BStub_RawStreamService; 
					typedef byps_ptr< BStub_RawStreamService > PStub_RawStreamService; 
					
					// de.elo.ix.client.compatibility.BStub_WClientService
					class BStub_WClientService; 
					typedef byps_ptr< BStub_WClientService > PStub_WClientService; 
					
					// de.elo.ix.client.compatibility.WClientC
					class WClientC; 
					typedef byps_ptr< WClientC > PWClientC; 
					
					// de.elo.ix.client.compatibility.RawStreamService
					class RawStreamService; 
					typedef byps_ptr< RawStreamService > PRawStreamService; 
					
					// de.elo.ix.client.compatibility.WClientService
					class WClientService; 
					typedef byps_ptr< WClientService > PWClientService; 
					
					// de.elo.ix.client.compatibility.RawStreamServiceAuth
					class RawStreamServiceAuth; 
					typedef byps_ptr< RawStreamServiceAuth > PRawStreamServiceAuth; 
					
					// de.elo.ix.client.compatibility.WClientServiceAuth
					class WClientServiceAuth; 
					typedef byps_ptr< WClientServiceAuth > PWClientServiceAuth; 
					
				} // de::elo::ix::client::compatibility
				
				//--------------------------------------------------------
				// Forward Definitions for Namespace de::elo::ix::client::feed
				//--------------------------------------------------------
				
				namespace feed {
				
					// de.elo.ix.client.feed.Action
					class Action; 
					typedef byps_ptr< Action > PAction; 
					
					// de.elo.ix.client.feed.ActionC
					class ActionC; 
					typedef byps_ptr< ActionC > PActionC; 
					
					// de.elo.ix.client.feed.ActionDataC
					class ActionDataC; 
					typedef byps_ptr< ActionDataC > PActionDataC; 
					
					// de.elo.ix.client.feed.ActionHistDataC
					class ActionHistDataC; 
					typedef byps_ptr< ActionHistDataC > PActionHistDataC; 
					
					// de.elo.ix.client.feed.ActionHistory
					class ActionHistory; 
					typedef byps_ptr< ActionHistory > PActionHistory; 
					
					// de.elo.ix.client.feed.ActionHistoryC
					class ActionHistoryC; 
					typedef byps_ptr< ActionHistoryC > PActionHistoryC; 
					
					// de.elo.ix.client.feed.ActionZ
					class ActionZ; 
					typedef byps_ptr< ActionZ > PActionZ; 
					
					// de.elo.ix.client.feed.BStub_FeedNotification
					class BStub_FeedNotification; 
					typedef byps_ptr< BStub_FeedNotification > PStub_FeedNotification; 
					
					// de.elo.ix.client.feed.BStub_FeedService
					class BStub_FeedService; 
					typedef byps_ptr< BStub_FeedService > PStub_FeedService; 
					
					// de.elo.ix.client.feed.EActionType
					enum EActionType : int32_t; 
					
					// de.elo.ix.client.feed.Feed
					class Feed; 
					typedef byps_ptr< Feed > PFeed; 
					
					// de.elo.ix.client.feed.FeedC
					class FeedC; 
					typedef byps_ptr< FeedC > PFeedC; 
					
					// de.elo.ix.client.feed.FeedDataC
					class FeedDataC; 
					typedef byps_ptr< FeedDataC > PFeedDataC; 
					
					// de.elo.ix.client.feed.FeedZ
					class FeedZ; 
					typedef byps_ptr< FeedZ > PFeedZ; 
					
					// de.elo.ix.client.feed.FindActionsInfo
					class FindActionsInfo; 
					typedef byps_ptr< FindActionsInfo > PFindActionsInfo; 
					
					// de.elo.ix.client.feed.FindActionsInfoC
					class FindActionsInfoC; 
					typedef byps_ptr< FindActionsInfoC > PFindActionsInfoC; 
					
					// de.elo.ix.client.feed.FindHashTagInfo
					class FindHashTagInfo; 
					typedef byps_ptr< FindHashTagInfo > PFindHashTagInfo; 
					
					// de.elo.ix.client.feed.FindNotificationInfo
					class FindNotificationInfo; 
					typedef byps_ptr< FindNotificationInfo > PFindNotificationInfo; 
					
					// de.elo.ix.client.feed.HashTag
					class HashTag; 
					typedef byps_ptr< HashTag > PHashTag; 
					
					// de.elo.ix.client.feed.HashTagC
					class HashTagC; 
					typedef byps_ptr< HashTagC > PHashTagC; 
					
					// de.elo.ix.client.feed.HashTagDataC
					class HashTagDataC; 
					typedef byps_ptr< HashTagDataC > PHashTagDataC; 
					
					// de.elo.ix.client.feed.HashTagRelation
					class HashTagRelation; 
					typedef byps_ptr< HashTagRelation > PHashTagRelation; 
					
					// de.elo.ix.client.feed.HashTagRelationC
					class HashTagRelationC; 
					typedef byps_ptr< HashTagRelationC > PHashTagRelationC; 
					
					// de.elo.ix.client.feed.HashTagRelationDataC
					class HashTagRelationDataC; 
					typedef byps_ptr< HashTagRelationDataC > PHashTagRelationDataC; 
					
					// de.elo.ix.client.feed.HashTagRelationZ
					class HashTagRelationZ; 
					typedef byps_ptr< HashTagRelationZ > PHashTagRelationZ; 
					
					// de.elo.ix.client.feed.HashTagZ
					class HashTagZ; 
					typedef byps_ptr< HashTagZ > PHashTagZ; 
					
					// de.elo.ix.client.feed.FeedNotification
					class FeedNotification; 
					typedef byps_ptr< FeedNotification > PFeedNotification; 
					
					// de.elo.ix.client.feed.FeedService
					class FeedService; 
					typedef byps_ptr< FeedService > PFeedService; 
					
					// de.elo.ix.client.feed.FeedServiceAuth
					class FeedServiceAuth; 
					typedef byps_ptr< FeedServiceAuth > PFeedServiceAuth; 
					
					// de.elo.ix.client.feed.Action[]
					typedef ::byps::BArray1< de::elo::ix::client::feed::PAction >  BArrayAction;
					typedef byps_ptr< BArrayAction > PArrayAction;
					
					// java.util.HashMap<java.lang.String,de.elo.ix.client.feed.HashTag>
					typedef ::std::map< ::std::wstring , de::elo::ix::client::feed::PHashTag > BMapStringHashTag;
					typedef byps_ptr< BMapStringHashTag > PMapStringHashTag;
					
					// java.util.List<de.elo.ix.client.feed.ActionHistory>
					typedef ::std::vector< de::elo::ix::client::feed::PActionHistory > BVectorActionHistory;
					typedef byps_ptr< BVectorActionHistory > PVectorActionHistory;
					
					// java.util.List<de.elo.ix.client.feed.EActionType>
					typedef ::std::vector< de::elo::ix::client::feed::EActionType > BVectorEActionType;
					typedef byps_ptr< BVectorEActionType > PVectorEActionType;
					
					// java.util.List<de.elo.ix.client.feed.HashTagRelation>
					typedef ::std::vector< de::elo::ix::client::feed::PHashTagRelation > BVectorHashTagRelation;
					typedef byps_ptr< BVectorHashTagRelation > PVectorHashTagRelation;
					
					// java.util.Map<java.lang.String,de.elo.ix.client.feed.Feed>
					typedef ::std::map< ::std::wstring , de::elo::ix::client::feed::PFeed > BMapStringFeed;
					typedef byps_ptr< BMapStringFeed > PMapStringFeed;
					
					// java.util.Map<java.lang.String,de.elo.ix.client.feed.HashTag>
					typedef ::std::map< ::std::wstring , de::elo::ix::client::feed::PHashTag > BMapStringHashTag;
					typedef byps_ptr< BMapStringHashTag > PMapStringHashTag;
					
				} // de::elo::ix::client::feed
				
				//--------------------------------------------------------
				// Forward Definitions for Namespace de::elo::ix::client::health
				//--------------------------------------------------------
				
				namespace health {
				
					// de.elo.ix.client.health.BStub_HealthCheckService
					class BStub_HealthCheckService; 
					typedef byps_ptr< BStub_HealthCheckService > PStub_HealthCheckService; 
					
					// de.elo.ix.client.health.HealthCheckInfo
					class HealthCheckInfo; 
					typedef byps_ptr< HealthCheckInfo > PHealthCheckInfo; 
					
					// de.elo.ix.client.health.HealthCheckInfoC
					class HealthCheckInfoC; 
					typedef byps_ptr< HealthCheckInfoC > PHealthCheckInfoC; 
					
					// de.elo.ix.client.health.HealthCheckInfos
					class HealthCheckInfos; 
					typedef byps_ptr< HealthCheckInfos > PHealthCheckInfos; 
					
					// de.elo.ix.client.health.HealthCheckValueNameC
					class HealthCheckValueNameC; 
					typedef byps_ptr< HealthCheckValueNameC > PHealthCheckValueNameC; 
					
					// de.elo.ix.client.health.HealthCheckValueOperation
					enum HealthCheckValueOperation : int32_t; 
					
					// de.elo.ix.client.health.HealthCheckService
					class HealthCheckService; 
					typedef byps_ptr< HealthCheckService > PHealthCheckService; 
					
					// de.elo.ix.client.health.HealthCheckServiceAuth
					class HealthCheckServiceAuth; 
					typedef byps_ptr< HealthCheckServiceAuth > PHealthCheckServiceAuth; 
					
					// java.util.List<de.elo.ix.client.health.HealthCheckInfo>
					typedef ::std::vector< de::elo::ix::client::health::PHealthCheckInfo > BVectorHealthCheckInfo;
					typedef byps_ptr< BVectorHealthCheckInfo > PVectorHealthCheckInfo;
					
				} // de::elo::ix::client::health
				
				//--------------------------------------------------------
				// Forward Definitions for Namespace de::elo::ix::client::myelo
				//--------------------------------------------------------
				
				namespace myelo {
				
					// de.elo.ix.client.myelo.BStub_MyELOService
					class BStub_MyELOService; 
					typedef byps_ptr< BStub_MyELOService > PStub_MyELOService; 
					
					// de.elo.ix.client.myelo.MyELOContent
					class MyELOContent; 
					typedef byps_ptr< MyELOContent > PMyELOContent; 
					
					// de.elo.ix.client.myelo.MyELOInfo
					class MyELOInfo; 
					typedef byps_ptr< MyELOInfo > PMyELOInfo; 
					
					// de.elo.ix.client.myelo.MyELOState
					class MyELOState; 
					typedef byps_ptr< MyELOState > PMyELOState; 
					
					// de.elo.ix.client.myelo.MyELOService
					class MyELOService; 
					typedef byps_ptr< MyELOService > PMyELOService; 
					
					// de.elo.ix.client.myelo.MyELOServiceAuth
					class MyELOServiceAuth; 
					typedef byps_ptr< MyELOServiceAuth > PMyELOServiceAuth; 
					
				} // de::elo::ix::client::myelo
				
				//--------------------------------------------------------
				// Forward Definitions for Namespace de::elo::ix::client::notify
				//--------------------------------------------------------
				
				namespace notify {
				
					// de.elo.ix.client.notify.BStub_ClientNotification
					class BStub_ClientNotification; 
					typedef byps_ptr< BStub_ClientNotification > PStub_ClientNotification; 
					
					// de.elo.ix.client.notify.TaskNotifyType
					enum TaskNotifyType : int32_t; 
					
					// de.elo.ix.client.notify.ClientNotification
					class ClientNotification; 
					typedef byps_ptr< ClientNotification > PClientNotification; 
					
				} // de::elo::ix::client::notify
				
				//--------------------------------------------------------
				// Forward Definitions for Namespace de::elo::ix::client::search
				//--------------------------------------------------------
				
				namespace search {
				
					// de.elo.ix.client.search.LanguageConfig
					class LanguageConfig; 
					typedef byps_ptr< LanguageConfig > PLanguageConfig; 
					
					// de.elo.ix.client.search.OptimizerConfig
					class OptimizerConfig; 
					typedef byps_ptr< OptimizerConfig > POptimizerConfig; 
					
					// de.elo.ix.client.search.ReindexerConfig
					class ReindexerConfig; 
					typedef byps_ptr< ReindexerConfig > PReindexerConfig; 
					
					// de.elo.ix.client.search.SearchIndexerConfig
					class SearchIndexerConfig; 
					typedef byps_ptr< SearchIndexerConfig > PSearchIndexerConfig; 
					
					// de.elo.ix.client.search.SearchIndexerStatus
					enum SearchIndexerStatus : int32_t; 
					
					// de.elo.ix.client.search.UpdaterConfig
					class UpdaterConfig; 
					typedef byps_ptr< UpdaterConfig > PUpdaterConfig; 
					
				} // de::elo::ix::client::search
				
				//--------------------------------------------------------
				// Forward Definitions for Namespace de::elo::ix::client::system
				//--------------------------------------------------------
				
				namespace system {
				
					// de.elo.ix.client.system.ArchivReport
					class ArchivReport; 
					typedef byps_ptr< ArchivReport > PArchivReport; 
					
					// de.elo.ix.client.system.ArchivValue
					class ArchivValue; 
					typedef byps_ptr< ArchivValue > PArchivValue; 
					
					// de.elo.ix.client.system.BStub_SystemInformation
					class BStub_SystemInformation; 
					typedef byps_ptr< BStub_SystemInformation > PStub_SystemInformation; 
					
					// de.elo.ix.client.system.LicenseCounter
					class LicenseCounter; 
					typedef byps_ptr< LicenseCounter > PLicenseCounter; 
					
					// de.elo.ix.client.system.LicenseReport
					class LicenseReport; 
					typedef byps_ptr< LicenseReport > PLicenseReport; 
					
					// de.elo.ix.client.system.SystemInfo
					class SystemInfo; 
					typedef byps_ptr< SystemInfo > PSystemInfo; 
					
					// de.elo.ix.client.system.SystemReport
					class SystemReport; 
					typedef byps_ptr< SystemReport > PSystemReport; 
					
					// de.elo.ix.client.system.UserReport
					class UserReport; 
					typedef byps_ptr< UserReport > PUserReport; 
					
					// de.elo.ix.client.system.SystemInformation
					class SystemInformation; 
					typedef byps_ptr< SystemInformation > PSystemInformation; 
					
					// de.elo.ix.client.system.SystemInformationAuth
					class SystemInformationAuth; 
					typedef byps_ptr< SystemInformationAuth > PSystemInformationAuth; 
					
					// java.util.List<de.elo.ix.client.system.ArchivValue>
					typedef ::std::vector< de::elo::ix::client::system::PArchivValue > BVectorArchivValue;
					typedef byps_ptr< BVectorArchivValue > PVectorArchivValue;
					
					// java.util.List<de.elo.ix.client.system.LicenseCounter>
					typedef ::std::vector< de::elo::ix::client::system::PLicenseCounter > BVectorLicenseCounter;
					typedef byps_ptr< BVectorLicenseCounter > PVectorLicenseCounter;
					
				} // de::elo::ix::client::system
			} // de::elo::ix::client
		} // de::elo::ix
	} // de::elo
} // de

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// SearchIndexerStatus
// typeId=632688378

namespace de { namespace elo { namespace ix { namespace client { namespace search { 


using namespace ::byps;

enum SearchIndexerStatus : int32_t  {
	Inactive = 0,
	Sleeping = 1,
	Running = 2,
	
};

void operator & (BIO& ar, SearchIndexerStatus& e);

}}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// TaskNotifyType
// typeId=1705789130

namespace de { namespace elo { namespace ix { namespace client { namespace notify { 


using namespace ::byps;

enum TaskNotifyType : int32_t  {
	InsertTask = 0,
	UpdateTask = 1,
	RemoveTask = 2,
	
};

void operator & (BIO& ar, TaskNotifyType& e);

}}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// HealthCheckValueOperation
// typeId=67730183

namespace de { namespace elo { namespace ix { namespace client { namespace health { 


using namespace ::byps;

/// <summary>
/// Defines the operation to process when updating a value.
/// </summary>
enum HealthCheckValueOperation : int32_t  {
	/// <summary>
	/// Overwrite the value.
	/// </summary>
	UPDATE_VALUE = 0,
	/// <summary>
	/// Compute an arithmetic mean.
	/// </summary>
	COMPUTE_MEAN = 1,
	/// <summary>
	/// Add the value.
	/// </summary>
	COMPUTE_ADD = 2,
	/// <summary>
	/// Select the minimum value.
	/// </summary>
	COMPUTE_MINIMUM = 3,
	/// <summary>
	/// Select the maximum value.
	/// </summary>
	COMPUTE_MAXIMUM = 4,
	
};

void operator & (BIO& ar, HealthCheckValueOperation& e);

}}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// EActionType
// typeId=39849084

namespace de { namespace elo { namespace ix { namespace client { namespace feed { 


using namespace ::byps;

/// <summary>
/// Types of document feed entries.
/// </summary>
enum EActionType : int32_t  {
	/// <summary>
	/// Reserved.
	/// </summary>
	Undefined = 0,
	/// <summary>
	/// Reserved.
	/// </summary>
	FeedCreated = 1,
	/// <summary>
	/// Comment created by a user.
	/// </summary>
	UserComment = 2,
	/// <summary>
	/// Comment created by a program or script.
	/// </summary>
	AutoComment = 3,
	/// <summary>
	/// Document version created.
	/// </summary>
	/// <remarks>
	/// An action of this type is automatically created by the system,
	/// if a new document version is checked in and this version
	/// is not set as the work version.
	/// </remarks>
	VersionCreated = 4,
	/// <summary>
	/// Document work version created.
	/// </summary>
	/// <remarks>
	/// An action of this type is automatically created by the system,
	/// if a new version of a non-release document is checked in and this version
	/// is set as the work version.
	/// </remarks>
	WorkVersionCreated = 5,
	/// <summary>
	/// Document work version switched.
	/// </summary>
	/// <remarks>
	/// An action of this type is automatically created by the system,
	/// if the work version of a non-release document is set and no content
	/// is uploaded.
	/// </remarks>
	WorkVersionSwitched = 6,
	/// <summary>
	/// Document work version switched.
	/// </summary>
	/// <remarks>
	/// An action of this type is automatically created by the system,
	/// if the work version of a release document is set.
	/// </remarks>
	Released = 7,
	/// <summary>
	/// Sord created.
	/// </summary>
	/// <remarks>
	/// An action of this type is automatically created by the system
	/// when the feed is initialized.
	/// The create date is set to the archiving date.
	/// For documents, member {@link Action#docVersion} represents
	/// the first version.
	/// </remarks>
	SordCreated = 8,
	
};

void operator & (BIO& ar, EActionType& e);

}}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// InheritKeywordingResult
// typeId=892356058

namespace de { namespace elo { namespace ix { namespace client { 


using namespace ::byps;

/// <summary>
/// Return values for server event {@link IXServerEvents#onInheritKeywording}.
/// </summary>
enum InheritKeywordingResult : int32_t  {
	/// <summary>
	/// Indexserver should stop processing of children of the given Sord.
	/// </summary>
	NOTHING = 0,
	/// <summary>
	/// The event function has not modified keywording of the given Sord.
	/// </summary>
	/// <remarks>
	/// Indexserver applies the default inheritance algorithm to the given Sord and continues processing of children.
	/// </remarks>
	APPLY_DEFAULT = 1,
	/// <summary>
	/// The event function has modified keywording of the given Sord.
	/// </summary>
	/// <remarks>
	/// Indexserver updates the given Sord in the database and continues processing of children.
	/// </remarks>
	INHERITED = 2,
	
};

void operator & (BIO& ar, InheritKeywordingResult& e);

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// AccessC
// typeId=384025970

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// <p>This class defines constants for access rights.
/// </summary>
/// <remarks>
/// </p>
/// <p>The <pre><code>FLAG_*</code></pre> constants are used in <pre><code>UserInfo.flags.
/// The <pre><code>LUR_*</code></pre> constants are used in access control lists. </p>
/// <p>Copyright: Copyright (c) 2004</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </remarks>
class AccessC : public BSerializable {
	/// <summary>
	/// Main administrator, can edit all users and groups.
	/// </summary>
	public: const static int32_t FLAG_ADMIN = 1;
	/// <summary>
	/// Edit master data
	/// </summary>
	public: const static int32_t FLAG_EDITCONFIG = 2;
	/// <summary>
	/// Edit archive structure: create, edit, move archive entries.
	/// </summary>
	public: const static int32_t FLAG_EDITSTRUCTURE = 4;
	/// <summary>
	/// Edit documents: checkin, checkout.
	/// </summary>
	public: const static int32_t FLAG_EDITDOCS = 8;
	/// <summary>
	/// Change password.
	/// </summary>
	public: const static int32_t FLAG_CHANGEPW = 16;
	/// <summary>
	/// Change the archiving mode of a document.
	/// </summary>
	public: const static int32_t FLAG_CHANGEREV = 32;
	/// <summary>
	/// Administrator, can edit only the users and groups he created.
	/// </summary>
	public: const static int32_t FLAG_SUBADMIN = 64;
	/// <summary>
	/// Edit work flows.
	/// </summary>
	public: const static int32_t FLAG_EDITWF = 128;
	/// <summary>
	/// Start work flows.
	/// </summary>
	public: const static int32_t FLAG_STARTWF = 256;
	/// <summary>
	/// Delete documents.
	/// </summary>
	public: const static int32_t FLAG_DELDOC = 512;
	/// <summary>
	/// Delete archive entries.
	/// </summary>
	public: const static int32_t FLAG_DELSTRUC = 1024;
	/// <summary>
	/// SAP administrator.
	/// </summary>
	public: const static int32_t FLAG_SAPADMIN = 4096;
	/// <summary>
	/// Import.
	/// </summary>
	public: const static int32_t FLAG_IMPORT = 8192;
	/// <summary>
	/// Export.
	/// </summary>
	public: const static int32_t FLAG_EXPORT = 16384;
	/// <summary>
	/// Create, edit, delete storage masks.
	/// </summary>
	public: const static int32_t FLAG_EDITMASK = 32768;
	/// <summary>
	/// Create, edit, delete scripts.
	/// </summary>
	public: const static int32_t FLAG_EDITSCRIPT = 65536;
	/// <summary>
	/// Edit expiration date of archive entries.
	/// </summary>
	public: const static int32_t FLAG_EDITDUEDATE = 131072;
	/// <summary>
	/// Edit catchwords.
	/// </summary>
	public: const static int32_t FLAG_EDITSWL = 262144;
	/// <summary>
	/// Delete read only documents.
	/// </summary>
	public: const static int32_t FLAG_DELREADONLY = 524288;
	/// <summary>
	/// Edit replication set assignment.
	/// </summary>
	public: const static int32_t FLAG_EDITREPL = 1048576;
	/// <summary>
	/// Edit security settings.
	/// </summary>
	public: const static int32_t FLAG_EDITACL = 2097152;
	/// <summary>
	/// Ignore access control lists.
	/// </summary>
	public: const static int32_t FLAG_IGNOREACL = 4194304;
	/// <summary>
	/// Edit scanner settings.
	/// </summary>
	public: const static int32_t FLAG_EDITSCAN = 8388608;
	/// <summary>
	/// Change the storage mask of an existing (not new) archive entry.
	/// </summary>
	public: const static int32_t FLAG_CHANGEMASK = 16777216;
	/// <summary>
	/// Edit activity projects.
	/// </summary>
	public: const static int32_t FLAG_EDITACT = 33554432;
	/// <summary>
	/// Change storage path settings.
	/// </summary>
	public: const static int32_t FLAG_CHANGEPATH = 67108864;
	/// <summary>
	/// User cannot login.
	/// </summary>
	/// <remarks>
	/// This is not a right but a prohibition.
	/// </remarks>
	public: const static int32_t FLAG_NOLOGIN = 134217728;
	/// <summary>
	/// Delete a document version in history
	/// </summary>
	public: const static int32_t FLAG_DELVERSION = 268435456;
	/// <summary>
	/// Author for release documents
	/// </summary>
	public: const static int32_t FLAG_AUTHOR = 536870912;
	/// <summary>
	/// Read document file.
	/// </summary>
	public: const static int32_t FLAG_HASFILEACCESS = 1073741824;
	/// <summary>
	/// This flag marks an option group.
	/// </summary>
	public: const static int32_t FLAG_IS_OPTION_GROUP = 0-2147483648;
	/// <summary>
	/// All rights (without flag <pre><code>FLAG_NOLOGIN</code></pre> and <pre><code>FLAG_IS_OPTION_GROUP</code></pre>).
	/// </summary>
	public: const static int32_t FLAG_ALL = 2013265919;
	/// <summary>
	/// User right: Allow interactive login.
	/// </summary>
	/// <remarks>
	/// This value has to be used in the UserInfo.flags2 member.
	/// </remarks>
	public: const static int32_t FLAG2_INTERACTIVE_LOGIN = 1;
	/// <summary>
	/// User right: extend ACL during workflow execution.
	/// </summary>
	/// <remarks>
	/// This value has to be used in the UserInfo.flags2 member.
	/// </remarks>
	public: const static int32_t FLAG2_EXTEND_WORKFLOW_RIGHTS = 2;
	/// <summary>
	/// User right: user is visible in a select box.
	/// </summary>
	/// <remarks>
	/// This value has to be used in the UserInfo.flags2 member.
	/// </remarks>
	public: const static int32_t FLAG2_VISIBLE_USER = 4;
	/// <summary>
	/// User right: user works with ELO DMS Desktop.
	/// </summary>
	/// <remarks>
	/// This value has to be used in the UserInfo.flags2 member.
	/// </remarks>
	public: const static int32_t FLAG2_IS_DMS_DESKTOP_USER = 8;
	/// <summary>
	/// User right: user can see additional keywording information.
	/// </summary>
	/// <remarks>
	/// This value has to be used in the UserInfo.flags2 member.
	/// </remarks>
	public: const static int32_t FLAG2_SHOW_EXTRA_INFO = 16;
	/// <summary>
	/// User right: user is visible in document feed.
	/// </summary>
	/// <remarks>
	/// This value has to be used in the UserInfo.flags2 member.
	/// </remarks>
	public: const static int32_t FLAG2_VISIBLE_FEED_USER = 32;
	/// <summary>
	/// User right: workflow controller.
	/// </summary>
	/// <remarks>
	/// This right allows a user to read all active workflows - even those where she or he is not involved.
	/// In IX 8.x, this functionality was implemented by the IX option usersCanReadAllActiveWorkflows.
	/// IX 9.x does not support this option, since it was a quick and very limited solution to archive compatibility with Windows Client.
	/// </remarks>
	public: const static int32_t FLAG2_WF_CONTROLLER = 64;
	/// <summary>
	/// User right: limited client.
	/// </summary>
	/// <remarks>
	/// This right limits the functionality of the client application.
	/// In AdminConsole, this flag ist named "ELOxc Client User, Email only".
	/// </remarks>
	public: const static int32_t FLAG2_LIMITED_CLIENT = 128;
	/// <summary>
	/// User right: analytics discover.
	/// </summary>
	/// <remarks>
	/// This right allows a user to access the 'discover' area at ELO Analytics and to edit searches.
	/// </remarks>
	public: const static int32_t FLAG2_ANALYTICS_DISCOVER = 256;
	/// <summary>
	/// User right: analytics visualize.
	/// </summary>
	/// <remarks>
	/// This right allows a user to access the 'visualize' area at ELO Analytics and to edit visualizations.
	/// </remarks>
	public: const static int32_t FLAG2_ANALYTICS_VISUALIZE = 512;
	/// <summary>
	/// User right: analytics dashboard edit.
	/// </summary>
	/// <remarks>
	/// This right allows a user to access the 'dashboard' area at ELO Analytics and to edit dashboards.
	/// </remarks>
	public: const static int32_t FLAG2_ANALYTICS_DASHBOARD_EDIT = 1024;
	/// <summary>
	/// User right: analytics dashboard view.
	/// </summary>
	/// <remarks>
	/// This right allows a user to view predefined dashboards.
	/// </remarks>
	public: const static int32_t FLAG2_ANALYTICS_DASHBOARD_VIEW = 2048;
	/// <summary>
	/// User right: all rights for UserInfo#flags2
	/// This value has to be used in the UserInfo.flags2 member.
	/// </summary>
	public: const static int32_t FLAG2_ALL = 255;
	/// <summary>
	/// Access control right for reading an archive entry.
	/// </summary>
	public: const static int32_t LUR_READ = 1;
	/// <summary>
	/// Access control right for writing an archive entry.
	/// </summary>
	public: const static int32_t LUR_WRITE = 2;
	/// <summary>
	/// Access control right for deleting an archive entry.
	/// </summary>
	public: const static int32_t LUR_DELETE = 4;
	/// <summary>
	/// Access control right for beeing able to checkin a new document version.
	/// </summary>
	public: const static int32_t LUR_EDIT = 8;
	/// <summary>
	/// Insert or remove an entry to the list of subentries of a Sord.
	/// </summary>
	public: const static int32_t LUR_LIST = 16;
	/// <summary>
	/// All access control rights.
	/// </summary>
	public: const static int32_t LUR_ALL = 31;
	/// <summary>
	/// No access.
	/// </summary>
	public: const static int32_t LUR_NOTHING = 0;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: AccessC();
	
	public: virtual BTYPEID BSerializable_getTypeId();
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// AclAccessInfo
// typeId=11569337

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// This class contains the option for the methode getAclAccess
/// </summary>
class AclAccessInfo : public BSerializable {
	protected: ::std::wstring acl;
	protected: PArrayAclItem aclItems;
	protected: ::std::wstring objId;
	/// <summary>
	/// Parent's ID of the current object.
	/// </summary>
	/// <remarks>
	/// (Useful to get the inherited ACLs of objects which haven't any ID yet, i.e.
	/// the ones being just added in archive.)
	/// </remarks>
	protected: ::std::wstring parentId;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: AclAccessInfo();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: AclAccessInfo(const ::std::wstring& acl, const PArrayAclItem& aclItems, const ::std::wstring& objId, const ::std::wstring& parentId);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: ::std::wstring getAcl() { return acl; }
	public: void setAcl(::std::wstring v);
	public: PArrayAclItem getAclItems() { return aclItems; }
	public: void setAclItems(PArrayAclItem v);
	public: ::std::wstring getObjId() { return objId; }
	public: void setObjId(::std::wstring v);
	public: ::std::wstring getParentId() { return parentId; }
	public: void setParentId(::std::wstring v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// AclAccessResult
// typeId=200528028

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// This class contains the result return by the method getAclAccess.
/// </summary>
class AclAccessResult : public BSerializable {
	protected: int32_t access;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: AclAccessResult();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: AclAccessResult(int32_t access);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getAccess() { return access; }
	public: void setAccess(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// ValueClass
// typeId=175726414

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

class ValueClass : public BValueClass {
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: ValueClass();
	
	public: virtual BTYPEID BSerializable_getTypeId();
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// AclItem
// typeId=1255072841

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// <p>Human readable ACL entry.
/// </summary>
/// <remarks>
/// </p>
/// <p>Copyright: Copyright (c) 2004</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </remarks>
class AclItem : public ValueClass {
	/// <summary>
	/// Access mode.
	/// </summary>
	/// <remarks>
	/// Bitset of LUR_*.
	/// </remarks>
	protected: int32_t access;
	/// <summary>
	/// ID of user, group, key.
	/// </summary>
	protected: int32_t id;
	/// <summary>
	/// Name of user, group, key.
	/// </summary>
	protected: ::std::wstring name;
	/// <summary>
	/// Item type: user, group, key, ...
	/// </summary>
	protected: int32_t type;
	/// <summary>
	/// Only valid for group items.
	/// </summary>
	/// <remarks>
	/// Contains the IDs and names of additional groups. The user has to
	/// be a member in each of this groups to be able to access the object.
	/// </remarks>
	protected: PArrayIdName andGroups;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: AclItem();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: AclItem(int32_t access, int32_t id, const ::std::wstring& name, int32_t type, const PArrayIdName& andGroups);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getAccess() { return access; }
	public: void setAccess(int32_t v);
	public: int32_t getId() { return id; }
	public: void setId(int32_t v);
	public: ::std::wstring getName() { return name; }
	public: void setName(::std::wstring v);
	public: int32_t getType() { return type; }
	public: void setType(int32_t v);
	public: PArrayIdName getAndGroups() { return andGroups; }
	public: void setAndGroups(PArrayIdName v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// AclItemC
// typeId=1507233874

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// <p>Types of ACL items.
/// </summary>
/// <remarks>
/// </p>
/// </remarks>
class AclItemC : public BSerializable {
	/// <summary>
	/// ACL item for group.
	/// </summary>
	public: const static int32_t TYPE_GROUP = 0;
	/// <summary>
	/// ACL item for user.
	/// </summary>
	public: const static int32_t TYPE_USER = 1;
	/// <summary>
	/// ACL item for key.
	/// </summary>
	public: const static int32_t TYPE_KEY = 10;
	/// <summary>
	/// ACL item to inherit rights.
	/// </summary>
	public: const static int32_t TYPE_INHERIT = 100;
	/// <summary>
	/// ACL item to set rights for the owner.
	/// </summary>
	public: const static int32_t TYPE_OWNER = 200;
	/// <summary>
	/// String representation of an ACL entry for
	/// group "Everyone" with full access.
	/// </summary>
	protected: ::std::wstring ACL_EVERYONE_RAW;
	/// <summary>
	/// ACL items for
	/// group "Everyone" with full access.
	/// </summary>
	protected: PArrayAclItem ACL_EVERYONE;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: AclItemC();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: AclItemC(int32_t TYPE_GROUP, int32_t TYPE_USER, int32_t TYPE_KEY, int32_t TYPE_INHERIT, int32_t TYPE_OWNER, const ::std::wstring& ACL_EVERYONE_RAW, const PArrayAclItem& ACL_EVERYONE);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: ::std::wstring getACL_EVERYONE_RAW() { return ACL_EVERYONE_RAW; }
	public: void setACL_EVERYONE_RAW(::std::wstring v);
	public: PArrayAclItem getACL_EVERYONE() { return ACL_EVERYONE; }
	public: void setACL_EVERYONE(PArrayAclItem v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// Activity
// typeId=460199434

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// This class represents an activity.
/// </summary>
/// <remarks>
/// <p>
/// An activity is a task delegated to an instance outside the ELO system.
/// It is created when the task is sent to the instance and deleted, if it is received back.
/// An activity defines a date for expecting the response, <code>dueDateIso</code>.
/// At this date, the activity appears in the task list of the initiator. If the task is finished,
/// the initiator sets the <code>backAt</code> member and the activity is closed.
/// </p><p>
/// Activities can be used to observe a document or a folder. For each modification,
/// a ELO_NOTIFY activity is created and displayed in the task list of the user that wants to
/// observe the object.
/// </p><p>
/// An activity object is an instance on an activity project. The project defines
/// the properties the user can edit or select to provide more information to the task.
/// </p>
/// </remarks>
class Activity : public ValueClass {
	/// <summary>
	/// Date and time of the last update.
	/// </summary>
	/// <remarks>
	/// Readonly
	/// </remarks>
	protected: ::std::wstring TStamp;
	/// <summary>
	/// Date when activity object was returned, ISO format.
	/// </summary>
	/// <remarks>
	/// This value does not contain a time portion.
	/// </remarks>
	protected: ::std::wstring backAt;
	/// <summary>
	/// Application defined purpose.
	/// </summary>
	protected: ::std::wstring backMode;
	/// <summary>
	/// Comment for the activity.
	/// </summary>
	protected: ::std::wstring comment;
	/// <summary>
	/// Application defined purpose.
	/// </summary>
	protected: ::std::wstring destination;
	/// <summary>
	/// Date when activity object is expected to be returned.
	/// </summary>
	/// <remarks>
	/// This value does not contain a time portion.
	/// </remarks>
	protected: ::std::wstring dueDateIso;
	/// <summary>
	/// Application defined purpose.
	/// </summary>
	protected: ::std::wstring fileName;
	/// <summary>
	/// GUID of the activity object.
	/// </summary>
	protected: ::std::wstring guid;
	/// <summary>
	/// Short name/description of the activity object.
	/// </summary>
	protected: ::std::wstring name;
	/// <summary>
	/// GUID of the assigned archive entry.
	/// </summary>
	protected: ::std::wstring objGuid;
	/// <summary>
	/// Priority for the activity.
	/// </summary>
	/// <remarks>
	/// Priority A has value 0, UserTaskPriorityC.HIGHEST
	/// Priority B has value 1.
	/// Priority C has value 2, UserTaskPriorityC#LOWEST
	/// </remarks>
	protected: int32_t prio;
	/// <summary>
	/// Project name for the activity.
	/// </summary>
	protected: ::std::wstring project;
	/// <summary>
	/// The ID of the recipient.
	/// </summary>
	protected: int32_t receiverId;
	/// <summary>
	/// Revision version of the activity object.
	/// </summary>
	protected: ::std::wstring revVers;
	/// <summary>
	/// ID of the user who created the activity.
	/// </summary>
	protected: int32_t senderId;
	/// <summary>
	/// Date the activity was sent in ISO format.
	/// </summary>
	/// <remarks>
	/// This value does not contain a time portion.
	/// </remarks>
	protected: ::std::wstring sentAtIso;
	/// <summary>
	/// Application defined purpose.
	/// </summary>
	protected: ::std::wstring sentMode;
	/// <summary>
	/// First application defined value.
	/// </summary>
	protected: ::std::wstring ud0;
	/// <summary>
	/// Second application defined value.
	/// </summary>
	protected: ::std::wstring ud1;
	/// <summary>
	/// Third application defined value.
	/// </summary>
	protected: ::std::wstring ud2;
	/// <summary>
	/// Fourth application defined value.
	/// </summary>
	protected: ::std::wstring ud3;
	/// <summary>
	/// Fifth application defined value.
	/// </summary>
	protected: ::std::wstring ud4;
	/// <summary>
	/// Sixth application defined value.
	/// </summary>
	protected: ::std::wstring ud5;
	/// <summary>
	/// Seventh application defined value.
	/// </summary>
	protected: ::std::wstring ud6;
	/// <summary>
	/// Eighth application defined value.
	/// </summary>
	protected: ::std::wstring ud7;
	/// <summary>
	/// Ninth application defined value.
	/// </summary>
	protected: ::std::wstring ud8;
	/// <summary>
	/// Tenth application defined value.
	/// </summary>
	protected: ::std::wstring ud9;
	/// <summary>
	/// Activity was created for this user.
	/// </summary>
	/// <remarks>
	/// Readonly.
	/// </remarks>
	protected: ::std::wstring receiverName;
	/// <summary>
	/// Activity was created by this user.
	/// </summary>
	/// <remarks>
	/// Readonly.
	/// </remarks>
	protected: ::std::wstring senderName;
	/// <summary>
	/// Application defined value.
	/// </summary>
	protected: ::std::wstring transId;
	/// <summary>
	/// Object ID of the associated folder or document.
	/// </summary>
	/// <remarks>
	/// Read-only.
	/// </remarks>
	protected: int32_t objId;
	/// <summary>
	/// Object type of the associated folder or document.
	/// </summary>
	/// <remarks>
	/// Read-only.
	/// </remarks>
	protected: int32_t objType;
	/// <summary>
	/// Timestamp of this object's last export by the replication.
	/// </summary>
	protected: ::std::wstring TStampSync;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: Activity();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: Activity(const ::std::wstring& TStamp, const ::std::wstring& backAt, const ::std::wstring& backMode, const ::std::wstring& comment, const ::std::wstring& destination, const ::std::wstring& dueDateIso, const ::std::wstring& fileName, const ::std::wstring& guid, const ::std::wstring& name, const ::std::wstring& objGuid, int32_t prio, const ::std::wstring& project, int32_t receiverId, const ::std::wstring& revVers, int32_t senderId, const ::std::wstring& sentAtIso, const ::std::wstring& sentMode, const ::std::wstring& ud0, const ::std::wstring& ud1, const ::std::wstring& ud2, const ::std::wstring& ud3, const ::std::wstring& ud4, const ::std::wstring& ud5, const ::std::wstring& ud6, const ::std::wstring& ud7, const ::std::wstring& ud8, const ::std::wstring& ud9, const ::std::wstring& receiverName, const ::std::wstring& senderName, const ::std::wstring& transId, int32_t objId, int32_t objType, const ::std::wstring& TStampSync);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: ::std::wstring getTStamp() { return TStamp; }
	public: void setTStamp(::std::wstring v);
	public: ::std::wstring getBackAt() { return backAt; }
	public: void setBackAt(::std::wstring v);
	public: ::std::wstring getBackMode() { return backMode; }
	public: void setBackMode(::std::wstring v);
	public: ::std::wstring getComment() { return comment; }
	public: void setComment(::std::wstring v);
	public: ::std::wstring getDestination() { return destination; }
	public: void setDestination(::std::wstring v);
	public: ::std::wstring getDueDateIso() { return dueDateIso; }
	public: void setDueDateIso(::std::wstring v);
	public: ::std::wstring getFileName() { return fileName; }
	public: void setFileName(::std::wstring v);
	public: ::std::wstring getGuid() { return guid; }
	public: void setGuid(::std::wstring v);
	public: ::std::wstring getName() { return name; }
	public: void setName(::std::wstring v);
	public: ::std::wstring getObjGuid() { return objGuid; }
	public: void setObjGuid(::std::wstring v);
	public: int32_t getPrio() { return prio; }
	public: void setPrio(int32_t v);
	public: ::std::wstring getProject() { return project; }
	public: void setProject(::std::wstring v);
	public: int32_t getReceiverId() { return receiverId; }
	public: void setReceiverId(int32_t v);
	public: ::std::wstring getRevVers() { return revVers; }
	public: void setRevVers(::std::wstring v);
	public: int32_t getSenderId() { return senderId; }
	public: void setSenderId(int32_t v);
	public: ::std::wstring getSentAtIso() { return sentAtIso; }
	public: void setSentAtIso(::std::wstring v);
	public: ::std::wstring getSentMode() { return sentMode; }
	public: void setSentMode(::std::wstring v);
	public: ::std::wstring getUd0() { return ud0; }
	public: void setUd0(::std::wstring v);
	public: ::std::wstring getUd1() { return ud1; }
	public: void setUd1(::std::wstring v);
	public: ::std::wstring getUd2() { return ud2; }
	public: void setUd2(::std::wstring v);
	public: ::std::wstring getUd3() { return ud3; }
	public: void setUd3(::std::wstring v);
	public: ::std::wstring getUd4() { return ud4; }
	public: void setUd4(::std::wstring v);
	public: ::std::wstring getUd5() { return ud5; }
	public: void setUd5(::std::wstring v);
	public: ::std::wstring getUd6() { return ud6; }
	public: void setUd6(::std::wstring v);
	public: ::std::wstring getUd7() { return ud7; }
	public: void setUd7(::std::wstring v);
	public: ::std::wstring getUd8() { return ud8; }
	public: void setUd8(::std::wstring v);
	public: ::std::wstring getUd9() { return ud9; }
	public: void setUd9(::std::wstring v);
	public: ::std::wstring getReceiverName() { return receiverName; }
	public: void setReceiverName(::std::wstring v);
	public: ::std::wstring getSenderName() { return senderName; }
	public: void setSenderName(::std::wstring v);
	public: ::std::wstring getTransId() { return transId; }
	public: void setTransId(::std::wstring v);
	public: int32_t getObjId() { return objId; }
	public: void setObjId(int32_t v);
	public: int32_t getObjType() { return objType; }
	public: void setObjType(int32_t v);
	public: ::std::wstring getTStampSync() { return TStampSync; }
	public: void setTStampSync(::std::wstring v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// ActivityDataC
// typeId=72578008

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// <p>Bit constants for members of Activity</p>
/// <p>Copyright: Copyright (c) 2003</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </summary>
class ActivityDataC : public BSerializable {
	/// <summary>
	/// DB column: actguid
	/// </summary>
	public: const static int64_t mbGuid = 1LL;
	/// <summary>
	/// DB column: actguid
	/// </summary>
	protected: int32_t lnGuid;
	/// <summary>
	/// DB column: docguid
	/// </summary>
	public: const static int64_t mbObjGuid = 2LL;
	/// <summary>
	/// DB column: docguid
	/// </summary>
	protected: int32_t lnObjGuid;
	/// <summary>
	/// DB column: acttstamp
	/// </summary>
	public: const static int64_t mbTStamp = 4LL;
	/// <summary>
	/// DB column: acttstamp
	/// </summary>
	protected: int32_t lnTStamp;
	/// <summary>
	/// DB column: project
	/// </summary>
	public: const static int64_t mbProject = 8LL;
	/// <summary>
	/// DB column: project
	/// </summary>
	protected: int32_t lnProject;
	/// <summary>
	/// DB column: revvers
	/// </summary>
	public: const static int64_t mbRevVers = 16LL;
	/// <summary>
	/// DB column: revvers
	/// </summary>
	protected: int32_t lnRevVers;
	/// <summary>
	/// DB column: owner
	/// </summary>
	public: const static int64_t mbReceiverId = 32LL;
	/// <summary>
	/// DB column: creator
	/// </summary>
	public: const static int64_t mbSenderId = 64LL;
	/// <summary>
	/// DB column: prio
	/// </summary>
	public: const static int64_t mbPrio = 128LL;
	/// <summary>
	/// DB column: shortdesc
	/// </summary>
	public: const static int64_t mbName = 256LL;
	/// <summary>
	/// DB column: shortdesc
	/// </summary>
	protected: int32_t lnName;
	/// <summary>
	/// DB column: destination
	/// </summary>
	public: const static int64_t mbDestination = 512LL;
	/// <summary>
	/// DB column: destination
	/// </summary>
	protected: int32_t lnDestination;
	/// <summary>
	/// DB column: sentat
	/// </summary>
	public: const static int64_t mbSentAtIso = 1024LL;
	/// <summary>
	/// DB column: sentat
	/// </summary>
	protected: int32_t lnSentAtIso;
	/// <summary>
	/// DB column: sentmode
	/// </summary>
	public: const static int64_t mbSentMode = 2048LL;
	/// <summary>
	/// DB column: sentmode
	/// </summary>
	protected: int32_t lnSentMode;
	/// <summary>
	/// DB column: duedate
	/// </summary>
	public: const static int64_t mbDueDateIso = 4096LL;
	/// <summary>
	/// DB column: duedate
	/// </summary>
	protected: int32_t lnDueDateIso;
	/// <summary>
	/// DB column: backat
	/// </summary>
	public: const static int64_t mbBackAt = 8192LL;
	/// <summary>
	/// DB column: backat
	/// </summary>
	protected: int32_t lnBackAt;
	/// <summary>
	/// DB column: backmode
	/// </summary>
	public: const static int64_t mbBackMode = 16384LL;
	/// <summary>
	/// DB column: backmode
	/// </summary>
	protected: int32_t lnBackMode;
	/// <summary>
	/// DB column: actcomment
	/// </summary>
	public: const static int64_t mbComment = 32768LL;
	/// <summary>
	/// DB column: actcomment
	/// </summary>
	protected: int32_t lnComment;
	/// <summary>
	/// DB column: filename
	/// </summary>
	public: const static int64_t mbFileName = 65536LL;
	/// <summary>
	/// DB column: filename
	/// </summary>
	protected: int32_t lnFileName;
	/// <summary>
	/// DB column: ud0
	/// </summary>
	public: const static int64_t mbUd0 = 131072LL;
	/// <summary>
	/// DB column: ud0
	/// </summary>
	protected: int32_t lnUd0;
	/// <summary>
	/// DB column: ud1
	/// </summary>
	public: const static int64_t mbUd1 = 262144LL;
	/// <summary>
	/// DB column: ud1
	/// </summary>
	protected: int32_t lnUd1;
	/// <summary>
	/// DB column: ud2
	/// </summary>
	public: const static int64_t mbUd2 = 524288LL;
	/// <summary>
	/// DB column: ud2
	/// </summary>
	protected: int32_t lnUd2;
	/// <summary>
	/// DB column: ud3
	/// </summary>
	public: const static int64_t mbUd3 = 1048576LL;
	/// <summary>
	/// DB column: ud3
	/// </summary>
	protected: int32_t lnUd3;
	/// <summary>
	/// DB column: ud4
	/// </summary>
	public: const static int64_t mbUd4 = 2097152LL;
	/// <summary>
	/// DB column: ud4
	/// </summary>
	protected: int32_t lnUd4;
	/// <summary>
	/// DB column: ud5
	/// </summary>
	public: const static int64_t mbUd5 = 4194304LL;
	/// <summary>
	/// DB column: ud5
	/// </summary>
	protected: int32_t lnUd5;
	/// <summary>
	/// DB column: ud6
	/// </summary>
	public: const static int64_t mbUd6 = 8388608LL;
	/// <summary>
	/// DB column: ud6
	/// </summary>
	protected: int32_t lnUd6;
	/// <summary>
	/// DB column: ud7
	/// </summary>
	public: const static int64_t mbUd7 = 16777216LL;
	/// <summary>
	/// DB column: ud7
	/// </summary>
	protected: int32_t lnUd7;
	/// <summary>
	/// DB column: ud8
	/// </summary>
	public: const static int64_t mbUd8 = 33554432LL;
	/// <summary>
	/// DB column: ud8
	/// </summary>
	protected: int32_t lnUd8;
	/// <summary>
	/// DB column: ud9
	/// </summary>
	public: const static int64_t mbUd9 = 67108864LL;
	/// <summary>
	/// DB column: ud9
	/// </summary>
	protected: int32_t lnUd9;
	/// <summary>
	/// Member bit: Application defined value.
	/// </summary>
	/// <remarks>
	/// DB column: transmitid
	/// </remarks>
	public: const static int64_t mbTransId = 134217728LL;
	/// <summary>
	/// Column length: Application defined value.
	/// </summary>
	/// <remarks>
	/// DB column: transmitid
	/// </remarks>
	protected: int32_t lnTransId;
	/// <summary>
	/// Member bit: Object ID of the associated folder or document.
	/// </summary>
	/// <remarks>
	/// DB column: objid
	/// </remarks>
	public: const static int64_t mbObjId = 268435456LL;
	/// <summary>
	/// Member bit: Object type of the associated folder or document.
	/// </summary>
	/// <remarks>
	/// DB column: objtype
	/// </remarks>
	public: const static int64_t mbObjType = 536870912LL;
	/// <summary>
	/// Member bit: Timestamp of this object's last export by the replication.
	/// </summary>
	/// <remarks>
	/// DB column: acttstampsync
	/// </remarks>
	public: const static int64_t mbTStampSync = 1073741824LL;
	/// <summary>
	/// Column length: Timestamp of this object's last export by the replication.
	/// </summary>
	/// <remarks>
	/// DB column: acttstampsync
	/// </remarks>
	protected: int32_t lnTStampSync;
	/// <summary>
	/// All valid member bits.
	/// </summary>
	public: const static int64_t mbAllMembers = 2147483647LL;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: ActivityDataC();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: ActivityDataC(int64_t mbGuid, int32_t lnGuid, int64_t mbObjGuid, int32_t lnObjGuid, int64_t mbTStamp, int32_t lnTStamp, int64_t mbProject, int32_t lnProject, int64_t mbRevVers, int32_t lnRevVers, int64_t mbReceiverId, int64_t mbSenderId, int64_t mbPrio, int64_t mbName, int32_t lnName, int64_t mbDestination, int32_t lnDestination, int64_t mbSentAtIso, int32_t lnSentAtIso, int64_t mbSentMode, int32_t lnSentMode, int64_t mbDueDateIso, int32_t lnDueDateIso, int64_t mbBackAt, int32_t lnBackAt, int64_t mbBackMode, int32_t lnBackMode, int64_t mbComment, int32_t lnComment, int64_t mbFileName, int32_t lnFileName, int64_t mbUd0, int32_t lnUd0, int64_t mbUd1, int32_t lnUd1, int64_t mbUd2, int32_t lnUd2, int64_t mbUd3, int32_t lnUd3, int64_t mbUd4, int32_t lnUd4, int64_t mbUd5, int32_t lnUd5, int64_t mbUd6, int32_t lnUd6, int64_t mbUd7, int32_t lnUd7, int64_t mbUd8, int32_t lnUd8, int64_t mbUd9, int32_t lnUd9, int64_t mbTransId, int32_t lnTransId, int64_t mbObjId, int64_t mbObjType, int64_t mbTStampSync, int32_t lnTStampSync, int64_t mbAllMembers);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getLnGuid() { return lnGuid; }
	public: void setLnGuid(int32_t v);
	public: int32_t getLnObjGuid() { return lnObjGuid; }
	public: void setLnObjGuid(int32_t v);
	public: int32_t getLnTStamp() { return lnTStamp; }
	public: void setLnTStamp(int32_t v);
	public: int32_t getLnProject() { return lnProject; }
	public: void setLnProject(int32_t v);
	public: int32_t getLnRevVers() { return lnRevVers; }
	public: void setLnRevVers(int32_t v);
	public: int32_t getLnName() { return lnName; }
	public: void setLnName(int32_t v);
	public: int32_t getLnDestination() { return lnDestination; }
	public: void setLnDestination(int32_t v);
	public: int32_t getLnSentAtIso() { return lnSentAtIso; }
	public: void setLnSentAtIso(int32_t v);
	public: int32_t getLnSentMode() { return lnSentMode; }
	public: void setLnSentMode(int32_t v);
	public: int32_t getLnDueDateIso() { return lnDueDateIso; }
	public: void setLnDueDateIso(int32_t v);
	public: int32_t getLnBackAt() { return lnBackAt; }
	public: void setLnBackAt(int32_t v);
	public: int32_t getLnBackMode() { return lnBackMode; }
	public: void setLnBackMode(int32_t v);
	public: int32_t getLnComment() { return lnComment; }
	public: void setLnComment(int32_t v);
	public: int32_t getLnFileName() { return lnFileName; }
	public: void setLnFileName(int32_t v);
	public: int32_t getLnUd0() { return lnUd0; }
	public: void setLnUd0(int32_t v);
	public: int32_t getLnUd1() { return lnUd1; }
	public: void setLnUd1(int32_t v);
	public: int32_t getLnUd2() { return lnUd2; }
	public: void setLnUd2(int32_t v);
	public: int32_t getLnUd3() { return lnUd3; }
	public: void setLnUd3(int32_t v);
	public: int32_t getLnUd4() { return lnUd4; }
	public: void setLnUd4(int32_t v);
	public: int32_t getLnUd5() { return lnUd5; }
	public: void setLnUd5(int32_t v);
	public: int32_t getLnUd6() { return lnUd6; }
	public: void setLnUd6(int32_t v);
	public: int32_t getLnUd7() { return lnUd7; }
	public: void setLnUd7(int32_t v);
	public: int32_t getLnUd8() { return lnUd8; }
	public: void setLnUd8(int32_t v);
	public: int32_t getLnUd9() { return lnUd9; }
	public: void setLnUd9(int32_t v);
	public: int32_t getLnTransId() { return lnTransId; }
	public: void setLnTransId(int32_t v);
	public: int32_t getLnTStampSync() { return lnTStampSync; }
	public: void setLnTStampSync(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// ActivityC
// typeId=1091363488

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Constants for class Activity.
/// </summary>
class ActivityC : public ActivityDataC {
	/// <summary>
	/// Typesafe element selector for members Activity.guid.
	/// </summary>
	/// <remarks>
	/// Contains ActivityC.mbGuid
	/// </remarks>
	public: const static PActivityZ mbOnlyGuid;
	/// <summary>
	/// Typesafe element selector for members Activity.guid and Activity.objGuid.
	/// </summary>
	/// <remarks>
	/// Contains ActivityC.mbGuid | ActivityC.mbObjGuid
	/// </remarks>
	public: const static PActivityZ mbActivityAndObjectGuid;
	/// <summary>
	/// Typesafe element selector for all members.
	/// </summary>
	/// <remarks>
	/// Contains ActivityC.mbAllMembers
	/// </remarks>
	public: const static PActivityZ mbAll;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: ActivityC();
	
	public: virtual BTYPEID BSerializable_getTypeId();
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// ActivityOption
// typeId=595132669

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// This class represents an option for an activity project.
/// </summary>
class ActivityOption : public ValueClass {
	/// <summary>
	/// Option ID.
	/// </summary>
	/// <remarks>
	/// This value can be one of the predefined option IDs in ActivityOptionC.
	/// Or you can use an application defined value greater or equal to ActivityOptionC.ID_VALUE.
	/// </remarks>
	protected: int32_t id;
	/// <summary>
	/// Activity option name.
	/// </summary>
	/// <remarks>
	/// The name must not contain one of this characters: ! $ - + *
	/// </remarks>
	protected: ::std::wstring name;
	/// <summary>
	/// The value can only be selected from the associated keyword list.
	/// </summary>
	/// <remarks>
	/// This option has to be checked by the client application. It is not checked by Indexserver.
	/// </remarks>
	protected: bool onlyKeyword;
	/// <summary>
	/// The value can not be edited in the user interface.
	/// </summary>
	/// <remarks>
	/// This option has to be checked by the client application. It is not checked by Indexserver.
	/// </remarks>
	protected: bool readOnly;
	/// <summary>
	/// The value has to be displayed in an appropriate order.
	/// </summary>
	/// <remarks>
	/// This option has to be checked by the client application. It is not checked by Indexserver.
	/// </remarks>
	protected: bool sorted;
	/// <summary>
	/// This option is a stamp field.
	/// </summary>
	/// <remarks>
	/// This option has to be checked by the client application. It is not checked by Indexserver.
	/// </remarks>
	protected: bool stamp;
	/// <summary>
	/// A value must be defined for this option.
	/// </summary>
	/// <remarks>
	/// This option has to be checked by the client application. It is not checked by Indexserver.
	/// </remarks>
	protected: bool mandatory;
	/// <summary>
	/// Keywords.
	/// </summary>
	/// <remarks>
	/// This array defines the values that can or must be used to set the option.
	/// If no keywords are defined, this member is null or an empty array.
	/// </remarks>
	protected: PArrayString keywords;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: ActivityOption();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: ActivityOption(int32_t id, const ::std::wstring& name, bool onlyKeyword, bool readOnly, bool sorted, bool stamp, bool mandatory, const PArrayString& keywords);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getId() { return id; }
	public: void setId(int32_t v);
	public: ::std::wstring getName() { return name; }
	public: void setName(::std::wstring v);
	public: bool getOnlyKeyword() { return onlyKeyword; }
	public: void setOnlyKeyword(bool v);
	public: bool getReadOnly() { return readOnly; }
	public: void setReadOnly(bool v);
	public: bool getSorted() { return sorted; }
	public: void setSorted(bool v);
	public: bool getStamp() { return stamp; }
	public: void setStamp(bool v);
	public: bool getMandatory() { return mandatory; }
	public: void setMandatory(bool v);
	public: PArrayString getKeywords() { return keywords; }
	public: void setKeywords(PArrayString v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// ActivityOptionC
// typeId=1364827052

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Constants for class ActivityOption
/// </summary>
class ActivityOptionC : public ValueClass {
	/// <summary>
	/// Option ID for receiver.
	/// </summary>
	public: const static int32_t ID_RECEIVER = 10;
	/// <summary>
	/// Option ID for shipping type.
	/// </summary>
	public: const static int32_t ID_TYPE = 11;
	/// <summary>
	/// Option ID for receiving status.
	/// </summary>
	public: const static int32_t ID_STATUS = 12;
	/// <summary>
	/// Option ID for transmission number.
	/// </summary>
	public: const static int32_t ID_TRANS = 13;
	/// <summary>
	/// Application defined IDs must be greater or equal to this value.
	/// </summary>
	/// <remarks>
	/// Up to 10 application defined IDs can be defined.
	/// Their values have to be in the range from ID_VALUE+0 to ID_VALUE+9.
	/// </remarks>
	public: const static int32_t ID_VALUE = 30;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: ActivityOptionC();
	
	public: virtual BTYPEID BSerializable_getTypeId();
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// ActivityProject
// typeId=2121298555

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// This class represents an activity project.
/// </summary>
/// <remarks>
/// An activity project is a template for an activity.
/// </remarks>
class ActivityProject : public ValueClass {
	/// <summary>
	/// Project name.
	/// </summary>
	/// <remarks>
	/// This can be one of the predefined project names: ActivityProjectC.DEFAULT, ActivityProjectC.REQUEST, ActivityProjectC.NOTIFY.
	/// Or an arbitrary name for an application defined use case.
	/// The name must be unique because it is internally used as an ID.
	/// It has to start with a letter and must only contain letters, numbers or underscores.
	/// </remarks>
	protected: ::std::wstring project;
	/// <summary>
	/// Reserved.
	/// </summary>
	protected: int32_t major;
	/// <summary>
	/// Reserved.
	/// </summary>
	protected: int32_t minor;
	/// <summary>
	/// Reserved.
	/// </summary>
	protected: ::std::wstring optValue;
	/// <summary>
	/// Options.
	/// </summary>
	protected: PArrayActivityOption options;
	/// <summary>
	/// Activity project is protected.
	/// </summary>
	protected: bool protectedProject;
	/// <summary>
	/// Activity project is locked when finished.
	/// </summary>
	protected: bool lockedWhenFinished;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: ActivityProject();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: ActivityProject(const ::std::wstring& project, int32_t major, int32_t minor, const ::std::wstring& optValue, const PArrayActivityOption& options, bool protectedProject, bool lockedWhenFinished);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: ::std::wstring getProject() { return project; }
	public: void setProject(::std::wstring v);
	public: int32_t getMajor() { return major; }
	public: void setMajor(int32_t v);
	public: int32_t getMinor() { return minor; }
	public: void setMinor(int32_t v);
	public: ::std::wstring getOptValue() { return optValue; }
	public: void setOptValue(::std::wstring v);
	public: PArrayActivityOption getOptions() { return options; }
	public: void setOptions(PArrayActivityOption v);
	public: bool getProtectedProject() { return protectedProject; }
	public: void setProtectedProject(bool v);
	public: bool getLockedWhenFinished() { return lockedWhenFinished; }
	public: void setLockedWhenFinished(bool v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// ActivityProjectDataC
// typeId=1946995741

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// <p>Bit constants for members of ActivityProject</p>
/// <p>Copyright: Copyright (c) 2003</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </summary>
class ActivityProjectDataC : public BSerializable {
	/// <summary>
	/// DB column: project
	/// </summary>
	public: const static int64_t mbProject = 1LL;
	/// <summary>
	/// DB column: project
	/// </summary>
	protected: int32_t lnProject;
	/// <summary>
	/// DB column: major
	/// </summary>
	public: const static int64_t mbMajor = 2LL;
	/// <summary>
	/// DB column: minor
	/// </summary>
	public: const static int64_t mbMinor = 4LL;
	/// <summary>
	/// DB column: optvalue
	/// </summary>
	public: const static int64_t mbOptValue = 8LL;
	/// <summary>
	/// DB column: optvalue
	/// </summary>
	protected: int32_t lnOptValue;
	/// <summary>
	/// All valid member bits.
	/// </summary>
	public: const static int64_t mbAllMembers = 15LL;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: ActivityProjectDataC();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: ActivityProjectDataC(int64_t mbProject, int32_t lnProject, int64_t mbMajor, int64_t mbMinor, int64_t mbOptValue, int32_t lnOptValue, int64_t mbAllMembers);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getLnProject() { return lnProject; }
	public: void setLnProject(int32_t v);
	public: int32_t getLnOptValue() { return lnOptValue; }
	public: void setLnOptValue(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// ActivityProjectC
// typeId=1697907147

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Constants for class ActivityProject.
/// </summary>
class ActivityProjectC : public ActivityProjectDataC {
	public: const static int64_t mbOptions = 8LL;
	/// <summary>
	/// Reserved.
	/// </summary>
	/// <remarks>
	/// This name is used internally only. Do not use this name in your code.
	/// </remarks>
	public: const static ::std::wstring SYSTEM;
	/// <summary>
	/// Default project name.
	/// </summary>
	public: const static ::std::wstring DEFAULT;
	/// <summary>
	/// Activity for observing documents and folders.
	/// </summary>
	public: const static ::std::wstring REQUEST;
	/// <summary>
	/// Activity used to notify about a new document version or new sub-item.
	/// </summary>
	public: const static ::std::wstring NOTIFY;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: ActivityProjectC();
	
	public: virtual BTYPEID BSerializable_getTypeId();
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// ActivityZ
// typeId=730005706

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Typed element selector for class Activity.
/// </summary>
class ActivityZ : public ValueClass {
	/// <summary>
	/// Bitset field.
	/// </summary>
	protected: int64_t bset;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: ActivityZ();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: ActivityZ(int64_t bset);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int64_t getBset() { return bset; }
	public: void setBset(int64_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// AdminModeC
// typeId=1820929375

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Constants for the administration mode.
/// </summary>
class AdminModeC : public BSerializable {
	/// <summary>
	/// Administration mode is active
	/// </summary>
	public: const static int32_t ON = 1;
	/// <summary>
	/// Administration mode is inactive
	/// </summary>
	public: const static int32_t OFF = 0;
	/// <summary>
	/// Query administration mode
	/// </summary>
	public: const static int32_t QUERY = -1;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: AdminModeC();
	
	public: virtual BTYPEID BSerializable_getTypeId();
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// Alert
// typeId=280775671

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Alerts are messages shown in the alert tab of ELO client.
/// </summary>
class Alert : public ValueClass {
	protected: int32_t dest;
	/// <summary>
	/// User name of the recipient.
	/// </summary>
	protected: ::std::wstring destName;
	/// <summary>
	/// User ID of the sender.
	/// </summary>
	/// <remarks>
	/// DB column: source
	/// </remarks>
	protected: int32_t source;
	/// <summary>
	/// User name of the sender.
	/// </summary>
	protected: ::std::wstring sourceName;
	/// <summary>
	/// Alert type.
	/// </summary>
	/// <remarks>
	/// DB column: alerttype
	/// </remarks>
	protected: int32_t type;
	/// <summary>
	/// Object ID.
	/// </summary>
	/// <remarks>
	/// DB column: objid
	/// </remarks>
	protected: int32_t objId;
	/// <summary>
	/// Extra data 1.
	/// </summary>
	/// <remarks>
	/// DB column: extra1
	/// </remarks>
	protected: int32_t extra1;
	/// <summary>
	/// Extra data 2.
	/// </summary>
	/// <remarks>
	/// DB column: extra2
	/// </remarks>
	protected: int32_t extra2;
	/// <summary>
	/// Comment text.
	/// </summary>
	/// <remarks>
	/// DB column: alertmemo
	/// </remarks>
	protected: ::std::wstring memo;
	/// <summary>
	/// Date and time when the alert was created.
	/// </summary>
	/// <remarks>
	/// DB column: alerttime
	/// </remarks>
	protected: int32_t time;
	/// <summary>
	/// ISO date when the alert was created.
	/// </summary>
	/// <remarks>
	/// Timezone is related to ClientInfo.timezone.
	/// </remarks>
	protected: ::std::wstring timeIso;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: Alert();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: Alert(int32_t dest, const ::std::wstring& destName, int32_t source, const ::std::wstring& sourceName, int32_t type, int32_t objId, int32_t extra1, int32_t extra2, const ::std::wstring& memo, int32_t time, const ::std::wstring& timeIso);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getDest() { return dest; }
	public: void setDest(int32_t v);
	public: ::std::wstring getDestName() { return destName; }
	public: void setDestName(::std::wstring v);
	public: int32_t getSource() { return source; }
	public: void setSource(int32_t v);
	public: ::std::wstring getSourceName() { return sourceName; }
	public: void setSourceName(::std::wstring v);
	public: int32_t getType() { return type; }
	public: void setType(int32_t v);
	public: int32_t getObjId() { return objId; }
	public: void setObjId(int32_t v);
	public: int32_t getExtra1() { return extra1; }
	public: void setExtra1(int32_t v);
	public: int32_t getExtra2() { return extra2; }
	public: void setExtra2(int32_t v);
	public: ::std::wstring getMemo() { return memo; }
	public: void setMemo(::std::wstring v);
	public: int32_t getTime() { return time; }
	public: void setTime(int32_t v);
	public: ::std::wstring getTimeIso() { return timeIso; }
	public: void setTimeIso(::std::wstring v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// AlertDataC
// typeId=1498169909

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// <p>Bit constants for members of Alert</p>
/// <p>Copyright: Copyright (c) 2003</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </summary>
class AlertDataC : public BSerializable {
	/// <summary>
	/// DB column: destination
	/// </summary>
	public: const static int64_t mbDest = 1LL;
	/// <summary>
	/// DB column: source
	/// </summary>
	public: const static int64_t mbSource = 2LL;
	/// <summary>
	/// DB column: alerttype
	/// </summary>
	public: const static int64_t mbType = 4LL;
	/// <summary>
	/// DB column: objid
	/// </summary>
	public: const static int64_t mbObjId = 8LL;
	/// <summary>
	/// DB column: extra1
	/// </summary>
	public: const static int64_t mbExtra1 = 16LL;
	/// <summary>
	/// DB column: extra2
	/// </summary>
	public: const static int64_t mbExtra2 = 32LL;
	/// <summary>
	/// DB column: alertmemo
	/// </summary>
	public: const static int64_t mbMemo = 64LL;
	/// <summary>
	/// DB column: alertmemo
	/// </summary>
	protected: int32_t lnMemo;
	/// <summary>
	/// DB column: alerttime
	/// </summary>
	public: const static int64_t mbTime = 128LL;
	/// <summary>
	/// All valid member bits.
	/// </summary>
	public: const static int64_t mbAllMembers = 255LL;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: AlertDataC();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: AlertDataC(int64_t mbDest, int64_t mbSource, int64_t mbType, int64_t mbObjId, int64_t mbExtra1, int64_t mbExtra2, int64_t mbMemo, int32_t lnMemo, int64_t mbTime, int64_t mbAllMembers);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getLnMemo() { return lnMemo; }
	public: void setLnMemo(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// AlertC
// typeId=1426544289

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

class AlertC : public AlertDataC {
	/// <summary>
	/// (to be defined)
	/// </summary>
	public: const static int32_t MASKALARM = 1;
	/// <summary>
	/// (to be defined)
	/// </summary>
	public: const static int32_t MASKWV = 16;
	/// <summary>
	/// (to be defined)
	/// </summary>
	public: const static int32_t MASKPOST = 32;
	/// <summary>
	/// (to be defined)
	/// </summary>
	public: const static int32_t MASKWF = 64;
	/// <summary>
	/// (to be defined)
	/// </summary>
	public: const static int32_t MASKSONST = 128;
	/// <summary>
	/// (to be defined)
	/// </summary>
	public: const static int32_t MASKVERT = 256;
	/// <summary>
	/// (to be defined)
	/// </summary>
	public: const static int32_t MASKWVEDMSG = 4096;
	/// <summary>
	/// (to be defined)
	/// </summary>
	public: const static int32_t MASKWVDELMSG = 8192;
	/// <summary>
	/// (to be defined)
	/// </summary>
	public: const static int32_t WVSEEN = 1;
	/// <summary>
	/// (to be defined)
	/// </summary>
	public: const static int32_t WVDELETED = 2;
	/// <summary>
	/// (to be defined)
	/// </summary>
	public: const static int32_t WVEDITED = 3;
	/// <summary>
	/// (to be defined)
	/// </summary>
	public: const static int32_t POSTMOVE = 4;
	/// <summary>
	/// (to be defined)
	/// </summary>
	public: const static int32_t WFSTART = 5;
	/// <summary>
	/// (to be defined)
	/// </summary>
	public: const static int32_t WFARRIVED = 6;
	/// <summary>
	/// (to be defined)
	/// </summary>
	public: const static int32_t MESSAGE = 7;
	/// <summary>
	/// (to be defined)
	/// </summary>
	public: const static int32_t NEWVERT = 8;
	/// <summary>
	/// (to be defined)
	/// </summary>
	public: const static int32_t DELVERT = 9;
	/// <summary>
	/// Alert is a message from the replication module
	/// </summary>
	public: const static int32_t REPLERR = 10;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: AlertC();
	
	public: virtual BTYPEID BSerializable_getTypeId();
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// Any
// typeId=1191976387

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// This class is a container for one value of a serializable type.
/// </summary>
class Any : public ValueClass {
	/// <summary>
	/// Type.
	/// </summary>
	/// <remarks>
	/// One of the type constants given in AnyC.
	/// </remarks>
	protected: int32_t type;
	/// <summary>
	/// Boolean value.
	/// </summary>
	protected: bool booleanValue;
	/// <summary>
	/// Integer value.
	/// </summary>
	protected: int32_t intValue;
	/// <summary>
	/// Long value.
	/// </summary>
	protected: int64_t longValue;
	/// <summary>
	/// Double value.
	/// </summary>
	protected: double doubleValue;
	/// <summary>
	/// String value.
	/// </summary>
	protected: ::std::wstring stringValue;
	/// <summary>
	/// Object value.
	/// </summary>
	protected: PValueClass objectValue;
	/// <summary>
	/// Byte array.
	/// </summary>
	protected: PBytes byteArray;
	/// <summary>
	/// Array of Any.
	/// </summary>
	protected: PArrayAny anyArray;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: Any();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: Any(int32_t type, bool booleanValue, int32_t intValue, int64_t longValue, double doubleValue, const ::std::wstring& stringValue, const PValueClass& objectValue, const PBytes& byteArray, const PArrayAny& anyArray);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getType() { return type; }
	public: void setType(int32_t v);
	public: bool getBooleanValue() { return booleanValue; }
	public: void setBooleanValue(bool v);
	public: int32_t getIntValue() { return intValue; }
	public: void setIntValue(int32_t v);
	public: int64_t getLongValue() { return longValue; }
	public: void setLongValue(int64_t v);
	public: double getDoubleValue() { return doubleValue; }
	public: void setDoubleValue(double v);
	public: ::std::wstring getStringValue() { return stringValue; }
	public: void setStringValue(::std::wstring v);
	public: PValueClass getObjectValue() { return objectValue; }
	public: void setObjectValue(PValueClass v);
	public: PBytes getByteArray() { return byteArray; }
	public: void setByteArray(PBytes v);
	public: PArrayAny getAnyArray() { return anyArray; }
	public: void setAnyArray(PArrayAny v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// AnyC
// typeId=908393697

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// This class defines the constants for the type member in Any.
/// </summary>
class AnyC : public BSerializable {
	public: const static int32_t TYPE_OBJECT = 0;
	public: const static int32_t TYPE_BOOLEAN = 1;
	public: const static int32_t TYPE_INT = 5;
	public: const static int32_t TYPE_LONG = 6;
	public: const static int32_t TYPE_DOUBLE = 7;
	public: const static int32_t TYPE_STRING = 8;
	public: const static int32_t TYPE_HANDLE = 10;
	public: const static int32_t TYPE_ARRAY_BYTE = 1001;
	public: const static int32_t TYPE_ARRAY_ANY = 1002;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: AnyC();
	
	public: virtual BTYPEID BSerializable_getTypeId();
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// ApplyForNotificationsInfo
// typeId=77743605

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// This class defines which notification messages the server has to send.
/// </summary>
class ApplyForNotificationsInfo : public ValueClass {
	/// <summary>
	/// Receive {@link de.elo.ix.client.notify.ClientNotification#adminMode(ClientInfo, int)}
	/// </summary>
	protected: bool adminMode;
	/// <summary>
	/// Reserved
	/// </summary>
	protected: bool userTask;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: ApplyForNotificationsInfo();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: ApplyForNotificationsInfo(bool adminMode, bool userTask);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: bool getAdminMode() { return adminMode; }
	public: void setAdminMode(bool v);
	public: bool getUserTask() { return userTask; }
	public: void setUserTask(bool v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// ArcPath
// typeId=945258954

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Archive path.
/// </summary>
class ArcPath : public ValueClass {
	/// <summary>
	/// IdName array.
	/// </summary>
	/// <remarks>
	/// Contains the identifiers and names for the archive paths.
	/// The first element is for the cabinet level. An entry does not exist for the archive level.
	/// </remarks>
	protected: PArrayIdName path;
	/// <summary>
	/// Path as string.
	/// </summary>
	/// <remarks>
	/// The first charachter is the path separator.
	/// </remarks>
	protected: ::std::wstring pathAsString;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: ArcPath();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: ArcPath(const PArrayIdName& path, const ::std::wstring& pathAsString);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: PArrayIdName getPath() { return path; }
	public: void setPath(PArrayIdName v);
	public: ::std::wstring getPathAsString() { return pathAsString; }
	public: void setPathAsString(::std::wstring v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// ArchiveStatistics
// typeId=2056457945

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Characteristic properties of the archive.
/// </summary>
class ArchiveStatistics : public ValueClass {
	/// <summary>
	/// Last document (version) ID.
	/// </summary>
	protected: int32_t maxDocId;
	/// <summary>
	/// Last object ID.
	/// </summary>
	protected: int32_t maxObjId;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: ArchiveStatistics();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: ArchiveStatistics(int32_t maxDocId, int32_t maxObjId);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getMaxDocId() { return maxDocId; }
	public: void setMaxDocId(int32_t v);
	public: int32_t getMaxObjId() { return maxObjId; }
	public: void setMaxObjId(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// ArchiveStatisticsOptionsC
// typeId=276716257

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// An object of this class controls the function getArchiveStatistics.
/// </summary>
class ArchiveStatisticsOptionsC : public BSerializable {
	/// <summary>
	/// Find the maximum document (version) ID
	/// </summary>
	public: const static int64_t mbMaxDocId = 1LL;
	/// <summary>
	/// Find the maximum object ID
	/// </summary>
	public: const static int64_t mbMaxObjId = 2LL;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: ArchiveStatisticsOptionsC();
	
	public: virtual BTYPEID BSerializable_getTypeId();
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// ArchivingModeC
// typeId=1464718703

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

class ArchivingModeC : public BSerializable {
	/// <summary>
	/// Version flag: no versioning.
	/// </summary>
	public: const static int32_t READWRITE = 2000;
	/// <summary>
	/// Version flag: version controlled.
	/// </summary>
	public: const static int32_t VERSION = 2001;
	/// <summary>
	/// Version flag: read only.
	/// </summary>
	public: const static int32_t READONLY = 2002;
	public: const static int32_t DEFAULT = 2001;
	public: const static int32_t NONE = 2999;
	private: int32_t dummy;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: ArchivingModeC();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: ArchivingModeC(int32_t READWRITE, int32_t VERSION, int32_t READONLY, int32_t DEFAULT, int32_t NONE, int32_t dummy);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getDummy() { return dummy; }
	public: void setDummy(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// AutoFilingOptions
// typeId=225606439

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Options for function {@link IXServicePortIF#evalAutoFiling(ClientInfo, String, Sord, AutoFilingOptions)}
/// </summary>
class AutoFilingOptions : public ValueClass {
	/// <summary>
	/// Auto filing index string.
	/// </summary>
	/// <remarks>
	/// If this option is set, paramter <code>maskId</code> in {@link IXServicePortIF#evalAutoFiling(ClientInfo, String, Sord, AutoFilingOptions)}
	/// is ignored.
	/// </remarks>
	protected: ::std::wstring autoFilingDefinition;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: AutoFilingOptions();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: AutoFilingOptions(const ::std::wstring& autoFilingDefinition);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: ::std::wstring getAutoFilingDefinition() { return autoFilingDefinition; }
	public: void setAutoFilingDefinition(::std::wstring v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// AutoFilingResult
// typeId=1881161566

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Contains the archive destination returned by a call to {@link IXServicePortIF#evalAutoFiling(ClientInfo, String, Sord, AutoFilingOptions)}.
/// </summary>
class AutoFilingResult : public ValueClass {
	/// <summary>
	/// Destination archive paths.
	/// </summary>
	/// <remarks>
	/// The first array element is the main path used to store the object.
	/// The other elements are archive paths for references to the object.
	/// The first character of each path is the separator.
	/// A path element is empty, if 1. the filing definition is an asterix (*, "chaos" folder) or if 2. the filing definition
	/// does not specify an archive path (e.g. "longest match" definition) and the destination path does not exist.
	/// A path element is the separator, if the destination path is the topmost archive level.
	/// If the filing definition given in {@link IXServicePortIF#evalAutoFiling(ClientInfo, String, Sord, AutoFilingOptions)} is empty,
	/// the array has one element of value "Â¶".
	/// </remarks>
	protected: PArrayString pathsAsString;
	/// <summary>
	/// Destination object IDs.
	/// </summary>
	/// <remarks>
	/// The first array element belongs to the main path. The other elements belong to reference paths.
	/// The element value is the object ID of the last entry in the path, if the path exists.
	/// If the path does not exist, the element value is -1.
	/// An element value of 0 indicates that the object is stored in the "chaos" folder. This happens if an asterix * is used as filing definition.
	/// If the filing definition given in {@link IXServicePortIF#evalAutoFiling(ClientInfo, String, Sord, AutoFilingOptions)} is empty,
	/// the array has one element of value 1.
	/// </remarks>
	protected: PArrayInt parentIds;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: AutoFilingResult();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: AutoFilingResult(const PArrayString& pathsAsString, const PArrayInt& parentIds);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: PArrayString getPathsAsString() { return pathsAsString; }
	public: void setPathsAsString(PArrayString v);
	public: PArrayInt getParentIds() { return parentIds; }
	public: void setParentIds(PArrayInt v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// BackupProfile
// typeId=1230334315

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// This class represents settings of a ELOdm backup profile.
/// </summary>
class BackupProfile : public ValueClass {
	/// <summary>
	/// Backup profile name
	/// </summary>
	protected: ::std::wstring name;
	/// <summary>
	/// Storage path id
	/// </summary>
	protected: int32_t pathId;
	/// <summary>
	/// Backup slot
	/// </summary>
	protected: int32_t slot;
	/// <summary>
	/// Store keywording too
	/// </summary>
	protected: bool writeKeywording;
	/// <summary>
	/// Optional SQL command to select the documents to be stored.
	/// </summary>
	protected: ::std::wstring sqlDocSelect;
	/// <summary>
	/// Maximum number of documents per backup loop.
	/// </summary>
	protected: int32_t nbOfDocsPerLoop;
	/// <summary>
	/// Reserved
	/// </summary>
	protected: int32_t retention;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: BackupProfile();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: BackupProfile(const ::std::wstring& name, int32_t pathId, int32_t slot, bool writeKeywording, const ::std::wstring& sqlDocSelect, int32_t nbOfDocsPerLoop, int32_t retention);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: ::std::wstring getName() { return name; }
	public: void setName(::std::wstring v);
	public: int32_t getPathId() { return pathId; }
	public: void setPathId(int32_t v);
	public: int32_t getSlot() { return slot; }
	public: void setSlot(int32_t v);
	public: bool getWriteKeywording() { return writeKeywording; }
	public: void setWriteKeywording(bool v);
	public: ::std::wstring getSqlDocSelect() { return sqlDocSelect; }
	public: void setSqlDocSelect(::std::wstring v);
	public: int32_t getNbOfDocsPerLoop() { return nbOfDocsPerLoop; }
	public: void setNbOfDocsPerLoop(int32_t v);
	public: int32_t getRetention() { return retention; }
	public: void setRetention(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// BackupPurgeStatus
// typeId=52201250

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// This class represents the status of the ELOdm backup and purge tasks
/// </summary>
class BackupPurgeStatus : public ValueClass {
	/// <summary>
	/// Status of the ELOdm backup task
	/// </summary>
	protected: PBackupStatus backupStatus;
	/// <summary>
	/// Status of the ELOdm purge task
	/// </summary>
	protected: PPurgeStatus purgeStatus;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: BackupPurgeStatus();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: BackupPurgeStatus(const PBackupStatus& backupStatus, const PPurgeStatus& purgeStatus);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: PBackupStatus getBackupStatus() { return backupStatus; }
	public: void setBackupStatus(PBackupStatus v);
	public: PPurgeStatus getPurgeStatus() { return purgeStatus; }
	public: void setPurgeStatus(PPurgeStatus v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// BackupStatus
// typeId=1288074907

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// This class represents the status of the ELOdm backup task
/// </summary>
class BackupStatus : public ValueClass {
	/// <summary>
	/// if the ELOdm backup task is running (the purge task can only run in
	/// combination with the backup task)
	/// </summary>
	protected: bool isRunning;
	/// <summary>
	/// number of copied documents since start of the backup task
	/// </summary>
	protected: int32_t numberOfDocsCopied;
	/// <summary>
	/// waiting time in seconds until the next proccessing
	/// (when the backup profiles are traversed)
	/// </summary>
	protected: int32_t secondsUntilNextCheck;
	/// <summary>
	/// an error message, if an error occured, else an empty String
	/// </summary>
	protected: ::std::wstring errorMessage;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: BackupStatus();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: BackupStatus(bool isRunning, int32_t numberOfDocsCopied, int32_t secondsUntilNextCheck, const ::std::wstring& errorMessage);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: bool getIsRunning() { return isRunning; }
	public: void setIsRunning(bool v);
	public: int32_t getNumberOfDocsCopied() { return numberOfDocsCopied; }
	public: void setNumberOfDocsCopied(int32_t v);
	public: int32_t getSecondsUntilNextCheck() { return secondsUntilNextCheck; }
	public: void setSecondsUntilNextCheck(int32_t v);
	public: ::std::wstring getErrorMessage() { return errorMessage; }
	public: void setErrorMessage(::std::wstring v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// BeginForwardWorkflowNodeInfo
// typeId=823426303

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

class BeginForwardWorkflowNodeInfo : public ValueClass {
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: BeginForwardWorkflowNodeInfo();
	
	public: virtual BTYPEID BSerializable_getTypeId();
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// Bitset
// typeId=1084624222

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// This class is used in the scripting API of IndexServer and
/// provides bit operations on 64 bit integers.
/// </summary>
/// <remarks>
/// JavaScript does
/// not support bit operations for 64 bit integers.
/// The global context of the JavaScripts executed by IndexServer
/// contain an object named Bitset which is an instance of
/// this class.
/// </remarks>
class Bitset : public BSerializable {
	/// <summary>
	/// Internal 64 bit integer value
	/// </summary>
	protected: int64_t v;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: Bitset();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: Bitset(int64_t v);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int64_t getV() { return v; }
	public: void setV(int64_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// CheckAccessOptions
// typeId=2061147439

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Options for function {@link IXServerEvents#onCheckSordAccess(IXServerEventsContext, Sord, SordZ, int, CheckAccessOptions)}
/// </summary>
class CheckAccessOptions : public ValueClass {
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: CheckAccessOptions();
	
	public: virtual BTYPEID BSerializable_getTypeId();
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// CheckInDocMaskLineTemplateOptions
// typeId=1586163042

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Option class for the methode CheckInDocMaskLineTemplate
/// </summary>
class CheckInDocMaskLineTemplateOptions : public BSerializable {
	/// <summary>
	/// Specifies which elements are passed to the document mask lines, which are using this template.
	/// </summary>
	protected: PDocMaskLineTemplateZ dmltZ;
	/// <summary>
	/// Only change template members are passed to the document mask lines, which are using this template.
	/// </summary>
	/// <remarks>
	/// This variable is ignored if dmltZ does not equal NULL.
	/// </remarks>
	protected: bool onlyModifiedTemplateMembers;
	/// <summary>
	/// Modified line members in the table masklines are kept.
	/// </summary>
	protected: bool keepModifiedLineMembers;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: CheckInDocMaskLineTemplateOptions();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: CheckInDocMaskLineTemplateOptions(const PDocMaskLineTemplateZ& dmltZ, bool onlyModifiedTemplateMembers, bool keepModifiedLineMembers);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: PDocMaskLineTemplateZ getDmltZ() { return dmltZ; }
	public: void setDmltZ(PDocMaskLineTemplateZ v);
	public: bool getOnlyModifiedTemplateMembers() { return onlyModifiedTemplateMembers; }
	public: void setOnlyModifiedTemplateMembers(bool v);
	public: bool getKeepModifiedLineMembers() { return keepModifiedLineMembers; }
	public: void setKeepModifiedLineMembers(bool v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// CheckinDocOptions
// typeId=1433031299

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// This class defines options for the API function checkinDocBegin2.
/// </summary>
class CheckinDocOptions : public ValueClass {
	/// <summary>
	/// If <tt>true</tt>, the DocVersion to check-in will use the ID and GUID you specify.
	/// </summary>
	/// <remarks>
	/// In
	/// order to only set the GUID, set the ID to 0.
	/// </remarks>
	protected: bool keepIds;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: CheckinDocOptions();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: CheckinDocOptions(bool keepIds);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: bool getKeepIds() { return keepIds; }
	public: void setKeepIds(bool v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// CheckinOrgUnitInfo
// typeId=740959052

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Objects of this class specify the selection criteria for
/// <code>checkinOrgUnits</code>.
/// </summary>
/// <remarks>
/// <p>Copyright: Copyright (c) 2013</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </remarks>
class CheckinOrgUnitInfo : public BSerializable {
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: CheckinOrgUnitInfo();
	
	public: virtual BTYPEID BSerializable_getTypeId();
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// CheckinReportInfo
// typeId=279483092

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Objects of this class specify the selection criteria for
/// <code>checkinReport</code>.
/// </summary>
/// <remarks>
/// <p>
/// Copyright: Copyright (c) 2014
/// </p>
/// <p>
/// Organisation: ELO Digital Office GmbH
/// </p>
/// </remarks>
class CheckinReportInfo : public BSerializable {
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: CheckinReportInfo();
	
	public: virtual BTYPEID BSerializable_getTypeId();
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// CheckinUsersC
// typeId=1602486374

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// <p>Constants for the function <code>checkinUsers</code>.
/// </summary>
/// <remarks>
/// </p>
/// <p>Copyright: Copyright (c) 2004</p>
/// <p>Organisation: </p>
/// </remarks>
class CheckinUsersC : public BSerializable {
	/// <summary>
	/// Checkin no user.
	/// </summary>
	/// <remarks>
	/// Makes sense if you only want to unlock user data.
	/// </remarks>
	public: const static int64_t bsetNOTHING = 0LL;
	/// <summary>
	/// Write without password.
	/// </summary>
	/// <remarks>
	/// Create new user if user ID &lt; 0.
	/// </remarks>
	public: const static int64_t bsetWRITE = 1LL;
	/// <summary>
	/// Updates a users password.
	/// </summary>
	public: const static int64_t bsetPASSWORD = 2LL;
	/// <summary>
	/// Insert a new user with the supplied user ID.
	/// </summary>
	public: const static int64_t bsetNEW_USER = 4LL;
	/// <summary>
	/// Checkin no user.
	/// </summary>
	/// <remarks>
	/// Makes sense if you only want to unlock user data.
	/// </remarks>
	public: const static PCheckinUsersZ NOTHING;
	/// <summary>
	/// Updates a users password.
	/// </summary>
	public: const static PCheckinUsersZ PASSWORD;
	/// <summary>
	/// Insert a new user with the supplied user ID.
	/// </summary>
	/// <remarks>
	/// Set the user's password.
	/// </remarks>
	public: const static PCheckinUsersZ NEW_USER;
	/// <summary>
	/// Updates or creates a user.
	/// </summary>
	public: const static PCheckinUsersZ WRITE;
	/// <summary>
	/// Updates or creates a user and set's the users's password.
	/// </summary>
	public: const static PCheckinUsersZ WRITE_PASSWORD;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: CheckinUsersC();
	
	public: virtual BTYPEID BSerializable_getTypeId();
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// CheckinUsersZ
// typeId=403687865

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// This class encapsulates the constants of CheckinUsersC.
/// </summary>
/// <remarks>
/// <p>Copyright: Copyright (c) 2004</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </remarks>
class CheckinUsersZ : public ValueClass {
	/// <summary>
	/// Bitset field for constants from CheckinUsersC class.
	/// </summary>
	protected: int64_t bset;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: CheckinUsersZ();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: CheckinUsersZ(int64_t bset);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int64_t getBset() { return bset; }
	public: void setBset(int64_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// CheckoutOrgUnitInfo
// typeId=948431844

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Objects of this class specify the selection criteria for
/// <code>checkoutOrgUnits</code>.
/// </summary>
/// <remarks>
/// </p>
/// No criterias can be set yet. All OUs are returned.
/// 
/// <p>Copyright: Copyright (c) 2013</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </remarks>
class CheckoutOrgUnitInfo : public BSerializable {
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: CheckoutOrgUnitInfo();
	
	public: virtual BTYPEID BSerializable_getTypeId();
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// CheckoutSordPathInfo
// typeId=730679282

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

class CheckoutSordPathInfo : public BSerializable {
	protected: bool inclRefPaths;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: CheckoutSordPathInfo();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: CheckoutSordPathInfo(bool inclRefPaths);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: bool getInclRefPaths() { return inclRefPaths; }
	public: void setInclRefPaths(bool v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// CheckoutUsersC
// typeId=531758278

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// <p>Constants to select users and groups</p>
/// </summary>
class CheckoutUsersC : public BSerializable {
	/// <summary>
	/// Internal use only.
	/// </summary>
	public: const static int64_t bsetNOTHING = 0LL;
	/// <summary>
	/// Internal use only.
	/// </summary>
	public: const static int64_t bsetBY_IDS = 1LL;
	/// <summary>
	/// Internal use only.
	/// </summary>
	public: const static int64_t bsetALL_USERS = 2LL;
	/// <summary>
	/// Internal use only.
	/// </summary>
	public: const static int64_t bsetALL_GROUPS = 3LL;
	/// <summary>
	/// Internal use only.
	/// </summary>
	public: const static int64_t bsetALL_USERS_AND_GROUPS = 4LL;
	/// <summary>
	/// Internal use only.
	/// </summary>
	public: const static int64_t bsetMEMBERS_OF_GROUP = 5LL;
	/// <summary>
	/// Internal use only.
	/// </summary>
	public: const static int64_t bsetUSERS_OF_GROUP = 6LL;
	/// <summary>
	/// Internal use only.
	/// </summary>
	public: const static int64_t bsetMEMBERS_OF_GROUP_RECURSIVE = 7LL;
	/// <summary>
	/// Internal use only.
	/// </summary>
	public: const static int64_t bsetUSERS_OF_GROUP_RECURSIVE = 8LL;
	/// <summary>
	/// Internal use only.
	/// </summary>
	public: const static int64_t bsetGROUPS_OF_MEMBER = 9LL;
	/// <summary>
	/// Internal use only.
	/// </summary>
	public: const static int64_t bsetGROUPS_OF_MEMBER_RECURSIVE = 10LL;
	/// <summary>
	/// Internal use only.
	/// </summary>
	public: const static int64_t bsetSESSION_INFO = 11LL;
	/// <summary>
	/// Internal use only.
	/// </summary>
	public: const static int64_t bsetSUBADMINS = 12LL;
	/// <summary>
	/// Internal use only.
	/// </summary>
	public: const static int64_t bsetMEMBERS_OF_ORGUNIT = 13LL;
	/// <summary>
	/// Internal use only.
	/// </summary>
	public: const static int64_t bsetUSERS_OF_SUBADMIN = 14LL;
	/// <summary>
	/// Internal use only.
	/// </summary>
	public: const static int64_t bsetSELECT_MASK = 255LL;
	/// <summary>
	/// Internal use only.
	/// </summary>
	public: const static int64_t bsetMY_USERS = 256LL;
	/// <summary>
	/// Internal use only.
	/// </summary>
	public: const static int64_t bsetEFFECTIVE_RIGHTS = 512LL;
	/// <summary>
	/// Select no user or group.
	/// </summary>
	/// <remarks>
	/// Makes sense if you only want to lock user data.
	/// </remarks>
	public: const static PCheckoutUsersZ NOTHING;
	/// <summary>
	/// Selects the user objects of the specified users.
	/// </summary>
	/// <remarks>
	/// Returned user data contains effective rights.
	/// </remarks>
	public: const static PCheckoutUsersZ BY_IDS;
	/// <summary>
	/// Selects the user objects of the specified users.
	/// </summary>
	/// <remarks>
	/// Returned user data does not contain effective rights.
	/// </remarks>
	public: const static PCheckoutUsersZ BY_IDS_RAW;
	/// <summary>
	/// Selects all users.
	/// </summary>
	/// <remarks>
	/// Returned user data contains effective rights.
	/// </remarks>
	public: const static PCheckoutUsersZ ALL_USERS;
	/// <summary>
	/// Selects all users.
	/// </summary>
	/// <remarks>
	/// Returned user data does not contain effective rights.
	/// </remarks>
	public: const static PCheckoutUsersZ ALL_USERS_RAW;
	/// <summary>
	/// Selects all groups.
	/// </summary>
	/// <remarks>
	/// Returned user data contains effective rights.
	/// </remarks>
	public: const static PCheckoutUsersZ ALL_GROUPS;
	/// <summary>
	/// Selects all groups.
	/// </summary>
	/// <remarks>
	/// Returned user data does not contain effective rights.
	/// </remarks>
	public: const static PCheckoutUsersZ ALL_GROUPS_RAW;
	/// <summary>
	/// Selects all users an all groups.
	/// </summary>
	/// <remarks>
	/// Returned user data contains effective rights.
	/// </remarks>
	public: const static PCheckoutUsersZ ALL_USERS_AND_GROUPS;
	/// <summary>
	/// Selects all users an all groups.
	/// </summary>
	/// <remarks>
	/// Returned user data does not contain effective rights.
	/// </remarks>
	public: const static PCheckoutUsersZ ALL_USERS_AND_GROUPS_RAW;
	/// <summary>
	/// Selects all members (users and groups) of the specified group.
	/// </summary>
	/// <remarks>
	/// Does not look
	/// for members of member groups recursively.
	/// Returned user data contains effective rights.
	/// </remarks>
	public: const static PCheckoutUsersZ MEMBERS_OF_GROUP;
	/// <summary>
	/// Selects all members (users and groups) of the specified group.
	/// </summary>
	/// <remarks>
	/// Does not look
	/// for members of member groups recursively.
	/// Returned user data does not contain effective rights.
	/// </remarks>
	public: const static PCheckoutUsersZ MEMBERS_OF_GROUP_RAW;
	/// <summary>
	/// Selects all users of the specified group.
	/// </summary>
	/// <remarks>
	/// Does not look
	/// for members of member groups recursively.
	/// Returned user data contains effective rights.
	/// </remarks>
	public: const static PCheckoutUsersZ USERS_OF_GROUP;
	/// <summary>
	/// Selects all users of the specified group.
	/// </summary>
	/// <remarks>
	/// Does not look
	/// for members of member groups recursively.
	/// Returned user data does not contain effective rights.
	/// </remarks>
	public: const static PCheckoutUsersZ USERS_OF_GROUP_RAW;
	/// <summary>
	/// Selects all members (users and groups) of the specified group.
	/// </summary>
	/// <remarks>
	/// Walks recursively
	/// over the group members and selects all members directly or indirectly contained
	/// in the specified group.
	/// Returned user data contains effective rights.
	/// </remarks>
	public: const static PCheckoutUsersZ MEMBERS_OF_GROUP_RECURSIVE;
	/// <summary>
	/// Selects all members (users and groups) of the specified group.
	/// </summary>
	/// <remarks>
	/// Walks recursively
	/// over the group members and selects all members directly or indirectly contained
	/// in the specified group.
	/// Returned user data does not contain effective rights.
	/// </remarks>
	public: const static PCheckoutUsersZ MEMBERS_OF_GROUP_RECURSIVE_RAW;
	/// <summary>
	/// Selects all users of the specified group.
	/// </summary>
	/// <remarks>
	/// Walks recursively
	/// over the group members and selects all users directly or indirectly contained
	/// in the specified group.
	/// Returned user data contains effective rights.
	/// </remarks>
	public: const static PCheckoutUsersZ USERS_OF_GROUP_RECURSIVE;
	/// <summary>
	/// Selects all users of the specified group.
	/// </summary>
	/// <remarks>
	/// Walks recursively
	/// over the group members and selects all users directly or indirectly contained
	/// in the specified group.
	/// Returned user data does not contain effective rights.
	/// </remarks>
	public: const static PCheckoutUsersZ USERS_OF_GROUP_RECURSIVE_RAW;
	/// <summary>
	/// Selects all direct groups of a user (or group).
	/// </summary>
	/// <remarks>
	/// Does not look for groups
	/// recursively.
	/// Returned user data contains effective rights.
	/// </remarks>
	public: const static PCheckoutUsersZ GROUPS_OF_MEMBER;
	/// <summary>
	/// Selects all direct groups of a user (or group).
	/// </summary>
	/// <remarks>
	/// Does not look for groups
	/// recursively.
	/// Returned user data does not contain effective rights.
	/// </remarks>
	public: const static PCheckoutUsersZ GROUPS_OF_MEMBER_RAW;
	/// <summary>
	/// Selects all direct groups of a user (or group).
	/// </summary>
	/// <remarks>
	/// Does not look for groups
	/// recursively. Walks recursively over the users groups.
	/// Returned user data contains effective rights.
	/// </remarks>
	public: const static PCheckoutUsersZ GROUPS_OF_MEMBER_RECURSIVE;
	/// <summary>
	/// Selects all direct groups of a user (or group).
	/// </summary>
	/// <remarks>
	/// Does not look for groups
	/// recursively. Walks recursively over the users groups.
	/// Returned user data does not contain effective rights.
	/// </remarks>
	public: const static PCheckoutUsersZ GROUPS_OF_MEMBER_RECURSIVE_RAW;
	/// <summary>
	/// Selects all active users.
	/// </summary>
	public: const static PCheckoutUsersZ SESSION_USERS;
	/// <summary>
	/// Selects all active users.
	/// </summary>
	/// <remarks>
	/// Returned user data does not contain effective rights.
	/// </remarks>
	public: const static PCheckoutUsersZ SESSION_USERS_RAW;
	/// <summary>
	/// Selects all sub-administrators.
	/// </summary>
	public: const static PCheckoutUsersZ SUBADMINS;
	/// <summary>
	/// Selects all Members of a given Orgunit
	/// </summary>
	public: const static PCheckoutUsersZ MEMBERS_OF_ORGUNIT;
	/// <summary>
	/// Selects all users and group managed by the given user.
	/// </summary>
	public: const static PCheckoutUsersZ USERS_OF_SUBADMIN;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: CheckoutUsersC();
	
	public: virtual BTYPEID BSerializable_getTypeId();
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// CheckoutUsersZ
// typeId=1897433533

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// This class encapsulates the constants of CheckoutUsersC.
/// </summary>
/// <remarks>
/// <p>Copyright: Copyright (c) 2004</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </remarks>
class CheckoutUsersZ : public ValueClass {
	/// <summary>
	/// Bitset field for constants from CheckoutUsersC class.
	/// </summary>
	protected: int64_t bset;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: CheckoutUsersZ();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: CheckoutUsersZ(int64_t bset);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int64_t getBset() { return bset; }
	public: void setBset(int64_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// CheckoutWorkflowHistoryParams
// typeId=299426984

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Parameter class for the method checkoutWorkflowHistory.
/// </summary>
class CheckoutWorkflowHistoryParams : public ValueClass {
	/// <summary>
	/// Workflow ID or workflow GUID.
	/// </summary>
	protected: ::std::wstring flowId;
	/// <summary>
	/// Node ID.
	/// </summary>
	/// <remarks>
	/// If node ID is 0, histories of all node are return.
	/// </remarks>
	protected: int32_t nodeId;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: CheckoutWorkflowHistoryParams();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: CheckoutWorkflowHistoryParams(const ::std::wstring& flowId, int32_t nodeId);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: ::std::wstring getFlowId() { return flowId; }
	public: void setFlowId(::std::wstring v);
	public: int32_t getNodeId() { return nodeId; }
	public: void setNodeId(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// CheckoutWorkflowHistoryResult
// typeId=1754570852

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// This class contains the results returned by the function checkoutWorkflowHistory.
/// </summary>
class CheckoutWorkflowHistoryResult : public ValueClass {
	/// <summary>
	/// Map of the node histories.
	/// </summary>
	/// <remarks>
	/// Node ID is the key.
	/// </remarks>
	protected: byps_ptr< ::std::map< int32_t , PVectorWFNodeHistory > > nodeHistories;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: CheckoutWorkflowHistoryResult();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: CheckoutWorkflowHistoryResult(const byps_ptr< ::std::map< int32_t , PVectorWFNodeHistory > >& nodeHistories);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: byps_ptr< ::std::map< int32_t , PVectorWFNodeHistory > > getNodeHistories() { return nodeHistories; }
	public: void setNodeHistories(byps_ptr< ::std::map< int32_t , PVectorWFNodeHistory > > v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// ClientInfo
// typeId=1258190913

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Contains the session ticket and the users language and country.
/// </summary>
/// <remarks>
/// Each
/// IndexServer interface function, except the login, requires a <code>ClientInfo</code>
/// object as parameter with a valid session ticket.
/// <p>Copyright: Copyright (c) 2004</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </remarks>
class ClientInfo : public ValueClass {
	/// <summary>
	/// This string is used for debugging purposes only.
	/// </summary>
	/// <remarks>
	/// It is displayed in error messages and reports.
	/// </remarks>
	protected: ::std::wstring callId;
	/// <summary>
	/// Country in ISO 3166 format - this is the country for the ELO Client.
	/// </summary>
	/// <remarks>
	/// <table border="2" summary=""><tr></tr>
	/// <tr><td>CZ</td><td>Czeach Republic</td></tr>
	/// <tr><td>FR</td><td>France</td></tr>
	/// <tr><td>DE</td><td>Germany</td></tr>
	/// <tr><td>GR</td><td>Greece</td></tr>
	/// <tr><td>ES</td><td>Spain</td></tr>
	/// <tr><td>PL</td><td>Poland</td></tr>
	/// <tr><td>GB</td><td>United Kingdom</td></tr>
	/// <tr><td>US</td><td>United States</td></tr>
	/// </table>
	/// </remarks>
	protected: ::std::wstring country;
	/// <summary>
	/// The users language in ISO 639 format.
	/// </summary>
	/// <remarks>
	/// Exception messages will be supplied in this language.
	/// <table border="2" summary=""><tr></tr>
	/// <tr><td>cs</td><td>Czech</td></tr>
	/// <tr><td>de</td><td>German</td></tr>
	/// <tr><td>el</td><td>Greek</td></tr>
	/// <tr><td>en</td><td>English</td></tr>
	/// <tr><td>es</td><td>Spanish</td></tr>
	/// <tr><td>fr</td><td>French</td></tr>
	/// <tr><td>pl</td><td>Polish</td></tr>
	/// </table>
	/// Only languages for which the localisations of the IndexServer resources exist
	/// can be selected, otherwise the messages are displayed in the default language.
	/// </remarks>
	protected: ::std::wstring language;
	/// <summary>
	/// <p>This is the session ID in the communication between the client and the IndexServer.
	/// </summary>
	/// <remarks>
	/// It has a limited lifetime. The lifetime can be configured at the ELOAM
	/// (access manager server). The IndexServer returns a valid ticket if the
	/// IXServicePortIF.login call succeeds. The lifetime of the ticket can be extended by calling
	/// IXServicePortIF.alive. </p>
	/// </remarks>
	protected: ::std::wstring ticket;
	/// <summary>
	/// The time zone for the ELO client.
	/// </summary>
	/// <remarks>
	/// Can be one of the predefined time zone IDs in the Java platform or a string
	/// of format "GMT" + sign + hh + ":" + mm.
	/// </remarks>
	protected: ::std::wstring timeZone;
	/// <summary>
	/// Internal use only.
	/// </summary>
	/// <remarks>
	/// Bit 0 of this member is set for requests that are send from one Indexserver instance to
	/// another instance in load balancing scenarios.
	/// </remarks>
	protected: int32_t options;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: ClientInfo();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: ClientInfo(const ::std::wstring& callId, const ::std::wstring& country, const ::std::wstring& language, const ::std::wstring& ticket, const ::std::wstring& timeZone, int32_t options);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: ::std::wstring getCallId() { return callId; }
	public: void setCallId(::std::wstring v);
	public: ::std::wstring getCountry() { return country; }
	public: void setCountry(::std::wstring v);
	public: ::std::wstring getLanguage() { return language; }
	public: void setLanguage(::std::wstring v);
	public: ::std::wstring getTicket() { return ticket; }
	public: void setTicket(::std::wstring v);
	public: ::std::wstring getTimeZone() { return timeZone; }
	public: void setTimeZone(::std::wstring v);
	public: int32_t getOptions() { return options; }
	public: void setOptions(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// ClientInfoC
// typeId=847449421

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Constants for ClientInfo.
/// </summary>
/// <remarks>
/// These constanse are only for internal usage.
/// </remarks>
class ClientInfoC : public BSerializable {
	/// <summary>
	/// Replication requests are marked with this bit.
	/// </summary>
	public: const static int32_t OPTION_REPLICATION_REQUEST = 1;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: ClientInfoC();
	
	public: virtual BTYPEID BSerializable_getTypeId();
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// ColorData
// typeId=1735048729

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// <p>Colours for marking entries in the archive.
/// </summary>
/// <remarks>
/// </p>
/// <p>Copyright: Copyright (c) 2003</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </remarks>
class ColorData : public ValueClass {
	/// <summary>
	/// RGB value.
	/// </summary>
	protected: int32_t RGB;
	/// <summary>
	/// Colour number (ID).
	/// </summary>
	protected: int32_t id;
	/// <summary>
	/// Colour name
	/// </summary>
	protected: ::std::wstring name;
	/// <summary>
	/// GUID
	/// </summary>
	protected: ::std::wstring guid;
	/// <summary>
	/// TStamp
	/// </summary>
	protected: ::std::wstring TStamp;
	/// <summary>
	/// Deleted
	/// </summary>
	protected: bool deleted;
	/// <summary>
	/// Timestamp of this object's last export by the replication.
	/// </summary>
	protected: ::std::wstring TStampSync;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: ColorData();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: ColorData(int32_t RGB, int32_t id, const ::std::wstring& name, const ::std::wstring& guid, const ::std::wstring& TStamp, bool deleted, const ::std::wstring& TStampSync);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getRGB() { return RGB; }
	public: void setRGB(int32_t v);
	public: int32_t getId() { return id; }
	public: void setId(int32_t v);
	public: ::std::wstring getName() { return name; }
	public: void setName(::std::wstring v);
	public: ::std::wstring getGuid() { return guid; }
	public: void setGuid(::std::wstring v);
	public: ::std::wstring getTStamp() { return TStamp; }
	public: void setTStamp(::std::wstring v);
	public: bool getDeleted() { return deleted; }
	public: void setDeleted(bool v);
	public: ::std::wstring getTStampSync() { return TStampSync; }
	public: void setTStampSync(::std::wstring v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// ColorDataInternC
// typeId=1208511866

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// <p>Bit constants for members of ColorData</p>
/// <p>Copyright: Copyright (c) 2003</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </summary>
class ColorDataInternC : public BSerializable {
	/// <summary>
	/// DB column: colorno
	/// </summary>
	public: const static int64_t mbId = 1LL;
	/// <summary>
	/// DB column: colorname
	/// </summary>
	public: const static int64_t mbName = 2LL;
	/// <summary>
	/// DB column: colorname
	/// </summary>
	protected: int32_t lnName;
	/// <summary>
	/// DB column: colorid
	/// </summary>
	public: const static int64_t mbRGB = 4LL;
	/// <summary>
	/// DB column: colorstatus
	/// </summary>
	public: const static int64_t mbStatus = 8LL;
	/// <summary>
	/// Member bit: GUID
	/// DB column: colorguid
	/// </summary>
	public: const static int64_t mbGuid = 16LL;
	/// <summary>
	/// Column length: GUID
	/// DB column: colorguid
	/// </summary>
	protected: int32_t lnGuid;
	/// <summary>
	/// Member bit: TStamp
	/// DB column: colortstamp
	/// </summary>
	public: const static int64_t mbTStamp = 32LL;
	/// <summary>
	/// Column length: TStamp
	/// DB column: colortstamp
	/// </summary>
	protected: int32_t lnTStamp;
	/// <summary>
	/// Member bit: Timestamp of this object's last export by the replication.
	/// </summary>
	/// <remarks>
	/// DB column: colortstampsync
	/// </remarks>
	public: const static int64_t mbTStampSync = 64LL;
	/// <summary>
	/// Column length: Timestamp of this object's last export by the replication.
	/// </summary>
	/// <remarks>
	/// DB column: colortstampsync
	/// </remarks>
	protected: int32_t lnTStampSync;
	/// <summary>
	/// All valid member bits.
	/// </summary>
	public: const static int64_t mbAllMembers = 127LL;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: ColorDataInternC();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: ColorDataInternC(int64_t mbId, int64_t mbName, int32_t lnName, int64_t mbRGB, int64_t mbStatus, int64_t mbGuid, int32_t lnGuid, int64_t mbTStamp, int32_t lnTStamp, int64_t mbTStampSync, int32_t lnTStampSync, int64_t mbAllMembers);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getLnName() { return lnName; }
	public: void setLnName(int32_t v);
	public: int32_t getLnGuid() { return lnGuid; }
	public: void setLnGuid(int32_t v);
	public: int32_t getLnTStamp() { return lnTStamp; }
	public: void setLnTStamp(int32_t v);
	public: int32_t getLnTStampSync() { return lnTStampSync; }
	public: void setLnTStampSync(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// ColorDataC
// typeId=881975137

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

class ColorDataC : public ColorDataInternC {
	/// <summary>
	/// System color
	/// </summary>
	protected: ::std::wstring GUID_SYSTEM;
	/// <summary>
	/// Color red
	/// </summary>
	protected: ::std::wstring GUID_RED;
	/// <summary>
	/// Color green
	/// </summary>
	protected: ::std::wstring GUID_GREEN;
	/// <summary>
	/// Color blue
	/// </summary>
	protected: ::std::wstring GUID_BLUE;
	public: const static int64_t mbDeleted = 8LL;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: ColorDataC();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: ColorDataC(const ::std::wstring& GUID_SYSTEM, const ::std::wstring& GUID_RED, const ::std::wstring& GUID_GREEN, const ::std::wstring& GUID_BLUE, int64_t mbDeleted);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: ::std::wstring getGUID_SYSTEM() { return GUID_SYSTEM; }
	public: void setGUID_SYSTEM(::std::wstring v);
	public: ::std::wstring getGUID_RED() { return GUID_RED; }
	public: void setGUID_RED(::std::wstring v);
	public: ::std::wstring getGUID_GREEN() { return GUID_GREEN; }
	public: void setGUID_GREEN(::std::wstring v);
	public: ::std::wstring getGUID_BLUE() { return GUID_BLUE; }
	public: void setGUID_BLUE(::std::wstring v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// CombineAclOptions
// typeId=66519402

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// This class specifies additional options for compareAcl.
/// </summary>
class CombineAclOptions : public BSerializable {
	/// <summary>
	/// Left operand for ACL operation in String representation.
	/// </summary>
	protected: ::std::wstring lhsAclStr;
	/// <summary>
	/// Right operand for ACL operation in String representation.
	/// </summary>
	protected: ::std::wstring rhsAclStr;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: CombineAclOptions();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: CombineAclOptions(const ::std::wstring& lhsAclStr, const ::std::wstring& rhsAclStr);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: ::std::wstring getLhsAclStr() { return lhsAclStr; }
	public: void setLhsAclStr(::std::wstring v);
	public: ::std::wstring getRhsAclStr() { return rhsAclStr; }
	public: void setRhsAclStr(::std::wstring v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// CombineAclResult
// typeId=1034263904

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// This class contains the results returned by the function combineAcl.
/// </summary>
class CombineAclResult : public BSerializable {
	/// <summary>
	/// Compare result.
	/// </summary>
	/// <remarks>
	/// Negative if ACL lhs is less than rhs.
	/// Posiitve if ACL lhs is greater than rhs.
	/// Zero if ACLs are equal.
	/// </remarks>
	protected: int32_t compareCode;
	/// <summary>
	/// Compare result by ignoring the member AclItem.access.
	/// </summary>
	/// <remarks>
	/// Negative if ACL lhs is less than rhs.
	/// Posiitve if ACL lhs is greater than rhs.
	/// Zero if ACLs are equal.
	/// </remarks>
	protected: int32_t compareIgnoreAccessCode;
	/// <summary>
	/// Contains the ACL items that are in both ACLs.
	/// </summary>
	protected: PArrayAclItem intersection;
	/// <summary>
	/// String representation of AclItem array intersection.
	/// </summary>
	protected: ::std::wstring intersectionAclStr;
	/// <summary>
	/// Contains the sum of both ACLs.
	/// </summary>
	protected: PArrayAclItem sum;
	/// <summary>
	/// String representation of AclItem array sum.
	/// </summary>
	protected: ::std::wstring sumAclStr;
	/// <summary>
	/// Contains the ACL items that are in ACL lhs but not in rhs.
	/// </summary>
	protected: PArrayAclItem difference;
	/// <summary>
	/// String representation of AclItem array difference.
	/// </summary>
	protected: ::std::wstring differenceAclStr;
	/// <summary>
	/// Contains the ACL items that are in ACL rhs but not in lhs.
	/// </summary>
	protected: PArrayAclItem inverseDifference;
	/// <summary>
	/// String representation of AclItem array inverseDifference.
	/// </summary>
	protected: ::std::wstring inverseDifferenceAclStr;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: CombineAclResult();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: CombineAclResult(int32_t compareCode, int32_t compareIgnoreAccessCode, const PArrayAclItem& intersection, const ::std::wstring& intersectionAclStr, const PArrayAclItem& sum, const ::std::wstring& sumAclStr, const PArrayAclItem& difference, const ::std::wstring& differenceAclStr, const PArrayAclItem& inverseDifference, const ::std::wstring& inverseDifferenceAclStr);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getCompareCode() { return compareCode; }
	public: void setCompareCode(int32_t v);
	public: int32_t getCompareIgnoreAccessCode() { return compareIgnoreAccessCode; }
	public: void setCompareIgnoreAccessCode(int32_t v);
	public: PArrayAclItem getIntersection() { return intersection; }
	public: void setIntersection(PArrayAclItem v);
	public: ::std::wstring getIntersectionAclStr() { return intersectionAclStr; }
	public: void setIntersectionAclStr(::std::wstring v);
	public: PArrayAclItem getSum() { return sum; }
	public: void setSum(PArrayAclItem v);
	public: ::std::wstring getSumAclStr() { return sumAclStr; }
	public: void setSumAclStr(::std::wstring v);
	public: PArrayAclItem getDifference() { return difference; }
	public: void setDifference(PArrayAclItem v);
	public: ::std::wstring getDifferenceAclStr() { return differenceAclStr; }
	public: void setDifferenceAclStr(::std::wstring v);
	public: PArrayAclItem getInverseDifference() { return inverseDifference; }
	public: void setInverseDifference(PArrayAclItem v);
	public: ::std::wstring getInverseDifferenceAclStr() { return inverseDifferenceAclStr; }
	public: void setInverseDifferenceAclStr(::std::wstring v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// ConfigFile
// typeId=582012382

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Used for accessing directories or files on the server.
/// </summary>
/// <remarks>
/// <p>Copyright: Copyright (c) 2004</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </remarks>
class ConfigFile : public ValueClass {
	/// <summary>
	/// The path to the file.
	/// </summary>
	protected: ::std::wstring dir;
	/// <summary>
	/// The content of the file.
	/// </summary>
	protected: PFileData fileData;
	/// <summary>
	/// Returns true if the object is a directory, false if it is a file.
	/// </summary>
	protected: bool isDirectory;
	/// <summary>
	/// The last-modified date of the script file.
	/// </summary>
	/// <remarks>
	/// This value is related to the UTC time-zone.
	/// </remarks>
	protected: ::std::wstring lastModifiedISO;
	/// <summary>
	/// The name of the file or the extension.
	/// </summary>
	protected: ::std::wstring name;
	/// <summary>
	/// File size.
	/// </summary>
	protected: int64_t size;
	/// <summary>
	/// HTTP-Response returned when file is uploaded.
	/// </summary>
	protected: ::std::wstring uploadResult;
	/// <summary>
	/// Download or upload URL.
	/// </summary>
	protected: ::std::wstring url;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: ConfigFile();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: ConfigFile(const ::std::wstring& dir, const PFileData& fileData, bool isDirectory, const ::std::wstring& lastModifiedISO, const ::std::wstring& name, int64_t size, const ::std::wstring& uploadResult, const ::std::wstring& url);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: ::std::wstring getDir() { return dir; }
	public: void setDir(::std::wstring v);
	public: PFileData getFileData() { return fileData; }
	public: void setFileData(PFileData v);
	public: bool getIsDirectory() { return isDirectory; }
	public: void setIsDirectory(bool v);
	public: ::std::wstring getLastModifiedISO() { return lastModifiedISO; }
	public: void setLastModifiedISO(::std::wstring v);
	public: ::std::wstring getName() { return name; }
	public: void setName(::std::wstring v);
	public: int64_t getSize() { return size; }
	public: void setSize(int64_t v);
	public: ::std::wstring getUploadResult() { return uploadResult; }
	public: void setUploadResult(::std::wstring v);
	public: ::std::wstring getUrl() { return url; }
	public: void setUrl(::std::wstring v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// ConfigFileC
// typeId=2098566124

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Constants for the ConfigFile class.
/// </summary>
/// <remarks>
/// These are used for accessing server directories.
/// 
/// <p>Copyright: Copyright (c) 2004</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </remarks>
class ConfigFileC : public BSerializable {
	/// <summary>
	/// Directory for COLD background files.
	/// </summary>
	public: const static ::std::wstring COLD;
	/// <summary>
	/// Directory for scripts.
	/// </summary>
	public: const static ::std::wstring ELO_SCRIPTS;
	/// <summary>
	/// Directory of initialization data.
	/// </summary>
	public: const static ::std::wstring INIT_DATA;
	/// <summary>
	/// Directory of Intray/postbox.
	/// </summary>
	public: const static ::std::wstring POSTBOX;
	/// <summary>
	/// Server side checkout directory.
	/// </summary>
	public: const static ::std::wstring CHECKOUT;
	/// <summary>
	/// Old document template directory (ELO 5.0).
	/// </summary>
	public: const static ::std::wstring TEMPLATE;
	/// <summary>
	/// RESERVED
	/// </summary>
	public: const static ::std::wstring VIEWER_POSTBOX;
	/// <summary>
	/// Member bit: name
	/// </summary>
	public: const static int64_t mbName = 1LL;
	/// <summary>
	/// Member bit: fileData
	/// </summary>
	public: const static int64_t mbFileData = 2LL;
	/// <summary>
	/// Member bit: lastModified
	/// </summary>
	public: const static int64_t mbLastModified = 4LL;
	/// <summary>
	/// Member bit: size
	/// </summary>
	public: const static int64_t mbSize = 8LL;
	/// <summary>
	/// Member bit: URL
	/// </summary>
	public: const static int64_t mbUrl = 16LL;
	/// <summary>
	/// Member bit set: all members.
	/// </summary>
	public: const static int64_t mbAllMembers = 31LL;
	/// <summary>
	/// Constant object for mbAllMembers.
	/// </summary>
	public: const static PConfigFileZ mbAll;
	/// <summary>
	/// Constant object for mbAllmembers without file data.
	/// </summary>
	public: const static PConfigFileZ mbNoFileData;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: ConfigFileC();
	
	public: virtual BTYPEID BSerializable_getTypeId();
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// ConfigFileZ
// typeId=821574897

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// This class encapsulates the constants of ConfigFileC.
/// </summary>
class ConfigFileZ : public ValueClass {
	/// <summary>
	/// Bitset field for constants of the ConfigFileC class.
	/// </summary>
	protected: int64_t bset;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: ConfigFileZ();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: ConfigFileZ(int64_t bset);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int64_t getBset() { return bset; }
	public: void setBset(int64_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// ContextTerm
// typeId=1464223403

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

class ContextTerm : public BSerializable {
	protected: ::std::wstring term;
	protected: int32_t docNum;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: ContextTerm();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: ContextTerm(const ::std::wstring& term, int32_t docNum);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: ::std::wstring getTerm() { return term; }
	public: void setTerm(::std::wstring v);
	public: int32_t getDocNum() { return docNum; }
	public: void setDocNum(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// ControlBackupInfo
// typeId=1738666671

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Mode for the ELOdm backup and purge tasks
/// </summary>
class ControlBackupInfo : public ValueClass {
	/// <summary>
	/// Start, stop and status of the ELOdm backup and purge tasks
	/// (constants in ControlBackupInfoC)
	/// </summary>
	protected: int32_t mode;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: ControlBackupInfo();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: ControlBackupInfo(int32_t mode);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getMode() { return mode; }
	public: void setMode(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// ControlBackupInfoC
// typeId=1165618755

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Constants for class ControlBackupInfo
/// (mode for the ELOdm backup and purge tasks)
/// </summary>
class ControlBackupInfoC : public ValueClass {
	/// <summary>
	/// Query the status of the backup and purge tasks
	/// </summary>
	public: const static int32_t MODE_STATUS = 0;
	/// <summary>
	/// Start the backup task (if it is already running, nothing happens).
	/// </summary>
	/// <remarks>
	/// If the purge task is already running, it is stopped.
	/// </remarks>
	public: const static int32_t MODE_START_BACKUP = 1;
	/// <summary>
	/// Start the backup and the purge task.
	/// </summary>
	/// <remarks>
	/// If the backup task is already running, only the purge task is started.
	/// </remarks>
	public: const static int32_t MODE_START_BACKUP_PURGE = 2;
	/// <summary>
	/// Stop the backup and purge tasks
	/// </summary>
	public: const static int32_t MODE_STOP = 3;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: ControlBackupInfoC();
	
	public: virtual BTYPEID BSerializable_getTypeId();
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// CopyInfo
// typeId=2138439536

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Controls the options of de.elo.ix.IXServicePortIF.copySord().
/// </summary>
/// <remarks>
/// <p>
/// Copyright: Copyright (c) 2004
/// </p>
/// <p>
/// Organisation: ELO Digital Office GmbH
/// </p>
/// </remarks>
class CopyInfo : public ValueClass {
	/// <summary>
	/// Depth up to which the structure is to be copied.
	/// </summary>
	/// <remarks>
	/// THIS FUNCTION IS NOT CURRENTLY SUPPORTED!
	/// </remarks>
	protected: int32_t depth;
	/// <summary>
	/// Manually determine the position.
	/// </summary>
	/// <remarks>
	/// Use 0 to insert at the beginning of the child list. Use -1 to
	/// insert at the end of the child list ( this is the fastest mode). A value n greater then 0
	/// inserts the object at the position n.
	/// </remarks>
	protected: int32_t manSortIdx;
	/// <summary>
	/// COPY-Mode: Name of the destination archive entry.
	/// </summary>
	/// <remarks>
	/// THIS FUNCTION IS NOT CURRENTLY SUPPORTED!
	/// </remarks>
	protected: ::std::wstring name;
	/// <summary>
	/// The permissions of the moved object are modified.
	/// </summary>
	/// <remarks>
	/// The permissions inherited from the old parent
	/// are substracted and the permissions of the new parent are added to the object.
	/// </remarks>
	protected: bool adjustAclDifference;
	/// <summary>
	/// Set the permissions of the moved object equal to the permissions of the new parent.
	/// </summary>
	protected: bool adjustAclOverwrite;
	/// <summary>
	/// Recursivly adjust the permissions of the sub-folders of the moved object too.
	/// </summary>
	protected: bool adjustAclIgnoreFolders;
	/// <summary>
	/// Recursivly adjust the permissions of the child-documents of the moved object too.
	/// </summary>
	protected: bool adjustAclIgnoreDocuments;
	/// <summary>
	/// Recursivly adjust the permissions of the child-elements in the background.
	/// </summary>
	protected: bool adjustAclInBackground;
	/// <summary>
	/// Check for recursion.
	/// </summary>
	/// <remarks>
	/// If this member is set, the function {@link IXServicePortIF#copySord(ClientInfo, String, String, CopyInfo, CopySordZ)} checks
	/// whether the copy or move operation causes a recursion in the archive hierarchy. If so, the function throws an exception with
	/// {@link IXExceptionC#ACCESS_DENIED}.
	/// </remarks>
	protected: bool checkRecursion;
	/// <summary>
	/// Parent ID for move operation.
	/// </summary>
	/// <remarks>
	/// Set this element to the old parent ID when a reference has to be moved.
	/// If an original entry has to be moved, set the main parent ID or leave the value empty.
	/// </remarks>
	protected: ::std::wstring oldParentId;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: CopyInfo();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: CopyInfo(int32_t depth, int32_t manSortIdx, const ::std::wstring& name, bool adjustAclDifference, bool adjustAclOverwrite, bool adjustAclIgnoreFolders, bool adjustAclIgnoreDocuments, bool adjustAclInBackground, bool checkRecursion, const ::std::wstring& oldParentId);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getDepth() { return depth; }
	public: void setDepth(int32_t v);
	public: int32_t getManSortIdx() { return manSortIdx; }
	public: void setManSortIdx(int32_t v);
	public: ::std::wstring getName() { return name; }
	public: void setName(::std::wstring v);
	public: bool getAdjustAclDifference() { return adjustAclDifference; }
	public: void setAdjustAclDifference(bool v);
	public: bool getAdjustAclOverwrite() { return adjustAclOverwrite; }
	public: void setAdjustAclOverwrite(bool v);
	public: bool getAdjustAclIgnoreFolders() { return adjustAclIgnoreFolders; }
	public: void setAdjustAclIgnoreFolders(bool v);
	public: bool getAdjustAclIgnoreDocuments() { return adjustAclIgnoreDocuments; }
	public: void setAdjustAclIgnoreDocuments(bool v);
	public: bool getAdjustAclInBackground() { return adjustAclInBackground; }
	public: void setAdjustAclInBackground(bool v);
	public: bool getCheckRecursion() { return checkRecursion; }
	public: void setCheckRecursion(bool v);
	public: ::std::wstring getOldParentId() { return oldParentId; }
	public: void setOldParentId(::std::wstring v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// CopyOptions
// typeId=1427182574

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Structure for the options for the copy-process.
/// </summary>
/// <remarks>
/// <p>
/// Copyright: Copyright (c) 2009
/// </p>
/// <p>
/// Organisation: ELO Digital Office GmbH
/// </p>
/// </remarks>
class CopyOptions : public BSerializable {
	/// <summary>
	/// Name of the target archive element.
	/// </summary>
	protected: ::std::wstring targetName;
	/// <summary>
	/// ParentId of the new element.
	/// </summary>
	protected: int32_t newParentId;
	/// <summary>
	/// Copy only the base element.
	/// </summary>
	protected: bool copyOnlyBaseElement;
	/// <summary>
	/// Copy all structures with the documents.
	/// </summary>
	protected: bool copyStructuresAndDocuments;
	/// <summary>
	/// If inclAttachments and copyOnlyWorkAttachment are true, copy only the work attachments.
	/// </summary>
	/// <remarks>
	/// Setting
	/// copyOnlyWorkAttachment to true when inclAttachments is false is invalid.
	/// </remarks>
	protected: bool copyOnlyWorkAttachment;
	/// <summary>
	/// Keep the original owner of the archive element.
	/// </summary>
	protected: bool keepOriginalOwner;
	/// <summary>
	/// Keep the current documentnotes.
	/// </summary>
	protected: bool keepCurrentNotes;
	/// <summary>
	/// Also copy all attachments.
	/// </summary>
	protected: bool inclAttachments;
	/// <summary>
	/// Keep the current permissions.
	/// </summary>
	/// <remarks>
	/// Only one of the three options keepOriginalPermissions, takeTargetPermissions and acceptChanges can be true.
	/// </remarks>
	protected: bool keepOriginalPermissions;
	/// <summary>
	/// Take the target permissions.
	/// </summary>
	/// <remarks>
	/// Only one of the three options keepOriginalPermissions, takeTargetPermissions and acceptChanges can be true.
	/// </remarks>
	protected: bool takeTargetPermissions;
	/// <summary>
	/// Accept the change.
	/// </summary>
	/// <remarks>
	/// Only one of the three options keepOriginalPermissions, takeTargetPermissions and acceptChanges can be true.
	/// </remarks>
	protected: bool acceptChanges;
	/// <summary>
	/// Keep references to original objects in copied parents.
	/// </summary>
	/// <remarks>
	/// This member is ignored, if ProcessInfo.inclReferences=false.
	/// If this member is true or only the parent is included in the tree,
	/// the copied reference links the copied parent to the original object.
	/// If this member is false and both the parent and object of a reference is included
	/// in the tree, the copied reference links the copied parent to the copied object.
	/// </remarks>
	protected: bool keepReferences;
	/// <summary>
	/// Do not copy all documents versions but only workversion
	/// </summary>
	protected: bool copyOnlyWorkversion;
	/// <summary>
	/// Only move the element.
	/// </summary>
	protected: bool moveOnly;
	/// <summary>
	/// The permissions of the moved objects are modified.
	/// </summary>
	/// <remarks>
	/// The permissions inherited from the old parent
	/// are substracted and the permissions of the new parent are added to the object.
	/// </remarks>
	private: bool adjustAclDifference;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: CopyOptions();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: CopyOptions(const ::std::wstring& targetName, int32_t newParentId, bool copyOnlyBaseElement, bool copyStructuresAndDocuments, bool copyOnlyWorkAttachment, bool keepOriginalOwner, bool keepCurrentNotes, bool inclAttachments, bool keepOriginalPermissions, bool takeTargetPermissions, bool acceptChanges, bool keepReferences, bool copyOnlyWorkversion, bool moveOnly, bool adjustAclDifference);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: ::std::wstring getTargetName() { return targetName; }
	public: void setTargetName(::std::wstring v);
	public: int32_t getNewParentId() { return newParentId; }
	public: void setNewParentId(int32_t v);
	public: bool getCopyOnlyBaseElement() { return copyOnlyBaseElement; }
	public: void setCopyOnlyBaseElement(bool v);
	public: bool getCopyStructuresAndDocuments() { return copyStructuresAndDocuments; }
	public: void setCopyStructuresAndDocuments(bool v);
	public: bool getCopyOnlyWorkAttachment() { return copyOnlyWorkAttachment; }
	public: void setCopyOnlyWorkAttachment(bool v);
	public: bool getKeepOriginalOwner() { return keepOriginalOwner; }
	public: void setKeepOriginalOwner(bool v);
	public: bool getKeepCurrentNotes() { return keepCurrentNotes; }
	public: void setKeepCurrentNotes(bool v);
	public: bool getInclAttachments() { return inclAttachments; }
	public: void setInclAttachments(bool v);
	public: bool getKeepOriginalPermissions() { return keepOriginalPermissions; }
	public: void setKeepOriginalPermissions(bool v);
	public: bool getTakeTargetPermissions() { return takeTargetPermissions; }
	public: void setTakeTargetPermissions(bool v);
	public: bool getAcceptChanges() { return acceptChanges; }
	public: void setAcceptChanges(bool v);
	public: bool getKeepReferences() { return keepReferences; }
	public: void setKeepReferences(bool v);
	public: bool getCopyOnlyWorkversion() { return copyOnlyWorkversion; }
	public: void setCopyOnlyWorkversion(bool v);
	public: bool getMoveOnly() { return moveOnly; }
	public: void setMoveOnly(bool v);
	public: bool getAdjustAclDifference() { return adjustAclDifference; }
	public: void setAdjustAclDifference(bool v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// CopyResult
// typeId=1904597264

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Results of a {@link ProcessCopyElements}-Operation.
/// </summary>
class CopyResult : public BSerializable {
	/// <summary>
	/// Maps the Ids of the source elements to the copied element's Ids.
	/// </summary>
	/// <remarks>
	/// <p>
	/// To reduce memory consumption, this map only contains the mapping for
	/// elements in the {@link NavigationInfo#startIDs} when using
	/// {@link IXServicePortIF#processTrees(ClientInfo, NavigationInfo, ProcessInfo)}
	/// .
	/// </p>
	/// <p>
	/// In case of using
	/// {@link IXServicePortIF#processFindResult(ClientInfo, String, ProcessInfo)},
	/// each element found by the search will be listed in this map!
	/// </p>
	/// </remarks>
	protected: byps::PMapIntegerInteger mapIdsSource2Copy;
	/// <summary>
	/// Maps the GUIDs of the source elements to the copied element's GUIDs.
	/// </summary>
	/// <remarks>
	/// <p>
	/// The same rules apply as for {@link CopyResult#mapIdsSource2Copy}.
	/// </p>
	/// </remarks>
	protected: byps::PMapStringString mapGuidsSource2Copy;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: CopyResult();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: CopyResult(const byps::PMapIntegerInteger& mapIdsSource2Copy, const byps::PMapStringString& mapGuidsSource2Copy);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: byps::PMapIntegerInteger getMapIdsSource2Copy() { return mapIdsSource2Copy; }
	public: void setMapIdsSource2Copy(byps::PMapIntegerInteger v);
	public: byps::PMapStringString getMapGuidsSource2Copy() { return mapGuidsSource2Copy; }
	public: void setMapGuidsSource2Copy(byps::PMapStringString v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// CopySordC
// typeId=1616091412

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Constants to copy or move archive entries, or to create a logical link.
/// </summary>
/// <remarks>
/// These constants are used
/// as parameters in the copySord function.
/// <p>
/// Copyright: Copyright (c) 2004
/// </p>
/// <p>
/// Organisation: ELO Digital Office GmbH
/// </p>
/// </remarks>
class CopySordC : public BSerializable {
	/// <summary>
	/// Move an archive entry.
	/// </summary>
	public: const static int64_t bsetMOVE = 1LL;
	/// <summary>
	/// Create a logical link.
	/// </summary>
	public: const static int64_t bsetREFERENCE = 2LL;
	/// <summary>
	/// Reserved.
	/// </summary>
	/// <remarks>
	/// Use ProcessCopyElements and processTrees to copy an archive structure.
	/// </remarks>
	public: const static int64_t bsetCOPY = 4LL;
	/// <summary>
	/// Copy archive entry with children (CURRENTLY NOT SUPPORTED!).
	/// </summary>
	public: const static int64_t bsetCOPY_WITH_CHILDREN = 8LL;
	/// <summary>
	/// Copy archive entry with documents (CURRENTLY NOT SUPPORTED!).
	/// </summary>
	public: const static int64_t bsetCOPY_WITH_DOCUMENTS = 16LL;
	/// <summary>
	/// Copy archive entry with document versions (CURRENTLY NOT SUPPORTED!).
	/// </summary>
	public: const static int64_t bsetCOPY_WITH_DOCUMENT_VERSIONS = 32LL;
	/// <summary>
	/// Copy archive entry with attachments (CURRENTLY NOT SUPPORTED!).
	/// </summary>
	public: const static int64_t bsetCOPY_WITH_ATTACHMENTS = 64LL;
	/// <summary>
	/// Copy archive entry with attachment versions (CURRENTLY NOT SUPPORTED!).
	/// </summary>
	public: const static int64_t bsetCOPY_WITH_ATTACHMENT_VERSIONS = 128LL;
	/// <summary>
	/// Copy archive entry with notes (CURRENTLY NOT SUPPORTED!).
	/// </summary>
	public: const static int64_t bsetCOPY_WITH_NOTES_TYPE_NORMAL = 256LL;
	/// <summary>
	/// Copy archive entry with personal notes (CURRENTLY NOT SUPPORTED!).
	/// </summary>
	public: const static int64_t bsetCOPY_WITH_NOTES_TYPE_PERSONAL = 512LL;
	/// <summary>
	/// Copy archive entry with stamps (CURRENTLY NOT SUPPORTED!).
	/// </summary>
	public: const static int64_t bsetCOPY_WITH_NOTES_TYPE_STAMP = 1024LL;
	/// <summary>
	/// RESERVED.
	/// </summary>
	/// <remarks>
	/// Use ProcessCopyElements and processTrees to copy an archive structure.
	/// </remarks>
	public: const static PCopySordZ COPY;
	/// <summary>
	/// Move the sord.
	/// </summary>
	/// <remarks>
	/// Used in ix.copySord(...).
	/// </remarks>
	public: const static PCopySordZ MOVE;
	/// <summary>
	/// Create a reference to the sord.
	/// </summary>
	/// <remarks>
	/// Used in ix.copySord(...).
	/// </remarks>
	public: const static PCopySordZ REFERENCE;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: CopySordC();
	
	public: virtual BTYPEID BSerializable_getTypeId();
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// CopySordZ
// typeId=2059126408

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// This class encapsulates the constants of the CopySordsC class.
/// </summary>
/// <remarks>
/// <p>Copyright: Copyright (c) 2004</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </remarks>
class CopySordZ : public ValueClass {
	/// <summary>
	/// Bitset field for constants from the CopySordC class.
	/// </summary>
	protected: int64_t bset;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: CopySordZ();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: CopySordZ(int64_t bset);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int64_t getBset() { return bset; }
	public: void setBset(int64_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// CountResult
// typeId=1581335066

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Class for the results of one count process.
/// </summary>
class CountResult : public BSerializable {
	/// <summary>
	/// count of the found documents
	/// </summary>
	protected: int32_t docCount;
	/// <summary>
	/// count of the found structures
	/// </summary>
	protected: int32_t structCount;
	/// <summary>
	/// count of the found document attachments
	/// </summary>
	protected: int32_t docAttachCount;
	/// <summary>
	/// count of the documents in the version history
	/// </summary>
	protected: int32_t docVersionsCount;
	/// <summary>
	/// count of the other attachment versions
	/// </summary>
	protected: int32_t otherAttachVersionsCount;
	/// <summary>
	/// count of the bytes of the current document version
	/// </summary>
	protected: int64_t docBytesCount;
	/// <summary>
	/// count of the bytes of other document versions
	/// </summary>
	protected: int64_t otherDocVersBytesCount;
	/// <summary>
	/// count of the bytes of the current attachment version
	/// </summary>
	protected: int64_t attBytesCount;
	/// <summary>
	/// count of the bytes of other attachment versions
	/// </summary>
	protected: int64_t otherAttVersBytesCount;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: CountResult();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: CountResult(int32_t docCount, int32_t structCount, int32_t docAttachCount, int32_t docVersionsCount, int32_t otherAttachVersionsCount, int64_t docBytesCount, int64_t otherDocVersBytesCount, int64_t attBytesCount, int64_t otherAttVersBytesCount);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getDocCount() { return docCount; }
	public: void setDocCount(int32_t v);
	public: int32_t getStructCount() { return structCount; }
	public: void setStructCount(int32_t v);
	public: int32_t getDocAttachCount() { return docAttachCount; }
	public: void setDocAttachCount(int32_t v);
	public: int32_t getDocVersionsCount() { return docVersionsCount; }
	public: void setDocVersionsCount(int32_t v);
	public: int32_t getOtherAttachVersionsCount() { return otherAttachVersionsCount; }
	public: void setOtherAttachVersionsCount(int32_t v);
	public: int64_t getDocBytesCount() { return docBytesCount; }
	public: void setDocBytesCount(int64_t v);
	public: int64_t getOtherDocVersBytesCount() { return otherDocVersBytesCount; }
	public: void setOtherDocVersBytesCount(int64_t v);
	public: int64_t getAttBytesCount() { return attBytesCount; }
	public: void setAttBytesCount(int64_t v);
	public: int64_t getOtherAttVersBytesCount() { return otherAttVersBytesCount; }
	public: void setOtherAttVersBytesCount(int64_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// CounterInfo
// typeId=1809378891

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// This class provides counters for use by the access manager.
/// </summary>
/// <remarks>
/// <p>Copyright: Copyright (c) 2004</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </remarks>
class CounterInfo : public ValueClass {
	/// <summary>
	/// Name of the counter
	/// </summary>
	protected: ::std::wstring name;
	/// <summary>
	/// The current value of the counter
	/// </summary>
	protected: int32_t value;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: CounterInfo();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: CounterInfo(const ::std::wstring& name, int32_t value);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: ::std::wstring getName() { return name; }
	public: void setName(::std::wstring v);
	public: int32_t getValue() { return value; }
	public: void setValue(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// CounterInfoC
// typeId=1843901056

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Constants class for the CounterInfo class.
/// </summary>
/// <remarks>
/// <p>Copyright: Copyright (c) 2004</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </remarks>
class CounterInfoC : public BSerializable {
	/// <summary>
	/// length field for Name.
	/// </summary>
	public: const static int32_t lnName = 255;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: CounterInfoC();
	
	public: virtual BTYPEID BSerializable_getTypeId();
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// CryptInfo
// typeId=1826259804

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// This class defines an encryption set.
/// </summary>
class CryptInfo : public ValueClass {
	/// <summary>
	/// Numerical ID of the encryption information.
	/// </summary>
	/// <remarks>
	/// The first ID is 1.
	/// </remarks>
	protected: int32_t id;
	/// <summary>
	/// Name.
	/// </summary>
	/// <remarks>
	/// Length of the field in database: 16byte.
	/// </remarks>
	protected: ::std::wstring name;
	/// <summary>
	/// External password used for encrypting documents.
	/// </summary>
	/// <remarks>
	/// It is empty if this object
	/// was returned by <code>checkoutCryptInfos</code>.
	/// </remarks>
	protected: ::std::wstring pwd;
	/// <summary>
	/// Key material.
	/// </summary>
	/// <remarks>
	/// Contains the external and internal password in serialized and
	/// encrypted format. Only for internal use.
	/// This member is ignored in <code>checkinCryptInfos</code>.
	/// </remarks>
	protected: ::std::wstring keyInfo;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: CryptInfo();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: CryptInfo(int32_t id, const ::std::wstring& name, const ::std::wstring& pwd, const ::std::wstring& keyInfo);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getId() { return id; }
	public: void setId(int32_t v);
	public: ::std::wstring getName() { return name; }
	public: void setName(::std::wstring v);
	public: ::std::wstring getPwd() { return pwd; }
	public: void setPwd(::std::wstring v);
	public: ::std::wstring getKeyInfo() { return keyInfo; }
	public: void setKeyInfo(::std::wstring v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// DeleteActivityOptions
// typeId=78913228

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// This class defines options for the API function deleteActivity.
/// </summary>
class DeleteActivityOptions : public ValueClass {
	/// <summary>
	/// Delete activity finally.
	/// </summary>
	/// <remarks>
	/// The database information for the activity is deleted, if this member is true.
	/// Otherwise the Activity.backAt is set to the current date.
	/// </remarks>
	protected: bool deleteFinally;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: DeleteActivityOptions();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: DeleteActivityOptions(bool deleteFinally);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: bool getDeleteFinally() { return deleteFinally; }
	public: void setDeleteFinally(bool v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// DeleteOptions
// typeId=329713511

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// This class contains options for deleting archive SORDs using the deleteSord function.
/// </summary>
/// <remarks>
/// <p>Copyright: Copyright (c) 2004</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </remarks>
class DeleteOptions : public ValueClass {
	/// <summary>
	/// deleteFinally=true causes the objects to be removed physically.
	/// </summary>
	/// <remarks>
	/// When used together with <code>cleanupStart</code>, this option is always true.
	/// Exception: see {@link #deleteExpiredOnly}
	/// </remarks>
	protected: bool deleteFinally;
	/// <summary>
	/// maxIDate ist the ISO representation of the local date used to mark the upper limit for deleting.
	/// </summary>
	protected: ::std::wstring maxIDate;
	/// <summary>
	/// Delete only expired objects.
	/// </summary>
	/// <remarks>
	/// Only supported in function <code>cleanupStart</code>.
	/// This option can be combined with <code>deleteFinally</code>.
	/// <table border="2" summary="">
	/// <tr><td><code>deleteFinally</code></td><td>Action</td></tr>
	/// <tr><td><code>false</code></td>
	/// <td>
	/// All expired objects will be marked as deleted (but not finally deleted).
	/// The objects ACL is checked before it is deleted.
	/// LockC.FORCE is applied when deleting an object.
	/// </td>
	/// </tr>
	/// <tr><td><code>true</code></td><td>Objects that are expired and marked are deleted finally.</td></tr>
	/// </table>
	/// </remarks>
	protected: bool deleteExpiredOnly;
	/// <summary>
	/// Delete objects modified last time before this date.
	/// </summary>
	/// <remarks>
	/// Only supported in function <code>cleanupStart</code>.
	/// If deleteFinally is true and this member is set, ony
	/// those objects are deleted finally, which were deleted
	/// logically before the given time.
	/// It must be an ISO value in the local time zone.
	/// </remarks>
	protected: ::std::wstring maxTStamp;
	/// <summary>
	/// Delete the document versions of the objects but keep
	/// keywording information.
	/// </summary>
	/// <remarks>
	/// In order to delete only the
	/// document versions, call deleteSord on an maybe undeleted
	/// object and set DeleteOptions.deleteFinally=true and
	/// DeleteOptions.deleteDocumentVersionsOnly=true.
	/// </remarks>
	protected: bool deleteDocumentVersionsOnly;
	/// <summary>
	/// Delete physically certain document versions of the objects.
	/// </summary>
	/// <remarks>
	/// In order to delete physically certain document versions, first mark
	/// document versions as deleted (using DocVersion.setDeleted, followed
	/// by checkinDocEnd). Then call deleteSord after having set
	/// DeleteOptions.deleteFinally=true and
	/// DeleteOptions.deleteCertainDocumentVersionsOnly=true.
	/// (In order to delete all document versions, use field
	/// deleteDocumentVersionsOnly)
	/// </remarks>
	protected: bool deleteCertainDocumentVersionsOnly;
	/// <summary>
	/// Delete all references to the objects in the database.
	/// </summary>
	/// <remarks>
	/// This includes reporting, replication control information,
	/// fulltext, etc.
	/// This option is ignroed, if deleteFinally is false.
	/// </remarks>
	protected: bool deleteResidueFree;
	/// <summary>
	/// Delete a folder only if it is empty.
	/// </summary>
	/// <remarks>
	/// Set this member to true, if deleteSord should delete only empty folders.
	/// If the parameters to deleteSord specify the original location of a
	/// non-empty folder, the exception IXExceptionC.ACCESS_DENIED is thrown.
	/// This option is ignored, if deleteSord is invokded with a reference.
	/// </remarks>
	protected: bool folderMustBeEmpty;
	/// <summary>
	/// Delete only expired folders and documents.
	/// </summary>
	/// <remarks>
	/// Only expired empty folders can be deleted.
	/// Only supported in function <code>cleanupStart</code>.
	/// This option can be combined with <code>deleteFinally</code>.
	/// <table border="2" summary="">
	/// <tr><td><code>deleteFinally</code></td><td>Action</td></tr>
	/// <tr><td><code>false</code></td>
	/// <td>
	/// All expired objects will be marked as deleted (but not finally deleted).
	/// The objects ACL is checked before it is deleted.
	/// LockC.FORCE is applied when deleting an object.
	/// </td>
	/// </tr>
	/// <tr><td><code>true</code></td><td>Objects that are expired and marked are deleted finally.</td></tr>
	/// </table>
	/// </remarks>
	protected: bool deleteExpiredFolders;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: DeleteOptions();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: DeleteOptions(bool deleteFinally, const ::std::wstring& maxIDate, bool deleteExpiredOnly, const ::std::wstring& maxTStamp, bool deleteDocumentVersionsOnly, bool deleteCertainDocumentVersionsOnly, bool deleteResidueFree, bool folderMustBeEmpty, bool deleteExpiredFolders);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: bool getDeleteFinally() { return deleteFinally; }
	public: void setDeleteFinally(bool v);
	public: ::std::wstring getMaxIDate() { return maxIDate; }
	public: void setMaxIDate(::std::wstring v);
	public: bool getDeleteExpiredOnly() { return deleteExpiredOnly; }
	public: void setDeleteExpiredOnly(bool v);
	public: ::std::wstring getMaxTStamp() { return maxTStamp; }
	public: void setMaxTStamp(::std::wstring v);
	public: bool getDeleteDocumentVersionsOnly() { return deleteDocumentVersionsOnly; }
	public: void setDeleteDocumentVersionsOnly(bool v);
	public: bool getDeleteCertainDocumentVersionsOnly() { return deleteCertainDocumentVersionsOnly; }
	public: void setDeleteCertainDocumentVersionsOnly(bool v);
	public: bool getDeleteResidueFree() { return deleteResidueFree; }
	public: void setDeleteResidueFree(bool v);
	public: bool getFolderMustBeEmpty() { return folderMustBeEmpty; }
	public: void setFolderMustBeEmpty(bool v);
	public: bool getDeleteExpiredFolders() { return deleteExpiredFolders; }
	public: void setDeleteExpiredFolders(bool v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// DeleteOrgUnitInfo
// typeId=537993523

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Objects of this class specify the selection criteria for
/// <code>deleteOrgUnits</code>.
/// </summary>
/// <remarks>
/// OU IDs or names can be set or both.
/// 
/// <p>Copyright: Copyright (c) 2013</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </remarks>
class DeleteOrgUnitInfo : public BSerializable {
	/// <summary>
	/// OU identifiers
	/// </summary>
	protected: PArrayInt ids;
	/// <summary>
	/// OU names
	/// </summary>
	protected: PArrayString names;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: DeleteOrgUnitInfo();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: DeleteOrgUnitInfo(const PArrayInt& ids, const PArrayString& names);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: PArrayInt getIds() { return ids; }
	public: void setIds(PArrayInt v);
	public: PArrayString getNames() { return names; }
	public: void setNames(PArrayString v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// DocHistory
// typeId=189452795

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Document version data, e. g. document version ID and GUID, version comment,
/// MD5 hash of document file.
/// </summary>
/// <remarks>
/// Internal use only.
/// </remarks>
class DocHistory : public ValueClass {
	/// <summary>
	/// Document version belongs to this object.
	/// </summary>
	/// <remarks>
	/// DB column: objectid
	/// </remarks>
	protected: int32_t objId;
	/// <summary>
	/// Document version ID.
	/// </summary>
	/// <remarks>
	/// DB column: documentid
	/// </remarks>
	protected: int32_t docId;
	/// <summary>
	/// The user who inserts the version into the archive.
	/// </summary>
	/// <remarks>
	/// DB column: userid
	/// </remarks>
	protected: int32_t user;
	/// <summary>
	/// The version is created at this date.
	/// </summary>
	/// <remarks>
	/// The value is an ELO date format.
	/// DB column: createdate
	/// </remarks>
	protected: int32_t createDate;
	/// <summary>
	/// The user can enter a comment that describes the version.
	/// </summary>
	/// <remarks>
	/// DB column: histcomment
	/// </remarks>
	protected: ::std::wstring comment;
	/// <summary>
	/// The version number (like 1.0) of the document version.
	/// </summary>
	/// <remarks>
	/// DB column: histversion
	/// </remarks>
	protected: ::std::wstring version;
	/// <summary>
	/// The MD5 hash of the document file.
	/// </summary>
	/// <remarks>
	/// DB column: docmd5
	/// </remarks>
	protected: ::std::wstring docMD5;
	/// <summary>
	/// GUID of the document version.
	/// </summary>
	/// <remarks>
	/// DB column: docguid
	/// </remarks>
	protected: ::std::wstring guid;
	/// <summary>
	/// The last update time of the version in ISO format (with dots).
	/// </summary>
	/// <remarks>
	/// DB column: doctstamp
	/// </remarks>
	protected: ::std::wstring tStamp;
	/// <summary>
	/// Document signature ID.
	/// </summary>
	/// <remarks>
	/// DB column: docsignature
	/// </remarks>
	protected: int32_t sigId;
	/// <summary>
	/// Deleted versions have Status=1.
	/// </summary>
	/// <remarks>
	/// DB column: docstatus
	/// </remarks>
	protected: int32_t status;
	/// <summary>
	/// MFG_BURNIN
	/// DB column: docflags
	/// </summary>
	protected: int32_t flags;
	/// <summary>
	/// The version is deleted at this date.
	/// </summary>
	/// <remarks>
	/// The value is an ELO date format. The
	/// value is zero, if isDeleted() returns false.
	/// </remarks>
	protected: int32_t deleteDate;
	/// <summary>
	/// Number of valid signatures.
	/// </summary>
	protected: int32_t nbOfValidSignatures;
	/// <summary>
	/// The type of this DocHistory makes the difference between attachments and
	/// document versions.
	/// </summary>
	protected: int32_t type;
	/// <summary>
	/// Timestamp of this object's last export by the replication.
	/// </summary>
	protected: ::std::wstring TStampSync;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: DocHistory();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: DocHistory(int32_t objId, int32_t docId, int32_t user, int32_t createDate, const ::std::wstring& comment, const ::std::wstring& version, const ::std::wstring& docMD5, const ::std::wstring& guid, const ::std::wstring& tStamp, int32_t sigId, int32_t status, int32_t flags, int32_t deleteDate, int32_t nbOfValidSignatures, int32_t type, const ::std::wstring& TStampSync);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getObjId() { return objId; }
	public: void setObjId(int32_t v);
	public: int32_t getDocId() { return docId; }
	public: void setDocId(int32_t v);
	public: int32_t getUser() { return user; }
	public: void setUser(int32_t v);
	public: int32_t getCreateDate() { return createDate; }
	public: void setCreateDate(int32_t v);
	public: ::std::wstring getComment() { return comment; }
	public: void setComment(::std::wstring v);
	public: ::std::wstring getVersion() { return version; }
	public: void setVersion(::std::wstring v);
	public: ::std::wstring getDocMD5() { return docMD5; }
	public: void setDocMD5(::std::wstring v);
	public: ::std::wstring getGuid() { return guid; }
	public: void setGuid(::std::wstring v);
	public: ::std::wstring getTStamp() { return tStamp; }
	public: void setTStamp(::std::wstring v);
	public: int32_t getSigId() { return sigId; }
	public: void setSigId(int32_t v);
	public: int32_t getStatus() { return status; }
	public: void setStatus(int32_t v);
	public: int32_t getFlags() { return flags; }
	public: void setFlags(int32_t v);
	public: int32_t getDeleteDate() { return deleteDate; }
	public: void setDeleteDate(int32_t v);
	public: int32_t getNbOfValidSignatures() { return nbOfValidSignatures; }
	public: void setNbOfValidSignatures(int32_t v);
	public: int32_t getType() { return type; }
	public: void setType(int32_t v);
	public: ::std::wstring getTStampSync() { return TStampSync; }
	public: void setTStampSync(::std::wstring v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// DocHistoryC
// typeId=1456349355

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// <p>Bit constants for members of DocHistory</p>
/// <p>Copyright: Copyright (c) 2003</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </summary>
class DocHistoryC : public BSerializable {
	/// <summary>
	/// DB column: objectid
	/// </summary>
	public: const static int64_t mbObjId = 1LL;
	/// <summary>
	/// DB column: documentid
	/// </summary>
	public: const static int64_t mbDocId = 2LL;
	/// <summary>
	/// DB column: userid
	/// </summary>
	public: const static int64_t mbUser = 4LL;
	/// <summary>
	/// DB column: createdate
	/// </summary>
	public: const static int64_t mbCreateDate = 8LL;
	/// <summary>
	/// DB column: histcomment
	/// </summary>
	public: const static int64_t mbComment = 16LL;
	/// <summary>
	/// DB column: histcomment
	/// </summary>
	protected: int32_t lnComment;
	/// <summary>
	/// DB column: histversion
	/// </summary>
	public: const static int64_t mbVersion = 32LL;
	/// <summary>
	/// DB column: histversion
	/// </summary>
	protected: int32_t lnVersion;
	/// <summary>
	/// DB column: docmd5
	/// </summary>
	public: const static int64_t mbDocMD5 = 64LL;
	/// <summary>
	/// DB column: docmd5
	/// </summary>
	protected: int32_t lnDocMD5;
	/// <summary>
	/// DB column: docguid
	/// </summary>
	public: const static int64_t mbGuid = 128LL;
	/// <summary>
	/// DB column: docguid
	/// </summary>
	protected: int32_t lnGuid;
	/// <summary>
	/// DB column: doctstamp
	/// </summary>
	public: const static int64_t mbTStamp = 256LL;
	/// <summary>
	/// DB column: doctstamp
	/// </summary>
	protected: int32_t lnTStamp;
	/// <summary>
	/// DB column: docsignature
	/// </summary>
	public: const static int64_t mbSigId = 512LL;
	/// <summary>
	/// DB column: docstatus
	/// </summary>
	public: const static int64_t mbStatus = 1024LL;
	/// <summary>
	/// DB column: docflags
	/// </summary>
	public: const static int64_t mbFlags = 2048LL;
	/// <summary>
	/// Member bit: The version is deleted at this date.
	/// </summary>
	/// <remarks>
	/// The value is an ELO date format. The
	/// DB column: deletedate
	/// </remarks>
	public: const static int64_t mbDeleteDate = 4096LL;
	/// <summary>
	/// Member bit: Number of valid signatures.
	/// </summary>
	/// <remarks>
	/// DB column: nbofvalidsignatures
	/// </remarks>
	public: const static int64_t mbNbOfValidSignatures = 8192LL;
	/// <summary>
	/// Member bit: The type of this DocHistory makes the difference between attachments and
	/// DB column: doctype
	/// </summary>
	public: const static int64_t mbType = 16384LL;
	/// <summary>
	/// Member bit: Timestamp of this object's last export by the replication.
	/// </summary>
	/// <remarks>
	/// DB column: doctstampsync
	/// </remarks>
	public: const static int64_t mbTStampSync = 32768LL;
	/// <summary>
	/// Column length: Timestamp of this object's last export by the replication.
	/// </summary>
	/// <remarks>
	/// DB column: doctstampsync
	/// </remarks>
	protected: int32_t lnTStampSync;
	/// <summary>
	/// All valid member bits.
	/// </summary>
	public: const static int64_t mbAllMembers = 65535LL;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: DocHistoryC();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: DocHistoryC(int64_t mbObjId, int64_t mbDocId, int64_t mbUser, int64_t mbCreateDate, int64_t mbComment, int32_t lnComment, int64_t mbVersion, int32_t lnVersion, int64_t mbDocMD5, int32_t lnDocMD5, int64_t mbGuid, int32_t lnGuid, int64_t mbTStamp, int32_t lnTStamp, int64_t mbSigId, int64_t mbStatus, int64_t mbFlags, int64_t mbDeleteDate, int64_t mbNbOfValidSignatures, int64_t mbType, int64_t mbTStampSync, int32_t lnTStampSync, int64_t mbAllMembers);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getLnComment() { return lnComment; }
	public: void setLnComment(int32_t v);
	public: int32_t getLnVersion() { return lnVersion; }
	public: void setLnVersion(int32_t v);
	public: int32_t getLnDocMD5() { return lnDocMD5; }
	public: void setLnDocMD5(int32_t v);
	public: int32_t getLnGuid() { return lnGuid; }
	public: void setLnGuid(int32_t v);
	public: int32_t getLnTStamp() { return lnTStamp; }
	public: void setLnTStamp(int32_t v);
	public: int32_t getLnTStampSync() { return lnTStampSync; }
	public: void setLnTStampSync(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// DocInfoDM
// typeId=673204378

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// <p>Document information table of DM.
/// </summary>
/// <remarks>
/// For performance reason directly read by IX</p>
/// <p>Copyright: Copyright (c) 2003</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </remarks>
class DocInfoDM : public ValueClass {
	/// <summary>
	/// Document version ID.
	/// </summary>
	/// <remarks>
	/// DB column: docid
	/// </remarks>
	protected: int32_t id;
	/// <summary>
	/// Document GUID.
	/// </summary>
	/// <remarks>
	/// DB column: docguid
	/// </remarks>
	protected: ::std::wstring guid;
	/// <summary>
	/// File size.
	/// </summary>
	/// <remarks>
	/// DB column: docsize
	/// </remarks>
	protected: int32_t size;
	/// <summary>
	/// MD5 hash.
	/// </summary>
	/// <remarks>
	/// DB column: md5
	/// </remarks>
	protected: ::std::wstring md5;
	/// <summary>
	/// Storage path ID
	/// DB column: pathid
	/// </summary>
	protected: int32_t pathId;
	/// <summary>
	/// reserved
	/// DB column: pathid2
	/// </summary>
	protected: int32_t pathId2;
	/// <summary>
	/// Create date ISO.
	/// </summary>
	/// <remarks>
	/// DB column: createdate
	/// </remarks>
	protected: ::std::wstring createDateIso;
	/// <summary>
	/// Last access date ISO.
	/// </summary>
	/// <remarks>
	/// DB column: lastaccess
	/// </remarks>
	protected: ::std::wstring lastAccessIso;
	/// <summary>
	/// Last update date ISO.
	/// </summary>
	/// <remarks>
	/// DB column: lastupdate
	/// </remarks>
	protected: ::std::wstring lastUpdateIso;
	/// <summary>
	/// User ID.
	/// </summary>
	/// <remarks>
	/// DB column: owner
	/// </remarks>
	protected: int32_t owner;
	/// <summary>
	/// File extension
	/// DB column: ext
	/// </summary>
	protected: ::std::wstring ext;
	/// <summary>
	/// reserved
	/// DB column: fclip
	/// </summary>
	protected: ::std::wstring fclip;
	/// <summary>
	/// Original file extension for encrypted documents
	/// </summary>
	protected: ::std::wstring extOrig;
	/// <summary>
	/// Original file size for encrypted documents
	/// </summary>
	protected: int32_t sizeOrig;
	/// <summary>
	/// Encryption set.
	/// </summary>
	protected: int32_t encrSet;
	/// <summary>
	/// Size of preview file.
	/// </summary>
	/// <remarks>
	/// Is 0, if there is no preview file assigned.
	/// Is -1, if preview creation has failed.
	/// </remarks>
	protected: int32_t previewSize;
	/// <summary>
	/// Preview file extension.
	/// </summary>
	protected: ::std::wstring previewExt;
	/// <summary>
	/// Fulltext content timestamp
	/// </summary>
	protected: ::std::wstring fulltextContentTStamp;
	/// <summary>
	/// Fulltext content file size.
	/// </summary>
	/// <remarks>
	/// Since the fulltext content file is usually stored in UTF-8 encoding,
	/// the file size might be different from the number of characters.
	/// </remarks>
	protected: int32_t fulltextContentSize;
	/// <summary>
	/// Document file size.
	/// </summary>
	protected: int64_t sizeL;
	/// <summary>
	/// Original file extension for encrypted documents
	/// </summary>
	protected: int64_t sizeOrigL;
	/// <summary>
	/// Size of preview file.
	/// </summary>
	/// <remarks>
	/// Is 0, if there is no preview file assigned.
	/// Is -1, if preview creation has failed.
	/// </remarks>
	protected: int64_t previewSizeL;
	/// <summary>
	/// Relative file path
	/// </summary>
	protected: ::std::wstring relFilePath;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: DocInfoDM();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: DocInfoDM(int32_t id, const ::std::wstring& guid, int32_t size, const ::std::wstring& md5, int32_t pathId, int32_t pathId2, const ::std::wstring& createDateIso, const ::std::wstring& lastAccessIso, const ::std::wstring& lastUpdateIso, int32_t owner, const ::std::wstring& ext, const ::std::wstring& fclip, const ::std::wstring& extOrig, int32_t sizeOrig, int32_t encrSet, int32_t previewSize, const ::std::wstring& previewExt, const ::std::wstring& fulltextContentTStamp, int32_t fulltextContentSize, int64_t sizeL, int64_t sizeOrigL, int64_t previewSizeL, const ::std::wstring& relFilePath);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getId() { return id; }
	public: void setId(int32_t v);
	public: ::std::wstring getGuid() { return guid; }
	public: void setGuid(::std::wstring v);
	public: int32_t getSize() { return size; }
	public: void setSize(int32_t v);
	public: ::std::wstring getMd5() { return md5; }
	public: void setMd5(::std::wstring v);
	public: int32_t getPathId() { return pathId; }
	public: void setPathId(int32_t v);
	public: int32_t getPathId2() { return pathId2; }
	public: void setPathId2(int32_t v);
	public: ::std::wstring getCreateDateIso() { return createDateIso; }
	public: void setCreateDateIso(::std::wstring v);
	public: ::std::wstring getLastAccessIso() { return lastAccessIso; }
	public: void setLastAccessIso(::std::wstring v);
	public: ::std::wstring getLastUpdateIso() { return lastUpdateIso; }
	public: void setLastUpdateIso(::std::wstring v);
	public: int32_t getOwner() { return owner; }
	public: void setOwner(int32_t v);
	public: ::std::wstring getExt() { return ext; }
	public: void setExt(::std::wstring v);
	public: ::std::wstring getFclip() { return fclip; }
	public: void setFclip(::std::wstring v);
	public: ::std::wstring getExtOrig() { return extOrig; }
	public: void setExtOrig(::std::wstring v);
	public: int32_t getSizeOrig() { return sizeOrig; }
	public: void setSizeOrig(int32_t v);
	public: int32_t getEncrSet() { return encrSet; }
	public: void setEncrSet(int32_t v);
	public: int32_t getPreviewSize() { return previewSize; }
	public: void setPreviewSize(int32_t v);
	public: ::std::wstring getPreviewExt() { return previewExt; }
	public: void setPreviewExt(::std::wstring v);
	public: ::std::wstring getFulltextContentTStamp() { return fulltextContentTStamp; }
	public: void setFulltextContentTStamp(::std::wstring v);
	public: int32_t getFulltextContentSize() { return fulltextContentSize; }
	public: void setFulltextContentSize(int32_t v);
	public: int64_t getSizeL() { return sizeL; }
	public: void setSizeL(int64_t v);
	public: int64_t getSizeOrigL() { return sizeOrigL; }
	public: void setSizeOrigL(int64_t v);
	public: int64_t getPreviewSizeL() { return previewSizeL; }
	public: void setPreviewSizeL(int64_t v);
	public: ::std::wstring getRelFilePath() { return relFilePath; }
	public: void setRelFilePath(::std::wstring v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// DocInfoDMC
// typeId=1042422760

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// <p>Bit constants for members of DocInfoDM</p>
/// <p>Copyright: Copyright (c) 2003</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </summary>
class DocInfoDMC : public BSerializable {
	/// <summary>
	/// DB column: docid
	/// </summary>
	public: const static int64_t mbId = 1LL;
	/// <summary>
	/// DB column: docguid
	/// </summary>
	public: const static int64_t mbGuid = 2LL;
	/// <summary>
	/// DB column: docguid
	/// </summary>
	protected: int32_t lnGuid;
	/// <summary>
	/// DB column: md5
	/// </summary>
	public: const static int64_t mbMd5 = 4LL;
	/// <summary>
	/// DB column: md5
	/// </summary>
	protected: int32_t lnMd5;
	/// <summary>
	/// DB column: pathid
	/// </summary>
	public: const static int64_t mbPathId = 8LL;
	/// <summary>
	/// DB column: pathid2
	/// </summary>
	public: const static int64_t mbPathId2 = 16LL;
	/// <summary>
	/// DB column: createdate
	/// </summary>
	public: const static int64_t mbCreateDateIso = 32LL;
	/// <summary>
	/// DB column: createdate
	/// </summary>
	protected: int32_t lnCreateDateIso;
	/// <summary>
	/// DB column: lastaccess
	/// </summary>
	public: const static int64_t mbLastAccessIso = 64LL;
	/// <summary>
	/// DB column: lastaccess
	/// </summary>
	protected: int32_t lnLastAccessIso;
	/// <summary>
	/// DB column: lastupdate
	/// </summary>
	public: const static int64_t mbLastUpdateIso = 128LL;
	/// <summary>
	/// DB column: lastupdate
	/// </summary>
	protected: int32_t lnLastUpdateIso;
	/// <summary>
	/// DB column: owner
	/// </summary>
	public: const static int64_t mbOwner = 256LL;
	/// <summary>
	/// DB column: ext
	/// </summary>
	public: const static int64_t mbExt = 512LL;
	/// <summary>
	/// DB column: ext
	/// </summary>
	protected: int32_t lnExt;
	/// <summary>
	/// DB column: fclip
	/// </summary>
	public: const static int64_t mbFclip = 1024LL;
	/// <summary>
	/// DB column: fclip
	/// </summary>
	protected: int32_t lnFclip;
	/// <summary>
	/// DB column: null
	/// </summary>
	public: const static int64_t mbSize = 2048LL;
	/// <summary>
	/// DB column: null
	/// </summary>
	public: const static int64_t mbPreviewSize = 4096LL;
	/// <summary>
	/// DB column: null
	/// </summary>
	public: const static int64_t mbSizeOrig = 8192LL;
	/// <summary>
	/// Member bit: Original file extension for encrypted documents
	/// DB column: extorig
	/// </summary>
	public: const static int64_t mbExtOrig = 16384LL;
	/// <summary>
	/// Column length: Original file extension for encrypted documents
	/// DB column: extorig
	/// </summary>
	protected: int32_t lnExtOrig;
	/// <summary>
	/// Member bit: Encryption set.
	/// </summary>
	/// <remarks>
	/// DB column: cryptno
	/// </remarks>
	public: const static int64_t mbEncrSet = 32768LL;
	/// <summary>
	/// Member bit: Preview file extension.
	/// </summary>
	/// <remarks>
	/// DB column: previewext
	/// </remarks>
	public: const static int64_t mbPreviewExt = 65536LL;
	/// <summary>
	/// Column length: Preview file extension.
	/// </summary>
	/// <remarks>
	/// DB column: previewext
	/// </remarks>
	protected: int32_t lnPreviewExt;
	/// <summary>
	/// Member bit: Fulltext content timestamp
	/// DB column: fttstamp
	/// </summary>
	public: const static int64_t mbFulltextContentTStamp = 131072LL;
	/// <summary>
	/// Column length: Fulltext content timestamp
	/// DB column: fttstamp
	/// </summary>
	protected: int32_t lnFulltextContentTStamp;
	/// <summary>
	/// Member bit: Fulltext content file size.
	/// </summary>
	/// <remarks>
	/// DB column: ftsize
	/// </remarks>
	public: const static int64_t mbFulltextContentSize = 262144LL;
	/// <summary>
	/// Member bit: Document file size.
	/// </summary>
	/// <remarks>
	/// DB column: docsize
	/// </remarks>
	public: const static int64_t mbSizeL = 524288LL;
	/// <summary>
	/// Column length: Document file size.
	/// </summary>
	/// <remarks>
	/// DB column: docsize
	/// </remarks>
	protected: int32_t lnSizeL;
	/// <summary>
	/// Member bit: Original file extension for encrypted documents
	/// DB column: docsizeorig
	/// </summary>
	public: const static int64_t mbSizeOrigL = 1048576LL;
	/// <summary>
	/// Column length: Original file extension for encrypted documents
	/// DB column: docsizeorig
	/// </summary>
	protected: int32_t lnSizeOrigL;
	/// <summary>
	/// Member bit: Size of preview file.
	/// </summary>
	/// <remarks>
	/// DB column: previewsize
	/// </remarks>
	public: const static int64_t mbPreviewSizeL = 2097152LL;
	/// <summary>
	/// Column length: Size of preview file.
	/// </summary>
	/// <remarks>
	/// DB column: previewsize
	/// </remarks>
	protected: int32_t lnPreviewSizeL;
	/// <summary>
	/// Member bit: Relative file path
	/// DB column: relfilepath
	/// </summary>
	public: const static int64_t mbRelFilePath = 4194304LL;
	/// <summary>
	/// Column length: Relative file path
	/// DB column: relfilepath
	/// </summary>
	protected: int32_t lnRelFilePath;
	/// <summary>
	/// All valid member bits.
	/// </summary>
	public: const static int64_t mbAllMembers = 8388607LL;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: DocInfoDMC();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: DocInfoDMC(int64_t mbId, int64_t mbGuid, int32_t lnGuid, int64_t mbMd5, int32_t lnMd5, int64_t mbPathId, int64_t mbPathId2, int64_t mbCreateDateIso, int32_t lnCreateDateIso, int64_t mbLastAccessIso, int32_t lnLastAccessIso, int64_t mbLastUpdateIso, int32_t lnLastUpdateIso, int64_t mbOwner, int64_t mbExt, int32_t lnExt, int64_t mbFclip, int32_t lnFclip, int64_t mbSize, int64_t mbPreviewSize, int64_t mbSizeOrig, int64_t mbExtOrig, int32_t lnExtOrig, int64_t mbEncrSet, int64_t mbPreviewExt, int32_t lnPreviewExt, int64_t mbFulltextContentTStamp, int32_t lnFulltextContentTStamp, int64_t mbFulltextContentSize, int64_t mbSizeL, int32_t lnSizeL, int64_t mbSizeOrigL, int32_t lnSizeOrigL, int64_t mbPreviewSizeL, int32_t lnPreviewSizeL, int64_t mbRelFilePath, int32_t lnRelFilePath, int64_t mbAllMembers);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getLnGuid() { return lnGuid; }
	public: void setLnGuid(int32_t v);
	public: int32_t getLnMd5() { return lnMd5; }
	public: void setLnMd5(int32_t v);
	public: int32_t getLnCreateDateIso() { return lnCreateDateIso; }
	public: void setLnCreateDateIso(int32_t v);
	public: int32_t getLnLastAccessIso() { return lnLastAccessIso; }
	public: void setLnLastAccessIso(int32_t v);
	public: int32_t getLnLastUpdateIso() { return lnLastUpdateIso; }
	public: void setLnLastUpdateIso(int32_t v);
	public: int32_t getLnExt() { return lnExt; }
	public: void setLnExt(int32_t v);
	public: int32_t getLnFclip() { return lnFclip; }
	public: void setLnFclip(int32_t v);
	public: int32_t getLnExtOrig() { return lnExtOrig; }
	public: void setLnExtOrig(int32_t v);
	public: int32_t getLnPreviewExt() { return lnPreviewExt; }
	public: void setLnPreviewExt(int32_t v);
	public: int32_t getLnFulltextContentTStamp() { return lnFulltextContentTStamp; }
	public: void setLnFulltextContentTStamp(int32_t v);
	public: int32_t getLnSizeL() { return lnSizeL; }
	public: void setLnSizeL(int32_t v);
	public: int32_t getLnSizeOrigL() { return lnSizeOrigL; }
	public: void setLnSizeOrigL(int32_t v);
	public: int32_t getLnPreviewSizeL() { return lnPreviewSizeL; }
	public: void setLnPreviewSizeL(int32_t v);
	public: int32_t getLnRelFilePath() { return lnRelFilePath; }
	public: void setLnRelFilePath(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// DocMask
// typeId=2054753789

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// <p>Contains the data for a storage mask.
/// </summary>
/// <remarks>
/// </p>
/// <p>Copyright: Copyright (c) 2004</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </remarks>
class DocMask : public ValueClass {
	/// <summary>
	/// New objects are created with these ACL permission settings.
	/// </summary>
	protected: ::std::wstring DAcl;
	/// <summary>
	/// The marker color ID for new objects created with this mask.
	/// </summary>
	protected: int32_t DKind;
	/// <summary>
	/// Document storage path name where the documents of this mask
	/// should be stored.
	/// </summary>
	protected: int32_t DPath;
	/// <summary>
	/// Last update time of the storage mask data.
	/// </summary>
	protected: ::std::wstring TStamp;
	/// <summary>
	/// Barcode string.
	/// </summary>
	protected: ::std::wstring barcode;
	/// <summary>
	/// The ID of a workflow that is started if a new object with this
	/// mask is created.
	/// </summary>
	/// <remarks>
	/// If the SessionOption START_DOCMASK_WORKFLOWS is set, the IndexServer
	/// starts this workflow, if an associated document is created. Otherwise the
	/// client application is responsible for starting the workflow.
	/// </remarks>
	protected: int32_t flowId;
	/// <summary>
	/// Storage mask ID.
	/// </summary>
	protected: int32_t id;
	/// <summary>
	/// This control string provides a way of storing new storage mask objects
	/// automatically in a particular archive path.
	/// </summary>
	protected: ::std::wstring index;
	/// <summary>
	/// New objects are valid for this length of time.
	/// </summary>
	protected: ::std::wstring lifetime;
	/// <summary>
	/// User ID of the user that has locked the storage mask.
	/// </summary>
	/// <remarks>
	/// If -1, no lock is held.
	/// </remarks>
	protected: int32_t lockId;
	/// <summary>
	/// Name of the user that has locked th storage mask.
	/// </summary>
	/// <remarks>
	/// Read-only, ignored in checkinDocMask.
	/// </remarks>
	protected: ::std::wstring lockName;
	/// <summary>
	/// Storage mask name.
	/// </summary>
	/// <remarks>
	/// It can be translated into reps. from the users language:
	/// set <code>SessionOptionsC.TRANSLATE_TERM</code>.
	/// </remarks>
	protected: ::std::wstring name;
	/// <summary>
	/// Tab captions.
	/// </summary>
	/// <remarks>
	/// List of tab captions separated by pipe char |.
	/// </remarks>
	protected: ::std::wstring text;
	/// <summary>
	/// Access control for the mask line
	/// </summary>
	protected: ::std::wstring acl;
	/// <summary>
	/// Access control to mask line.
	/// </summary>
	/// <remarks>
	/// Currently this can only be null or one item representing a key.
	/// </remarks>
	protected: PArrayAclItem aclItems;
	/// <summary>
	/// Detailed properties for the DocMask object.
	/// </summary>
	protected: PDocMaskDetails details;
	/// <summary>
	/// These access control items are the initial values for new documents inserted with this mask.
	/// </summary>
	protected: PArrayAclItem docAclItems;
	/// <summary>
	/// Array of index value definitions.
	/// </summary>
	protected: PArrayDocMaskLine lines;
	/// <summary>
	/// GUID
	/// </summary>
	protected: ::std::wstring guid;
	/// <summary>
	/// Deleted status.
	/// </summary>
	protected: bool deleted;
	/// <summary>
	/// The ID of a workflow that is to be started if a new version of an associated
	/// document is checked in.
	/// </summary>
	/// <remarks>
	/// If the SessionOption START_DOCMASK_WORKFLOWS is set, the IndexServer
	/// starts this workflow, if an associated document is checked in. Otherwise the
	/// client application is responsible for starting the workflow.
	/// </remarks>
	protected: int32_t flowId2;
	/// <summary>
	/// Timestamp of this object's last export by the replication.
	/// </summary>
	protected: ::std::wstring TStampSync;
	/// <summary>
	/// Translation-keyword for {@link DocMask#text}.
	/// </summary>
	protected: ::std::wstring textTranslationKey;
	/// <summary>
	/// Translation-keyword for {@link DocMask#name}.
	/// </summary>
	protected: ::std::wstring nameTranslationKey;
	/// <summary>
	/// This member specifies how the index values are stored in database.
	/// </summary>
	protected: int32_t dataOrganisation;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: DocMask();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: DocMask(const ::std::wstring& DAcl, int32_t DKind, int32_t DPath, const ::std::wstring& TStamp, const ::std::wstring& barcode, int32_t flowId, int32_t id, const ::std::wstring& index, const ::std::wstring& lifetime, int32_t lockId, const ::std::wstring& lockName, const ::std::wstring& name, const ::std::wstring& text, const ::std::wstring& acl, const PArrayAclItem& aclItems, const PDocMaskDetails& details, const PArrayAclItem& docAclItems, const PArrayDocMaskLine& lines, const ::std::wstring& guid, bool deleted, int32_t flowId2, const ::std::wstring& TStampSync, const ::std::wstring& textTranslationKey, const ::std::wstring& nameTranslationKey, int32_t dataOrganisation);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: ::std::wstring getDAcl() { return DAcl; }
	public: void setDAcl(::std::wstring v);
	public: int32_t getDKind() { return DKind; }
	public: void setDKind(int32_t v);
	public: int32_t getDPath() { return DPath; }
	public: void setDPath(int32_t v);
	public: ::std::wstring getTStamp() { return TStamp; }
	public: void setTStamp(::std::wstring v);
	public: ::std::wstring getBarcode() { return barcode; }
	public: void setBarcode(::std::wstring v);
	public: int32_t getFlowId() { return flowId; }
	public: void setFlowId(int32_t v);
	public: int32_t getId() { return id; }
	public: void setId(int32_t v);
	public: ::std::wstring getIndex() { return index; }
	public: void setIndex(::std::wstring v);
	public: ::std::wstring getLifetime() { return lifetime; }
	public: void setLifetime(::std::wstring v);
	public: int32_t getLockId() { return lockId; }
	public: void setLockId(int32_t v);
	public: ::std::wstring getLockName() { return lockName; }
	public: void setLockName(::std::wstring v);
	public: ::std::wstring getName() { return name; }
	public: void setName(::std::wstring v);
	public: ::std::wstring getText() { return text; }
	public: void setText(::std::wstring v);
	public: ::std::wstring getAcl() { return acl; }
	public: void setAcl(::std::wstring v);
	public: PArrayAclItem getAclItems() { return aclItems; }
	public: void setAclItems(PArrayAclItem v);
	public: PDocMaskDetails getDetails() { return details; }
	public: void setDetails(PDocMaskDetails v);
	public: PArrayAclItem getDocAclItems() { return docAclItems; }
	public: void setDocAclItems(PArrayAclItem v);
	public: PArrayDocMaskLine getLines() { return lines; }
	public: void setLines(PArrayDocMaskLine v);
	public: ::std::wstring getGuid() { return guid; }
	public: void setGuid(::std::wstring v);
	public: bool getDeleted() { return deleted; }
	public: void setDeleted(bool v);
	public: int32_t getFlowId2() { return flowId2; }
	public: void setFlowId2(int32_t v);
	public: ::std::wstring getTStampSync() { return TStampSync; }
	public: void setTStampSync(::std::wstring v);
	public: ::std::wstring getTextTranslationKey() { return textTranslationKey; }
	public: void setTextTranslationKey(::std::wstring v);
	public: ::std::wstring getNameTranslationKey() { return nameTranslationKey; }
	public: void setNameTranslationKey(::std::wstring v);
	public: int32_t getDataOrganisation() { return dataOrganisation; }
	public: void setDataOrganisation(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// DocMaskDataC
// typeId=1968969939

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// <p>Bit constants for members of DocMask</p>
/// <p>Copyright: Copyright (c) 2003</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </summary>
class DocMaskDataC : public BSerializable {
	/// <summary>
	/// DB column: maskno
	/// </summary>
	public: const static int64_t mbId = 1LL;
	/// <summary>
	/// DB column: maskname
	/// </summary>
	public: const static int64_t mbName = 2LL;
	/// <summary>
	/// DB column: maskname
	/// </summary>
	protected: int32_t lnName;
	/// <summary>
	/// DB column: maskindex
	/// </summary>
	public: const static int64_t mbIndex = 4LL;
	/// <summary>
	/// DB column: maskindex
	/// </summary>
	protected: int32_t lnIndex;
	/// <summary>
	/// DB column: maskbarcode
	/// </summary>
	public: const static int64_t mbBarcode = 8LL;
	/// <summary>
	/// DB column: maskbarcode
	/// </summary>
	protected: int32_t lnBarcode;
	/// <summary>
	/// DB column: maskkey
	/// </summary>
	public: const static int64_t mbKey = 16LL;
	/// <summary>
	/// DB column: maskdpath
	/// </summary>
	public: const static int64_t mbDPath = 32LL;
	/// <summary>
	/// DB column: maskdkind
	/// </summary>
	public: const static int64_t mbDKind = 64LL;
	/// <summary>
	/// DB column: maskdkey
	/// </summary>
	public: const static int64_t mbDKey = 128LL;
	/// <summary>
	/// DB column: masklock
	/// </summary>
	public: const static int64_t mbLockId = 256LL;
	/// <summary>
	/// DB column: maskflags
	/// </summary>
	public: const static int64_t mbFlags = 512LL;
	/// <summary>
	/// DB column: maskflowid
	/// </summary>
	public: const static int64_t mbFlowId = 1024LL;
	/// <summary>
	/// DB column: maskdacl
	/// </summary>
	public: const static int64_t mbDAcl = 2048LL;
	/// <summary>
	/// DB column: maskdacl
	/// </summary>
	protected: int32_t lnDAcl;
	/// <summary>
	/// DB column: lifetime
	/// </summary>
	public: const static int64_t mbLifetime = 4096LL;
	/// <summary>
	/// DB column: lifetime
	/// </summary>
	protected: int32_t lnLifetime;
	/// <summary>
	/// DB column: masktext
	/// </summary>
	public: const static int64_t mbText = 8192LL;
	/// <summary>
	/// DB column: masktext
	/// </summary>
	protected: int32_t lnText;
	/// <summary>
	/// DB column: masktstamp
	/// </summary>
	public: const static int64_t mbTStamp = 16384LL;
	/// <summary>
	/// DB column: masktstamp
	/// </summary>
	protected: int32_t lnTStamp;
	/// <summary>
	/// DB column: maskposinfo
	/// </summary>
	public: const static int64_t mbRawPosInfo = 32768LL;
	/// <summary>
	/// DB column: maskposinfo
	/// </summary>
	protected: int32_t lnRawPosInfo;
	/// <summary>
	/// Member bit: GUID
	/// DB column: maskguid
	/// </summary>
	public: const static int64_t mbGuid = 65536LL;
	/// <summary>
	/// Column length: GUID
	/// DB column: maskguid
	/// </summary>
	protected: int32_t lnGuid;
	/// <summary>
	/// Member bit: Deleted status.
	/// </summary>
	/// <remarks>
	/// DB column: maskstatus
	/// </remarks>
	public: const static int64_t mbStatus = 131072LL;
	/// <summary>
	/// Member bit: Internal acl.
	/// </summary>
	/// <remarks>
	/// DB column: maskacl
	/// </remarks>
	public: const static int64_t mbInternalAcl = 262144LL;
	/// <summary>
	/// Column length: Internal acl.
	/// </summary>
	/// <remarks>
	/// DB column: maskacl
	/// </remarks>
	protected: int32_t lnInternalAcl;
	/// <summary>
	/// Member bit: The ID of a workflow that is to be started if a new version of an associated
	/// DB column: maskflowid2
	/// </summary>
	public: const static int64_t mbFlowId2 = 524288LL;
	/// <summary>
	/// Member bit: Timestamp of this object's last export by the replication.
	/// </summary>
	/// <remarks>
	/// DB column: masktstampsync
	/// </remarks>
	public: const static int64_t mbTStampSync = 1048576LL;
	/// <summary>
	/// Column length: Timestamp of this object's last export by the replication.
	/// </summary>
	/// <remarks>
	/// DB column: masktstampsync
	/// </remarks>
	protected: int32_t lnTStampSync;
	/// <summary>
	/// Member bit: Translation-keyword for {@link DocMask#text}.
	/// </summary>
	/// <remarks>
	/// DB column: masktexttrkey
	/// </remarks>
	public: const static int64_t mbTextTranslationKey = 2097152LL;
	/// <summary>
	/// Column length: Translation-keyword for {@link DocMask#text}.
	/// </summary>
	/// <remarks>
	/// DB column: masktexttrkey
	/// </remarks>
	protected: int32_t lnTextTranslationKey;
	/// <summary>
	/// Member bit: Translation-keyword for {@link DocMask#name}.
	/// </summary>
	/// <remarks>
	/// DB column: masknametrkey
	/// </remarks>
	public: const static int64_t mbNameTranslationKey = 4194304LL;
	/// <summary>
	/// Column length: Translation-keyword for {@link DocMask#name}.
	/// </summary>
	/// <remarks>
	/// DB column: masknametrkey
	/// </remarks>
	protected: int32_t lnNameTranslationKey;
	/// <summary>
	/// Member bit: This member specifies how the index values are stored in database.
	/// </summary>
	/// <remarks>
	/// DB column: dataorg
	/// </remarks>
	public: const static int64_t mbDataOrganisation = 8388608LL;
	/// <summary>
	/// All valid member bits.
	/// </summary>
	public: const static int64_t mbAllMembers = 16777215LL;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: DocMaskDataC();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: DocMaskDataC(int64_t mbId, int64_t mbName, int32_t lnName, int64_t mbIndex, int32_t lnIndex, int64_t mbBarcode, int32_t lnBarcode, int64_t mbKey, int64_t mbDPath, int64_t mbDKind, int64_t mbDKey, int64_t mbLockId, int64_t mbFlags, int64_t mbFlowId, int64_t mbDAcl, int32_t lnDAcl, int64_t mbLifetime, int32_t lnLifetime, int64_t mbText, int32_t lnText, int64_t mbTStamp, int32_t lnTStamp, int64_t mbRawPosInfo, int32_t lnRawPosInfo, int64_t mbGuid, int32_t lnGuid, int64_t mbStatus, int64_t mbInternalAcl, int32_t lnInternalAcl, int64_t mbFlowId2, int64_t mbTStampSync, int32_t lnTStampSync, int64_t mbTextTranslationKey, int32_t lnTextTranslationKey, int64_t mbNameTranslationKey, int32_t lnNameTranslationKey, int64_t mbDataOrganisation, int64_t mbAllMembers);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getLnName() { return lnName; }
	public: void setLnName(int32_t v);
	public: int32_t getLnIndex() { return lnIndex; }
	public: void setLnIndex(int32_t v);
	public: int32_t getLnBarcode() { return lnBarcode; }
	public: void setLnBarcode(int32_t v);
	public: int32_t getLnDAcl() { return lnDAcl; }
	public: void setLnDAcl(int32_t v);
	public: int32_t getLnLifetime() { return lnLifetime; }
	public: void setLnLifetime(int32_t v);
	public: int32_t getLnText() { return lnText; }
	public: void setLnText(int32_t v);
	public: int32_t getLnTStamp() { return lnTStamp; }
	public: void setLnTStamp(int32_t v);
	public: int32_t getLnRawPosInfo() { return lnRawPosInfo; }
	public: void setLnRawPosInfo(int32_t v);
	public: int32_t getLnGuid() { return lnGuid; }
	public: void setLnGuid(int32_t v);
	public: int32_t getLnInternalAcl() { return lnInternalAcl; }
	public: void setLnInternalAcl(int32_t v);
	public: int32_t getLnTStampSync() { return lnTStampSync; }
	public: void setLnTStampSync(int32_t v);
	public: int32_t getLnTextTranslationKey() { return lnTextTranslationKey; }
	public: void setLnTextTranslationKey(int32_t v);
	public: int32_t getLnNameTranslationKey() { return lnNameTranslationKey; }
	public: void setLnNameTranslationKey(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// DocMaskC
// typeId=387842089

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// <p>Constants related to class <code>DocMask</code>.
/// </summary>
/// <remarks>
/// Some of the <code>MFG_</code> values are used in the member
/// <code>Flags</code> of class <code>Sord</code> too.
/// Each member of this class with prefix "mb" has a corresponding member in
/// class <code>DocMask</code></p> * </p>
/// </remarks>
class DocMaskC : public DocMaskDataC {
	/// <summary>
	/// Predefined GUID for keywording form "Freie Eingabe".
	/// </summary>
	protected: ::std::wstring GUID_BASIC;
	/// <summary>
	/// Predefined GUID for keywording form "EMail".
	/// </summary>
	protected: ::std::wstring GUID_EMAIL;
	/// <summary>
	/// Predefined GUID for keywording form "Strukturelement".
	/// </summary>
	protected: ::std::wstring GUID_STRUCTURE_ELEMENT;
	/// <summary>
	/// Predefined GUID for keywording form "Kontakt".
	/// </summary>
	protected: ::std::wstring GUID_CONTACT;
	/// <summary>
	/// Predefined GUID for the keywording form used for folders by default.
	/// </summary>
	protected: ::std::wstring GUID_FOLDER;
	/// <summary>
	/// Predefined GUID for the keywording form used to search entries regardless of their storage mask.
	/// </summary>
	protected: ::std::wstring GUID_SEARCH;
	/// <summary>
	/// Predefined GUID for the keywording form used for scripts.
	/// </summary>
	protected: ::std::wstring GUID_ELOSCRIPTS;
	/// <summary>
	/// Predefined GUID for the keywording form used by user folders.
	/// </summary>
	protected: ::std::wstring GUID_USER_FOLDER;
	/// <summary>
	/// Prefefined GUID for a keywording form for MS Sharepoint documents.
	/// </summary>
	protected: ::std::wstring GUID_MS_SHAREPOINT_DOCUMENT;
	/// <summary>
	/// Member bit: ACL
	/// </summary>
	public: const static int64_t mbAcl = 262144LL;
	/// <summary>
	/// ACL length
	/// </summary>
	protected: int32_t lnAcl;
	/// <summary>
	/// Member bit: use the ACL items in the member
	/// DocMask.aclItems and DocMask.docAclItems for reading and writing.
	/// </summary>
	public: const static int64_t mbAclItems = 1125899906842624LL;
	/// <summary>
	/// Member bit: read or write index lines.
	/// </summary>
	public: const static int64_t mbMaskLines = 2251799813685248LL;
	/// <summary>
	/// Member bit: read or write all elements.
	/// </summary>
	public: const static int64_t mbAllMembers = 4503599627370495LL;
	/// <summary>
	/// Member bit: this bit should be set if the Mask is to be used for structure elements and not for
	/// documents.
	/// </summary>
	/// <remarks>
	/// The effect is that the member DocMask.details.sortOrder is
	/// filled instead of DocMask.details.archivingMode.
	/// </remarks>
	public: const static int64_t mbSortOrderNotArchivingMode = 9007199254740992LL;
	/// <summary>
	/// Read or write all elements.
	/// </summary>
	public: const static PDocMaskZ mbAll;
	/// <summary>
	/// Only lock or unlock
	/// </summary>
	public: const static PDocMaskZ mbOnlyLock;
	public: const static int64_t mbDetails = 512LL;
	public: const static int64_t mbDocAclItems = 2048LL;
	public: const static int64_t mbLines = 2251799813685248LL;
	public: const static int64_t mbDeleted = 131072LL;
	/// <summary>
	/// Store index values as key-value-pairs in the objkeys table.
	/// </summary>
	public: const static int32_t DATA_ORGANISATION_OBJKEYS = 0;
	/// <summary>
	/// Store index values in columns of a dedicated table.
	/// </summary>
	public: const static int32_t DATA_ORGANISATION_TABLE = 1;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: DocMaskC();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: DocMaskC(const ::std::wstring& GUID_BASIC, const ::std::wstring& GUID_EMAIL, const ::std::wstring& GUID_STRUCTURE_ELEMENT, const ::std::wstring& GUID_CONTACT, const ::std::wstring& GUID_FOLDER, const ::std::wstring& GUID_SEARCH, const ::std::wstring& GUID_ELOSCRIPTS, const ::std::wstring& GUID_USER_FOLDER, const ::std::wstring& GUID_MS_SHAREPOINT_DOCUMENT, int64_t mbAcl, int32_t lnAcl, int64_t mbAclItems, int64_t mbMaskLines, int64_t mbAllMembers, int64_t mbSortOrderNotArchivingMode, const PDocMaskZ& mbAll, const PDocMaskZ& mbOnlyLock, int64_t mbDetails, int64_t mbDocAclItems, int64_t mbLines, int64_t mbDeleted, int32_t DATA_ORGANISATION_OBJKEYS, int32_t DATA_ORGANISATION_TABLE);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: ::std::wstring getGUID_BASIC() { return GUID_BASIC; }
	public: void setGUID_BASIC(::std::wstring v);
	public: ::std::wstring getGUID_EMAIL() { return GUID_EMAIL; }
	public: void setGUID_EMAIL(::std::wstring v);
	public: ::std::wstring getGUID_STRUCTURE_ELEMENT() { return GUID_STRUCTURE_ELEMENT; }
	public: void setGUID_STRUCTURE_ELEMENT(::std::wstring v);
	public: ::std::wstring getGUID_CONTACT() { return GUID_CONTACT; }
	public: void setGUID_CONTACT(::std::wstring v);
	public: ::std::wstring getGUID_FOLDER() { return GUID_FOLDER; }
	public: void setGUID_FOLDER(::std::wstring v);
	public: ::std::wstring getGUID_SEARCH() { return GUID_SEARCH; }
	public: void setGUID_SEARCH(::std::wstring v);
	public: ::std::wstring getGUID_ELOSCRIPTS() { return GUID_ELOSCRIPTS; }
	public: void setGUID_ELOSCRIPTS(::std::wstring v);
	public: ::std::wstring getGUID_USER_FOLDER() { return GUID_USER_FOLDER; }
	public: void setGUID_USER_FOLDER(::std::wstring v);
	public: ::std::wstring getGUID_MS_SHAREPOINT_DOCUMENT() { return GUID_MS_SHAREPOINT_DOCUMENT; }
	public: void setGUID_MS_SHAREPOINT_DOCUMENT(::std::wstring v);
	public: int32_t getLnAcl() { return lnAcl; }
	public: void setLnAcl(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// DocMaskDetails
// typeId=639048562

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// This class contains a member of a <code>DocMask</code> object.
/// </summary>
/// <remarks>
/// <p>Copyright: Copyright (c) 2004</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </remarks>
class DocMaskDetails : public ValueClass {
	/// <summary>
	/// Archiving mode.
	/// </summary>
	/// <remarks>
	/// Sort order and archiving mode share the same database column.
	/// If the mask is used for documents, set <code>sortOrder=SordOrderC.NONE</code>.
	/// ELO 7.0: This value is only valid for document masks, <code>documentMask=true</code>.
	/// </remarks>
	protected: int32_t archivingMode;
	/// <summary>
	/// Encryption set number.
	/// </summary>
	protected: int32_t encryptionSet;
	/// <summary>
	/// Document is or should be containted in the fultext database.
	/// </summary>
	protected: bool fulltext;
	/// <summary>
	/// Sort order of child entries.
	/// </summary>
	/// <remarks>
	/// Sort order and archiving mode share the same database column.
	/// If the mask is used for folders, set <code>archivingMode=ArchivingModeC.NONE</code>.
	/// If both <code>sortOrder</code> and <code>archivingMode</code> are set, <code>sortOrder</code>
	/// has precedence and <code>archivingMode</code> is ignored.
	/// ELO 7.0: This value is only valid for folder masks, <code>folderMask=true</code>.
	/// </remarks>
	protected: int32_t sortOrder;
	/// <summary>
	/// Mask can be used to edit indexing information of a document.
	/// </summary>
	protected: bool documentMask;
	/// <summary>
	/// Mask can be used to search for indexing information.
	/// </summary>
	protected: bool searchMask;
	/// <summary>
	/// Mask can be used to edit indexing information of a folder
	/// </summary>
	protected: bool folderMask;
	/// <summary>
	/// If <code>DocMask.index</code> is defined,
	/// this option effects that the resulting archieve path is created, if
	/// it does not exist.
	/// </summary>
	protected: bool createIndexPath;
	/// <summary>
	/// If <code>DocMask.index</code> is defined including reference paths,
	/// this option effects that the resulting reference paths are created, if
	/// they do not exist.
	/// </summary>
	protected: bool createIndexReferencesPaths;
	/// <summary>
	/// Documents using this mask may be used as release notes
	/// </summary>
	protected: bool releaseDocument;
	/// <summary>
	/// Folders indexed with this mask get the flag {@link SordDetails#documentContainer} set accordingly.
	/// </summary>
	protected: bool documentContainer;
	/// <summary>
	/// If <tt>true</tt> translate the sord's short description into or from the user language.
	/// </summary>
	protected: bool translateSordName;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: DocMaskDetails();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: DocMaskDetails(int32_t archivingMode, int32_t encryptionSet, bool fulltext, int32_t sortOrder, bool documentMask, bool searchMask, bool folderMask, bool createIndexPath, bool createIndexReferencesPaths, bool releaseDocument, bool documentContainer, bool translateSordName);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getArchivingMode() { return archivingMode; }
	public: void setArchivingMode(int32_t v);
	public: int32_t getEncryptionSet() { return encryptionSet; }
	public: void setEncryptionSet(int32_t v);
	public: bool getFulltext() { return fulltext; }
	public: void setFulltext(bool v);
	public: int32_t getSortOrder() { return sortOrder; }
	public: void setSortOrder(int32_t v);
	public: bool getDocumentMask() { return documentMask; }
	public: void setDocumentMask(bool v);
	public: bool getSearchMask() { return searchMask; }
	public: void setSearchMask(bool v);
	public: bool getFolderMask() { return folderMask; }
	public: void setFolderMask(bool v);
	public: bool getCreateIndexPath() { return createIndexPath; }
	public: void setCreateIndexPath(bool v);
	public: bool getCreateIndexReferencesPaths() { return createIndexReferencesPaths; }
	public: void setCreateIndexReferencesPaths(bool v);
	public: bool getReleaseDocument() { return releaseDocument; }
	public: void setReleaseDocument(bool v);
	public: bool getDocumentContainer() { return documentContainer; }
	public: void setDocumentContainer(bool v);
	public: bool getTranslateSordName() { return translateSordName; }
	public: void setTranslateSordName(bool v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// DocMaskLine
// typeId=1291500689

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// This class contains data for a line in the document mask.
/// </summary>
/// <remarks>
/// <p>Copyright: Copyright (c) 2004</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </remarks>
class DocMaskLine : public ValueClass {
	/// <summary>
	/// Quickinfo text for the attribute.
	/// </summary>
	protected: ::std::wstring comment;
	/// <summary>
	/// The ID of the line information.
	/// </summary>
	protected: int32_t id;
	/// <summary>
	/// The attribute group name.
	/// </summary>
	/// <remarks>
	/// This member corresponds to <code>ObjKey.name</code>.
	/// </remarks>
	protected: ::std::wstring key;
	/// <summary>
	/// This line information belongs to a storage mask with the ID MaskId.
	/// </summary>
	protected: int32_t maskId;
	/// <summary>
	/// The maximum value of this attribute.
	/// </summary>
	protected: int32_t max;
	/// <summary>
	/// The minimum value of this attribute.
	/// </summary>
	protected: int32_t min;
	/// <summary>
	/// The name of the attribute.
	/// </summary>
	/// <remarks>
	/// This value is displayed in the lable before the edit field.
	/// It can be translated into reps. from the users language:
	/// set <code>SessionOptionsC.TRANSLATE_TERM</code>.
	/// </remarks>
	protected: ::std::wstring name;
	/// <summary>
	/// Access control for mask line.
	/// </summary>
	/// <remarks>
	/// Currently this can only be null or one item representing a key.
	/// </remarks>
	protected: PArrayAclItem aclItems;
	/// <summary>
	/// Determines whether the index line can be modified.
	/// </summary>
	/// <remarks>
	/// Read-only.
	/// </remarks>
	protected: bool canEdit;
	/// <summary>
	/// Column position of edit control
	/// </summary>
	protected: int32_t editCol;
	/// <summary>
	/// Row postion of edit control
	/// </summary>
	protected: int32_t editRow;
	/// <summary>
	/// With of edit control
	/// </summary>
	protected: int32_t editWidth;
	/// <summary>
	/// This value should not be displayed to the user.
	/// </summary>
	protected: bool hidden;
	/// <summary>
	/// Column position of label control
	/// </summary>
	protected: int32_t labelCol;
	/// <summary>
	/// Row position of label control
	/// </summary>
	protected: int32_t labelRow;
	/// <summary>
	/// Creates a new tab in the keywording dialogue.
	/// </summary>
	protected: bool nextTab;
	/// <summary>
	/// The index line can only contain buzzwords.
	/// </summary>
	protected: bool onlyBuzzwords;
	/// <summary>
	/// Add "*" after index value in search operation.
	/// </summary>
	protected: bool postfixAsterix;
	/// <summary>
	/// Add "*" before index value in search operation.
	/// </summary>
	protected: bool prefixAsterix;
	/// <summary>
	/// This value should not be edited in a user interface (convention).
	/// </summary>
	/// <remarks>
	/// Scripts are allowed to edit the value.
	/// </remarks>
	protected: bool readOnly;
	/// <summary>
	/// Tabulator order of edit control
	/// </summary>
	protected: int32_t tabOrder;
	/// <summary>
	/// The type of the line information.
	/// </summary>
	/// <remarks>
	/// This can be one of the <code>DocMaskLineC.TYPE_*</code> constants.
	/// </remarks>
	protected: int32_t type;
	/// <summary>
	/// External data.
	/// </summary>
	/// <remarks>
	/// Can be used to store an arbitary string.
	/// </remarks>
	protected: ::std::wstring externalData;
	/// <summary>
	/// Display index value next to the objects short description.
	/// </summary>
	/// <remarks>
	/// This element has to be interpreted by the client application.
	/// IndexServer ignores this value.
	/// </remarks>
	protected: bool important;
	/// <summary>
	/// Defines whether a index value should be searchable as TOKENIZED or UN_TOKENIZED
	/// </summary>
	protected: bool notTokenized;
	/// <summary>
	/// If true a index value will not be searchable via iSearch.
	/// </summary>
	/// <remarks>
	/// Does not affect the index search.
	/// </remarks>
	protected: bool excludeFromISearch;
	/// <summary>
	/// Display index value in version information dialog when
	/// checking in a document.
	/// </summary>
	/// <remarks>
	/// This element has to be interpreted by the client application.
	/// IndexServer ignores this value.
	/// </remarks>
	protected: bool version;
	/// <summary>
	/// Translate index values into or from the users language.
	/// </summary>
	protected: bool translate;
	/// <summary>
	/// Access control for mask line.
	/// </summary>
	protected: ::std::wstring acl;
	/// <summary>
	/// Bitset of AccessC.LUR_* constants.
	/// </summary>
	/// <remarks>
	/// It contains the access bits for the current user.
	/// Only AccessC.LUR_READ and AccessC.LUR_WRITE are used.
	/// </remarks>
	protected: int32_t access;
	/// <summary>
	/// Disable word wheel.
	/// </summary>
	/// <remarks>
	/// Clients should not provide a function to list all
	/// existing values for this index vlaue.
	/// The IndexServer does not set or test this value.
	/// </remarks>
	protected: bool disableWordWheel;
	/// <summary>
	/// This value is assigned to the ObjKey.data element for a new Sord object.
	/// </summary>
	protected: ::std::wstring defaultValue;
	/// <summary>
	/// This value represents the number of the tab, this line has to appear on.
	/// </summary>
	/// <remarks>
	/// The first tab's index value is 0. It is on the client's hand to set valid
	/// values when checking in document masks.
	/// </remarks>
	protected: int32_t tabIndex;
	/// <summary>
	/// A script at the server can serve as the data source of a dynamic keyword
	/// list.
	/// </summary>
	/// <remarks>
	/// This value represents the name of that script. If the value is not
	/// empty, the client can request a list of available input values by calling
	/// the function {@link IXServicePortIF#checkoutKeywordsDynamic(ClientInfo, KeywordsDynamicInfo)}.
	/// </remarks>
	protected: ::std::wstring serverScriptName;
	/// <summary>
	/// Inherit this keywording field to subordinated entries.
	/// </summary>
	/// <remarks>
	/// <p>
	/// This option is used to make sure, that all entries in an archive sub-tree
	/// have the same value for this keywording field. Thereby the field is identified
	/// by its group name ({@link DocMaskLine#key} and {@link ObjKey#name}).
	/// </p><p>
	/// The option corresponds to {@link #inheritFromParent}. As far as {@link #inheritFromParent} is also true
	/// in the keywording forms definition of all sub-items, the option {@link #inherit} effects the following:
	/// <ul><li>The value of the keywording field can only be changed in the parent entry
	/// of the sub-tree. This is the uppermost entry that has the field, which means that the parent's
	/// parent does not have this field.
	/// </li><li>
	/// All sub-items of the parent inherit this value
	/// during a background process. The value is forwarded recursively to the entire
	/// sub-tree under the parent. The recursion stops at items that are assigned to a keywording form
	/// without this field.
	/// </li><li>
	/// When a child entry under the parent is updated, this field is always corrected to the parent's value.
	/// </li><li>
	/// For an object moved into a parent, the object and all sub-items inherit
	/// the keywording field.
	/// </li></ul>
	/// </p><p>
	/// If {@link #inheritFromParent} is false in the keywording form definition of a sub-item, inheritance stops for
	/// the sub-item. Thus, the index field is treated as a different field although it has the same group name.
	/// </p>
	/// </remarks>
	protected: bool inherit;
	/// <summary>
	/// Do not inherit the parent's value.
	/// </summary>
	protected: bool inheritFromParent;
	/// <summary>
	/// Translation-keyword for {@link DocMaskLine#name}.
	/// </summary>
	protected: ::std::wstring nameTranslationKey;
	/// <summary>
	/// Translation-keyword for {@link DocMaskLine#comment}.
	/// </summary>
	protected: ::std::wstring commentTranslationKey;
	/// <summary>
	/// Allows multiple values for keywording tables.
	/// </summary>
	/// <remarks>
	/// For keywording forms organized as tables, see {@link DocMaskC#DATA_ORGANISATION_TABLE},
	/// index lines must be explicitly declared for storing multiple values. If this member is true,
	/// the index line is able to store an arbitrary number of values. For keywording forms organized
	/// as name-value pairs, see {@link DocMaskC#DATA_ORGANISATION_OBJKEYS}, index lines can store
	/// multiple values by default and this member has to be ignored.
	/// </remarks>
	protected: bool valueArray;
	/// <summary>
	/// RegEx to validate user input for entry.
	/// </summary>
	protected: ::std::wstring validateExpression;
	/// <summary>
	/// Entry is required.
	/// </summary>
	protected: bool required;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: DocMaskLine();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: DocMaskLine(const ::std::wstring& comment, int32_t id, const ::std::wstring& key, int32_t maskId, int32_t max, int32_t min, const ::std::wstring& name, const PArrayAclItem& aclItems, bool canEdit, int32_t editCol, int32_t editRow, int32_t editWidth, bool hidden, int32_t labelCol, int32_t labelRow, bool nextTab, bool onlyBuzzwords, bool postfixAsterix, bool prefixAsterix, bool readOnly, int32_t tabOrder, int32_t type, const ::std::wstring& externalData, bool important, bool notTokenized, bool excludeFromISearch, bool version, bool translate, const ::std::wstring& acl, int32_t access, bool disableWordWheel, const ::std::wstring& defaultValue, int32_t tabIndex, const ::std::wstring& serverScriptName, bool inherit, bool inheritFromParent, const ::std::wstring& nameTranslationKey, const ::std::wstring& commentTranslationKey, bool valueArray, const ::std::wstring& validateExpression, bool required);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: ::std::wstring getComment() { return comment; }
	public: void setComment(::std::wstring v);
	public: int32_t getId() { return id; }
	public: void setId(int32_t v);
	public: ::std::wstring getKey() { return key; }
	public: void setKey(::std::wstring v);
	public: int32_t getMaskId() { return maskId; }
	public: void setMaskId(int32_t v);
	public: int32_t getMax() { return max; }
	public: void setMax(int32_t v);
	public: int32_t getMin() { return min; }
	public: void setMin(int32_t v);
	public: ::std::wstring getName() { return name; }
	public: void setName(::std::wstring v);
	public: PArrayAclItem getAclItems() { return aclItems; }
	public: void setAclItems(PArrayAclItem v);
	public: bool getCanEdit() { return canEdit; }
	public: void setCanEdit(bool v);
	public: int32_t getEditCol() { return editCol; }
	public: void setEditCol(int32_t v);
	public: int32_t getEditRow() { return editRow; }
	public: void setEditRow(int32_t v);
	public: int32_t getEditWidth() { return editWidth; }
	public: void setEditWidth(int32_t v);
	public: bool getHidden() { return hidden; }
	public: void setHidden(bool v);
	public: int32_t getLabelCol() { return labelCol; }
	public: void setLabelCol(int32_t v);
	public: int32_t getLabelRow() { return labelRow; }
	public: void setLabelRow(int32_t v);
	public: bool getNextTab() { return nextTab; }
	public: void setNextTab(bool v);
	public: bool getOnlyBuzzwords() { return onlyBuzzwords; }
	public: void setOnlyBuzzwords(bool v);
	public: bool getPostfixAsterix() { return postfixAsterix; }
	public: void setPostfixAsterix(bool v);
	public: bool getPrefixAsterix() { return prefixAsterix; }
	public: void setPrefixAsterix(bool v);
	public: bool getReadOnly() { return readOnly; }
	public: void setReadOnly(bool v);
	public: int32_t getTabOrder() { return tabOrder; }
	public: void setTabOrder(int32_t v);
	public: int32_t getType() { return type; }
	public: void setType(int32_t v);
	public: ::std::wstring getExternalData() { return externalData; }
	public: void setExternalData(::std::wstring v);
	public: bool getImportant() { return important; }
	public: void setImportant(bool v);
	public: bool getNotTokenized() { return notTokenized; }
	public: void setNotTokenized(bool v);
	public: bool getExcludeFromISearch() { return excludeFromISearch; }
	public: void setExcludeFromISearch(bool v);
	public: bool getVersion() { return version; }
	public: void setVersion(bool v);
	public: bool getTranslate() { return translate; }
	public: void setTranslate(bool v);
	public: ::std::wstring getAcl() { return acl; }
	public: void setAcl(::std::wstring v);
	public: int32_t getAccess() { return access; }
	public: void setAccess(int32_t v);
	public: bool getDisableWordWheel() { return disableWordWheel; }
	public: void setDisableWordWheel(bool v);
	public: ::std::wstring getDefaultValue() { return defaultValue; }
	public: void setDefaultValue(::std::wstring v);
	public: int32_t getTabIndex() { return tabIndex; }
	public: void setTabIndex(int32_t v);
	public: ::std::wstring getServerScriptName() { return serverScriptName; }
	public: void setServerScriptName(::std::wstring v);
	public: bool getInherit() { return inherit; }
	public: void setInherit(bool v);
	public: bool getInheritFromParent() { return inheritFromParent; }
	public: void setInheritFromParent(bool v);
	public: ::std::wstring getNameTranslationKey() { return nameTranslationKey; }
	public: void setNameTranslationKey(::std::wstring v);
	public: ::std::wstring getCommentTranslationKey() { return commentTranslationKey; }
	public: void setCommentTranslationKey(::std::wstring v);
	public: bool getValueArray() { return valueArray; }
	public: void setValueArray(bool v);
	public: ::std::wstring getValidateExpression() { return validateExpression; }
	public: void setValidateExpression(::std::wstring v);
	public: bool getRequired() { return required; }
	public: void setRequired(bool v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// DocMaskLineDataC
// typeId=1178569423

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// <p>Bit constants for members of DocMaskLine</p>
/// <p>Copyright: Copyright (c) 2003</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </summary>
class DocMaskLineDataC : public BSerializable {
	/// <summary>
	/// DB column: maskno
	/// </summary>
	public: const static int64_t mbMaskId = 1LL;
	/// <summary>
	/// DB column: mlineno
	/// </summary>
	public: const static int64_t mbId = 2LL;
	/// <summary>
	/// DB column: linetype
	/// </summary>
	public: const static int64_t mbRawType = 4LL;
	/// <summary>
	/// DB column: linebez
	/// </summary>
	public: const static int64_t mbName = 8LL;
	/// <summary>
	/// DB column: linebez
	/// </summary>
	protected: int32_t lnName;
	/// <summary>
	/// DB column: linekey
	/// </summary>
	public: const static int64_t mbKey = 16LL;
	/// <summary>
	/// DB column: linekey
	/// </summary>
	protected: int32_t lnKey;
	/// <summary>
	/// DB column: linemin
	/// </summary>
	public: const static int64_t mbMin = 32LL;
	/// <summary>
	/// DB column: linemax
	/// </summary>
	public: const static int64_t mbMax = 64LL;
	/// <summary>
	/// DB column: linelkey
	/// </summary>
	public: const static int64_t mbLKey = 128LL;
	/// <summary>
	/// DB column: lineflags
	/// </summary>
	public: const static int64_t mbRawFlags = 256LL;
	/// <summary>
	/// DB column: linecomment
	/// </summary>
	public: const static int64_t mbComment = 512LL;
	/// <summary>
	/// DB column: linecomment
	/// </summary>
	protected: int32_t lnComment;
	/// <summary>
	/// Member bit: External data.
	/// </summary>
	/// <remarks>
	/// DB column: lineext
	/// </remarks>
	public: const static int64_t mbExternalData = 1024LL;
	/// <summary>
	/// Column length: External data.
	/// </summary>
	/// <remarks>
	/// DB column: lineext
	/// </remarks>
	protected: int32_t lnExternalData;
	/// <summary>
	/// Member bit: Internal acl.
	/// </summary>
	/// <remarks>
	/// DB column: lineacl
	/// </remarks>
	public: const static int64_t mbInternalAcl = 2048LL;
	/// <summary>
	/// Column length: Internal acl.
	/// </summary>
	/// <remarks>
	/// DB column: lineacl
	/// </remarks>
	protected: int32_t lnInternalAcl;
	/// <summary>
	/// Member bit: This value is assigned to the ObjKey.data element for a new Sord object.
	/// </summary>
	/// <remarks>
	/// DB column: linedefault
	/// </remarks>
	public: const static int64_t mbDefaultValue = 4096LL;
	/// <summary>
	/// Column length: This value is assigned to the ObjKey.data element for a new Sord object.
	/// </summary>
	/// <remarks>
	/// DB column: linedefault
	/// </remarks>
	protected: int32_t lnDefaultValue;
	/// <summary>
	/// Member bit: This value represents the number of the tab, this line has to appear on.
	/// </summary>
	/// <remarks>
	/// DB column: linetab
	/// </remarks>
	public: const static int64_t mbTabIndex = 8192LL;
	/// <summary>
	/// Member bit: A script at the server can serve as the data source of a dynamic keyword
	/// DB column: linescript
	/// </summary>
	public: const static int64_t mbServerScriptName = 16384LL;
	/// <summary>
	/// Column length: A script at the server can serve as the data source of a dynamic keyword
	/// DB column: linescript
	/// </summary>
	protected: int32_t lnServerScriptName;
	/// <summary>
	/// Member bit: Translation-keyword for {@link DocMaskLine#name}.
	/// </summary>
	/// <remarks>
	/// DB column: linebeztrkey
	/// </remarks>
	public: const static int64_t mbNameTranslationKey = 32768LL;
	/// <summary>
	/// Column length: Translation-keyword for {@link DocMaskLine#name}.
	/// </summary>
	/// <remarks>
	/// DB column: linebeztrkey
	/// </remarks>
	protected: int32_t lnNameTranslationKey;
	/// <summary>
	/// Member bit: Translation-keyword for {@link DocMaskLine#comment}.
	/// </summary>
	/// <remarks>
	/// DB column: linecommenttrkey
	/// </remarks>
	public: const static int64_t mbCommentTranslationKey = 65536LL;
	/// <summary>
	/// Column length: Translation-keyword for {@link DocMaskLine#comment}.
	/// </summary>
	/// <remarks>
	/// DB column: linecommenttrkey
	/// </remarks>
	protected: int32_t lnCommentTranslationKey;
	/// <summary>
	/// Member bit: RegEx to validate user input for entry.
	/// </summary>
	/// <remarks>
	/// DB column: validateexpression
	/// </remarks>
	public: const static int64_t mbValidateExpression = 131072LL;
	/// <summary>
	/// Column length: RegEx to validate user input for entry.
	/// </summary>
	/// <remarks>
	/// DB column: validateexpression
	/// </remarks>
	protected: int32_t lnValidateExpression;
	/// <summary>
	/// All valid member bits.
	/// </summary>
	public: const static int64_t mbAllMembers = 262143LL;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: DocMaskLineDataC();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: DocMaskLineDataC(int64_t mbMaskId, int64_t mbId, int64_t mbRawType, int64_t mbName, int32_t lnName, int64_t mbKey, int32_t lnKey, int64_t mbMin, int64_t mbMax, int64_t mbLKey, int64_t mbRawFlags, int64_t mbComment, int32_t lnComment, int64_t mbExternalData, int32_t lnExternalData, int64_t mbInternalAcl, int32_t lnInternalAcl, int64_t mbDefaultValue, int32_t lnDefaultValue, int64_t mbTabIndex, int64_t mbServerScriptName, int32_t lnServerScriptName, int64_t mbNameTranslationKey, int32_t lnNameTranslationKey, int64_t mbCommentTranslationKey, int32_t lnCommentTranslationKey, int64_t mbValidateExpression, int32_t lnValidateExpression, int64_t mbAllMembers);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getLnName() { return lnName; }
	public: void setLnName(int32_t v);
	public: int32_t getLnKey() { return lnKey; }
	public: void setLnKey(int32_t v);
	public: int32_t getLnComment() { return lnComment; }
	public: void setLnComment(int32_t v);
	public: int32_t getLnExternalData() { return lnExternalData; }
	public: void setLnExternalData(int32_t v);
	public: int32_t getLnInternalAcl() { return lnInternalAcl; }
	public: void setLnInternalAcl(int32_t v);
	public: int32_t getLnDefaultValue() { return lnDefaultValue; }
	public: void setLnDefaultValue(int32_t v);
	public: int32_t getLnServerScriptName() { return lnServerScriptName; }
	public: void setLnServerScriptName(int32_t v);
	public: int32_t getLnNameTranslationKey() { return lnNameTranslationKey; }
	public: void setLnNameTranslationKey(int32_t v);
	public: int32_t getLnCommentTranslationKey() { return lnCommentTranslationKey; }
	public: void setLnCommentTranslationKey(int32_t v);
	public: int32_t getLnValidateExpression() { return lnValidateExpression; }
	public: void setLnValidateExpression(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// DocMaskLineC
// typeId=1453574806

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// <p>Constants for class <code>DocMaskLine</code></p>
/// <p>Copyright: Copyright (c) 2003</p>
/// <p>Organisation: ELO Digital Office GmbH </p>
/// </summary>
class DocMaskLineC : public DocMaskLineDataC {
	/// <summary>
	/// Member bit: The type of the line information.
	/// </summary>
	/// <remarks>
	/// This can be one of the <code>DocMaskLineC.LINETYPE_*</code> constants.
	/// </remarks>
	public: const static int64_t mbType = 4LL;
	/// <summary>
	/// Member bit: Line flags
	/// </summary>
	public: const static int64_t mbFlags = 256LL;
	/// <summary>
	/// Member bit: ACL
	/// </summary>
	public: const static int64_t mbAcl = 2048LL;
	/// <summary>
	/// ACL length
	/// </summary>
	protected: int32_t lnAcl;
	/// <summary>
	/// Used to check wether a correct constant is used.
	/// </summary>
	public: const static int32_t _TYPE_TYPE_ID = 3000;
	/// <summary>
	/// Index line contains text information.
	/// </summary>
	public: const static int32_t TYPE_TEXT = 3000;
	/// <summary>
	/// Index line contains a date.
	/// </summary>
	public: const static int32_t TYPE_DATE = 3001;
	/// <summary>
	/// Index line contains a number.
	/// </summary>
	/// <remarks>
	/// The number is internally stored as a string
	/// value without any padding. Thus it is not possible to search over an interval.
	/// Use one of the TYPE_NUMBER_F* types to be able to search over intervals.
	/// The number must be formatted according to the locale information of the server.
	/// </remarks>
	public: const static int32_t TYPE_NUMBER = 3002;
	/// <summary>
	/// Index line contains a reference number ("Aktenzeichen").
	/// </summary>
	public: const static int32_t TYPE_AZ = 3003;
	/// <summary>
	/// Index line contains a date in ISO format.
	/// </summary>
	public: const static int32_t TYPE_ISO_DATE = 3004;
	/// <summary>
	/// Index line contains a list entry.
	/// </summary>
	public: const static int32_t TYPE_LIST = 3005;
	/// <summary>
	/// Index line contains a user name.
	/// </summary>
	public: const static int32_t TYPE_USER = 3006;
	/// <summary>
	/// Thesaurus
	/// </summary>
	public: const static int32_t TYPE_THES = 3007;
	/// <summary>
	/// Index line contains a number value with an arbitrary number of fraction digits.
	/// </summary>
	/// <remarks>
	/// The value is internally stored with a padding of &amp; (positive numbers)
	/// or @ (negative numbers). This gives the possibility to search over an interval
	/// of numeric values, e. b. search for "1 ... 12" finds objects with index values 1,2,3,4,...12.
	/// The number must be formatted according to the locale information given in the ClientInfo object.
	/// With this type, the user is responsible to enter always the same number of fraction digits.
	/// Otherwise, a search over a number range will not return the correct results.
	/// The meaning of this field was changed in 8.00.032. The meaning before was a field without any fraction digits.
	/// </remarks>
	public: const static int32_t TYPE_NUMBER_F0 = 3008;
	/// <summary>
	/// Index line contains a number value with one digit after the decimal point.
	/// </summary>
	public: const static int32_t TYPE_NUMBER_F1 = 3009;
	/// <summary>
	/// Index line contains a number value with one digit after the decimal point.
	/// </summary>
	public: const static int32_t TYPE_NUMBER_F2 = 3010;
	/// <summary>
	/// Index line contains a number value of with four digits after the decimal point.
	/// </summary>
	public: const static int32_t TYPE_NUMBER_F4 = 3011;
	/// <summary>
	/// Index line contains a number value with six digits after the decimal point.
	/// </summary>
	public: const static int32_t TYPE_NUMBER_F6 = 3012;
	/// <summary>
	/// Index line contains a number value without fraction in the range of (-2^31) to (2^31)-1.
	/// </summary>
	/// <remarks>
	/// This type can only be used for keywording forms with {@link DocMaskC#DATA_ORGANISATION_TABLE}.
	/// </remarks>
	public: const static int32_t TYPE_INTEGER = 3013;
	/// <summary>
	/// Index line contains a number value without fraction in the range of (-2^63) to (2^63)-1.
	/// </summary>
	/// <remarks>
	/// This type can only be used for keywording forms with {@link DocMaskC#DATA_ORGANISATION_TABLE}.
	/// </remarks>
	public: const static int32_t TYPE_LONG = 3014;
	/// <summary>
	/// Index line contains a floating point number value with 7 significant digits.
	/// </summary>
	/// <remarks>
	/// This type can only be used for keywording forms with {@link DocMaskC#DATA_ORGANISATION_TABLE}.
	/// To assign a value of this type to {@link ObjKey#data}, the String representation has to conform to the Float.toString() method of Java.
	/// Use dot to separate the fraction part and character 'E' to prefix the exponent.
	/// </remarks>
	public: const static int32_t TYPE_FLOAT = 3015;
	/// <summary>
	/// Index line contains a floating point number value with 15 significant digits.
	/// </summary>
	/// <remarks>
	/// This type can only be used for keywording forms with {@link DocMaskC#DATA_ORGANISATION_TABLE}.
	/// To assign a value of this type to {@link ObjKey#data}, the String representation has to conform to the Double.toString() method of Java.
	/// Use dot to separate the fraction part and character 'E' to prefix the exponent.
	/// </remarks>
	public: const static int32_t TYPE_DOUBLE = 3016;
	/// <summary>
	/// Default ist text
	/// </summary>
	public: const static int32_t DEFAULT = 3000;
	/// <summary>
	/// Index line ID of links.
	/// </summary>
	/// <remarks>
	/// Sord.linksGoOut and Sord.linksComeIn provide a
	/// more convinient way to access links. Links can be added and removed with
	/// the functions linkSords resp. unlinkSords.
	/// </remarks>
	public: const static int32_t ID_LINK = 50;
	/// <summary>
	/// Index line name of links.
	/// </summary>
	public: const static ::std::wstring NAME_LINK;
	/// <summary>
	/// Index line ID of original file name
	/// </summary>
	public: const static int32_t ID_FILENAME = 51;
	/// <summary>
	/// Index line name of original file name
	/// </summary>
	public: const static ::std::wstring NAME_FILENAME;
	/// <summary>
	/// Index line ID to store informations used by "Versendemappe".
	/// </summary>
	public: const static int32_t DOCKEY_VSL = 52;
	/// <summary>
	/// Index line name to store informations used by "Versendemappe".
	/// </summary>
	public: const static ::std::wstring DOCNAME_VSL;
	/// <summary>
	/// This constant defines a limit for ObjKey.id values.
	/// </summary>
	/// <remarks>
	/// The following table defines which ObjKey.id values are allowed.
	/// <p><table border="2" summary="">
	/// <tr><td>ObjKey.id</td><td>Comment</td></tr>
	/// <tr><td>0 ... MAX_ID_DOCMASK_LINE</td><td>ObjKeys with ObjKey.data.length &gt; 1 allowed.</td></tr>
	/// <tr><td>MAX_ID_DOCMASK_LINE+1 ... MAX_ID_VALUE_ARRAY</td><td>ObjKeys for Special purposes, e.g. ID_FILE_NAME</td></tr>
	/// </table>
	/// </p><p>
	/// <table border="2">
	/// <tr><td>Symbol</td><td>Value</td></tr>
	/// <tr><td>MAX_ID_DOCMASK_LINE</td><td>49</td></tr>
	/// <tr><td>MAX_ID_VALUE_ARRAY</td><td>59</td></tr>
	/// </table></p>
	/// </remarks>
	public: const static int32_t MAX_ID_DOCMASK_LINE = 49;
	/// <summary>
	/// This constant defines a limit for ObjKey.id values.
	/// </summary>
	public: const static int32_t MAX_ID_VALUE_ARRAY = 59;
	public: const static int32_t MIN_ID_HIDDEN_VALUE = 1000;
	public: const static int32_t MAX_ID_HIDDEN_VALUE = 100000;
	public: const static int64_t mbAclItems = 2048LL;
	public: const static int64_t mbHidden = 256LL;
	public: const static int64_t mbNextTab = 256LL;
	public: const static int64_t mbOnlyBuzzwords = 256LL;
	public: const static int64_t mbPostfixAsterix = 256LL;
	public: const static int64_t mbPrefixAsterix = 256LL;
	public: const static int64_t mbReadOnly = 256LL;
	public: const static int64_t mbTabOrder = 256LL;
	public: const static int64_t mbTranslate = 256LL;
	public: const static int64_t mbImportant = 256LL;
	public: const static int64_t mbVersion = 256LL;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: DocMaskLineC();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: DocMaskLineC(int64_t mbType, int64_t mbFlags, int64_t mbAcl, int32_t lnAcl, int32_t _TYPE_TYPE_ID, int32_t TYPE_TEXT, int32_t TYPE_DATE, int32_t TYPE_NUMBER, int32_t TYPE_AZ, int32_t TYPE_ISO_DATE, int32_t TYPE_LIST, int32_t TYPE_USER, int32_t TYPE_THES, int32_t TYPE_NUMBER_F0, int32_t TYPE_NUMBER_F1, int32_t TYPE_NUMBER_F2, int32_t TYPE_NUMBER_F4, int32_t TYPE_NUMBER_F6, int32_t TYPE_INTEGER, int32_t TYPE_LONG, int32_t TYPE_FLOAT, int32_t TYPE_DOUBLE, int32_t DEFAULT, int32_t ID_LINK, const ::std::wstring& NAME_LINK, int32_t ID_FILENAME, const ::std::wstring& NAME_FILENAME, int32_t DOCKEY_VSL, const ::std::wstring& DOCNAME_VSL, int32_t MAX_ID_DOCMASK_LINE, int32_t MAX_ID_VALUE_ARRAY, int32_t MIN_ID_HIDDEN_VALUE, int32_t MAX_ID_HIDDEN_VALUE, int64_t mbAclItems, int64_t mbHidden, int64_t mbNextTab, int64_t mbOnlyBuzzwords, int64_t mbPostfixAsterix, int64_t mbPrefixAsterix, int64_t mbReadOnly, int64_t mbTabOrder, int64_t mbTranslate, int64_t mbImportant, int64_t mbVersion);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getLnAcl() { return lnAcl; }
	public: void setLnAcl(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// DocMaskLineTemplate
// typeId=117741089

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// This class contains data for a document mask line template.
/// </summary>
class DocMaskLineTemplate : public ValueClass {
	/// <summary>
	/// Last update time of the storage template data.
	/// </summary>
	protected: ::std::wstring TStamp;
	/// <summary>
	/// Timestamp of this object's last export by the replication.
	/// </summary>
	protected: ::std::wstring TStampSync;
	/// <summary>
	/// User ID of the user that has locked the mask line template.
	/// </summary>
	/// <remarks>
	/// If -1, no lock is held.
	/// </remarks>
	protected: int32_t lockId;
	/// <summary>
	/// Quickinfo text for the attribute.
	/// </summary>
	protected: ::std::wstring comment;
	/// <summary>
	/// The ID of the line information.
	/// </summary>
	protected: int32_t id;
	/// <summary>
	/// The attribute group name.
	/// </summary>
	/// <remarks>
	/// This member corresponds to <code>ObjKey.name</code>.
	/// </remarks>
	protected: ::std::wstring key;
	/// <summary>
	/// The maximum value of this attribute.
	/// </summary>
	protected: int32_t max;
	/// <summary>
	/// The minimum value of this attribute.
	/// </summary>
	protected: int32_t min;
	/// <summary>
	/// The name of the attribute.
	/// </summary>
	/// <remarks>
	/// This value is displayed in the lable before the edit field.
	/// It can be translated into reps. from the users language:
	/// set <code>SessionOptionsC.TRANSLATE_TERM</code>.
	/// </remarks>
	protected: ::std::wstring name;
	/// <summary>
	/// Access control for mask line.
	/// </summary>
	/// <remarks>
	/// Currently this can only be null or one item representing a key.
	/// </remarks>
	protected: PArrayAclItem aclItems;
	/// <summary>
	/// This value should not be displayed to the user.
	/// </summary>
	protected: bool hidden;
	/// <summary>
	/// The index line can only contain buzzwords.
	/// </summary>
	protected: bool onlyBuzzwords;
	/// <summary>
	/// Add "*" after index value in search operation.
	/// </summary>
	protected: bool postfixAsterix;
	/// <summary>
	/// Add "*" before index value in search operation.
	/// </summary>
	protected: bool prefixAsterix;
	/// <summary>
	/// This value should not be edited in a user interface (convention).
	/// </summary>
	/// <remarks>
	/// Scripts are allowed to edit the value.
	/// </remarks>
	protected: bool readOnly;
	/// <summary>
	/// The type of the line information.
	/// </summary>
	/// <remarks>
	/// This can be one of the <code>DocMaskLineC.TYPE_*</code> constants.
	/// </remarks>
	protected: int32_t type;
	/// <summary>
	/// External data.
	/// </summary>
	/// <remarks>
	/// Can be used to store an arbitary string.
	/// </remarks>
	protected: ::std::wstring externalData;
	/// <summary>
	/// Display index value next to the objects short description.
	/// </summary>
	/// <remarks>
	/// This element has to be interpreted by the client application.
	/// IndexServer ignores this value.
	/// </remarks>
	protected: bool important;
	/// <summary>
	/// Defines whether a index value should be searchable as TOKENIZED or UN_TOKENIZED
	/// </summary>
	protected: bool notTokenized;
	/// <summary>
	/// If true a index value will not be searchable via iSearch.
	/// </summary>
	/// <remarks>
	/// Does not affect the index search.
	/// </remarks>
	protected: bool excludeFromISearch;
	/// <summary>
	/// Display index value in version information dialog when
	/// checking in a document.
	/// </summary>
	/// <remarks>
	/// This element has to be interpreted by the client application.
	/// IndexServer ignores this value.
	/// </remarks>
	protected: bool version;
	/// <summary>
	/// Translate index values into or from the users language.
	/// </summary>
	protected: bool translate;
	/// <summary>
	/// Access control for mask line.
	/// </summary>
	protected: ::std::wstring acl;
	/// <summary>
	/// Disable word wheel.
	/// </summary>
	/// <remarks>
	/// Clients should not provide a function to list all
	/// existing values for this index vlaue.
	/// The IndexServer does not set or test this value.
	/// </remarks>
	protected: bool disableWordWheel;
	/// <summary>
	/// This value is assigned to the ObjKey.data element for a new Sord object.
	/// </summary>
	protected: ::std::wstring defaultValue;
	/// <summary>
	/// A script at the server can serve as the data source of a dynamic keyword
	/// list.
	/// </summary>
	/// <remarks>
	/// This value represents the name of that script. If the value is not
	/// empty, the client can request a list of available input values by calling
	/// the function {@link IXServicePortIF#checkoutKeywordsDynamic(ClientInfo, KeywordsDynamicInfo)}.
	/// </remarks>
	protected: ::std::wstring serverScriptName;
	/// <summary>
	/// Inherit this keywording field to subordinated entries.
	/// </summary>
	/// <remarks>
	/// <p>
	/// This option is used to make sure, that all entries in an archive sub-tree
	/// have the same value for this keywording field. Thereby the field is identified
	/// by its group name ({@link DocMaskLine#key} and {@link ObjKey#name}).
	/// </p><p>
	/// The option corresponds to {@link #inheritFromParent}. As far as {@link #inheritFromParent} is also true
	/// in the keywording forms definition of all sub-items, the option {@link #inherit} effects the following:
	/// <ul><li>The value of the keywording field can only be changed in the parent entry
	/// of the sub-tree. This is the uppermost entry that has the field, which means that the parent's
	/// parent does not have this field.
	/// </li><li>
	/// All sub-items of the parent inherit this value
	/// during a background process. The value is forwarded recursively to the entire
	/// sub-tree under the parent. The recursion stops at items that are assigned to a keywording form
	/// without this field.
	/// </li><li>
	/// When a child entry under the parent is updated, this field is always corrected to the parent's value.
	/// </li><li>
	/// For an object moved into a parent, the object and all sub-items inherit
	/// the keywording field.
	/// </li></ul>
	/// </p><p>
	/// If {@link #inheritFromParent} is false in the keywording form definition of a sub-item, inheritance stops for
	/// the sub-item. Thus, the index field is treated as a different field although it has the same group name.
	/// </p>
	/// </remarks>
	protected: bool inherit;
	/// <summary>
	/// Do not inherit the parent's value.
	/// </summary>
	protected: bool inheritFromParent;
	/// <summary>
	/// Translation-keyword for {@link DocMaskLine#name}.
	/// </summary>
	protected: ::std::wstring nameTranslationKey;
	/// <summary>
	/// Translation-keyword for {@link DocMaskLine#comment}.
	/// </summary>
	protected: ::std::wstring commentTranslationKey;
	/// <summary>
	/// Name of the user that has locked the mask line template.
	/// </summary>
	/// <remarks>
	/// Read-only, ignored in checkinDocMaskLineTemplate.
	/// </remarks>
	protected: ::std::wstring lockName;
	/// <summary>
	/// RegEx to validate user input for entry.
	/// </summary>
	protected: ::std::wstring validateExpression;
	/// <summary>
	/// Entry is required.
	/// </summary>
	protected: bool required;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: DocMaskLineTemplate();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: DocMaskLineTemplate(const ::std::wstring& TStamp, const ::std::wstring& TStampSync, int32_t lockId, const ::std::wstring& comment, int32_t id, const ::std::wstring& key, int32_t max, int32_t min, const ::std::wstring& name, const PArrayAclItem& aclItems, bool hidden, bool onlyBuzzwords, bool postfixAsterix, bool prefixAsterix, bool readOnly, int32_t type, const ::std::wstring& externalData, bool important, bool notTokenized, bool excludeFromISearch, bool version, bool translate, const ::std::wstring& acl, bool disableWordWheel, const ::std::wstring& defaultValue, const ::std::wstring& serverScriptName, bool inherit, bool inheritFromParent, const ::std::wstring& nameTranslationKey, const ::std::wstring& commentTranslationKey, const ::std::wstring& lockName, const ::std::wstring& validateExpression, bool required);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: ::std::wstring getTStamp() { return TStamp; }
	public: void setTStamp(::std::wstring v);
	public: ::std::wstring getTStampSync() { return TStampSync; }
	public: void setTStampSync(::std::wstring v);
	public: int32_t getLockId() { return lockId; }
	public: void setLockId(int32_t v);
	public: ::std::wstring getComment() { return comment; }
	public: void setComment(::std::wstring v);
	public: int32_t getId() { return id; }
	public: void setId(int32_t v);
	public: ::std::wstring getKey() { return key; }
	public: void setKey(::std::wstring v);
	public: int32_t getMax() { return max; }
	public: void setMax(int32_t v);
	public: int32_t getMin() { return min; }
	public: void setMin(int32_t v);
	public: ::std::wstring getName() { return name; }
	public: void setName(::std::wstring v);
	public: PArrayAclItem getAclItems() { return aclItems; }
	public: void setAclItems(PArrayAclItem v);
	public: bool getHidden() { return hidden; }
	public: void setHidden(bool v);
	public: bool getOnlyBuzzwords() { return onlyBuzzwords; }
	public: void setOnlyBuzzwords(bool v);
	public: bool getPostfixAsterix() { return postfixAsterix; }
	public: void setPostfixAsterix(bool v);
	public: bool getPrefixAsterix() { return prefixAsterix; }
	public: void setPrefixAsterix(bool v);
	public: bool getReadOnly() { return readOnly; }
	public: void setReadOnly(bool v);
	public: int32_t getType() { return type; }
	public: void setType(int32_t v);
	public: ::std::wstring getExternalData() { return externalData; }
	public: void setExternalData(::std::wstring v);
	public: bool getImportant() { return important; }
	public: void setImportant(bool v);
	public: bool getNotTokenized() { return notTokenized; }
	public: void setNotTokenized(bool v);
	public: bool getExcludeFromISearch() { return excludeFromISearch; }
	public: void setExcludeFromISearch(bool v);
	public: bool getVersion() { return version; }
	public: void setVersion(bool v);
	public: bool getTranslate() { return translate; }
	public: void setTranslate(bool v);
	public: ::std::wstring getAcl() { return acl; }
	public: void setAcl(::std::wstring v);
	public: bool getDisableWordWheel() { return disableWordWheel; }
	public: void setDisableWordWheel(bool v);
	public: ::std::wstring getDefaultValue() { return defaultValue; }
	public: void setDefaultValue(::std::wstring v);
	public: ::std::wstring getServerScriptName() { return serverScriptName; }
	public: void setServerScriptName(::std::wstring v);
	public: bool getInherit() { return inherit; }
	public: void setInherit(bool v);
	public: bool getInheritFromParent() { return inheritFromParent; }
	public: void setInheritFromParent(bool v);
	public: ::std::wstring getNameTranslationKey() { return nameTranslationKey; }
	public: void setNameTranslationKey(::std::wstring v);
	public: ::std::wstring getCommentTranslationKey() { return commentTranslationKey; }
	public: void setCommentTranslationKey(::std::wstring v);
	public: ::std::wstring getLockName() { return lockName; }
	public: void setLockName(::std::wstring v);
	public: ::std::wstring getValidateExpression() { return validateExpression; }
	public: void setValidateExpression(::std::wstring v);
	public: bool getRequired() { return required; }
	public: void setRequired(bool v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// DocMaskLineTemplateDataC
// typeId=96404005

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// <p>Bit constants for members of DocMaskLineTemplate</p>
/// <p>Copyright: Copyright (c) 2003</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </summary>
class DocMaskLineTemplateDataC : public BSerializable {
	/// <summary>
	/// DB column: mlineno
	/// </summary>
	public: const static int64_t mbId = 1LL;
	/// <summary>
	/// DB column: linetype
	/// </summary>
	public: const static int64_t mbRawType = 2LL;
	/// <summary>
	/// DB column: linebez
	/// </summary>
	public: const static int64_t mbName = 4LL;
	/// <summary>
	/// DB column: linebez
	/// </summary>
	protected: int32_t lnName;
	/// <summary>
	/// DB column: linekey
	/// </summary>
	public: const static int64_t mbKey = 8LL;
	/// <summary>
	/// DB column: linekey
	/// </summary>
	protected: int32_t lnKey;
	/// <summary>
	/// DB column: linemin
	/// </summary>
	public: const static int64_t mbMin = 16LL;
	/// <summary>
	/// DB column: linemax
	/// </summary>
	public: const static int64_t mbMax = 32LL;
	/// <summary>
	/// DB column: linelock
	/// </summary>
	public: const static int64_t mbLockId = 64LL;
	/// <summary>
	/// DB column: linelkey
	/// </summary>
	public: const static int64_t mbLKey = 128LL;
	/// <summary>
	/// DB column: lineflags
	/// </summary>
	public: const static int64_t mbRawFlags = 256LL;
	/// <summary>
	/// DB column: linecomment
	/// </summary>
	public: const static int64_t mbComment = 512LL;
	/// <summary>
	/// DB column: linecomment
	/// </summary>
	protected: int32_t lnComment;
	/// <summary>
	/// DB column: linedefault
	/// </summary>
	public: const static int64_t mbDefaultValue = 1024LL;
	/// <summary>
	/// DB column: linedefault
	/// </summary>
	protected: int32_t lnDefaultValue;
	/// <summary>
	/// DB column: lineext
	/// </summary>
	public: const static int64_t mbExternalData = 2048LL;
	/// <summary>
	/// DB column: lineext
	/// </summary>
	protected: int32_t lnExternalData;
	/// <summary>
	/// DB column: lineacl
	/// </summary>
	public: const static int64_t mbInternalAcl = 4096LL;
	/// <summary>
	/// DB column: lineacl
	/// </summary>
	protected: int32_t lnInternalAcl;
	/// <summary>
	/// DB column: linecommenttrkey
	/// </summary>
	public: const static int64_t mbCommentTranslationKey = 8192LL;
	/// <summary>
	/// DB column: linecommenttrkey
	/// </summary>
	protected: int32_t lnCommentTranslationKey;
	/// <summary>
	/// DB column: linebeztrkey
	/// </summary>
	public: const static int64_t mbNameTranslationKey = 16384LL;
	/// <summary>
	/// DB column: linebeztrkey
	/// </summary>
	protected: int32_t lnNameTranslationKey;
	/// <summary>
	/// DB column: linescript
	/// </summary>
	public: const static int64_t mbServerScriptName = 32768LL;
	/// <summary>
	/// DB column: linescript
	/// </summary>
	protected: int32_t lnServerScriptName;
	/// <summary>
	/// DB column: linetstamp
	/// </summary>
	public: const static int64_t mbTStamp = 65536LL;
	/// <summary>
	/// DB column: linetstamp
	/// </summary>
	protected: int32_t lnTStamp;
	/// <summary>
	/// DB column: linetstampsync
	/// </summary>
	public: const static int64_t mbTStampSync = 131072LL;
	/// <summary>
	/// DB column: linetstampsync
	/// </summary>
	protected: int32_t lnTStampSync;
	/// <summary>
	/// Member bit: RegEx to validate user input for entry.
	/// </summary>
	/// <remarks>
	/// DB column: validateexpression
	/// </remarks>
	public: const static int64_t mbValidateExpression = 262144LL;
	/// <summary>
	/// Column length: RegEx to validate user input for entry.
	/// </summary>
	/// <remarks>
	/// DB column: validateexpression
	/// </remarks>
	protected: int32_t lnValidateExpression;
	/// <summary>
	/// All valid member bits.
	/// </summary>
	public: const static int64_t mbAllMembers = 524287LL;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: DocMaskLineTemplateDataC();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: DocMaskLineTemplateDataC(int64_t mbId, int64_t mbRawType, int64_t mbName, int32_t lnName, int64_t mbKey, int32_t lnKey, int64_t mbMin, int64_t mbMax, int64_t mbLockId, int64_t mbLKey, int64_t mbRawFlags, int64_t mbComment, int32_t lnComment, int64_t mbDefaultValue, int32_t lnDefaultValue, int64_t mbExternalData, int32_t lnExternalData, int64_t mbInternalAcl, int32_t lnInternalAcl, int64_t mbCommentTranslationKey, int32_t lnCommentTranslationKey, int64_t mbNameTranslationKey, int32_t lnNameTranslationKey, int64_t mbServerScriptName, int32_t lnServerScriptName, int64_t mbTStamp, int32_t lnTStamp, int64_t mbTStampSync, int32_t lnTStampSync, int64_t mbValidateExpression, int32_t lnValidateExpression, int64_t mbAllMembers);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getLnName() { return lnName; }
	public: void setLnName(int32_t v);
	public: int32_t getLnKey() { return lnKey; }
	public: void setLnKey(int32_t v);
	public: int32_t getLnComment() { return lnComment; }
	public: void setLnComment(int32_t v);
	public: int32_t getLnDefaultValue() { return lnDefaultValue; }
	public: void setLnDefaultValue(int32_t v);
	public: int32_t getLnExternalData() { return lnExternalData; }
	public: void setLnExternalData(int32_t v);
	public: int32_t getLnInternalAcl() { return lnInternalAcl; }
	public: void setLnInternalAcl(int32_t v);
	public: int32_t getLnCommentTranslationKey() { return lnCommentTranslationKey; }
	public: void setLnCommentTranslationKey(int32_t v);
	public: int32_t getLnNameTranslationKey() { return lnNameTranslationKey; }
	public: void setLnNameTranslationKey(int32_t v);
	public: int32_t getLnServerScriptName() { return lnServerScriptName; }
	public: void setLnServerScriptName(int32_t v);
	public: int32_t getLnTStamp() { return lnTStamp; }
	public: void setLnTStamp(int32_t v);
	public: int32_t getLnTStampSync() { return lnTStampSync; }
	public: void setLnTStampSync(int32_t v);
	public: int32_t getLnValidateExpression() { return lnValidateExpression; }
	public: void setLnValidateExpression(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// DocMaskLineTemplateC
// typeId=984407269

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// <p>Constants related to class <code>DocMaskLineTemplate</code>.
/// </summary>
class DocMaskLineTemplateC : public DocMaskLineTemplateDataC {
	/// <summary>
	/// Member bit: The type of the line information.
	/// </summary>
	/// <remarks>
	/// This can be one of the <code>DocMaskLineC.LINETYPE_*</code> constants.
	/// </remarks>
	public: const static int64_t mbType = 2LL;
	/// <summary>
	/// Member bit: Line flags
	/// </summary>
	public: const static int64_t mbFlags = 256LL;
	/// <summary>
	/// Member bit: ACL
	/// </summary>
	public: const static int64_t mbAcl = 4096LL;
	/// <summary>
	/// Only lock or unlock
	/// </summary>
	public: const static PDocMaskLineTemplateZ mbOnlyLock;
	/// <summary>
	/// Read or write all elements.
	/// </summary>
	public: const static PDocMaskLineTemplateZ mbAll;
	/// <summary>
	/// ACL length
	/// </summary>
	protected: int32_t lnAcl;
	public: const static int64_t mbAclItems = 4096LL;
	public: const static int64_t mbHidden = 256LL;
	public: const static int64_t mbOnlyBuzzwords = 256LL;
	public: const static int64_t mbPostfixAsterix = 256LL;
	public: const static int64_t mbPrefixAsterix = 256LL;
	public: const static int64_t mbReadOnly = 256LL;
	public: const static int64_t mbTranslate = 256LL;
	public: const static int64_t mbImportant = 256LL;
	public: const static int64_t mbVersion = 256LL;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: DocMaskLineTemplateC();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: DocMaskLineTemplateC(int64_t mbType, int64_t mbFlags, int64_t mbAcl, const PDocMaskLineTemplateZ& mbOnlyLock, const PDocMaskLineTemplateZ& mbAll, int32_t lnAcl, int64_t mbAclItems, int64_t mbHidden, int64_t mbOnlyBuzzwords, int64_t mbPostfixAsterix, int64_t mbPrefixAsterix, int64_t mbReadOnly, int64_t mbTranslate, int64_t mbImportant, int64_t mbVersion);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getLnAcl() { return lnAcl; }
	public: void setLnAcl(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// DocMaskLineTemplateZ
// typeId=1687510263

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// This class encapsulates the constants of the DocMaskLineTemplateC class.
/// </summary>
class DocMaskLineTemplateZ : public ValueClass {
	protected: int64_t bset;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: DocMaskLineTemplateZ();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: DocMaskLineTemplateZ(int64_t bset);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int64_t getBset() { return bset; }
	public: void setBset(int64_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// DocMaskZ
// typeId=1064616030

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// This class encapsulates the constants of the DocMaskC class.
/// </summary>
/// <remarks>
/// <p>Copyright: Copyright (c) 2004</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </remarks>
class DocMaskZ : public ValueClass {
	/// <summary>
	/// Bitset field for constants from the DocMaskC class.
	/// </summary>
	protected: int64_t bset;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: DocMaskZ();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: DocMaskZ(int64_t bset);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int64_t getBset() { return bset; }
	public: void setBset(int64_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// DocVersion
// typeId=633004623

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// <p>Description: This class describes a document version, a document preview
/// or a signature.
/// </summary>
/// <remarks>
/// </p>
/// <p>Copyright: Copyright (c) 2002</p>
/// <p>Organisation: ELO DIgital Office GmbH</p>
/// </remarks>
class DocVersion : public ValueClass {
	/// <summary>
	/// Last access date.
	/// </summary>
	/// <remarks>
	/// ClientInfo determines the Timezone.
	/// <p>Applies to document version and signature.
	/// Is undefined for preview and fulltextContent.</p>
	/// </remarks>
	protected: ::std::wstring accessDateIso;
	/// <summary>
	/// Version comment
	/// <p>Applies to document version.
	/// </summary>
	/// <remarks>
	/// Is undefined for signature, preview and fulltextContent.</p>
	/// </remarks>
	protected: ::std::wstring comment;
	/// <summary>
	/// Create date.
	/// </summary>
	/// <remarks>
	/// ClientInfo determines the Timezone.
	/// <p>Applies to document version and signature.
	/// Is undefined for preview and fulltextContent.</p>
	/// </remarks>
	protected: ::std::wstring createDateIso;
	/// <summary>
	/// Indicates whether the version is logically deleted.
	/// </summary>
	/// <remarks>
	/// <p>Applies to document version.
	/// Is undefined for signature, preview and fulltextContent.</p>
	/// </remarks>
	protected: bool deleted;
	/// <summary>
	/// Document file extension (without ".")
	/// </summary>
	/// <remarks>
	/// <p>Applies to document version, signature and preview.
	/// Is readonly for fulltextContent.</p>
	/// This value has precedence before <code>contentType</code>.
	/// </remarks>
	protected: ::std::wstring ext;
	/// <summary>
	/// Content-Type (MIME-Type).
	/// </summary>
	protected: ::std::wstring contentType;
	/// <summary>
	/// Document, preview or fulltextContent file content.
	/// </summary>
	/// <remarks>
	/// If <code>checkoutDoc</code> is called with option
	/// <code>mbSordDocSmallContent</code> and the requested document (version) is small (less than
	/// the configured value), this member contains the file data and content type. If
	/// <code>mbPreview</code> is additionally set, <code>fileData</code> contains the content of
	/// the preview - REGARDLESS of the size. In case there is no preview, <code>fileData</code>
	/// contains the data of the document (if it's a small file).
	/// <p>Applies to document version, signature and preview.</p>
	/// </remarks>
	protected: PFileData fileData;
	/// <summary>
	/// Document GUID.
	/// </summary>
	/// <remarks>
	/// <p>Applies to document version and signature. Is undefined for preview and fulltextContent.</p>
	/// </remarks>
	protected: ::std::wstring guid;
	/// <summary>
	/// Document ID
	/// <p>Applies to document version and signature.
	/// </summary>
	/// <remarks>
	/// Is undefined for preview and fulltextContent.</p>
	/// </remarks>
	protected: int32_t id;
	/// <summary>
	/// MD5 hash of the documet file.
	/// </summary>
	/// <remarks>
	/// <p>Applies to document version and signature. Is undefined for preview and fulltextContent.</p>
	/// </remarks>
	protected: ::std::wstring md5;
	/// <summary>
	/// Indicates whether the version is marked as a milestone version.
	/// </summary>
	/// <remarks>
	/// <p>Applies to document version. Is undefined for signature and preview and fulltextContent.</p>
	/// </remarks>
	protected: bool milestone;
	/// <summary>
	/// The owners user ID.
	/// </summary>
	/// <remarks>
	/// <p>Applies to document version. Is undefined for signature and preview and fulltextContent.</p>
	/// </remarks>
	protected: int32_t ownerId;
	/// <summary>
	/// The owners user name.
	/// </summary>
	/// <remarks>
	/// This value is read only (ignored in checkinDoc...).
	/// <p>Applies to document version. Is undefined for signature and preview and fulltextContent.</p>
	/// </remarks>
	protected: ::std::wstring ownerName;
	/// <summary>
	/// Storage path ID
	/// <p>Applies to document version and signature.
	/// </summary>
	/// <remarks>
	/// Is undefined for preview and fulltextContent.</p>
	/// </remarks>
	protected: int32_t pathId;
	/// <summary>
	/// (to be defined)
	/// <p>Applies to document version and signature.
	/// </summary>
	/// <remarks>
	/// Is undefined for preview and fulltextContent.</p>
	/// </remarks>
	protected: int32_t pathId2;
	/// <summary>
	/// Physical path
	/// <p>Applies to document version and signature.
	/// </summary>
	/// <remarks>
	/// Is undefined for preview and fulltextContent.</p>
	/// Set SordC.mbPhysPath or EditInfoC.mbPhysPath in the member selector
	/// passed to checkoutSord or checkoutDoc to read the physical path.
	/// </remarks>
	protected: ::std::wstring physPath;
	/// <summary>
	/// <p>URL to up-/download a document preview.
	/// </summary>
	/// <remarks>
	/// </p>
	/// <p>Applies to document version. Is empty for signature and preview and fulltextContent.</p>
	/// </remarks>
	protected: ::std::wstring previewUrl;
	/// <summary>
	/// Document signature
	/// <p>Applies to document version.
	/// </summary>
	/// <remarks>
	/// Is null for signature and preview and fulltextContent.</p>
	/// </remarks>
	protected: PDocVersion sig;
	/// <summary>
	/// Document preview
	/// <p>Applies to document version.
	/// </summary>
	/// <remarks>
	/// Is null for signature and preview and fulltextContent.</p>
	/// </remarks>
	protected: PDocVersion preview;
	/// <summary>
	/// File size.
	/// </summary>
	protected: int64_t size;
	/// <summary>
	/// Document timestamp
	/// <p>Applies to document version and signature.
	/// </summary>
	/// <remarks>
	/// Is undefined for preview. (Is available for fulltextContent)</p>
	/// The format is JJJJ.MM.DD.hh.mm.ss
	/// </remarks>
	protected: ::std::wstring tStamp;
	/// <summary>
	/// Last update date.
	/// </summary>
	/// <remarks>
	/// ClientInfo determines the Timezone.
	/// <p>Applies to document version and signature. Is undefined for preview and fulltextContent.</p>
	/// </remarks>
	protected: ::std::wstring updateDateIso;
	/// <summary>
	/// Result from the ELODM if the document was uploaded.
	/// </summary>
	/// <remarks>
	/// <p>Applies to document version, signature, preview and fulltextContent.</p>
	/// </remarks>
	protected: ::std::wstring uploadResult;
	/// <summary>
	/// URL to up-/download
	/// <p>Applies to document version, signature,preview and fulltextContent.
	/// </summary>
	/// <remarks>
	/// </p>
	/// </remarks>
	protected: ::std::wstring url;
	/// <summary>
	/// Version number
	/// <p>Applies to document version.
	/// </summary>
	/// <remarks>
	/// Is undefined for signature, preview and fulltextContent.</p>
	/// </remarks>
	protected: ::std::wstring version;
	/// <summary>
	/// Indicates whether the version is the current work version.
	/// </summary>
	/// <remarks>
	/// <p>Applies to document version. Is undefined for signature, preview and fulltextContent.</p>
	/// </remarks>
	protected: bool workVersion;
	/// <summary>
	/// ID of the encryption set.
	/// </summary>
	/// <remarks>
	/// It's password is used to encrypt or decrypt the document.
	/// It a new document or version should be checked in, this member must be set
	/// to Sord.details.encryptionSet before checkinDocBegin is called.
	/// When this object is retrieved via IX it is always set to Sord.details.encryptionSet.
	/// <p>Applies to document version. Is undefined for signature, preview and fulltextContent.</p>
	/// </remarks>
	protected: int32_t encryptionSet;
	/// <summary>
	/// This object provides the content of the fulltext database for the document version.
	/// </summary>
	/// <remarks>
	/// The information is read-only and only available for DocVersion objects that refer to
	/// a document version (and not an attachment, preview or signature).
	/// Currenly, only the members url, ext, contentType and encryptionSet are valid vor a DocVersion object
	/// that belongs to fulltext content. Whereby ext is always txt and contentType is always text/plain.
	/// A Byte Order Mark preceedes the content data.
	/// If the related document version is encrypted, the appropriate encryption password
	/// has to be set, before the fulltext information can be downloaded.
	/// If the SessionOptionC.DECRYPT_DOCUMENTS is not set, the fulltext information is transmitted
	/// encrypted.
	/// <p>Applies to document version. Is undefined for signature and preview.</p>
	/// </remarks>
	protected: PDocVersion fulltextContent;
	/// <summary>
	/// Delete date.
	/// </summary>
	/// <remarks>
	/// ClientInfo determines the Timezone.
	/// <p>Is undefined if isDeleted() returns false.</p>
	/// </remarks>
	protected: ::std::wstring deleteDateIso;
	/// <summary>
	/// Number of valid signatures.
	/// </summary>
	/// <remarks>
	/// This member holds the count of valid signatures in the signature file.
	/// It is only valid for a DocVersion object that represents a signature (member {@link #sig}).
	/// A value of zero means, that the signatures are unchecked. A number greater than zero means,
	/// that all signatures are valid. In this case the member value is equal to the number of signatures.
	/// If at least one signature is invalid, the value is less than zero. The number of invalid signatures is thereby unknown.
	/// Client applications are responsible to check signatures. The ELOix does not check signatures.
	/// </remarks>
	protected: int32_t nbOfValidSignatures;
	/// <summary>
	/// Relative file path for external file.
	/// </summary>
	/// <remarks>
	/// This member specifies the location of the file relative to a custom path.
	/// If {@link #pathId} does not refer a custom path, this member is empty and ignored in {@link IXServicePortIF#checkinDocEnd(ClientInfo, Sord, SordZ, Document, LockZ)}.
	/// </remarks>
	protected: ::std::wstring relativeFilePath;
	/// <summary>
	/// Timestamp of this object's ACLs last export by the replication.
	/// </summary>
	protected: ::std::wstring tStampSync;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: DocVersion();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: DocVersion(const ::std::wstring& accessDateIso, const ::std::wstring& comment, const ::std::wstring& createDateIso, bool deleted, const ::std::wstring& ext, const ::std::wstring& contentType, const PFileData& fileData, const ::std::wstring& guid, int32_t id, const ::std::wstring& md5, bool milestone, int32_t ownerId, const ::std::wstring& ownerName, int32_t pathId, int32_t pathId2, const ::std::wstring& physPath, const ::std::wstring& previewUrl, const PDocVersion& sig, const PDocVersion& preview, int64_t size, const ::std::wstring& tStamp, const ::std::wstring& updateDateIso, const ::std::wstring& uploadResult, const ::std::wstring& url, const ::std::wstring& version, bool workVersion, int32_t encryptionSet, const PDocVersion& fulltextContent, const ::std::wstring& deleteDateIso, int32_t nbOfValidSignatures, const ::std::wstring& relativeFilePath, const ::std::wstring& tStampSync);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: ::std::wstring getAccessDateIso() { return accessDateIso; }
	public: void setAccessDateIso(::std::wstring v);
	public: ::std::wstring getComment() { return comment; }
	public: void setComment(::std::wstring v);
	public: ::std::wstring getCreateDateIso() { return createDateIso; }
	public: void setCreateDateIso(::std::wstring v);
	public: bool getDeleted() { return deleted; }
	public: void setDeleted(bool v);
	public: ::std::wstring getExt() { return ext; }
	public: void setExt(::std::wstring v);
	public: ::std::wstring getContentType() { return contentType; }
	public: void setContentType(::std::wstring v);
	public: PFileData getFileData() { return fileData; }
	public: void setFileData(PFileData v);
	public: ::std::wstring getGuid() { return guid; }
	public: void setGuid(::std::wstring v);
	public: int32_t getId() { return id; }
	public: void setId(int32_t v);
	public: ::std::wstring getMd5() { return md5; }
	public: void setMd5(::std::wstring v);
	public: bool getMilestone() { return milestone; }
	public: void setMilestone(bool v);
	public: int32_t getOwnerId() { return ownerId; }
	public: void setOwnerId(int32_t v);
	public: ::std::wstring getOwnerName() { return ownerName; }
	public: void setOwnerName(::std::wstring v);
	public: int32_t getPathId() { return pathId; }
	public: void setPathId(int32_t v);
	public: int32_t getPathId2() { return pathId2; }
	public: void setPathId2(int32_t v);
	public: ::std::wstring getPhysPath() { return physPath; }
	public: void setPhysPath(::std::wstring v);
	public: ::std::wstring getPreviewUrl() { return previewUrl; }
	public: void setPreviewUrl(::std::wstring v);
	public: PDocVersion getSig() { return sig; }
	public: void setSig(PDocVersion v);
	public: PDocVersion getPreview() { return preview; }
	public: void setPreview(PDocVersion v);
	public: int64_t getSize() { return size; }
	public: void setSize(int64_t v);
	public: ::std::wstring getTStamp() { return tStamp; }
	public: void setTStamp(::std::wstring v);
	public: ::std::wstring getUpdateDateIso() { return updateDateIso; }
	public: void setUpdateDateIso(::std::wstring v);
	public: ::std::wstring getUploadResult() { return uploadResult; }
	public: void setUploadResult(::std::wstring v);
	public: ::std::wstring getUrl() { return url; }
	public: void setUrl(::std::wstring v);
	public: ::std::wstring getVersion() { return version; }
	public: void setVersion(::std::wstring v);
	public: bool getWorkVersion() { return workVersion; }
	public: void setWorkVersion(bool v);
	public: int32_t getEncryptionSet() { return encryptionSet; }
	public: void setEncryptionSet(int32_t v);
	public: PDocVersion getFulltextContent() { return fulltextContent; }
	public: void setFulltextContent(PDocVersion v);
	public: ::std::wstring getDeleteDateIso() { return deleteDateIso; }
	public: void setDeleteDateIso(::std::wstring v);
	public: int32_t getNbOfValidSignatures() { return nbOfValidSignatures; }
	public: void setNbOfValidSignatures(int32_t v);
	public: ::std::wstring getRelativeFilePath() { return relativeFilePath; }
	public: void setRelativeFilePath(::std::wstring v);
	public: ::std::wstring getTStampSync() { return tStampSync; }
	public: void setTStampSync(::std::wstring v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// DocVersionC
// typeId=615288749

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

class DocVersionC : public BSerializable {
	/// <summary>
	/// This value should be set in DocVersion.uploadResult, if
	/// preview creation fails.
	/// </summary>
	public: const static ::std::wstring UPLOAD_RESULT_ERROR;
	/// <summary>
	/// URL parameter offset.
	/// </summary>
	/// <remarks>
	/// Used to read a file at a particular offset.
	/// Do not position offset after the length of the file.
	/// Example: String readUrl = docVersion.url + "&" + URL_PARAM_OFFSET + "=" + 123;
	/// </remarks>
	public: const static ::std::wstring URL_PARAM_OFFSET;
	/// <summary>
	/// URL parameter length.
	/// </summary>
	/// <remarks>
	/// Used to read length bytes from a file.
	/// Do not read more bytes than the legnth of the file.
	/// Example: String readUrl = docVersion.url + "&" + URL_PARAM_LENGTH + "=" + 123;
	/// </remarks>
	public: const static ::std::wstring URL_PARAM_LENGTH;
	/// <summary>
	/// URL parameter create date.
	/// </summary>
	/// <remarks>
	/// Used to set the create date of the file.
	/// ISO date in UTC timezone.
	/// Example: String writeUrl = docVersion.url + "&" + URL_PARAM_CREATE_DATE + "=" + 20010203040506;
	/// </remarks>
	public: const static ::std::wstring URL_PARAM_CREATE_DATE;
	/// <summary>
	/// URL parameter last write date.
	/// </summary>
	/// <remarks>
	/// Used to set the last write time of the file.
	/// ISO date in UTC timezone.
	/// Example: String writeUrl = docVersion.url + "&" + URL_PARAM_LAST_UPDATE + "=" + 20010203040506;
	/// </remarks>
	public: const static ::std::wstring URL_PARAM_LAST_UPDATE;
	/// <summary>
	/// URL parameter last access date.
	/// </summary>
	/// <remarks>
	/// Used to set the last access time of the file.
	/// ISO date in UTC timezone.
	/// Example: String writeUrl = docVersion.url + "&" + URL_PARAM_LAST_ACCESS + "=" + 20010203040506;
	/// </remarks>
	public: const static ::std::wstring URL_PARAM_LAST_ACCESS;
	/// <summary>
	/// Document versions marked with this flag cannot be deleted.
	/// </summary>
	public: const static int32_t FLAG_MILESTONE = 1;
	public: const static int32_t TYPE_DOCVERSION = 1;
	public: const static int32_t TYPE_ATTACHMENT = 2;
	/// <summary>
	/// Length of version comment.
	/// </summary>
	protected: int32_t lnComment;
	/// <summary>
	/// Length of version number (like 1.0).
	/// </summary>
	protected: int32_t lnVersion;
	/// <summary>
	/// Length of file extension.
	/// </summary>
	protected: int32_t lnExt;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: DocVersionC();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: DocVersionC(const ::std::wstring& UPLOAD_RESULT_ERROR, const ::std::wstring& URL_PARAM_OFFSET, const ::std::wstring& URL_PARAM_LENGTH, const ::std::wstring& URL_PARAM_CREATE_DATE, const ::std::wstring& URL_PARAM_LAST_UPDATE, const ::std::wstring& URL_PARAM_LAST_ACCESS, int32_t FLAG_MILESTONE, int32_t TYPE_DOCVERSION, int32_t TYPE_ATTACHMENT, int32_t lnComment, int32_t lnVersion, int32_t lnExt);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getLnComment() { return lnComment; }
	public: void setLnComment(int32_t v);
	public: int32_t getLnVersion() { return lnVersion; }
	public: void setLnVersion(int32_t v);
	public: int32_t getLnExt() { return lnExt; }
	public: void setLnExt(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// Document
// typeId=341056676

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Document object with identifier and version arrays for
/// the document and attachments.
/// </summary>
/// <remarks>
/// <p>Copyright: Copyright (c) 2004</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </remarks>
class Document : public ValueClass {
	/// <summary>
	/// Attachment versions for the document.
	/// </summary>
	protected: PArrayDocVersion atts;
	/// <summary>
	/// Versions of the document.
	/// </summary>
	protected: PArrayDocVersion docs;
	/// <summary>
	/// Object ID for the document.
	/// </summary>
	protected: ::std::wstring objId;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: Document();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: Document(const PArrayDocVersion& atts, const PArrayDocVersion& docs, const ::std::wstring& objId);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: PArrayDocVersion getAtts() { return atts; }
	public: void setAtts(PArrayDocVersion v);
	public: PArrayDocVersion getDocs() { return docs; }
	public: void setDocs(PArrayDocVersion v);
	public: ::std::wstring getObjId() { return objId; }
	public: void setObjId(::std::wstring v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// EditInfo
// typeId=820228328

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Contains data to edit the indexing information.
/// </summary>
/// <remarks>
/// Therfore it provides storage
/// mask names, storage path names, marker names, document template names,
/// replication set names, document version information, etc.
/// 
/// <p>Copyright: Copyright (c) 2004</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </remarks>
class EditInfo : public ValueClass {
	/// <summary>
	/// Document template names (Template files for new documents).
	/// </summary>
	protected: PArrayIdName docTemplates;
	/// <summary>
	/// Document or attachment information.
	/// </summary>
	protected: PDocument document;
	/// <summary>
	/// Root keywords with first level of keywords below.
	/// </summary>
	/// <remarks>
	/// <p>
	/// <table border="2">
	/// <tr><td rowspan="4">for documents, keyword[.].id is one of: </td><td>KeywordC.KWID_STANDARD_LIST, Standard keyword list</td></tr>
	/// <tr><td>KeywordC.KWID_VERSION, Version number keyword list</td></tr>
	/// <tr><td>KeywordC.KWID_VERSION_COMMENT, Version comment keyword list</td></tr>
	/// <tr><td>Keyword lists of storage mask</td></tr>
	/// <tr><td rowspan="2">for non-documents, keyword[.].id is one of: </td><td>KeywordC.KWID_STANDARD_LIST, Standard keyword list</td></tr>
	/// <tr><td>Keyword lists of storage mask</td></tr>
	/// </table>
	/// </p>
	/// </remarks>
	protected: PArrayKeyword keywords;
	/// <summary>
	/// Marker names (Colours).
	/// </summary>
	protected: PArrayIdName markerNames;
	/// <summary>
	/// Document mask data of the mask selected in <code>sord</code>.
	/// </summary>
	protected: PDocMask mask;
	/// <summary>
	/// Storage mask names.
	/// </summary>
	protected: PArrayMaskName maskNames;
	/// <summary>
	/// Notes.
	/// </summary>
	protected: PArrayNote notes;
	/// <summary>
	/// Storage path names.
	/// </summary>
	protected: PArrayIdName pathNames;
	/// <summary>
	/// Replication set names.
	/// </summary>
	protected: PArrayIdName replNames;
	/// <summary>
	/// Indexing information.
	/// </summary>
	protected: PSord sord;
	/// <summary>
	/// Sord types (labels, icons, extensions corresponding to Sord.type).
	/// </summary>
	protected: PArraySordType sordTypes;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: EditInfo();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: EditInfo(const PArrayIdName& docTemplates, const PDocument& document, const PArrayKeyword& keywords, const PArrayIdName& markerNames, const PDocMask& mask, const PArrayMaskName& maskNames, const PArrayNote& notes, const PArrayIdName& pathNames, const PArrayIdName& replNames, const PSord& sord, const PArraySordType& sordTypes);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: PArrayIdName getDocTemplates() { return docTemplates; }
	public: void setDocTemplates(PArrayIdName v);
	public: PDocument getDocument() { return document; }
	public: void setDocument(PDocument v);
	public: PArrayKeyword getKeywords() { return keywords; }
	public: void setKeywords(PArrayKeyword v);
	public: PArrayIdName getMarkerNames() { return markerNames; }
	public: void setMarkerNames(PArrayIdName v);
	public: PDocMask getMask() { return mask; }
	public: void setMask(PDocMask v);
	public: PArrayMaskName getMaskNames() { return maskNames; }
	public: void setMaskNames(PArrayMaskName v);
	public: PArrayNote getNotes() { return notes; }
	public: void setNotes(PArrayNote v);
	public: PArrayIdName getPathNames() { return pathNames; }
	public: void setPathNames(PArrayIdName v);
	public: PArrayIdName getReplNames() { return replNames; }
	public: void setReplNames(PArrayIdName v);
	public: PSord getSord() { return sord; }
	public: void setSord(PSord v);
	public: PArraySordType getSordTypes() { return sordTypes; }
	public: void setSordTypes(PArraySordType v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// EditInfoC
// typeId=2100880359

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// <p>Constants to read data for editing the indexing information of an archive entry</p>
/// </summary>
class EditInfoC : public BSerializable {
	/// <summary>
	/// Mask names.
	/// </summary>
	public: const static int64_t mbMaskNames = 1LL;
	/// <summary>
	/// Path names.
	/// </summary>
	public: const static int64_t mbPathNames = 2LL;
	/// <summary>
	/// Marker names (colors).
	/// </summary>
	public: const static int64_t mbMarkerNames = 4LL;
	/// <summary>
	/// RESERVED.
	/// </summary>
	/// <remarks>
	/// Document templates.
	/// </remarks>
	public: const static int64_t mbDocTemplates = 8LL;
	/// <summary>
	/// Complete data of the mask of the specified object.
	/// </summary>
	public: const static int64_t mbMask = 16LL;
	/// <summary>
	/// Information to download the document of the archive entry.
	/// </summary>
	public: const static int64_t mbDocumentMembers = 64LL;
	/// <summary>
	/// Information to download the attachment of the archive entry.
	/// </summary>
	public: const static int64_t mbAttachmentMembers = 128LL;
	/// <summary>
	/// Information to download the signature of the archive entry.
	/// </summary>
	public: const static int64_t mbSignatureMembers = 256LL;
	/// <summary>
	/// Names of all replication sets.
	/// </summary>
	public: const static int64_t mbReplNames = 512LL;
	/// <summary>
	/// List of Sord types (labels, icons, extensions corresponding to Sord.type).
	/// </summary>
	/// <remarks>
	/// Icon images are returned in JPEG format.
	/// </remarks>
	public: const static int64_t mbSordTypesJPG = 1024LL;
	/// <summary>
	/// Return notes in checkoutSord and checkoutDoc.
	/// </summary>
	public: const static int64_t mbNoteMembers = 2048LL;
	/// <summary>
	/// Return keywords in checkoutSord and checkoutDoc.
	/// </summary>
	public: const static int64_t mbKeywordMembers = 4096LL;
	/// <summary>
	/// Return document preview in checkoutDoc
	/// </summary>
	public: const static int64_t mbPreviewMembers = 8192LL;
	/// <summary>
	/// Return the physical path of the document in checkoutDoc.
	/// </summary>
	/// <remarks>
	/// This requires a request to Document Mangager.
	/// </remarks>
	public: const static int64_t mbPhysPath = 8192LL;
	/// <summary>
	/// All members: indexing information + basic data + document + attachment + signature
	/// </summary>
	public: const static int64_t mbAllMembers = 16383LL;
	/// <summary>
	/// Sord object with all members.
	/// </summary>
	public: const static PEditInfoZ mbSord;
	/// <summary>
	/// Sord object with all members, work version can be read from an InputStream.
	/// </summary>
	/// <remarks>
	/// File content is supplied in {@link Sord#docVersion}, {@link FileData#stream}.
	/// </remarks>
	public: const static PEditInfoZ mbSordContentStream;
	/// <summary>
	/// Sord object with lean members.
	/// </summary>
	public: const static PEditInfoZ mbSordLean;
	/// <summary>
	/// Sord object with SordC.mbAll, document versions, signatures.
	/// </summary>
	public: const static PEditInfoZ mbSordDoc;
	/// <summary>
	/// Sord object with SordC.mbAll, document versions, attachment versions, signatures.
	/// </summary>
	public: const static PEditInfoZ mbSordDocAtt;
	/// <summary>
	/// Sord object with SordC.mbAll, document versions, attachment versions, signatures.
	/// </summary>
	/// <remarks>
	/// File contents are supplied in {@link FileData#stream}.
	/// </remarks>
	public: const static PEditInfoZ mbSordDocAttContentStream;
	/// <summary>
	/// Includes
	/// mbDocumentMembers, mbSignatureMembers, SordC.mbCheckout
	/// </summary>
	public: const static PEditInfoZ mbSordDocSmallContent;
	/// <summary>
	/// Includes
	/// mbDocumentMembers|mbSignatureMembers, SordC.mbCheckoutPreview
	/// </summary>
	public: const static PEditInfoZ mbSordPreviewSmallContent;
	/// <summary>
	/// Document version(s) and signature, no index information
	/// </summary>
	public: const static PEditInfoZ mbDocument;
	/// <summary>
	/// Attachment version(s), no index information
	/// </summary>
	public: const static PEditInfoZ mbAttachment;
	/// <summary>
	/// All members
	/// without
	/// mbSmallDocumentContent
	/// </summary>
	public: const static PEditInfoZ mbAll;
	/// <summary>
	/// Arrays of mask, marker, repl, path names
	/// </summary>
	public: const static PEditInfoZ mbBasicData;
	/// <summary>
	/// Lock or unlock object, do not read or write any data.
	/// </summary>
	public: const static PEditInfoZ mbOnlyLock;
	/// <summary>
	/// Return only notes.
	/// </summary>
	public: const static PEditInfoZ mbNotes;
	/// <summary>
	/// Return all Sord members and notes.
	/// </summary>
	public: const static PEditInfoZ mbSordNotes;
	/// <summary>
	/// Read only Sord ID and GUID.
	/// </summary>
	public: const static PEditInfoZ mbOnlyId;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: EditInfoC();
	
	public: virtual BTYPEID BSerializable_getTypeId();
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// EditInfoEswOptions
// typeId=522299581

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Options for reading or writing of esw-files.
/// </summary>
class EditInfoEswOptions : public BSerializable {
	/// <summary>
	/// Reserved
	/// </summary>
	protected: int32_t reserved;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: EditInfoEswOptions();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: EditInfoEswOptions(int32_t reserved);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getReserved() { return reserved; }
	public: void setReserved(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// EditInfoZ
// typeId=878901868

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// This class encapsulates the constants of the EditInfoC class.
/// </summary>
/// <remarks>
/// EditInfo also returns a Sord object and a SordZ member is included
/// to control the Sord data returned.
/// 
/// <p>Copyright: Copyright (c) 2004</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </remarks>
class EditInfoZ : public ValueClass {
	/// <summary>
	/// Bitset field for constants from the EditInfoC class.
	/// </summary>
	protected: int64_t bset;
	/// <summary>
	/// SordZ object to control the SordC elements returned.
	/// </summary>
	protected: PSordZ sordZ;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: EditInfoZ();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: EditInfoZ(int64_t bset, const PSordZ& sordZ);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int64_t getBset() { return bset; }
	public: void setBset(int64_t v);
	public: PSordZ getSordZ() { return sordZ; }
	public: void setSordZ(PSordZ v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// EloDmOpt
// typeId=353149300

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Internal class.
/// </summary>
class EloDmOpt : public ValueClass {
	/// <summary>
	/// DB column: optno
	/// </summary>
	protected: int32_t id;
	/// <summary>
	/// DB column: optval
	/// </summary>
	protected: ::std::wstring value;
	/// <summary>
	/// DB column: remark
	/// </summary>
	protected: ::std::wstring remark;
	/// <summary>
	/// DB column: instance
	/// </summary>
	protected: ::std::wstring instanceName;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: EloDmOpt();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: EloDmOpt(int32_t id, const ::std::wstring& value, const ::std::wstring& remark, const ::std::wstring& instanceName);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getId() { return id; }
	public: void setId(int32_t v);
	public: ::std::wstring getValue() { return value; }
	public: void setValue(::std::wstring v);
	public: ::std::wstring getRemark() { return remark; }
	public: void setRemark(::std::wstring v);
	public: ::std::wstring getInstanceName() { return instanceName; }
	public: void setInstanceName(::std::wstring v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// EloDmOptDataC
// typeId=1218961099

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// <p>Bit constants for members of EloDmOpt</p>
/// <p>Copyright: Copyright (c) 2003</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </summary>
class EloDmOptDataC : public BSerializable {
	/// <summary>
	/// DB column: optno
	/// </summary>
	public: const static int64_t mbId = 1LL;
	/// <summary>
	/// DB column: optval
	/// </summary>
	public: const static int64_t mbValue = 2LL;
	/// <summary>
	/// DB column: optval
	/// </summary>
	protected: int32_t lnValue;
	/// <summary>
	/// DB column: remark
	/// </summary>
	public: const static int64_t mbRemark = 4LL;
	/// <summary>
	/// DB column: remark
	/// </summary>
	protected: int32_t lnRemark;
	/// <summary>
	/// Member bit: DB column: instance
	/// DB column: instancename
	/// </summary>
	public: const static int64_t mbInstanceName = 8LL;
	/// <summary>
	/// Column length: DB column: instance
	/// DB column: instancename
	/// </summary>
	protected: int32_t lnInstanceName;
	/// <summary>
	/// All valid member bits.
	/// </summary>
	public: const static int64_t mbAllMembers = 15LL;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: EloDmOptDataC();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: EloDmOptDataC(int64_t mbId, int64_t mbValue, int32_t lnValue, int64_t mbRemark, int32_t lnRemark, int64_t mbInstanceName, int32_t lnInstanceName, int64_t mbAllMembers);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getLnValue() { return lnValue; }
	public: void setLnValue(int32_t v);
	public: int32_t getLnRemark() { return lnRemark; }
	public: void setLnRemark(int32_t v);
	public: int32_t getLnInstanceName() { return lnInstanceName; }
	public: void setLnInstanceName(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// EloDmOptC
// typeId=605470240

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Internal class
/// </summary>
class EloDmOptC : public EloDmOptDataC {
	/// <summary>
	/// Instance name for options related to all ELOdm instances.
	/// </summary>
	public: const static ::std::wstring INSTANCE_ALL;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: EloDmOptC();
	
	public: virtual BTYPEID BSerializable_getTypeId();
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// EloFtOpt
// typeId=181406923

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Internal class.
/// </summary>
class EloFtOpt : public ValueClass {
	/// <summary>
	/// DB column: optid
	/// </summary>
	protected: int32_t id;
	/// <summary>
	/// DB column: optval
	/// </summary>
	protected: ::std::wstring value;
	/// <summary>
	/// DB column: remark
	/// </summary>
	protected: ::std::wstring remark;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: EloFtOpt();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: EloFtOpt(int32_t id, const ::std::wstring& value, const ::std::wstring& remark);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getId() { return id; }
	public: void setId(int32_t v);
	public: ::std::wstring getValue() { return value; }
	public: void setValue(::std::wstring v);
	public: ::std::wstring getRemark() { return remark; }
	public: void setRemark(::std::wstring v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// EloFtOptDataC
// typeId=1220982870

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// <p>Bit constants for members of EloFtOpt</p>
/// <p>Copyright: Copyright (c) 2003</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </summary>
class EloFtOptDataC : public BSerializable {
	/// <summary>
	/// DB column: optid
	/// </summary>
	public: const static int64_t mbId = 1LL;
	/// <summary>
	/// DB column: optval
	/// </summary>
	public: const static int64_t mbValue = 2LL;
	/// <summary>
	/// DB column: optval
	/// </summary>
	protected: int32_t lnValue;
	/// <summary>
	/// DB column: remark
	/// </summary>
	public: const static int64_t mbRemark = 4LL;
	/// <summary>
	/// DB column: remark
	/// </summary>
	protected: int32_t lnRemark;
	/// <summary>
	/// All valid member bits.
	/// </summary>
	public: const static int64_t mbAllMembers = 7LL;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: EloFtOptDataC();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: EloFtOptDataC(int64_t mbId, int64_t mbValue, int32_t lnValue, int64_t mbRemark, int32_t lnRemark, int64_t mbAllMembers);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getLnValue() { return lnValue; }
	public: void setLnValue(int32_t v);
	public: int32_t getLnRemark() { return lnRemark; }
	public: void setLnRemark(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// EloFtOptC
// typeId=1603857234

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Internal class.
/// </summary>
class EloFtOptC : public EloFtOptDataC {
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: EloFtOptC();
	
	public: virtual BTYPEID BSerializable_getTypeId();
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// EloFtStop
// typeId=2135577346

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Internal class.
/// </summary>
class EloFtStop : public ValueClass {
	/// <summary>
	/// DB column: stopword
	/// </summary>
	protected: ::std::wstring stopword;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: EloFtStop();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: EloFtStop(const ::std::wstring& stopword);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: ::std::wstring getStopword() { return stopword; }
	public: void setStopword(::std::wstring v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// EloFtStopC
// typeId=1842033553

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// <p>Bit constants for members of EloFtStop</p>
/// <p>Copyright: Copyright (c) 2003</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </summary>
class EloFtStopC : public BSerializable {
	/// <summary>
	/// DB column: stopword
	/// </summary>
	public: const static int64_t mbStopword = 1LL;
	/// <summary>
	/// DB column: stopword
	/// </summary>
	protected: int32_t lnStopword;
	/// <summary>
	/// All valid member bits.
	/// </summary>
	public: const static int64_t mbAllMembers = 1LL;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: EloFtStopC();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: EloFtStopC(int64_t mbStopword, int32_t lnStopword, int64_t mbAllMembers);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getLnStopword() { return lnStopword; }
	public: void setLnStopword(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// EloIxOpt
// typeId=1454054253

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Internal class.
/// </summary>
class EloIxOpt : public ValueClass {
	/// <summary>
	/// DB column: optname
	/// </summary>
	protected: ::std::wstring name;
	/// <summary>
	/// DB column: ixid
	/// </summary>
	protected: ::std::wstring ixId;
	/// <summary>
	/// DB column: optval
	/// </summary>
	protected: ::std::wstring value;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: EloIxOpt();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: EloIxOpt(const ::std::wstring& name, const ::std::wstring& ixId, const ::std::wstring& value);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: ::std::wstring getName() { return name; }
	public: void setName(::std::wstring v);
	public: ::std::wstring getIxId() { return ixId; }
	public: void setIxId(::std::wstring v);
	public: ::std::wstring getValue() { return value; }
	public: void setValue(::std::wstring v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// EloIxOptDataC
// typeId=1223860309

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// <p>Bit constants for members of EloIxOpt</p>
/// <p>Copyright: Copyright (c) 2003</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </summary>
class EloIxOptDataC : public BSerializable {
	/// <summary>
	/// DB column: optname
	/// </summary>
	public: const static int64_t mbName = 1LL;
	/// <summary>
	/// DB column: optname
	/// </summary>
	protected: int32_t lnName;
	/// <summary>
	/// DB column: ixid
	/// </summary>
	public: const static int64_t mbIxId = 2LL;
	/// <summary>
	/// DB column: ixid
	/// </summary>
	protected: int32_t lnIxId;
	/// <summary>
	/// DB column: optval
	/// </summary>
	public: const static int64_t mbValue = 4LL;
	/// <summary>
	/// DB column: optval
	/// </summary>
	protected: int32_t lnValue;
	/// <summary>
	/// All valid member bits.
	/// </summary>
	public: const static int64_t mbAllMembers = 7LL;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: EloIxOptDataC();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: EloIxOptDataC(int64_t mbName, int32_t lnName, int64_t mbIxId, int32_t lnIxId, int64_t mbValue, int32_t lnValue, int64_t mbAllMembers);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getLnName() { return lnName; }
	public: void setLnName(int32_t v);
	public: int32_t getLnIxId() { return lnIxId; }
	public: void setLnIxId(int32_t v);
	public: int32_t getLnValue() { return lnValue; }
	public: void setLnValue(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// EloIxOptC
// typeId=149956656

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

class EloIxOptC : public EloIxOptDataC {
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: EloIxOptC();
	
	public: virtual BTYPEID BSerializable_getTypeId();
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// EloIxOpt_old
// typeId=399031267

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Internal class.
/// </summary>
class EloIxOpt_old : public ValueClass {
	/// <summary>
	/// DB column: optno
	/// </summary>
	protected: int32_t optNo;
	/// <summary>
	/// DB column: optval
	/// </summary>
	protected: ::std::wstring optVal;
	/// <summary>
	/// DB column: remark
	/// </summary>
	protected: ::std::wstring remark;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: EloIxOpt_old();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: EloIxOpt_old(int32_t optNo, const ::std::wstring& optVal, const ::std::wstring& remark);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getOptNo() { return optNo; }
	public: void setOptNo(int32_t v);
	public: ::std::wstring getOptVal() { return optVal; }
	public: void setOptVal(::std::wstring v);
	public: ::std::wstring getRemark() { return remark; }
	public: void setRemark(::std::wstring v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// EloIxOpt_oldC
// typeId=1148546611

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// <p>Bit constants for members of EloIxOpt_old</p>
/// <p>Copyright: Copyright (c) 2003</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </summary>
class EloIxOpt_oldC : public BSerializable {
	/// <summary>
	/// DB column: optno
	/// </summary>
	public: const static int64_t mbOptNo = 1LL;
	/// <summary>
	/// DB column: optval
	/// </summary>
	public: const static int64_t mbOptVal = 2LL;
	/// <summary>
	/// DB column: optval
	/// </summary>
	protected: int32_t lnOptVal;
	/// <summary>
	/// DB column: remark
	/// </summary>
	public: const static int64_t mbRemark = 4LL;
	/// <summary>
	/// DB column: remark
	/// </summary>
	protected: int32_t lnRemark;
	/// <summary>
	/// All valid member bits.
	/// </summary>
	public: const static int64_t mbAllMembers = 7LL;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: EloIxOpt_oldC();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: EloIxOpt_oldC(int64_t mbOptNo, int64_t mbOptVal, int32_t lnOptVal, int64_t mbRemark, int32_t lnRemark, int64_t mbAllMembers);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getLnOptVal() { return lnOptVal; }
	public: void setLnOptVal(int32_t v);
	public: int32_t getLnRemark() { return lnRemark; }
	public: void setLnRemark(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// Event
// typeId=877454055

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// This class represents an event used by the event bus API functions.
/// </summary>
class Event : public ValueClass {
	/// <summary>
	/// Bus-ID
	/// </summary>
	protected: int64_t busId;
	/// <summary>
	/// Event type.
	/// </summary>
	/// <remarks>
	/// Event filters check this value.
	/// This must be one of the predefined event types or an application defined type with a larger value than EventBusC.EVENT_TYPE_MAX_SYSTEM.
	/// </remarks>
	protected: int64_t type;
	/// <summary>
	/// Value depends on event type.
	/// </summary>
	/// <remarks>
	/// Event filters check this value.
	/// </remarks>
	protected: int64_t param1;
	/// <summary>
	/// Value depends on event type.
	/// </summary>
	/// <remarks>
	/// Event filters check this value.
	/// </remarks>
	protected: ::std::wstring param2;
	/// <summary>
	/// Event ID.
	/// </summary>
	/// <remarks>
	/// If the sender awaits a response to this event, it should set a random number in <code>id</code>.
	/// The receiver should use the same number in the response.
	/// </remarks>
	protected: int64_t id;
	/// <summary>
	/// User ID of event sender.
	/// </summary>
	/// <remarks>
	/// Might be used for other IDs in future too.
	/// Read-only.
	/// </remarks>
	protected: int64_t senderId;
	/// <summary>
	/// Event payload data as byte array.
	/// </summary>
	protected: PBytes data;
	/// <summary>
	/// Event payload data as Any object.
	/// </summary>
	protected: PAny any;
	/// <summary>
	/// Access control list.
	/// </summary>
	/// <remarks>
	/// An empty ACL means here, that the event is dispatched to everyone.
	/// </remarks>
	protected: ::std::wstring acl;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: Event();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: Event(int64_t busId, int64_t type, int64_t param1, const ::std::wstring& param2, int64_t id, int64_t senderId, const PBytes& data, const PAny& any, const ::std::wstring& acl);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int64_t getBusId() { return busId; }
	public: void setBusId(int64_t v);
	public: int64_t getType() { return type; }
	public: void setType(int64_t v);
	public: int64_t getParam1() { return param1; }
	public: void setParam1(int64_t v);
	public: ::std::wstring getParam2() { return param2; }
	public: void setParam2(::std::wstring v);
	public: int64_t getId() { return id; }
	public: void setId(int64_t v);
	public: int64_t getSenderId() { return senderId; }
	public: void setSenderId(int64_t v);
	public: PBytes getData() { return data; }
	public: void setData(PBytes v);
	public: PAny getAny() { return any; }
	public: void setAny(PAny v);
	public: ::std::wstring getAcl() { return acl; }
	public: void setAcl(::std::wstring v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// EventBusC
// typeId=572745886

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Constants related to the event bus API.
/// </summary>
class EventBusC : public BSerializable {
	/// <summary>
	/// Broadcast bus ID.
	/// </summary>
	/// <remarks>
	/// The EventBusC.BUSID_BROADCAST refers to a
	/// public communication channel that can used by all applications and users.
	/// Any user can send events to this bus and is allowed to listen to it.
	/// </remarks>
	public: const static int64_t BUSID_BROADCAST = -1LL;
	/// <summary>
	/// User related bus ID.
	/// </summary>
	/// <remarks>
	/// For each user, an event bus exists with the bus ID EventBusC.BUSID_USER + user-ID. Any user can send
	/// events to this bus but only the owning user can listen to it.
	/// </remarks>
	public: const static int64_t BUSID_USER = 0LL;
	/// <summary>
	/// Reserved.
	/// </summary>
	public: const static int64_t BUSID_MAX_SYSTEM = 1000000LL;
	/// <summary>
	/// Open chat event type.
	/// </summary>
	/// <remarks>
	/// Events of this type are used to invite subscribers
	/// to open a public final static chat channel.
	/// </remarks>
	public: const static int64_t EVENT_TYPE_OPEN_CHAT = 2LL;
	/// <summary>
	/// Chat event type.
	/// </summary>
	/// <remarks>
	/// Events of this type contain chat text.
	/// </remarks>
	public: const static int64_t EVENT_TYPE_CHAT = 3LL;
	/// <summary>
	/// Close chat event type.
	/// </summary>
	/// <remarks>
	/// An event of this type is sent to notify the subscribers that the
	/// chat channel (resp. event bus) will be closed shortly.
	/// </remarks>
	public: const static int64_t EVENT_TYPE_CLOSE_CHAT = 4LL;
	/// <summary>
	/// Watch folder event.
	/// </summary>
	/// <remarks>
	/// An event of this type is sent, if the contents of a given folder have been changed.
	/// <p>
	/// In order to register a listener for such events, the folder to be watched has to be
	/// specified with an object ID expression in <code>EventFilter.param2</code>(see checkoutSord):
	/// <pre><code>
	/// IXConnection conn = ...
	/// 
	/// // Folder to be watched
	/// int folderId = ...
	/// 
	/// // Register listener
	/// conn.getEventBusApi().getBroadcastBus().addListener(
	/// EventBusC.EVENT_TYPE_WATCH_FOLDER,
	/// Integer.toString(folderId) );
	/// </code></pre>
	/// </p><p>
	/// For each modified Sord object in the watched folder, the client application receives one <code>Event</code>,
	/// whereby the data members are set as follows:
	/// <pre><code>
	/// Event ev = ...
	/// 
	/// // Folder being watched
	/// int folderId = Integer.parseInt(ev.getParam2());
	/// 
	/// // Arguments
	/// Object[] args = (Object[])AnyToObject.toObject(ev.getAny());
	/// 
	/// // Inserted, updated (e.g. locked) or deleted Sord
	/// Sord sord = (Sord)args[0];
	/// 
	/// // Valid members of args[0]
	/// SordZ sordMembersZ = (SordZ)args[1];
	/// 
	/// // What has happened: EventBusC.WATCH_INSERT, EventBusC.WATCH_UPDATE, EventBusC.WATCH_DELETE
	/// int what = (Integer)args[2];
	/// </code></pre>
	/// </p><p>
	/// Watch folder events are sent to every current acitve connection, provided that a listener
	/// was registered for it and the associated user has at least read access to the changed object.
	/// It is also sent to the connection that fires this event.
	/// </p>
	/// </remarks>
	public: const static int64_t EVENT_TYPE_WATCH_FOLDER = 10LL;
	/// <summary>
	/// An object was inserted.
	/// </summary>
	public: const static int32_t WATCH_INSERT = 1;
	/// <summary>
	/// An object was updated, locked or unlocked.
	/// </summary>
	public: const static int32_t WATCH_UPDATE = 2;
	/// <summary>
	/// An object was deleted.
	/// </summary>
	public: const static int32_t WATCH_DELETE = 4;
	/// <summary>
	/// OCR Request Event.
	/// </summary>
	/// <remarks>
	/// OCR Worker Processes listen to this event and process OCR on the supplied image data.
	/// In order to listen for this event, the session user must have the permission FLAG_ADMIN.
	/// </remarks>
	public: const static int64_t EVENT_OCR_REQUEST = 101LL;
	/// <summary>
	/// OCR Finished Event.
	/// </summary>
	/// <remarks>
	/// OCR Worker Process sends this event if the OCR processing is finished.
	/// The client application initiates a OCR request by calling API function processOCR.
	/// It receives an Event ID
	/// </remarks>
	public: const static int64_t EVENT_OCR_RESULT = 102LL;
	/// <summary>
	/// Notify about status change in fulltext indexing.
	/// </summary>
	public: const static int64_t EVENT_FULLTEXT_INDEXING_STATUS_UPDATE = 201LL;
	/// <summary>
	/// User defined events must have a higher type value than this limit.
	/// </summary>
	public: const static int64_t EVENT_TYPE_MAX_SYSTEM = 1000000LL;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: EventBusC();
	
	public: virtual BTYPEID BSerializable_getTypeId();
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// EventBusParams
// typeId=1489333610

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// This class supplies params to control the creation of an event bus ID.
/// </summary>
/// <remarks>
/// Only one of the members ticket, userId and channelId should be set.
/// </remarks>
class EventBusParams : public ValueClass {
	/// <summary>
	/// Create event bus ID based on this ticket.
	/// </summary>
	protected: ::std::wstring ticket;
	/// <summary>
	/// Get the event bus ID for this user.
	/// </summary>
	/// <remarks>
	/// A numeric ID, GUID or user name can be specified.
	/// The returned bus ID is computed as EventBusC.BUSID_USER + uid,
	/// where uid is the numeric user ID.
	/// </remarks>
	protected: ::std::wstring userId;
	/// <summary>
	/// Create an event bus ID based on this string.
	/// </summary>
	/// <remarks>
	/// An arbitary string can be supplied.
	/// </remarks>
	protected: ::std::wstring channelId;
	/// <summary>
	/// Do not open this bus on other Indexservers.
	/// </summary>
	/// <remarks>
	/// In load balancing environments, event busses are opened on each Indexserver
	/// by default. Set this option to true to open this event bus only on
	/// the currently attached Indexserver.
	/// </remarks>
	protected: bool noForwardToOtherIxs;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: EventBusParams();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: EventBusParams(const ::std::wstring& ticket, const ::std::wstring& userId, const ::std::wstring& channelId, bool noForwardToOtherIxs);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: ::std::wstring getTicket() { return ticket; }
	public: void setTicket(::std::wstring v);
	public: ::std::wstring getUserId() { return userId; }
	public: void setUserId(::std::wstring v);
	public: ::std::wstring getChannelId() { return channelId; }
	public: void setChannelId(::std::wstring v);
	public: bool getNoForwardToOtherIxs() { return noForwardToOtherIxs; }
	public: void setNoForwardToOtherIxs(bool v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// EventFilter
// typeId=1095275943

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// This class describes an event filter.
/// </summary>
class EventFilter : public ValueClass {
	/// <summary>
	/// Event bus ID
	/// </summary>
	protected: int64_t busId;
	/// <summary>
	/// Event type.
	/// </summary>
	/// <remarks>
	/// This must be one of the predefined event types or an application defined type with a larger value than EventBusC.EVENT_TYPE_MAX_SYSTEM.
	/// </remarks>
	protected: int64_t type;
	/// <summary>
	/// First event param.
	/// </summary>
	/// <remarks>
	/// Optional. Depends on event type.
	/// </remarks>
	protected: int64_t param1;
	/// <summary>
	/// Second event param.
	/// </summary>
	/// <remarks>
	/// Optional. Depends on event type.
	/// </remarks>
	protected: ::std::wstring param2;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: EventFilter();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: EventFilter(int64_t busId, int64_t type, int64_t param1, const ::std::wstring& param2);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int64_t getBusId() { return busId; }
	public: void setBusId(int64_t v);
	public: int64_t getType() { return type; }
	public: void setType(int64_t v);
	public: int64_t getParam1() { return param1; }
	public: void setParam1(int64_t v);
	public: ::std::wstring getParam2() { return param2; }
	public: void setParam2(::std::wstring v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// EventListener
// typeId=1005733106

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// This class describes an event bus listener.
/// </summary>
class EventListener : public ValueClass {
	/// <summary>
	/// Array of event filters.
	/// </summary>
	protected: PArrayEventFilter filters;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: EventListener();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: EventListener(const PArrayEventFilter& filters);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: PArrayEventFilter getFilters() { return filters; }
	public: void setFilters(PArrayEventFilter v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// ExecuteScriptParams
// typeId=936440117

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// This class is used to specify which script has to be executed in
/// function executeScript.
/// </summary>
/// <remarks>
/// The script has to be an ELO Windows CLIENT OLE-Automation script.
/// </remarks>
class ExecuteScriptParams : public BSerializable {
	/// <summary>
	/// This value defines the scripting engine to be used to execute the script.
	/// </summary>
	/// <remarks>
	/// Currently, this value must be null or empty or "EloixAuto".
	/// If the value is null or empty, EloixAuto is used by default.
	/// </remarks>
	protected: ::std::wstring scriptEngine;
	/// <summary>
	/// This object contains the script code to be executed as a byte array.
	/// </summary>
	/// <remarks>
	/// The FileData.contentType is either "text/javascript" or "text/vbscript".
	/// FileData.data has to be encoded in UTF-8.
	/// The scriptCode.data length must be less or equal than 65535.
	/// If this member is set, the members scriptString and scriptObjId should be null.
	/// </remarks>
	protected: PFileData scriptCode;
	/// <summary>
	/// This object contains the script code to be executed as a string object.
	/// </summary>
	/// <remarks>
	/// The string must either start with "javascript:" or "vbscript:".
	/// The maximum scriptString length is 65535 UTF-8 characters.
	/// If this member is set, the members scriptCode and scriptObjId should be null.
	/// </remarks>
	protected: ::std::wstring scriptString;
	/// <summary>
	/// If the script to be executed is available in the ELO archive,
	/// this member can specify the object ID (or ARCPATH: - see checkoutSord)
	/// of the script document.
	/// </summary>
	/// <remarks>
	/// The file is assumed to be encoded in characterset ISO-8859-1, if it does not start with a BOM.
	/// If this member is set, the members scriptCode and scriptString should be null.
	/// </remarks>
	protected: ::std::wstring scriptObjId;
	/// <summary>
	/// Call this function in the script code.
	/// </summary>
	/// <remarks>
	/// A function defined in script code that was supplied in a previsious call can be invoked too,
	/// as long as this object does not specify scriptCode, scriptString or scriptObjId.
	/// </remarks>
	protected: ::std::wstring functionName;
	/// <summary>
	/// Function parameters.
	/// </summary>
	protected: PArrayString functionParams;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: ExecuteScriptParams();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: ExecuteScriptParams(const ::std::wstring& scriptEngine, const PFileData& scriptCode, const ::std::wstring& scriptString, const ::std::wstring& scriptObjId, const ::std::wstring& functionName, const PArrayString& functionParams);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: ::std::wstring getScriptEngine() { return scriptEngine; }
	public: void setScriptEngine(::std::wstring v);
	public: PFileData getScriptCode() { return scriptCode; }
	public: void setScriptCode(PFileData v);
	public: ::std::wstring getScriptString() { return scriptString; }
	public: void setScriptString(::std::wstring v);
	public: ::std::wstring getScriptObjId() { return scriptObjId; }
	public: void setScriptObjId(::std::wstring v);
	public: ::std::wstring getFunctionName() { return functionName; }
	public: void setFunctionName(::std::wstring v);
	public: PArrayString getFunctionParams() { return functionParams; }
	public: void setFunctionParams(PArrayString v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// ExecuteScriptResult
// typeId=63967077

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// The function executeScript returns an object of this class
/// to provide returned information or error information.
/// </summary>
class ExecuteScriptResult : public BSerializable {
	/// <summary>
	/// Return value as string.
	/// </summary>
	protected: ::std::wstring returnedString;
	/// <summary>
	/// Error message.
	/// </summary>
	protected: ::std::wstring errorMessage;
	/// <summary>
	/// Line where the error occured.
	/// </summary>
	protected: int32_t errorLine;
	/// <summary>
	/// Column where the error occured.
	/// </summary>
	protected: int32_t errorColumn;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: ExecuteScriptResult();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: ExecuteScriptResult(const ::std::wstring& returnedString, const ::std::wstring& errorMessage, int32_t errorLine, int32_t errorColumn);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: ::std::wstring getReturnedString() { return returnedString; }
	public: void setReturnedString(::std::wstring v);
	public: ::std::wstring getErrorMessage() { return errorMessage; }
	public: void setErrorMessage(::std::wstring v);
	public: int32_t getErrorLine() { return errorLine; }
	public: void setErrorLine(int32_t v);
	public: int32_t getErrorColumn() { return errorColumn; }
	public: void setErrorColumn(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// ExportExtOptions
// typeId=291967

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Options for extended export.
/// </summary>
class ExportExtOptions : public ValueClass {
	/// <summary>
	/// Type of the export's source (archive or search results)
	/// </summary>
	protected: int32_t srcType;
	/// <summary>
	/// List of the source objects IDs (folders in archive or search results)
	/// </summary>
	protected: PArrayString srcList;
	/// <summary>
	/// If the source is the search and if all results have to be exported,
	/// then this option must be set with the search's ID.
	/// </summary>
	protected: ::std::wstring searchId;
	protected: bool exportDocs;
	protected: bool exportDocsVersions;
	protected: bool exportAttachments;
	protected: bool exportKeywords;
	protected: bool exportReminders;
	protected: bool replaceRefWithOriginal;
	/// <summary>
	/// Export encrypted documents too?
	/// </summary>
	protected: bool exportEncrytedDocs;
	/// <summary>
	/// Export documents to filesystem structure.
	/// </summary>
	/// <remarks>
	/// If this member is false, only documents are exported and
	/// they are all located at the root export folder.
	/// </remarks>
	protected: bool exportStructure;
	/// <summary>
	/// Do not export empty branches (without any document).
	/// </summary>
	protected: bool ignoreEmptyFolders;
	/// <summary>
	/// Beginning date for filter in ISO format (null for no date)
	/// </summary>
	protected: ::std::wstring dateStartIso;
	/// <summary>
	/// Ending date for filter in ISO format (null for no date)
	/// </summary>
	protected: ::std::wstring dateEndIso;
	/// <summary>
	/// Which type of date must be considered?
	/// </summary>
	protected: int32_t dateType;
	/// <summary>
	/// List of masks IDs to export
	/// Empty list means: export all objects regardless of the masks.
	/// </summary>
	protected: PArrayString masksList;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: ExportExtOptions();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: ExportExtOptions(int32_t srcType, const PArrayString& srcList, const ::std::wstring& searchId, bool exportDocs, bool exportDocsVersions, bool exportAttachments, bool exportKeywords, bool exportReminders, bool replaceRefWithOriginal, bool exportEncrytedDocs, bool exportStructure, bool ignoreEmptyFolders, const ::std::wstring& dateStartIso, const ::std::wstring& dateEndIso, int32_t dateType, const PArrayString& masksList);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getSrcType() { return srcType; }
	public: void setSrcType(int32_t v);
	public: PArrayString getSrcList() { return srcList; }
	public: void setSrcList(PArrayString v);
	public: ::std::wstring getSearchId() { return searchId; }
	public: void setSearchId(::std::wstring v);
	public: bool getExportDocs() { return exportDocs; }
	public: void setExportDocs(bool v);
	public: bool getExportDocsVersions() { return exportDocsVersions; }
	public: void setExportDocsVersions(bool v);
	public: bool getExportAttachments() { return exportAttachments; }
	public: void setExportAttachments(bool v);
	public: bool getExportKeywords() { return exportKeywords; }
	public: void setExportKeywords(bool v);
	public: bool getExportReminders() { return exportReminders; }
	public: void setExportReminders(bool v);
	public: bool getReplaceRefWithOriginal() { return replaceRefWithOriginal; }
	public: void setReplaceRefWithOriginal(bool v);
	public: bool getExportEncrytedDocs() { return exportEncrytedDocs; }
	public: void setExportEncrytedDocs(bool v);
	public: bool getExportStructure() { return exportStructure; }
	public: void setExportStructure(bool v);
	public: bool getIgnoreEmptyFolders() { return ignoreEmptyFolders; }
	public: void setIgnoreEmptyFolders(bool v);
	public: ::std::wstring getDateStartIso() { return dateStartIso; }
	public: void setDateStartIso(::std::wstring v);
	public: ::std::wstring getDateEndIso() { return dateEndIso; }
	public: void setDateEndIso(::std::wstring v);
	public: int32_t getDateType() { return dateType; }
	public: void setDateType(int32_t v);
	public: PArrayString getMasksList() { return masksList; }
	public: void setMasksList(PArrayString v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// ExportExtOptionsC
// typeId=162646972

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Constant class for the ExportExtOptions class.
/// </summary>
/// <remarks>
/// (The default value are always 0)
/// </remarks>
class ExportExtOptionsC : public BSerializable {
	/// <summary>
	/// Objects from archive are exported
	/// </summary>
	public: const static int32_t EXPORT_SRC_TYPE_ARCHIVE = 0;
	/// <summary>
	/// Search results are exported
	/// </summary>
	public: const static int32_t EXPORT_SRC_TYPE_SEARCH = 1;
	/// <summary>
	/// Export filtered according document date
	/// </summary>
	public: const static int32_t EXPORT_DATE_TYPE_DOC = 0;
	/// <summary>
	/// Export filtered according depot date
	/// </summary>
	public: const static int32_t EXPORT_DATE_TYPE_DEPOT = 1;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: ExportExtOptionsC();
	
	public: virtual BTYPEID BSerializable_getTypeId();
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// ExportOptionsC
// typeId=2043834611

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Constants class for the ExportOptions class.
/// </summary>
/// <remarks>
/// Contains constants used when
/// exporting objects from the ELO archive.
/// 
/// <p>Copyright: Copyright (c) 2004</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </remarks>
class ExportOptionsC : public BSerializable {
	/// <summary>
	/// Include other versions in the export.
	/// </summary>
	/// <remarks>
	/// The default is to only export the
	/// current active document.
	/// </remarks>
	public: const static int64_t EXPORT_ALL_VERSIONS = 8LL;
	/// <summary>
	/// Include the document-files in the export.
	/// </summary>
	public: const static int64_t EXPORT_DOCUMENTS = 1LL;
	/// <summary>
	/// Include the used keyword-lists in the export.
	/// </summary>
	public: const static int64_t EXPORT_KEYWORDS = 2LL;
	/// <summary>
	/// Include refereced documents in the export.
	/// </summary>
	public: const static int64_t EXPORT_REFERENCED_DOCUMENTS = 4LL;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: ExportOptionsC();
	
	public: virtual BTYPEID BSerializable_getTypeId();
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// FileData
// typeId=888671717

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Class for the data contained in a file.
/// </summary>
/// <remarks>
/// <p>
/// Copyright: Copyright (c) 2004
/// </p>
/// <p>
/// Organisation: ELO Digital Office GmbH
/// </p>
/// </remarks>
class FileData : public ValueClass {
	/// <summary>
	/// MIME-Type/document extension, for example text/xml or image/tiff or txt.
	/// </summary>
	protected: ::std::wstring contentType;
	/// <summary>
	/// File data as byte array.
	/// </summary>
	protected: PBytes data;
	/// <summary>
	/// File data as input stream.
	/// </summary>
	/// <remarks>
	/// This member can only be used if the FileData object is a member of
	/// {@link MapValue} or {@link DocVersion}.
	/// </remarks>
	protected: PContentStream stream;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: FileData();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: FileData(const ::std::wstring& contentType, const PBytes& data, const PContentStream& stream);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: ::std::wstring getContentType() { return contentType; }
	public: void setContentType(::std::wstring v);
	public: PBytes getData() { return data; }
	public: void setData(PBytes v);
	public: PContentStream getStream() { return stream; }
	public: void setStream(PContentStream v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// FileDataC
// typeId=1011013570

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Member constants for class FileData.
/// </summary>
class FileDataC : public BSerializable {
	public: const static int64_t mbContentType = 1LL;
	public: const static int64_t mbData = 2LL;
	public: const static int64_t mbStream = 4LL;
	public: const static PFileDataZ mbDataArray;
	public: const static PFileDataZ mbDataStream;
	/// <summary>
	/// Maximum length of BLOB fields.
	/// </summary>
	/// <remarks>
	/// This value is set to 1MB.
	/// </remarks>
	public: const static int64_t MAX_BLOB_LENGTH = 1048576LL;
	protected: int32_t lnContentType;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: FileDataC();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: FileDataC(int64_t mbContentType, int64_t mbData, int64_t mbStream, const PFileDataZ& mbDataArray, const PFileDataZ& mbDataStream, int64_t MAX_BLOB_LENGTH, int32_t lnContentType);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getLnContentType() { return lnContentType; }
	public: void setLnContentType(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// FileDataZ
// typeId=686143141

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Member selector for class FileData.
/// </summary>
class FileDataZ : public ValueClass {
	/// <summary>
	/// Bitset field for constants from the DocMaskC class.
	/// </summary>
	protected: int64_t bset;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: FileDataZ();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: FileDataZ(int64_t bset);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int64_t getBset() { return bset; }
	public: void setBset(int64_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// FindActivityInfo
// typeId=1456865464

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// This class specifies constraints for
/// the API function {@link IXServicePortIF#findFirstActivities(ClientInfo, FindActivityInfo, int, ActivityZ)}.
/// </summary>
/// <remarks>
/// <p>
/// By default, the members of this class are combined by AND.
/// If {@link #senderOrReceiver} is set, senderId and receiverId are combined by OR.
/// </p><p>
/// If neither senderId nor receiverId is set, the function findFirstActivities collects all activities
/// that can be read by the current session.
/// </p>
/// </remarks>
class FindActivityInfo : public ValueClass {
	/// <summary>
	/// Find by object ID.
	/// </summary>
	/// <remarks>
	/// Find activities assigned to this object.
	/// Optional.
	/// </remarks>
	public: ::std::wstring objId;
	/// <summary>
	/// Find activities created by this user.
	/// </summary>
	/// <remarks>
	/// Can be set to a user ID, user GUID or user name.
	/// Optional.
	/// </remarks>
	public: ::std::wstring senderId;
	/// <summary>
	/// Find activities created for this receiver.
	/// </summary>
	/// <remarks>
	/// Can be set to a user ID, user GUID or user name.
	/// Optional.
	/// </remarks>
	public: ::std::wstring receiverId;
	/// <summary>
	/// Search for sender or receiver.
	/// </summary>
	/// <remarks>
	/// Combine the senderId and receiverId by logical OR operation.
	/// </remarks>
	public: bool senderOrReceiver;
	/// <summary>
	/// Search for all groups of sender and receiver too.
	/// </summary>
	public: bool inclGroup;
	/// <summary>
	/// Search for the activities of the deputized users too.
	/// </summary>
	public: bool inclDeputy;
	/// <summary>
	/// Find activities for deleted folders and documents too.
	/// </summary>
	public: bool inclDeleted;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: FindActivityInfo();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: FindActivityInfo(const ::std::wstring& objId, const ::std::wstring& senderId, const ::std::wstring& receiverId, bool senderOrReceiver, bool inclGroup, bool inclDeputy, bool inclDeleted);	
	public: virtual BTYPEID BSerializable_getTypeId();
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// FindActivityProjectsInfo
// typeId=151574948

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// This class defines the options for IXServicePortIF.findActivityProjects.
/// </summary>
class FindActivityProjectsInfo : public ValueClass {
	/// <summary>
	/// Project name.
	/// </summary>
	/// <remarks>
	/// This value can contain wildcards.
	/// </remarks>
	protected: ::std::wstring projectName;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: FindActivityProjectsInfo();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: FindActivityProjectsInfo(const ::std::wstring& projectName);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: ::std::wstring getProjectName() { return projectName; }
	public: void setProjectName(::std::wstring v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// FindAlertInfo
// typeId=897433042

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Find criterias for selecting alerts.
/// </summary>
/// <remarks>
/// RESERVED
/// </remarks>
class FindAlertInfo : public BSerializable {
	/// <summary>
	/// Find alerts created by this user, ID or name.
	/// </summary>
	protected: ::std::wstring sourceId;
	/// <summary>
	/// Find alerts sendet to this user, ID or name.
	/// </summary>
	/// <remarks>
	/// Only main administrators can set this value to an arbitary user ID.
	/// Other users can only set one of her or his groups or one of her or
	/// his substituted users.
	/// </remarks>
	protected: ::std::wstring destId;
	/// <summary>
	/// Find all notification types.
	/// </summary>
	/// <remarks>
	/// If this member is set, the other members related to
	/// notification types are ignored.
	/// </remarks>
	protected: bool inclAll;
	/// <summary>
	/// Find alarm notifications.
	/// </summary>
	/// <remarks>
	/// Ignored, if <code>inclAll</code> is true.
	/// </remarks>
	protected: bool inclAlam;
	/// <summary>
	/// Find reminder notifications.
	/// </summary>
	/// <remarks>
	/// Ignored, if <code>inclAll</code> is true.
	/// </remarks>
	protected: bool inclReminder;
	/// <summary>
	/// Find notifications related to the In Tray.
	/// </summary>
	/// <remarks>
	/// Ignored, if <code>inclAll</code> is true.
	/// </remarks>
	protected: bool inclInTray;
	/// <summary>
	/// Find workflow notifications.
	/// </summary>
	/// <remarks>
	/// Ignored, if <code>inclAll</code> is true.
	/// </remarks>
	protected: bool inclWorkFlow;
	/// <summary>
	/// Find all other notifications that are not explicitly
	/// listed here.
	/// </summary>
	/// <remarks>
	/// Ignored, if <code>inclAll</code> is true.
	/// </remarks>
	protected: bool inclOthers;
	/// <summary>
	/// Find notifications related to substitution rules.
	/// </summary>
	/// <remarks>
	/// Ignored, if <code>inclAll</code> is true.
	/// </remarks>
	protected: bool inclSubs;
	/// <summary>
	/// Find notifications related to this object.
	/// </summary>
	/// <remarks>
	/// For valid values see <code>checkoutSord</code>.
	/// </remarks>
	protected: ::std::wstring objId;
	/// <summary>
	/// Find notifiations with this create date or
	/// in this date range.
	/// </summary>
	/// <remarks>
	/// A date range must be separated by "...".
	/// </remarks>
	protected: ::std::wstring timeIso;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: FindAlertInfo();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: FindAlertInfo(const ::std::wstring& sourceId, const ::std::wstring& destId, bool inclAll, bool inclAlam, bool inclReminder, bool inclInTray, bool inclWorkFlow, bool inclOthers, bool inclSubs, const ::std::wstring& objId, const ::std::wstring& timeIso);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: ::std::wstring getSourceId() { return sourceId; }
	public: void setSourceId(::std::wstring v);
	public: ::std::wstring getDestId() { return destId; }
	public: void setDestId(::std::wstring v);
	public: bool getInclAll() { return inclAll; }
	public: void setInclAll(bool v);
	public: bool getInclAlam() { return inclAlam; }
	public: void setInclAlam(bool v);
	public: bool getInclReminder() { return inclReminder; }
	public: void setInclReminder(bool v);
	public: bool getInclInTray() { return inclInTray; }
	public: void setInclInTray(bool v);
	public: bool getInclWorkFlow() { return inclWorkFlow; }
	public: void setInclWorkFlow(bool v);
	public: bool getInclOthers() { return inclOthers; }
	public: void setInclOthers(bool v);
	public: bool getInclSubs() { return inclSubs; }
	public: void setInclSubs(bool v);
	public: ::std::wstring getObjId() { return objId; }
	public: void setObjId(::std::wstring v);
	public: ::std::wstring getTimeIso() { return timeIso; }
	public: void setTimeIso(::std::wstring v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// FindBackgroundThreadOptions
// typeId=1054287589

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

class FindBackgroundThreadOptions : public ValueClass {
	/// <summary>
	/// Includes running Jobs in the result.
	/// </summary>
	/// <remarks>
	/// Defaults to true.
	/// </remarks>
	protected: bool inclActiveJobs;
	/// <summary>
	/// Includes finished Jobs in the result.
	/// </summary>
	/// <remarks>
	/// Defaults to false.
	/// </remarks>
	protected: bool inclFinishedJobs;
	/// <summary>
	/// enables extended result information in the ProcessInfo member (if
	/// available)
	/// </summary>
	protected: bool inclFullInfo;
	/// <summary>
	/// The order in which the results has to be sorted.
	/// </summary>
	protected: int32_t sortOrder;
	/// <summary>
	/// Filter jobs of specific users; Ignored if the caller is no admin.
	/// </summary>
	protected: PArrayUserInfo userInfo;
	/// <summary>
	/// Filter jobs with specific Job-GUIDs.
	/// </summary>
	protected: PArrayString guids;
	/// <summary>
	/// Filter jobs started after this date.
	/// </summary>
	protected: ::std::wstring dateAfter;
	/// <summary>
	/// Filter jobs started before this date.
	/// </summary>
	protected: ::std::wstring dateBefore;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: FindBackgroundThreadOptions();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: FindBackgroundThreadOptions(bool inclActiveJobs, bool inclFinishedJobs, bool inclFullInfo, int32_t sortOrder, const PArrayUserInfo& userInfo, const PArrayString& guids, const ::std::wstring& dateAfter, const ::std::wstring& dateBefore);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: bool getInclActiveJobs() { return inclActiveJobs; }
	public: void setInclActiveJobs(bool v);
	public: bool getInclFinishedJobs() { return inclFinishedJobs; }
	public: void setInclFinishedJobs(bool v);
	public: bool getInclFullInfo() { return inclFullInfo; }
	public: void setInclFullInfo(bool v);
	public: int32_t getSortOrder() { return sortOrder; }
	public: void setSortOrder(int32_t v);
	public: PArrayUserInfo getUserInfo() { return userInfo; }
	public: void setUserInfo(PArrayUserInfo v);
	public: PArrayString getGuids() { return guids; }
	public: void setGuids(PArrayString v);
	public: ::std::wstring getDateAfter() { return dateAfter; }
	public: void setDateAfter(::std::wstring v);
	public: ::std::wstring getDateBefore() { return dateBefore; }
	public: void setDateBefore(::std::wstring v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// FindByAcl
// typeId=1535514212

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Find objects by ACL
/// </summary>
class FindByAcl : public ValueClass {
	/// <summary>
	/// Return a list of unique ACL entries.
	/// </summary>
	/// <remarks>
	/// The ACL entries are wrapped in arbitary Sord objects which
	/// are returned in FindResult.sords.
	/// This functionality can be combinded with a FindChildren object
	/// to return all ACLs used in a sub tree.
	/// </remarks>
	protected: bool distinctAcl;
	/// <summary>
	/// Find objects that are protected by one of this ACLs.
	/// </summary>
	/// <remarks>
	/// For access checking, the order of the ACL items is irrelevant.
	/// That means, two ACL lists with the same items in different order are equal.
	/// But for this search option, the order of the items are relevant.
	/// Thus, the ACLs in the database must exactly match the given values.
	/// Wildcard * is supported, if only one ACL is supplied.
	/// This member is ignored, if {@link #distinctAcl} is true.
	/// </remarks>
	protected: PArrayString acls;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: FindByAcl();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: FindByAcl(bool distinctAcl, const PArrayString& acls);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: bool getDistinctAcl() { return distinctAcl; }
	public: void setDistinctAcl(bool v);
	public: PArrayString getAcls() { return acls; }
	public: void setAcls(PArrayString v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// FindByFulltext
// typeId=829543678

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Performs a fulltext search.
/// </summary>
/// <remarks>
/// It depends on the system configuration, which fulltext engine is used.
/// The returned list of sords might contain sords with sord.id=0 and no
/// further data. This happens when the fulltext engine retuns a sord but
/// the current user does not have read access.
/// </remarks>
class FindByFulltext : public ValueClass {
	/// <summary>
	/// Search term to be located in the fulltext database.
	/// </summary>
	/// <remarks>
	/// Can be a single word or a number of words.
	/// Wildcard * is allowed, it matches any number of characters. Term is
	/// interpreted based on the options given by FindOptions in FindInfo.
	/// Exception: FindOptionsC.ONE_TERM is not supported.
	/// </remarks>
	protected: ::std::wstring term;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: FindByFulltext();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: FindByFulltext(const ::std::wstring& term);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: ::std::wstring getTerm() { return term; }
	public: void setTerm(::std::wstring v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// FindByFulltextCtrl
// typeId=96165507

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// This class is used to search for objects
/// that have to be indexed by the fulltext
/// database engine.
/// </summary>
/// <remarks>
/// <p>
/// The selected objects are ordered by their timestamp.
/// If the search process is interrupted because of a timeout or
/// because the FindOptions.totalCount limit is reached,
/// all the Objects of the lates timestamp second are
/// discarded.
/// </p><p>
/// If the search process is terminated due to breakTotalCount
/// and the array of results is empty, the search should be
/// repeated with a greater value for totalCount.
/// </p><p>
/// Access checking is performed as in all other searches.
/// </p><p>
/// A search of this type can only be combined with
/// FindOptions.totalCount and FindOptions.timeoutSeconds.
/// </p><p>
/// The results are returned in the member FindInfo.fulltextCtrlResultItems.
/// The Sord objects are available in the member FindInfo.sords too.
/// </p>
/// </remarks>
class FindByFulltextCtrl : public BSerializable {
	/// <summary>
	/// Find objects from this date or newer.
	/// </summary>
	/// <remarks>
	/// This value can be null or empty in which case the
	/// time range has no lower limit.
	/// </remarks>
	protected: ::std::wstring startTStamp;
	/// <summary>
	/// Find objects from this date or older.
	/// </summary>
	/// <remarks>
	/// If the value is null or empty, the time range
	/// has no upper limit.
	/// </remarks>
	protected: ::std::wstring endTStamp;
	/// <summary>
	/// Find next documents for textreader.
	/// </summary>
	protected: bool onlyDocs;
	/// <summary>
	/// Key prefix for loop state.
	/// </summary>
	protected: ::std::wstring profileKeyPrefix;
	/// <summary>
	/// Re-index processing.
	/// </summary>
	/// <remarks>
	/// If this member is true, a search returns objects from the largest object ID to 2.
	/// If this member is false, a search returns the next objects in a timestamp interval.
	/// </remarks>
	protected: bool reindex;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: FindByFulltextCtrl();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: FindByFulltextCtrl(const ::std::wstring& startTStamp, const ::std::wstring& endTStamp, bool onlyDocs, const ::std::wstring& profileKeyPrefix, bool reindex);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: ::std::wstring getStartTStamp() { return startTStamp; }
	public: void setStartTStamp(::std::wstring v);
	public: ::std::wstring getEndTStamp() { return endTStamp; }
	public: void setEndTStamp(::std::wstring v);
	public: bool getOnlyDocs() { return onlyDocs; }
	public: void setOnlyDocs(bool v);
	public: ::std::wstring getProfileKeyPrefix() { return profileKeyPrefix; }
	public: void setProfileKeyPrefix(::std::wstring v);
	public: bool getReindex() { return reindex; }
	public: void setReindex(bool v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// FindByFulltextCtrlResultItem
// typeId=1755682788

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// A search using FindByFulltextCtrl returns this result items
/// in addition to findResult.sords.
/// </summary>
class FindByFulltextCtrlResultItem : public BSerializable {
	/// <summary>
	/// Sord object.
	/// </summary>
	/// <remarks>
	/// Same as in <code>findResult.sords[.]</code>
	/// </remarks>
	protected: PSord sord;
	/// <summary>
	/// Timestamp of the last change of either indexing information, note data,
	/// fulltext content or attachment fulltext content.
	/// </summary>
	protected: ::std::wstring TStamp;
	/// <summary>
	/// Note object.
	/// </summary>
	/// <remarks>
	/// If this member is set, member <code>sord</code> can be ignored.
	/// </remarks>
	protected: PNote note;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: FindByFulltextCtrlResultItem();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: FindByFulltextCtrlResultItem(const PSord& sord, const ::std::wstring& TStamp, const PNote& note);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: PSord getSord() { return sord; }
	public: void setSord(PSord v);
	public: ::std::wstring getTStamp() { return TStamp; }
	public: void setTStamp(::std::wstring v);
	public: PNote getNote() { return note; }
	public: void setNote(PNote v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// FindByFulltextResultItem
// typeId=709720021

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Additional information for an item found
/// by fulltext search.
/// </summary>
class FindByFulltextResultItem : public BSerializable {
	/// <summary>
	/// Relevance in per mill.
	/// </summary>
	protected: int32_t relevance;
	/// <summary>
	/// Textpart from document.
	/// </summary>
	protected: ::std::wstring summaryFulltext;
	/// <summary>
	/// Textpart from memo text.
	/// </summary>
	protected: ::std::wstring summaryDesc;
	/// <summary>
	/// List of index field names that contain the query text.
	/// </summary>
	protected: PArrayString fieldNames;
	/// <summary>
	/// Sord object.
	/// </summary>
	protected: PSord sord;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: FindByFulltextResultItem();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: FindByFulltextResultItem(int32_t relevance, const ::std::wstring& summaryFulltext, const ::std::wstring& summaryDesc, const PArrayString& fieldNames, const PSord& sord);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getRelevance() { return relevance; }
	public: void setRelevance(int32_t v);
	public: ::std::wstring getSummaryFulltext() { return summaryFulltext; }
	public: void setSummaryFulltext(::std::wstring v);
	public: ::std::wstring getSummaryDesc() { return summaryDesc; }
	public: void setSummaryDesc(::std::wstring v);
	public: PArrayString getFieldNames() { return fieldNames; }
	public: void setFieldNames(PArrayString v);
	public: PSord getSord() { return sord; }
	public: void setSord(PSord v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// FindByIndex
// typeId=1985205034

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Finds an object according to the object's index properties.
/// </summary>
/// <remarks>
/// The search terms are concatinated by the operator specified with
/// FindOptions.searchMode. If FindOptionsC.OPERATOR_OR is the specified
/// searchMode the members of this class are concatinated in the search string
/// with the boolean operator "OR". Any other searchMode concatinates with "AND".
/// 
/// Exception: userId and maskId are always used as "AND" terms.
/// 
/// <p>Copyright: Copyright (c) 2004</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </remarks>
class FindByIndex : public ValueClass {
	/// <summary>
	/// Find objects with this due date.
	/// </summary>
	/// <remarks>
	/// It is a single date value or a
	/// date range in ISO format.
	/// </remarks>
	protected: ::std::wstring delDateIso;
	/// <summary>
	/// Find objects with this term included in the description of the object
	/// (case insensitive).
	/// </summary>
	/// <remarks>
	/// This value can be a list of terms separated by blanks.
	/// The terms are concatinated with the operator specified by
	/// FindOptions.searchMode. The wildcard * is allowed, it matches any number
	/// of characters. If desc is to be ignored this value must be set to null.
	/// </remarks>
	protected: ::std::wstring desc;
	/// <summary>
	/// Find objects with this internal date.
	/// </summary>
	/// <remarks>
	/// It is a single date value or a
	/// date range in ISO format.
	/// </remarks>
	protected: ::std::wstring iDateIso;
	/// <summary>
	/// Find objects related to this mask ID or name.
	/// </summary>
	/// <remarks>
	/// If the mask relation
	/// is to be ignored this value must be set to an empty string or null.
	/// </remarks>
	protected: ::std::wstring maskId;
	/// <summary>
	/// Find objects with this term(s) included in the name of the object
	/// (case insensitive).
	/// </summary>
	/// <remarks>
	/// This value can be a list of terms separated with
	/// blanks. They are concatinated with the operator specified by
	/// FindOptions.searchMode. The wildcard * is allowed, it matches any number
	/// of characters. If name is to be ignored this value must be set to null.
	/// </remarks>
	protected: ::std::wstring name;
	/// <summary>
	/// If this option is false, all objects are found that contain the
	/// term specified in <code>name</code> anywhere in their short description
	/// (Sord.name).
	/// </summary>
	/// <remarks>
	/// In other words: a search by <code>*name*</code> is executed.
	/// Set this option true, if wildcards should not added implicitly to the
	/// search term.
	/// </remarks>
	protected: bool exactName;
	/// <summary>
	/// Find objects with this indexing attributes.
	/// </summary>
	/// <remarks>
	/// The values of the attributes
	/// can contain a value range. The wildcard * is allowed in ObjKey.name and
	/// ObjKey.data[], it matches any number of characters. If objKeys is to be
	/// ignored this value must be set to null. The ObjKey.id is ignored, if
	/// ObjKey.name is not empty or ObjKey.id &eq; 0. Searching over ObjKey.id
	/// can only handle one element in ObjKey.data.
	/// </remarks>
	protected: PArrayObjKey objKeys;
	/// <summary>
	/// Find objects owned by the user with this user ID or name.
	/// </summary>
	/// <remarks>
	/// If the owner
	/// is to be ignored this value must be set to null.
	/// </remarks>
	protected: ::std::wstring ownerId;
	/// <summary>
	/// Find objects with this external date.
	/// </summary>
	/// <remarks>
	/// It is a single date value or a
	/// date range in ISO format.
	/// 
	/// <p>
	/// IX versions from 9.00.060 support relative date values. Relative date values give
	/// an offset to the current date and use a format similar to ISO format:
	/// "{+|-}YYYY-MM-DD hh:mm:ss", whereby the separator characters can be omitted: "{+|-}YYYYMMDDhhmmss".
	/// A relative date has to be prefixed by + (date is added) or - (date is subtracted).
	/// </p><p>
	/// Examples, assuming the current date is 2016-06-24 16:29:00
	/// <table border="2">
	/// <tr><td>Relative date</td><td>Resulting absolute date</td><td>Remark</td></tr>
	/// <tr><td>+0001-00-00 00:00:00</td><td>2017-06-24 16:29</td><td>Next year, same month etc.</td></tr>
	/// <tr><td>-0000-01-00 00:00:00</td><td>2016-05-24 16:29</td><td>Previous month, same day etc.</td></tr>
	/// <tr><td>+0000</td><td>2016-01-01 00:00...2016-12-31 23:59</td><td>Search documents of this year. Incomplete relative dates are automatically expanded to a date range.</td></tr>
	/// <tr><td>+0000-00</td><td>2016-06-01 00:00...2016-06-30 23:59</td><td>Search documents of this month.</td></tr>
	/// <tr><td>-0000-01</td><td>2016-05-01 00:00...2016-05-31 23:59</td><td>Search documents of the last month.</td></tr>
	/// <tr><td>-0000-00-10...+0000-00-00 00:00:00</td><td>2016-06-14 00:00...2016-06-24 16:29</td><td>Search documents from the last 10 days.</td></tr>
	/// <tr><td>-0001...</td><td>2015-01-01 00:00...</td><td>Search documents from last year or newer.</td></tr>
	/// </table>
	/// </p>
	/// <p>
	/// <i>Hint: Only relative date values are allowed that could also be an absolute date. E.g. a relative date of 100 days or 13 months cannot be specified.</i>
	/// </p>
	/// </remarks>
	protected: ::std::wstring xDateIso;
	/// <summary>
	/// Constrain results to objects with this access control list.
	/// </summary>
	protected: ::std::wstring acl;
	/// <summary>
	/// Storage path ID or name
	/// </summary>
	protected: ::std::wstring pathId;
	/// <summary>
	/// Colour.
	/// </summary>
	/// <remarks>
	/// If the colour is to be ignored this value must be set to null.
	/// </remarks>
	protected: ::std::wstring kind;
	/// <summary>
	/// Set this value to an user's id or name to search for objects currently
	/// locked by that user.
	/// </summary>
	/// <remarks>
	/// To ignore this option, set this value to
	/// <code>null</code> (default).
	/// </remarks>
	protected: ::std::wstring lockId;
	/// <summary>
	/// Array of maskIds.
	/// </summary>
	/// <remarks>
	/// Find objects associated to one of this keywording forms.
	/// </remarks>
	protected: PArrayString maskIds;
	/// <summary>
	/// Find objects deleted by the user with this user ID or name.
	/// </summary>
	/// <remarks>
	/// If the deleted user
	/// is to be ignored this value must be set to null.
	/// </remarks>
	protected: ::std::wstring deleteUser;
	/// <summary>
	/// Find objects with this delete date.
	/// </summary>
	/// <remarks>
	/// It is a single date value or a
	/// date range in ISO format.
	/// </remarks>
	protected: ::std::wstring deleteDateIso;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: FindByIndex();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: FindByIndex(const ::std::wstring& delDateIso, const ::std::wstring& desc, const ::std::wstring& iDateIso, const ::std::wstring& maskId, const ::std::wstring& name, bool exactName, const PArrayObjKey& objKeys, const ::std::wstring& ownerId, const ::std::wstring& xDateIso, const ::std::wstring& acl, const ::std::wstring& pathId, const ::std::wstring& kind, const ::std::wstring& lockId, const PArrayString& maskIds, const ::std::wstring& deleteUser, const ::std::wstring& deleteDateIso);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: ::std::wstring getDelDateIso() { return delDateIso; }
	public: void setDelDateIso(::std::wstring v);
	public: ::std::wstring getDesc() { return desc; }
	public: void setDesc(::std::wstring v);
	public: ::std::wstring getIDateIso() { return iDateIso; }
	public: void setIDateIso(::std::wstring v);
	public: ::std::wstring getMaskId() { return maskId; }
	public: void setMaskId(::std::wstring v);
	public: ::std::wstring getName() { return name; }
	public: void setName(::std::wstring v);
	public: bool getExactName() { return exactName; }
	public: void setExactName(bool v);
	public: PArrayObjKey getObjKeys() { return objKeys; }
	public: void setObjKeys(PArrayObjKey v);
	public: ::std::wstring getOwnerId() { return ownerId; }
	public: void setOwnerId(::std::wstring v);
	public: ::std::wstring getXDateIso() { return xDateIso; }
	public: void setXDateIso(::std::wstring v);
	public: ::std::wstring getAcl() { return acl; }
	public: void setAcl(::std::wstring v);
	public: ::std::wstring getPathId() { return pathId; }
	public: void setPathId(::std::wstring v);
	public: ::std::wstring getKind() { return kind; }
	public: void setKind(::std::wstring v);
	public: ::std::wstring getLockId() { return lockId; }
	public: void setLockId(::std::wstring v);
	public: PArrayString getMaskIds() { return maskIds; }
	public: void setMaskIds(PArrayString v);
	public: ::std::wstring getDeleteUser() { return deleteUser; }
	public: void setDeleteUser(::std::wstring v);
	public: ::std::wstring getDeleteDateIso() { return deleteDateIso; }
	public: void setDeleteDateIso(::std::wstring v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// FindByNotes
// typeId=735083434

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Finds an object according to the objects notes (sticky notes) content.
/// </summary>
class FindByNotes : public ValueClass {
	/// <summary>
	/// The search term to be found within the notes.
	/// </summary>
	protected: ::std::wstring term;
	/// <summary>
	/// Find notes of this type.
	/// </summary>
	/// <remarks>
	/// Use TYPE_NONE (=0) to find all notes.
	/// </remarks>
	protected: int32_t type;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: FindByNotes();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: FindByNotes(const ::std::wstring& term, int32_t type);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: ::std::wstring getTerm() { return term; }
	public: void setTerm(::std::wstring v);
	public: int32_t getType() { return type; }
	public: void setType(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// FindByPreviewCtrl
// typeId=78436038

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// This class can be used to find the documents for
/// which preview files have to be created.
/// </summary>
/// <remarks>
/// The main purpose is to control the automatic
/// preview generation in a server process.
/// </remarks>
class FindByPreviewCtrl : public BSerializable {
	/// <summary>
	/// Finds all documents with previews.
	/// </summary>
	protected: bool previewAvailable;
	/// <summary>
	/// Finds all documents for which the preview generation failed.
	/// </summary>
	protected: bool previewError;
	/// <summary>
	/// Select only those documents with one of this extension.
	/// </summary>
	protected: PArrayString fileExtensions;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: FindByPreviewCtrl();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: FindByPreviewCtrl(bool previewAvailable, bool previewError, const PArrayString& fileExtensions);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: bool getPreviewAvailable() { return previewAvailable; }
	public: void setPreviewAvailable(bool v);
	public: bool getPreviewError() { return previewError; }
	public: void setPreviewError(bool v);
	public: PArrayString getFileExtensions() { return fileExtensions; }
	public: void setFileExtensions(PArrayString v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// FindByRegisteredFunction
// typeId=700871698

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

class FindByRegisteredFunction : public ValueClass {
	protected: ::std::wstring functionName;
	protected: PAny args;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: FindByRegisteredFunction();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: FindByRegisteredFunction(const ::std::wstring& functionName, const PAny& args);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: ::std::wstring getFunctionName() { return functionName; }
	public: void setFunctionName(::std::wstring v);
	public: PAny getArgs() { return args; }
	public: void setArgs(PAny v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// FindBySordHist
// typeId=2098788325

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

class FindBySordHist : public ValueClass {
	protected: PArraySordHistKey histKeys;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: FindBySordHist();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: FindBySordHist(const PArraySordHistKey& histKeys);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: PArraySordHistKey getHistKeys() { return histKeys; }
	public: void setHistKeys(PArraySordHistKey v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// FindByType
// typeId=151307616

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// This class holds additional information for FindInfo, in order to restrict
/// a search using document types.
/// </summary>
/// <remarks>
/// The default resolving sequence is ordered by the grade of restriction: <br>
/// 1. typeIDs, typeNames, typeExtensions is the most specialised information, <br>
/// 2. typeDocuments containing all document types (IDs, Names, Extensions), <br>
/// 3. and typeStructures including all levels of structure elements. <br>
/// 4. If none of the parameters above is valid, the complete restriction
/// FindByType is omitted. <br>
/// 
/// <p>Copyright: Copyright (c) 2004</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </remarks>
class FindByType : public ValueClass {
	/// <summary>
	/// Include all document types
	/// </summary>
	protected: bool typeDocuments;
	/// <summary>
	/// Associated document extensions; must be resolved to typeIDs
	/// </summary>
	protected: PArrayString typeExtensions;
	/// <summary>
	/// Type identifiers; a direct mapping of objtype
	/// </summary>
	protected: PArrayInt typeIDs;
	/// <summary>
	/// Type names; must be resolved to typeIDs
	/// </summary>
	protected: PArrayString typeNames;
	/// <summary>
	/// Include all structure elements
	/// </summary>
	protected: bool typeStructures;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: FindByType();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: FindByType(bool typeDocuments, const PArrayString& typeExtensions, const PArrayInt& typeIDs, const PArrayString& typeNames, bool typeStructures);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: bool getTypeDocuments() { return typeDocuments; }
	public: void setTypeDocuments(bool v);
	public: PArrayString getTypeExtensions() { return typeExtensions; }
	public: void setTypeExtensions(PArrayString v);
	public: PArrayInt getTypeIDs() { return typeIDs; }
	public: void setTypeIDs(PArrayInt v);
	public: PArrayString getTypeNames() { return typeNames; }
	public: void setTypeNames(PArrayString v);
	public: bool getTypeStructures() { return typeStructures; }
	public: void setTypeStructures(bool v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// FindByVersion
// typeId=925953882

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// This class holds additional information for FindInfo, in order to restrict
/// a search using the document history (version).
/// </summary>
/// <remarks>
/// <p>Copyright: Copyright (c) 2004</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </remarks>
class FindByVersion : public ValueClass {
	/// <summary>
	/// User defined version description.
	/// </summary>
	/// <remarks>
	/// The wildcard * is allowed,
	/// it matches any number of characters.
	/// </remarks>
	protected: ::std::wstring versionComment;
	/// <summary>
	/// The md5 Hash value for the file.
	/// </summary>
	protected: ::std::wstring versionMD5;
	/// <summary>
	/// User defined version number or version id.
	/// </summary>
	/// <remarks>
	/// The wildcard * is allowed,
	/// it matches any number of characters.
	/// </remarks>
	protected: ::std::wstring versionNumber;
	/// <summary>
	/// Optional flag to restrict the search to active versions only.
	/// </summary>
	protected: bool workVersionOnly;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: FindByVersion();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: FindByVersion(const ::std::wstring& versionComment, const ::std::wstring& versionMD5, const ::std::wstring& versionNumber, bool workVersionOnly);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: ::std::wstring getVersionComment() { return versionComment; }
	public: void setVersionComment(::std::wstring v);
	public: ::std::wstring getVersionMD5() { return versionMD5; }
	public: void setVersionMD5(::std::wstring v);
	public: ::std::wstring getVersionNumber() { return versionNumber; }
	public: void setVersionNumber(::std::wstring v);
	public: bool getWorkVersionOnly() { return workVersionOnly; }
	public: void setWorkVersionOnly(bool v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// FindChildren
// typeId=752202075

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// This class controls the search for child objects of an archive entry.
/// </summary>
/// <remarks>
/// <p>Copyright: Copyright (c) 2004</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </remarks>
class FindChildren : public ValueClass {
	/// <summary>
	/// Include only main parent relations.
	/// </summary>
	protected: bool mainParent;
	/// <summary>
	/// Search child objects of the parent entry with this object ID or GUID.
	/// </summary>
	protected: ::std::wstring parentId;
	/// <summary>
	/// Search child objects up to this level below parentId.
	/// </summary>
	/// <remarks>
	/// A value of 0 or 1 means, that only the sub entries
	/// directly under the parent are included.
	/// Set this value to -1, to search over all levels. In this
	/// case the level is internally constrained to 32 to avoid
	/// an endless loop, if the tree under the parent contains
	/// recursive references.
	/// </remarks>
	protected: int32_t endLevel;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: FindChildren();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: FindChildren(bool mainParent, const ::std::wstring& parentId, int32_t endLevel);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: bool getMainParent() { return mainParent; }
	public: void setMainParent(bool v);
	public: ::std::wstring getParentId() { return parentId; }
	public: void setParentId(::std::wstring v);
	public: int32_t getEndLevel() { return endLevel; }
	public: void setEndLevel(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// FindConfigFileInfo
// typeId=1887106523

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// This class describes the files to select from a postbox directory or
/// from a configuration directory.
/// </summary>
class FindConfigFileInfo : public ValueClass {
	/// <summary>
	/// Find files with this names or in this directory.
	/// </summary>
	/// <remarks>
	/// To specify a directory, put the directory name into names[.] and append "/*".
	/// If this member is set, <code>inclDeputy</code> and <code>postboxUserId</code> is ignored.
	/// </remarks>
	protected: PArrayString names;
	/// <summary>
	/// Find files in the in-tray folder of all deputized users.
	/// </summary>
	/// <remarks>
	/// This member is ignored, if <code>names</code> is set.
	/// </remarks>
	protected: bool inclDeputy;
	/// <summary>
	/// Find files in the in-tray of the user specified by ID or name.
	/// </summary>
	/// <remarks>
	/// This member is ignored, if <code>names</code> is set.
	/// If neither <code>names</code> nor <code>postboxUserId</code> is set, the
	/// in-tray of the current user is listed.
	/// </remarks>
	protected: ::std::wstring postboxUserId;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: FindConfigFileInfo();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: FindConfigFileInfo(const PArrayString& names, bool inclDeputy, const ::std::wstring& postboxUserId);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: PArrayString getNames() { return names; }
	public: void setNames(PArrayString v);
	public: bool getInclDeputy() { return inclDeputy; }
	public: void setInclDeputy(bool v);
	public: ::std::wstring getPostboxUserId() { return postboxUserId; }
	public: void setPostboxUserId(::std::wstring v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// FindDirect
// typeId=1028007046

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Search query for locating text in the archive.
/// </summary>
class FindDirect : public BSerializable {
	/// <summary>
	/// Search query.
	/// </summary>
	protected: ::std::wstring query;
	protected: bool searchInSordName;
	protected: bool searchInMemo;
	protected: bool searchInIndex;
	protected: bool searchInFulltext;
	protected: bool searchInNotes;
	protected: bool searchInVersions;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: FindDirect();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: FindDirect(const ::std::wstring& query, bool searchInSordName, bool searchInMemo, bool searchInIndex, bool searchInFulltext, bool searchInNotes, bool searchInVersions);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: ::std::wstring getQuery() { return query; }
	public: void setQuery(::std::wstring v);
	public: bool getSearchInSordName() { return searchInSordName; }
	public: void setSearchInSordName(bool v);
	public: bool getSearchInMemo() { return searchInMemo; }
	public: void setSearchInMemo(bool v);
	public: bool getSearchInIndex() { return searchInIndex; }
	public: void setSearchInIndex(bool v);
	public: bool getSearchInFulltext() { return searchInFulltext; }
	public: void setSearchInFulltext(bool v);
	public: bool getSearchInNotes() { return searchInNotes; }
	public: void setSearchInNotes(bool v);
	public: bool getSearchInVersions() { return searchInVersions; }
	public: void setSearchInVersions(bool v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// FindDirectC
// typeId=627433249

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Constants used in class FindDirect
/// </summary>
class FindDirectC : public BSerializable {
	/// <summary>
	/// ELO iSearch field: descripton (memo text, Sord.desc)
	/// </summary>
	protected: ::std::wstring FIELD_DESC;
	/// <summary>
	/// ELO iSearch field: document file extension without leading dot (DocVersion.ext)
	/// </summary>
	protected: ::std::wstring FIELD_EXT;
	/// <summary>
	/// ELO iSearch field: owner name (Sord.ownerName)
	/// </summary>
	protected: ::std::wstring FIELD_OWNER;
	/// <summary>
	/// ELO iSearch field: last modified time stamp, UTC (Sord.tStamp)
	/// </summary>
	protected: ::std::wstring FIELD_TSTAMP;
	/// <summary>
	/// ELO iSearch field: GUID (Sord.guid)
	/// </summary>
	protected: ::std::wstring FIELD_GUID;
	/// <summary>
	/// ELO iSearch field: ID (Sord.id)
	/// </summary>
	protected: ::std::wstring FIELD_ID;
	/// <summary>
	/// ELO iSearch field: ISO formatted delete date, UTC (Sord.delDateIso)
	/// </summary>
	protected: ::std::wstring FIELD_DELDATE;
	/// <summary>
	/// ELO iSearch field: Year of delete date, UTC (Sord.delDateIso)
	/// </summary>
	protected: ::std::wstring FIELD_DELDATE_YEAR;
	/// <summary>
	/// ELO iSearch field: Month of delete date, UTC (Sord.delDateIso), always 2 characters, e.g. 01 for January.
	/// </summary>
	protected: ::std::wstring FIELD_DELDATE_MONTH;
	/// <summary>
	/// ELO iSearch field: ISO formatted archiving date, UTC (Sord.iDateIso)
	/// </summary>
	protected: ::std::wstring FIELD_IDATE;
	/// <summary>
	/// ELO iSearch field: Year of archiving date, UTC (Sord.iDateIso)
	/// </summary>
	protected: ::std::wstring FIELD_IDATE_YEAR;
	/// <summary>
	/// ELO iSearch field: Month of archiving date, UTC (Sord.iDateIso), always 2 characters, e.g. 01 for January.
	/// </summary>
	protected: ::std::wstring FIELD_IDATE_MONTH;
	/// <summary>
	/// ELO iSearch field: ISO formatted document date, UTC (Sord.xDateIso)
	/// </summary>
	protected: ::std::wstring FIELD_XDATE;
	/// <summary>
	/// ELO iSearch field: Year of document date, UTC (Sord.xDateIso)
	/// </summary>
	protected: ::std::wstring FIELD_XDATE_YEAR;
	/// <summary>
	/// ELO iSearch field: Month of document date, UTC (Sord.xDateIso), always 2 characters, e.g. 01 for January.
	/// </summary>
	protected: ::std::wstring FIELD_XDATE_MONTH;
	/// <summary>
	/// ELO iSearch field: Keywording form ID, (Sord.mask)
	/// </summary>
	protected: ::std::wstring FIELD_MASK_ID;
	/// <summary>
	/// ELO iSearch field: Keywording form name, (Sord.maskName)
	/// </summary>
	protected: ::std::wstring FIELD_MASK_NAME;
	/// <summary>
	/// ELO iSearch field: short description (Sord.name)
	/// </summary>
	protected: ::std::wstring FIELD_NAME;
	/// <summary>
	/// ELO iSearch field: owner ID (Sord.ownerId)
	/// </summary>
	protected: ::std::wstring FIELD_OWNER_ID;
	/// <summary>
	/// ELO iSearch field: folder or document type (Sord.type)
	/// </summary>
	protected: ::std::wstring FIELD_TYPE;
	/// <summary>
	/// ELO iSearch field: group name of index field (Sord.objKey[.].name, DocMask.line[.].key)
	/// </summary>
	protected: ::std::wstring FIELD_OBJ_KEY;
	/// <summary>
	/// ELO iSearch field: group name of index field (Sord.objKey[.].name, DocMask.line[.].key)
	/// This field contains tokenized content (linguistic processing applied)
	/// </summary>
	protected: ::std::wstring FIELD_OBJ_KEY_TOKENIZED;
	/// <summary>
	/// Numeric Indexfields (nLINE)
	/// </summary>
	protected: ::std::wstring FIELD_OBJ_KEY_NUMERIC;
	/// <summary>
	/// Date Indexfields (dLINE)
	/// </summary>
	protected: ::std::wstring FIELD_OBJ_KEY_DATE;
	/// <summary>
	/// Document size
	/// </summary>
	protected: ::std::wstring FIELD_DOC_SIZE;
	/// <summary>
	/// DocVersion.version
	/// </summary>
	protected: ::std::wstring FIELD_VERSION_NUMBER;
	/// <summary>
	/// DocVersion.comment
	/// </summary>
	protected: ::std::wstring FIELD_VERSION_COMMENT;
	/// <summary>
	/// DocVersion.ownerId
	/// </summary>
	protected: ::std::wstring FIELD_VERSION_OWNER;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: FindDirectC();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: FindDirectC(const ::std::wstring& FIELD_DESC, const ::std::wstring& FIELD_EXT, const ::std::wstring& FIELD_OWNER, const ::std::wstring& FIELD_TSTAMP, const ::std::wstring& FIELD_GUID, const ::std::wstring& FIELD_ID, const ::std::wstring& FIELD_DELDATE, const ::std::wstring& FIELD_DELDATE_YEAR, const ::std::wstring& FIELD_DELDATE_MONTH, const ::std::wstring& FIELD_IDATE, const ::std::wstring& FIELD_IDATE_YEAR, const ::std::wstring& FIELD_IDATE_MONTH, const ::std::wstring& FIELD_XDATE, const ::std::wstring& FIELD_XDATE_YEAR, const ::std::wstring& FIELD_XDATE_MONTH, const ::std::wstring& FIELD_MASK_ID, const ::std::wstring& FIELD_MASK_NAME, const ::std::wstring& FIELD_NAME, const ::std::wstring& FIELD_OWNER_ID, const ::std::wstring& FIELD_TYPE, const ::std::wstring& FIELD_OBJ_KEY, const ::std::wstring& FIELD_OBJ_KEY_TOKENIZED, const ::std::wstring& FIELD_OBJ_KEY_NUMERIC, const ::std::wstring& FIELD_OBJ_KEY_DATE, const ::std::wstring& FIELD_DOC_SIZE, const ::std::wstring& FIELD_VERSION_NUMBER, const ::std::wstring& FIELD_VERSION_COMMENT, const ::std::wstring& FIELD_VERSION_OWNER);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: ::std::wstring getFIELD_DESC() { return FIELD_DESC; }
	public: void setFIELD_DESC(::std::wstring v);
	public: ::std::wstring getFIELD_EXT() { return FIELD_EXT; }
	public: void setFIELD_EXT(::std::wstring v);
	public: ::std::wstring getFIELD_OWNER() { return FIELD_OWNER; }
	public: void setFIELD_OWNER(::std::wstring v);
	public: ::std::wstring getFIELD_TSTAMP() { return FIELD_TSTAMP; }
	public: void setFIELD_TSTAMP(::std::wstring v);
	public: ::std::wstring getFIELD_GUID() { return FIELD_GUID; }
	public: void setFIELD_GUID(::std::wstring v);
	public: ::std::wstring getFIELD_ID() { return FIELD_ID; }
	public: void setFIELD_ID(::std::wstring v);
	public: ::std::wstring getFIELD_DELDATE() { return FIELD_DELDATE; }
	public: void setFIELD_DELDATE(::std::wstring v);
	public: ::std::wstring getFIELD_DELDATE_YEAR() { return FIELD_DELDATE_YEAR; }
	public: void setFIELD_DELDATE_YEAR(::std::wstring v);
	public: ::std::wstring getFIELD_DELDATE_MONTH() { return FIELD_DELDATE_MONTH; }
	public: void setFIELD_DELDATE_MONTH(::std::wstring v);
	public: ::std::wstring getFIELD_IDATE() { return FIELD_IDATE; }
	public: void setFIELD_IDATE(::std::wstring v);
	public: ::std::wstring getFIELD_IDATE_YEAR() { return FIELD_IDATE_YEAR; }
	public: void setFIELD_IDATE_YEAR(::std::wstring v);
	public: ::std::wstring getFIELD_IDATE_MONTH() { return FIELD_IDATE_MONTH; }
	public: void setFIELD_IDATE_MONTH(::std::wstring v);
	public: ::std::wstring getFIELD_XDATE() { return FIELD_XDATE; }
	public: void setFIELD_XDATE(::std::wstring v);
	public: ::std::wstring getFIELD_XDATE_YEAR() { return FIELD_XDATE_YEAR; }
	public: void setFIELD_XDATE_YEAR(::std::wstring v);
	public: ::std::wstring getFIELD_XDATE_MONTH() { return FIELD_XDATE_MONTH; }
	public: void setFIELD_XDATE_MONTH(::std::wstring v);
	public: ::std::wstring getFIELD_MASK_ID() { return FIELD_MASK_ID; }
	public: void setFIELD_MASK_ID(::std::wstring v);
	public: ::std::wstring getFIELD_MASK_NAME() { return FIELD_MASK_NAME; }
	public: void setFIELD_MASK_NAME(::std::wstring v);
	public: ::std::wstring getFIELD_NAME() { return FIELD_NAME; }
	public: void setFIELD_NAME(::std::wstring v);
	public: ::std::wstring getFIELD_OWNER_ID() { return FIELD_OWNER_ID; }
	public: void setFIELD_OWNER_ID(::std::wstring v);
	public: ::std::wstring getFIELD_TYPE() { return FIELD_TYPE; }
	public: void setFIELD_TYPE(::std::wstring v);
	public: ::std::wstring getFIELD_OBJ_KEY() { return FIELD_OBJ_KEY; }
	public: void setFIELD_OBJ_KEY(::std::wstring v);
	public: ::std::wstring getFIELD_OBJ_KEY_TOKENIZED() { return FIELD_OBJ_KEY_TOKENIZED; }
	public: void setFIELD_OBJ_KEY_TOKENIZED(::std::wstring v);
	public: ::std::wstring getFIELD_OBJ_KEY_NUMERIC() { return FIELD_OBJ_KEY_NUMERIC; }
	public: void setFIELD_OBJ_KEY_NUMERIC(::std::wstring v);
	public: ::std::wstring getFIELD_OBJ_KEY_DATE() { return FIELD_OBJ_KEY_DATE; }
	public: void setFIELD_OBJ_KEY_DATE(::std::wstring v);
	public: ::std::wstring getFIELD_DOC_SIZE() { return FIELD_DOC_SIZE; }
	public: void setFIELD_DOC_SIZE(::std::wstring v);
	public: ::std::wstring getFIELD_VERSION_NUMBER() { return FIELD_VERSION_NUMBER; }
	public: void setFIELD_VERSION_NUMBER(::std::wstring v);
	public: ::std::wstring getFIELD_VERSION_COMMENT() { return FIELD_VERSION_COMMENT; }
	public: void setFIELD_VERSION_COMMENT(::std::wstring v);
	public: ::std::wstring getFIELD_VERSION_OWNER() { return FIELD_VERSION_OWNER; }
	public: void setFIELD_VERSION_OWNER(::std::wstring v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// FindInfo
// typeId=1017838205

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// This class controls the search function findFirstSords.
/// </summary>
/// <remarks>
/// <p>Copyright: Copyright (c) 2004</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </remarks>
class FindInfo : public ValueClass {
	/// <summary>
	/// If not null the results are constrained to documents including this
	/// fulltext term (or terms).
	/// </summary>
	protected: PFindByFulltext findByFulltext;
	/// <summary>
	/// Terms for google-like search in Java-Client.
	/// </summary>
	protected: PFindDirect findDirect;
	/// <summary>
	/// If not null the function searches through the indexing information.
	/// </summary>
	protected: PFindByIndex findByIndex;
	/// <summary>
	/// If not null the function searches through the notes.
	/// </summary>
	/// <remarks>
	/// (NOT CURRENTLY IMPLEMENTED!)
	/// </remarks>
	protected: PFindByNotes findByNotes;
	/// <summary>
	/// If not null the function searches in versioning history of indexing information.
	/// </summary>
	protected: PFindBySordHist findBySordHist;
	/// <summary>
	/// If not null the function searches using objtype.
	/// </summary>
	protected: PFindByType findByType;
	/// <summary>
	/// If not null the function searches using histversion and histcomment.
	/// </summary>
	protected: PFindByVersion findByVersion;
	/// <summary>
	/// If not null, the results are constrained to child entries of the
	/// specified parent in this object.
	/// </summary>
	/// <remarks>
	/// To retrieve child lists for an archive
	/// entry this member must be set with the related parent ID and
	/// all others members in this class must be null.
	/// </remarks>
	protected: PFindChildren findChildren;
	/// <summary>
	/// This member controls several options, e. g. sorting, time limitation.
	/// </summary>
	protected: PFindOptions findOptions;
	/// <summary>
	/// Find sords by ACL.
	/// </summary>
	protected: PFindByAcl findByAcl;
	/// <summary>
	/// Find sords by preview control information.
	/// </summary>
	protected: PFindByPreviewCtrl findByPreviewCtrl;
	/// <summary>
	/// Find the sords that have to be indexed by the fulltext engine.
	/// </summary>
	protected: PFindByFulltextCtrl findByFulltextCtrl;
	protected: PFindByRegisteredFunction findByRegisteredFunction;
	/// <summary>
	/// If not null, the results are constrained to entries linked to the specified
	/// object in findLinks.
	/// </summary>
	protected: PFindLinks findLinks;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: FindInfo();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: FindInfo(const PFindByFulltext& findByFulltext, const PFindDirect& findDirect, const PFindByIndex& findByIndex, const PFindByNotes& findByNotes, const PFindBySordHist& findBySordHist, const PFindByType& findByType, const PFindByVersion& findByVersion, const PFindChildren& findChildren, const PFindOptions& findOptions, const PFindByAcl& findByAcl, const PFindByPreviewCtrl& findByPreviewCtrl, const PFindByFulltextCtrl& findByFulltextCtrl, const PFindByRegisteredFunction& findByRegisteredFunction, const PFindLinks& findLinks);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: PFindByFulltext getFindByFulltext() { return findByFulltext; }
	public: void setFindByFulltext(PFindByFulltext v);
	public: PFindDirect getFindDirect() { return findDirect; }
	public: void setFindDirect(PFindDirect v);
	public: PFindByIndex getFindByIndex() { return findByIndex; }
	public: void setFindByIndex(PFindByIndex v);
	public: PFindByNotes getFindByNotes() { return findByNotes; }
	public: void setFindByNotes(PFindByNotes v);
	public: PFindBySordHist getFindBySordHist() { return findBySordHist; }
	public: void setFindBySordHist(PFindBySordHist v);
	public: PFindByType getFindByType() { return findByType; }
	public: void setFindByType(PFindByType v);
	public: PFindByVersion getFindByVersion() { return findByVersion; }
	public: void setFindByVersion(PFindByVersion v);
	public: PFindChildren getFindChildren() { return findChildren; }
	public: void setFindChildren(PFindChildren v);
	public: PFindOptions getFindOptions() { return findOptions; }
	public: void setFindOptions(PFindOptions v);
	public: PFindByAcl getFindByAcl() { return findByAcl; }
	public: void setFindByAcl(PFindByAcl v);
	public: PFindByPreviewCtrl getFindByPreviewCtrl() { return findByPreviewCtrl; }
	public: void setFindByPreviewCtrl(PFindByPreviewCtrl v);
	public: PFindByFulltextCtrl getFindByFulltextCtrl() { return findByFulltextCtrl; }
	public: void setFindByFulltextCtrl(PFindByFulltextCtrl v);
	public: PFindByRegisteredFunction getFindByRegisteredFunction() { return findByRegisteredFunction; }
	public: void setFindByRegisteredFunction(PFindByRegisteredFunction v);
	public: PFindLinks getFindLinks() { return findLinks; }
	public: void setFindLinks(PFindLinks v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// FindInfoAsInternalSQL
// typeId=2003160309

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// SQL command that is built from a FindInfo object.
/// </summary>
/// <remarks>
/// This class contains the elements of an internal SQL statement for finding Sord objects.
/// Modifying this elements might cause errors or wrong results in subsequent versions of IX.
/// </remarks>
class FindInfoAsInternalSQL : public BSerializable {
	/// <summary>
	/// Comma separated list of table names.
	/// </summary>
	protected: ::std::wstring fromTables;
	/// <summary>
	/// SQL WHERE clause.
	/// </summary>
	protected: ::std::wstring whereClause;
	/// <summary>
	/// SQL ORDER BY clause.
	/// </summary>
	protected: ::std::wstring orderByClause;
	/// <summary>
	/// SQL GROUP BY clause.
	/// </summary>
	protected: ::std::wstring groupByClause;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: FindInfoAsInternalSQL();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: FindInfoAsInternalSQL(const ::std::wstring& fromTables, const ::std::wstring& whereClause, const ::std::wstring& orderByClause, const ::std::wstring& groupByClause);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: ::std::wstring getFromTables() { return fromTables; }
	public: void setFromTables(::std::wstring v);
	public: ::std::wstring getWhereClause() { return whereClause; }
	public: void setWhereClause(::std::wstring v);
	public: ::std::wstring getOrderByClause() { return orderByClause; }
	public: void setOrderByClause(::std::wstring v);
	public: ::std::wstring getGroupByClause() { return groupByClause; }
	public: void setGroupByClause(::std::wstring v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// FindLinks
// typeId=832548178

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Finds the links of an object.
/// </summary>
class FindLinks : public ValueClass {
	/// <summary>
	/// The Object to search for its links.
	/// </summary>
	protected: ::std::wstring objectId;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: FindLinks();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: FindLinks(const ::std::wstring& objectId);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: ::std::wstring getObjectId() { return objectId; }
	public: void setObjectId(::std::wstring v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// FindOptions
// typeId=1371440255

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// This class contains several options to control the search process of
/// findFirstSords.
/// </summary>
class FindOptions : public ValueClass {
	/// <summary>
	/// SQL escape character.
	/// </summary>
	/// <remarks>
	/// Overwrites the character that can be specified
	/// by setSessionOptions.
	/// </remarks>
	protected: ::std::wstring escapeChar;
	/// <summary>
	/// Include logically deleted objects.
	/// </summary>
	protected: bool inclDeleted;
	/// <summary>
	/// Restricts the results to objects with these IDs or GUIDs.
	/// </summary>
	protected: PArrayString objIds;
	/// <summary>
	/// An SQL ORDER BY clause can be provided here, if required.
	/// </summary>
	protected: ::std::wstring orderBy;
	/// <summary>
	/// Range values can be used to search many index and date attribute values.
	/// </summary>
	/// <remarks>
	/// The delimiter between the lower limit and upper limit value is defined
	/// by rangeDelimiter. The default rangeDelimiter is "...".
	/// </remarks>
	protected: ::std::wstring rangeDelimiter;
	/// <summary>
	/// Results are returned only for objects that reside in this replication set.
	/// </summary>
	protected: PReplSet replSet;
	/// <summary>
	/// This value is reserved for internal testing purposes and must be set
	/// to 0  in all cases.
	/// </summary>
	protected: int64_t reserved;
	/// <summary>
	/// Restricts the results to objects returned by a previous search.
	/// </summary>
	protected: ::std::wstring searchId;
	/// <summary>
	/// The searchMode describes how search terms are concatinated with the
	/// boolean operators AND or OR.
	/// </summary>
	protected: PSearchModeZ searchMode;
	/// <summary>
	/// Defines the sort order of the results.
	/// </summary>
	/// <remarks>
	/// If sortOrder is 0 and the search process searches for child objects
	/// (FindInfo.findChildren!=null), the objects are sorted by the sort flags
	/// of the parent.
	/// If sortOrder is 0 and the search uses FindInfo.findByIndex, the
	/// objects are sorted alphabetically.
	/// </remarks>
	protected: int32_t sortOrder;
	/// <summary>
	/// Specifies the time limit for the search.
	/// </summary>
	/// <remarks>
	/// If the limit is exceeded, the
	/// search is interruped. If the search is not to have a time limit
	/// timeoutSeconds=0 must be used.
	/// </remarks>
	protected: int32_t timeoutSeconds;
	/// <summary>
	/// The search is terminated if this number of objects are found.
	/// </summary>
	/// <remarks>
	/// If the number of results should not be constrained, set this value to
	/// 2^32-1 = 2147483647 (maximum value of a positive 32bit integer minus 1).
	/// If totalCount is not set, the IndexServer option totalCount is used,
	/// which is 10000 by default.
	/// If this value is set to 1, findFirstSords will not generate a report entry
	/// {@link ReportInfoC#ACT_CLIENT_SEARCH}.
	/// </remarks>
	protected: int32_t totalCount;
	/// <summary>
	/// Compute the number of results.
	/// </summary>
	/// <remarks>
	/// The number of results are returned in FindResult.count.
	/// Be aware of the fact that
	/// this option needs to read all database result rows and check user access
	/// before findFirstSords returns.
	/// </remarks>
	protected: bool evalCount;
	/// <summary>
	/// Only logically deleted objects.
	/// </summary>
	/// <remarks>
	/// If this member is true, inclDeleted is ignored.
	/// </remarks>
	protected: bool onlyDeleted;
	/// <summary>
	/// Return objects that were last modified at this time or in this time range.
	/// </summary>
	/// <remarks>
	/// The time stamp is an ISO formatted value in the UTC timezone. It might include dots
	/// to separate the date and time elements. A time range is separated by the <code>rangeDelimiter</code>.
	/// The selection includes the range limits.
	/// Because the FindOptions cannot be the only criteria in FindInfo, use FindByIndex.name="*" to
	/// select over the entire archive.
	/// </remarks>
	protected: ::std::wstring TStamp;
	/// <summary>
	/// This characters are used as wildcards in search terms.
	/// </summary>
	/// <remarks>
	/// The first wildcard is used for zero or more characters.
	/// The second wildcard is used for exactly one character.
	/// By default (if this member is null or empty), only the first wildcard is defined: *.
	/// </remarks>
	protected: ::std::wstring wildcards;
	/// <summary>
	/// Lock all result Sords.
	/// </summary>
	/// <remarks>
	/// If at least one of the sords cannot be locked, an exception is thrown from findFirstSords.
	/// Be aware of the fact that
	/// this option needs to read all database result rows and check user access.
	/// The objects are unlocked by a call to findClose.
	/// </remarks>
	protected: PLockZ lockZ;
	/// <summary>
	/// Lifetime of cached search results.
	/// </summary>
	/// <remarks>
	/// This value overrides the ELOix configuration option searchLifetimeSeconds.
	/// The value determines the time in seconds, how long the search results are cached.
	/// As long the results are valid, they can be read by findNext-functions of the API.
	/// </remarks>
	protected: int32_t searchLifetimeSeconds;
	/// <summary>
	/// Do not generate summary information.
	/// </summary>
	/// <remarks>
	/// Retrieving summaries is very expensive for the iSearch module.
	/// </remarks>
	protected: bool excludeSummary;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: FindOptions();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: FindOptions(const ::std::wstring& escapeChar, bool inclDeleted, const PArrayString& objIds, const ::std::wstring& orderBy, const ::std::wstring& rangeDelimiter, const PReplSet& replSet, int64_t reserved, const ::std::wstring& searchId, const PSearchModeZ& searchMode, int32_t sortOrder, int32_t timeoutSeconds, int32_t totalCount, bool evalCount, bool onlyDeleted, const ::std::wstring& TStamp, const ::std::wstring& wildcards, const PLockZ& lockZ, int32_t searchLifetimeSeconds, bool excludeSummary);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: ::std::wstring getEscapeChar() { return escapeChar; }
	public: void setEscapeChar(::std::wstring v);
	public: bool getInclDeleted() { return inclDeleted; }
	public: void setInclDeleted(bool v);
	public: PArrayString getObjIds() { return objIds; }
	public: void setObjIds(PArrayString v);
	public: ::std::wstring getOrderBy() { return orderBy; }
	public: void setOrderBy(::std::wstring v);
	public: ::std::wstring getRangeDelimiter() { return rangeDelimiter; }
	public: void setRangeDelimiter(::std::wstring v);
	public: PReplSet getReplSet() { return replSet; }
	public: void setReplSet(PReplSet v);
	public: int64_t getReserved() { return reserved; }
	public: void setReserved(int64_t v);
	public: ::std::wstring getSearchId() { return searchId; }
	public: void setSearchId(::std::wstring v);
	public: PSearchModeZ getSearchMode() { return searchMode; }
	public: void setSearchMode(PSearchModeZ v);
	public: int32_t getSortOrder() { return sortOrder; }
	public: void setSortOrder(int32_t v);
	public: int32_t getTimeoutSeconds() { return timeoutSeconds; }
	public: void setTimeoutSeconds(int32_t v);
	public: int32_t getTotalCount() { return totalCount; }
	public: void setTotalCount(int32_t v);
	public: bool getEvalCount() { return evalCount; }
	public: void setEvalCount(bool v);
	public: bool getOnlyDeleted() { return onlyDeleted; }
	public: void setOnlyDeleted(bool v);
	public: ::std::wstring getTStamp() { return TStamp; }
	public: void setTStamp(::std::wstring v);
	public: ::std::wstring getWildcards() { return wildcards; }
	public: void setWildcards(::std::wstring v);
	public: PLockZ getLockZ() { return lockZ; }
	public: void setLockZ(PLockZ v);
	public: int32_t getSearchLifetimeSeconds() { return searchLifetimeSeconds; }
	public: void setSearchLifetimeSeconds(int32_t v);
	public: bool getExcludeSummary() { return excludeSummary; }
	public: void setExcludeSummary(bool v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// FindReportInfo
// typeId=504724737

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Objects of this class specify the selection criteria for report entries in
/// <code>findReport</code>.
/// </summary>
/// <remarks>
/// <p>Copyright: Copyright (c) 2004</p>
/// <p>Organisation: ELO Digital Office GmbH </p>
/// </remarks>
class FindReportInfo : public ValueClass {
	/// <summary>
	/// End date (UTC)
	/// </summary>
	protected: ::std::wstring endDateIso;
	/// <summary>
	/// Constrained to this ERP codes.
	/// </summary>
	protected: PArrayInt erpCodes;
	/// <summary>
	/// Object ID or GUID
	/// </summary>
	protected: ::std::wstring objId;
	/// <summary>
	/// Can contain an SQL ORDER BY clause.
	/// </summary>
	protected: ::std::wstring orderBy;
	/// <summary>
	/// reserved.
	/// </summary>
	protected: ::std::wstring searchId;
	/// <summary>
	/// Start date (UTC)
	/// </summary>
	protected: ::std::wstring startDateIso;
	/// <summary>
	/// Specifies the time limit for the search.
	/// </summary>
	/// <remarks>
	/// If the limit is exceeded, the search
	/// is interruped. <code>timeoutSeconds=0</code> means that the search has no time limit.
	/// </remarks>
	protected: int32_t timeoutSeconds;
	/// <summary>
	/// The search is ended once this number of objects have been found.
	/// </summary>
	/// <remarks>
	/// A value of <code>0</code> sets no constraint to the number of objects.
	/// </remarks>
	protected: int32_t totalCount;
	/// <summary>
	/// User ID or name.
	/// </summary>
	protected: ::std::wstring userId;
	/// <summary>
	/// Find the last entry before the given {@link #endDateIso}.
	/// </summary>
	/// <remarks>
	/// This option e.g. allows to find the user permissions at the given {@link #endDateIso}.
	/// Therefore, set <code>erpCodes = new int[] { ReportOptionsC.ERP_LOGOPENARC, ReportOptionsC.ERP_LOGUSERDATA };</code>.
	/// </remarks>
	protected: bool findLastEntryBeforeEndDate;
	/// <summary>
	/// Specifies the extra1 value.
	/// </summary>
	/// <remarks>
	/// Only Integer values are allowed for this element.
	/// </remarks>
	protected: ::std::wstring extra1;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: FindReportInfo();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: FindReportInfo(const ::std::wstring& endDateIso, const PArrayInt& erpCodes, const ::std::wstring& objId, const ::std::wstring& orderBy, const ::std::wstring& searchId, const ::std::wstring& startDateIso, int32_t timeoutSeconds, int32_t totalCount, const ::std::wstring& userId, bool findLastEntryBeforeEndDate, const ::std::wstring& extra1);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: ::std::wstring getEndDateIso() { return endDateIso; }
	public: void setEndDateIso(::std::wstring v);
	public: PArrayInt getErpCodes() { return erpCodes; }
	public: void setErpCodes(PArrayInt v);
	public: ::std::wstring getObjId() { return objId; }
	public: void setObjId(::std::wstring v);
	public: ::std::wstring getOrderBy() { return orderBy; }
	public: void setOrderBy(::std::wstring v);
	public: ::std::wstring getSearchId() { return searchId; }
	public: void setSearchId(::std::wstring v);
	public: ::std::wstring getStartDateIso() { return startDateIso; }
	public: void setStartDateIso(::std::wstring v);
	public: int32_t getTimeoutSeconds() { return timeoutSeconds; }
	public: void setTimeoutSeconds(int32_t v);
	public: int32_t getTotalCount() { return totalCount; }
	public: void setTotalCount(int32_t v);
	public: ::std::wstring getUserId() { return userId; }
	public: void setUserId(::std::wstring v);
	public: bool getFindLastEntryBeforeEndDate() { return findLastEntryBeforeEndDate; }
	public: void setFindLastEntryBeforeEndDate(bool v);
	public: ::std::wstring getExtra1() { return extra1; }
	public: void setExtra1(::std::wstring v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// FindResult
// typeId=1301335819

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// <p>This class contains the search results of a call to <code>IXServicePortIF.findFirstSords</code></p>
/// or <code>IXServicePortIF.findNextSords</code>.
/// </summary>
/// <remarks>
/// <p>Copyright: Copyright (c) 2004</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </remarks>
class FindResult : public ValueClass {
	/// <summary>
	/// The time limit for the search is exceeded.
	/// </summary>
	protected: bool breakTimeout;
	/// <summary>
	/// The search is breaked because the total number of results are reached.
	/// </summary>
	protected: bool breakTotalCount;
	/// <summary>
	/// Array of configuration files.
	/// </summary>
	protected: PArrayConfigFile configFiles;
	/// <summary>
	/// Array of IDs or GUIDs found.
	/// </summary>
	protected: PArrayString ids;
	/// <summary>
	/// Is true if there are more results.
	/// </summary>
	protected: bool moreResults;
	/// <summary>
	/// Report entries.
	/// </summary>
	protected: PArrayReportInfo reportInfos;
	/// <summary>
	/// Number of results.
	/// </summary>
	/// <remarks>
	/// This member is only valid, if FindInfo.findOptions.evalCount is true.
	/// </remarks>
	protected: int32_t count;
	/// <summary>
	/// Estimated number of hits that can be found by the query.
	/// </summary>
	/// <remarks>
	/// This number cannot be computed for any search and is usually -1.
	/// Only if the search engine supplies an estimated count, it is &gt;= 0.
	/// </remarks>
	protected: int32_t estimatedCount;
	/// <summary>
	/// Identifier to get more results.
	/// </summary>
	protected: ::std::wstring searchId;
	/// <summary>
	/// Array of <code>sord</code> objects.
	/// </summary>
	/// <remarks>
	/// This member is set if <code>sordC</code>
	/// </remarks>
	protected: PArraySord sords;
	/// <summary>
	/// Array of user tasks.
	/// </summary>
	protected: PArrayUserTask tasks;
	/// <summary>
	/// Array of WorkflowDiagrams
	/// </summary>
	protected: PArrayWFDiagram workflows;
	/// <summary>
	/// Array of terms translated into different languages.
	/// </summary>
	protected: PArrayTranslateTerm translateTerms;
	/// <summary>
	/// Additional information from the fulltext database.
	/// </summary>
	/// <remarks>
	/// This member can be null, if the fulltext engine does not
	/// support additional information.
	/// </remarks>
	protected: PArrayFindByFulltextResultItem fulltextResultItems;
	/// <summary>
	/// Result items returned from a seach for new information to be added into the fulltext database.
	/// </summary>
	protected: PArrayFindByFulltextCtrlResultItem fulltextCtrlResultItems;
	/// <summary>
	/// String representation of FindInfo used to define a dynamic register.
	/// </summary>
	/// <remarks>
	/// Function {@link IXServicePortIF#findFirstSords(ClientInfo, FindInfo, int, SordZ)} returns a
	/// serialized FindInfo in this member. It can be used to define a dynamic register by setting
	/// <code>Sord.desc=FindResult.dynamicFolder</code>.
	/// </remarks>
	protected: ::std::wstring dynamicFolder;
	/// <summary>
	/// Result items returned from a search for background threads.
	/// </summary>
	protected: PArrayJobState jobStates;
	/// <summary>
	/// Document feed actions.
	/// </summary>
	/// <remarks>
	/// This array is filled by findFirst/findNextActions of the interface FeedService.
	/// The associated Feed objects are returned in the collection {@link #feeds}.
	/// </remarks>
	protected: de::elo::ix::client::feed::PArrayAction actions;
	/// <summary>
	/// Document feeds.
	/// </summary>
	/// <remarks>
	/// Feed objects mapped to their GUID.
	/// </remarks>
	protected: de::elo::ix::client::feed::PMapStringFeed feeds;
	/// <summary>
	/// Subscriptions.
	/// </summary>
	/// <remarks>
	/// Subscription objects mapped to their Subscription.watchGuid.
	/// </remarks>
	protected: PMapStringSubscription subscriptions;
	/// <summary>
	/// Notifications.
	/// </summary>
	/// <remarks>
	/// Notification objects mapped to their Notification.watchGuid
	/// </remarks>
	protected: PMapStringNotification notifications;
	/// <summary>
	/// HashTag Relations.
	/// </summary>
	protected: de::elo::ix::client::feed::PVectorHashTagRelation hashTagRelations;
	/// <summary>
	/// HashTags.
	/// </summary>
	/// <remarks>
	/// HashTag Objects mapped to their HashTagGuid
	/// </remarks>
	protected: de::elo::ix::client::feed::PMapStringHashTag hashTags;
	/// <summary>
	/// Notes.
	/// </summary>
	/// <remarks>
	/// This member returns the note objects found by findFirstNotes/findNextNotes.
	/// </remarks>
	protected: PVectorNote notes;
	/// <summary>
	/// User objects.
	/// </summary>
	/// <remarks>
	/// Map of user ID to user object.
	/// </remarks>
	protected: PMapIntegerUserInfo userInfos;
	/// <summary>
	/// Lean user objects.
	/// </summary>
	/// <remarks>
	/// Map of user ID to user object.
	/// </remarks>
	protected: PMapIntegerUserName userNames;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: FindResult();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: FindResult(bool breakTimeout, bool breakTotalCount, const PArrayConfigFile& configFiles, const PArrayString& ids, bool moreResults, const PArrayReportInfo& reportInfos, int32_t count, int32_t estimatedCount, const ::std::wstring& searchId, const PArraySord& sords, const PArrayUserTask& tasks, const PArrayWFDiagram& workflows, const PArrayTranslateTerm& translateTerms, const PArrayFindByFulltextResultItem& fulltextResultItems, const PArrayFindByFulltextCtrlResultItem& fulltextCtrlResultItems, const ::std::wstring& dynamicFolder, const PArrayJobState& jobStates, const de::elo::ix::client::feed::PArrayAction& actions, const de::elo::ix::client::feed::PMapStringFeed& feeds, const PMapStringSubscription& subscriptions, const PMapStringNotification& notifications, const de::elo::ix::client::feed::PVectorHashTagRelation& hashTagRelations, const de::elo::ix::client::feed::PMapStringHashTag& hashTags, const PVectorNote& notes, const PMapIntegerUserInfo& userInfos, const PMapIntegerUserName& userNames);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: bool getBreakTimeout() { return breakTimeout; }
	public: void setBreakTimeout(bool v);
	public: bool getBreakTotalCount() { return breakTotalCount; }
	public: void setBreakTotalCount(bool v);
	public: PArrayConfigFile getConfigFiles() { return configFiles; }
	public: void setConfigFiles(PArrayConfigFile v);
	public: PArrayString getIds() { return ids; }
	public: void setIds(PArrayString v);
	public: bool getMoreResults() { return moreResults; }
	public: void setMoreResults(bool v);
	public: PArrayReportInfo getReportInfos() { return reportInfos; }
	public: void setReportInfos(PArrayReportInfo v);
	public: int32_t getCount() { return count; }
	public: void setCount(int32_t v);
	public: int32_t getEstimatedCount() { return estimatedCount; }
	public: void setEstimatedCount(int32_t v);
	public: ::std::wstring getSearchId() { return searchId; }
	public: void setSearchId(::std::wstring v);
	public: PArraySord getSords() { return sords; }
	public: void setSords(PArraySord v);
	public: PArrayUserTask getTasks() { return tasks; }
	public: void setTasks(PArrayUserTask v);
	public: PArrayWFDiagram getWorkflows() { return workflows; }
	public: void setWorkflows(PArrayWFDiagram v);
	public: PArrayTranslateTerm getTranslateTerms() { return translateTerms; }
	public: void setTranslateTerms(PArrayTranslateTerm v);
	public: PArrayFindByFulltextResultItem getFulltextResultItems() { return fulltextResultItems; }
	public: void setFulltextResultItems(PArrayFindByFulltextResultItem v);
	public: PArrayFindByFulltextCtrlResultItem getFulltextCtrlResultItems() { return fulltextCtrlResultItems; }
	public: void setFulltextCtrlResultItems(PArrayFindByFulltextCtrlResultItem v);
	public: ::std::wstring getDynamicFolder() { return dynamicFolder; }
	public: void setDynamicFolder(::std::wstring v);
	public: PArrayJobState getJobStates() { return jobStates; }
	public: void setJobStates(PArrayJobState v);
	public: de::elo::ix::client::feed::PArrayAction getActions() { return actions; }
	public: void setActions(de::elo::ix::client::feed::PArrayAction v);
	public: de::elo::ix::client::feed::PMapStringFeed getFeeds() { return feeds; }
	public: void setFeeds(de::elo::ix::client::feed::PMapStringFeed v);
	public: PMapStringSubscription getSubscriptions() { return subscriptions; }
	public: void setSubscriptions(PMapStringSubscription v);
	public: PMapStringNotification getNotifications() { return notifications; }
	public: void setNotifications(PMapStringNotification v);
	public: de::elo::ix::client::feed::PVectorHashTagRelation getHashTagRelations() { return hashTagRelations; }
	public: void setHashTagRelations(de::elo::ix::client::feed::PVectorHashTagRelation v);
	public: de::elo::ix::client::feed::PMapStringHashTag getHashTags() { return hashTags; }
	public: void setHashTags(de::elo::ix::client::feed::PMapStringHashTag v);
	public: PVectorNote getNotes() { return notes; }
	public: void setNotes(PVectorNote v);
	public: PMapIntegerUserInfo getUserInfos() { return userInfos; }
	public: void setUserInfos(PMapIntegerUserInfo v);
	public: PMapIntegerUserName getUserNames() { return userNames; }
	public: void setUserNames(PMapIntegerUserName v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// FindSubscriptionInfo
// typeId=1419135016

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Find criteria for function findFirstSubscriptions.
/// </summary>
class FindSubscriptionInfo : public ValueClass {
	/// <summary>
	/// Element selector for Sord objects.
	/// </summary>
	/// <remarks>
	/// If this member is not null or empty, FindResult.sords contains
	/// the Sord objects associated to FindResult.subscriptions.
	/// </remarks>
	protected: PSordZ sordZ;
	/// <summary>
	/// Element selector for Feed objects.
	/// </summary>
	/// <remarks>
	/// If this member is not null or empty, FindResult.feeds contains
	/// the Feed objects associated to FindResult.subscriptions.
	/// </remarks>
	protected: de::elo::ix::client::feed::PFeedZ feedZ;
	/// <summary>
	/// Find subscriptions of this user.
	/// </summary>
	/// <remarks>
	/// If this member is empty, the current users subscriptions are returned.
	/// This member is ignored for non-administrators.
	/// User ID, GUID or Name is accepted.
	/// </remarks>
	protected: ::std::wstring userId;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: FindSubscriptionInfo();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: FindSubscriptionInfo(const PSordZ& sordZ, const de::elo::ix::client::feed::PFeedZ& feedZ, const ::std::wstring& userId);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: PSordZ getSordZ() { return sordZ; }
	public: void setSordZ(PSordZ v);
	public: de::elo::ix::client::feed::PFeedZ getFeedZ() { return feedZ; }
	public: void setFeedZ(de::elo::ix::client::feed::PFeedZ v);
	public: ::std::wstring getUserId() { return userId; }
	public: void setUserId(::std::wstring v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// FindTasksInfo
// typeId=1489194452

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// This class contains the search criteria that are required for locating a
/// task (reminders, workflow tasks or activity).
/// </summary>
class FindTasksInfo : public ValueClass {
	/// <summary>
	/// Collect tasks up to this date.
	/// </summary>
	protected: ::std::wstring endDateIso;
	/// <summary>
	/// Collect tasks of this or lower priority.
	/// </summary>
	protected: int32_t highestPriority;
	/// <summary>
	/// Collect activities.
	/// </summary>
	protected: bool inclActivities;
	/// <summary>
	/// Collect tasks received from users for which the current
	/// user is a substitute.
	/// </summary>
	protected: bool inclDeputy;
	/// <summary>
	/// Collect tasks of the users groups.
	/// </summary>
	protected: bool inclGroup;
	/// <summary>
	/// Collect reminders.
	/// </summary>
	protected: bool inclReminders;
	/// <summary>
	/// Collect workflows.
	/// </summary>
	protected: bool inclWorkflows;
	/// <summary>
	/// Collect tasks of this or higher priority.
	/// </summary>
	protected: int32_t lowestPriority;
	/// <summary>
	/// Collect tasks for this Sord (ID or GUID).
	/// </summary>
	protected: ::std::wstring objId;
	/// <summary>
	/// Controls the sort order or returned arrays.
	/// </summary>
	/// <remarks>
	/// If null, PRIORITY_DATE_NAME is used.
	/// </remarks>
	protected: PUserTaskSortOrderZ sortOrder;
	/// <summary>
	/// Collect tasks beginning at this date.
	/// </summary>
	protected: ::std::wstring startDateIso;
	/// <summary>
	/// Collect nodes that exceeded the time limit.
	/// </summary>
	/// <remarks>
	/// Workflow only
	/// </remarks>
	protected: bool overTimeLimit;
	/// <summary>
	/// Collect tasks for a superior as defined in the escalation options.
	/// </summary>
	/// <remarks>
	/// When a workflow task exceeds its time limit, and the current user is
	/// assigned in the time limit options of this task,
	/// then the user receives this task from findFirstTasks/findNextTasks although
	/// she or he is not the owner of the task.
	/// If an entire workflow is over time, the user receives the start node of the workflow.
	/// This option applies to workflow tasks only.
	/// </remarks>
	protected: bool inclOverTimeForSuperior;
	/// <summary>
	/// IDs of the users which tasks can be collected by the administrator.
	/// </summary>
	/// <remarks>
	/// This member is ignored, if the current user does not have administrator privileges {@link AccessC#FLAG_ADMIN}.
	/// For administrators, this can be a list of user or groups which tasks should be selected. If the list is null or empty,
	/// The tasks of the administrator are collected. In order to collect all tasks from all users, set member {@link #allUsers}=true.
	/// </remarks>
	protected: PArrayString userIds;
	/// <summary>
	/// Select tasks for deleted folders and documents too.
	/// </summary>
	protected: bool inclDeleted;
	/// <summary>
	/// Collect tasks from all users.
	/// </summary>
	/// <remarks>
	/// This member is ignored, if the current user does not have administrator privileges {@link AccessC#FLAG_ADMIN}.
	/// If set to true, element {@link #userIds} is ignored and the tasks of all users are selected.
	/// </remarks>
	protected: bool allUsers;
	/// <summary>
	/// Return the associated Sord objects to the selected Tasks.
	/// </summary>
	/// <remarks>
	/// If this member is not null, the Sord objects to the selected Tasks are read from the database.
	/// The Sord objects can be found in {@link FindResult#sords} and in each {@link UserTask#sord}
	/// of the array {@link FindResult#tasks}.
	/// The Sord objects contain the elements defined in this element selector as valid members.
	/// </remarks>
	protected: PSordZ sordZ;
	/// <summary>
	/// Select tasks with this name.
	/// </summary>
	/// <remarks>
	/// The task name of a Reminder is Reminder.name. The task name of an Activity is Activity.name.
	/// The task name of a workflow node is WFNode.name and WFCollectNode.nodeName.
	/// This element can contain wildcard characters.
	/// The underlying database column is by default not indexed. Thus, selecting only by taskName
	/// will result in a full table scan.
	/// </remarks>
	protected: ::std::wstring taskName;
	/// <summary>
	/// Update WFNode.inUseDateIso for selected tasks.
	/// </summary>
	protected: bool updateInUseDate;
	/// <summary>
	/// Only select activities of the given types
	/// </summary>
	protected: byps::PVectorString inclActivityTypes;
	/// <summary>
	/// Inlcude hidden tasks.
	/// </summary>
	/// <remarks>
	/// Currently this only affects workflows.
	/// </remarks>
	protected: bool inclHidden;
	/// <summary>
	/// Time limit bias.
	/// </summary>
	/// <remarks>
	/// This value added to each {@link WFNode#timeLimit} before evaluating whether the node is over time.
	/// It is measured in minutes. Indexserver uses a timeLimitBias of 1min when looking for over-timed nodes to be
	/// forwarded automatically through a {@link WFNodeMatrixC#IF_OVERTIME} edge.
	/// </remarks>
	protected: int32_t timeLimitBias;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: FindTasksInfo();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: FindTasksInfo(const ::std::wstring& endDateIso, int32_t highestPriority, bool inclActivities, bool inclDeputy, bool inclGroup, bool inclReminders, bool inclWorkflows, int32_t lowestPriority, const ::std::wstring& objId, const PUserTaskSortOrderZ& sortOrder, const ::std::wstring& startDateIso, bool overTimeLimit, bool inclOverTimeForSuperior, const PArrayString& userIds, bool inclDeleted, bool allUsers, const PSordZ& sordZ, const ::std::wstring& taskName, bool updateInUseDate, const byps::PVectorString& inclActivityTypes, bool inclHidden, int32_t timeLimitBias);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: ::std::wstring getEndDateIso() { return endDateIso; }
	public: void setEndDateIso(::std::wstring v);
	public: int32_t getHighestPriority() { return highestPriority; }
	public: void setHighestPriority(int32_t v);
	public: bool getInclActivities() { return inclActivities; }
	public: void setInclActivities(bool v);
	public: bool getInclDeputy() { return inclDeputy; }
	public: void setInclDeputy(bool v);
	public: bool getInclGroup() { return inclGroup; }
	public: void setInclGroup(bool v);
	public: bool getInclReminders() { return inclReminders; }
	public: void setInclReminders(bool v);
	public: bool getInclWorkflows() { return inclWorkflows; }
	public: void setInclWorkflows(bool v);
	public: int32_t getLowestPriority() { return lowestPriority; }
	public: void setLowestPriority(int32_t v);
	public: ::std::wstring getObjId() { return objId; }
	public: void setObjId(::std::wstring v);
	public: PUserTaskSortOrderZ getSortOrder() { return sortOrder; }
	public: void setSortOrder(PUserTaskSortOrderZ v);
	public: ::std::wstring getStartDateIso() { return startDateIso; }
	public: void setStartDateIso(::std::wstring v);
	public: bool getOverTimeLimit() { return overTimeLimit; }
	public: void setOverTimeLimit(bool v);
	public: bool getInclOverTimeForSuperior() { return inclOverTimeForSuperior; }
	public: void setInclOverTimeForSuperior(bool v);
	public: PArrayString getUserIds() { return userIds; }
	public: void setUserIds(PArrayString v);
	public: bool getInclDeleted() { return inclDeleted; }
	public: void setInclDeleted(bool v);
	public: bool getAllUsers() { return allUsers; }
	public: void setAllUsers(bool v);
	public: PSordZ getSordZ() { return sordZ; }
	public: void setSordZ(PSordZ v);
	public: ::std::wstring getTaskName() { return taskName; }
	public: void setTaskName(::std::wstring v);
	public: bool getUpdateInUseDate() { return updateInUseDate; }
	public: void setUpdateInUseDate(bool v);
	public: byps::PVectorString getInclActivityTypes() { return inclActivityTypes; }
	public: void setInclActivityTypes(byps::PVectorString v);
	public: bool getInclHidden() { return inclHidden; }
	public: void setInclHidden(bool v);
	public: int32_t getTimeLimitBias() { return timeLimitBias; }
	public: void setTimeLimitBias(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// FindTranslateTermInfo
// typeId=986701599

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// This class is used to find translations of terms.
/// </summary>
class FindTranslateTermInfo : public BSerializable {
	/// <summary>
	/// Terms for which translations should be selected.
	/// </summary>
	/// <remarks>
	/// Set this element to <code>null</code> or empty, if all terms should be returned.
	/// The given terms have to be in the language specified in <code>langs[0]</code> object.
	/// If <code>langs</code> is <code>null</code> or empty, the terms are assumed to
	/// be in the system language.
	/// </remarks>
	protected: PArrayString terms;
	/// <summary>
	/// Return the terms specified by element <code>terms</code>
	/// for wich translations exist in this languages.
	/// </summary>
	/// <remarks>
	/// If a term is not found in one of the languages, an empty string is
	/// returned.
	/// The languages must be given in ISO 639 2-letter codes, e.g. "en" for English.
	/// The language at the first index specifies the language of the <code>terms</code>.
	/// This element is corresponding to <code>TranslateTerm.termLangs</code>:
	/// <code>termLangs[i]</code> is in language <code>langs[i]</code>
	/// If this element is <code>null</code>, terms in all available languages are returned.
	/// </remarks>
	protected: PArrayString langs;
	/// <summary>
	/// Reserved - Find deleted terms too (currently not implemented).
	/// </summary>
	protected: bool inclDeleted;
	/// <summary>
	/// Return those terms too, that should be translated into other languages:
	/// e.g.
	/// </summary>
	/// <remarks>
	/// Keywording form names (DocMask.name), index value lables (DocMaskLine.name)
	/// and Keywords.
	/// </remarks>
	protected: bool inclToBeTranslated;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: FindTranslateTermInfo();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: FindTranslateTermInfo(const PArrayString& terms, const PArrayString& langs, bool inclDeleted, bool inclToBeTranslated);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: PArrayString getTerms() { return terms; }
	public: void setTerms(PArrayString v);
	public: PArrayString getLangs() { return langs; }
	public: void setLangs(PArrayString v);
	public: bool getInclDeleted() { return inclDeleted; }
	public: void setInclDeleted(bool v);
	public: bool getInclToBeTranslated() { return inclToBeTranslated; }
	public: void setInclToBeTranslated(bool v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// FindUserInfo
// typeId=1847547446

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// This class describes the search criteria for {@link IXServicePortIF#findFirstUsers}.
/// </summary>
/// <remarks>
/// The wildcards defined by {@link SessionOptionsC#DB_WILDCARDS} can be used for {@link #name}, {@link #desc}, {@link #property}, and {@link #ldapProperty}.
/// 
/// Members {@link #name}, {@link #desc}, {@link #property}, and {@link #ldapProperty} are combined by OR. Other members are combinded by AND.
/// </remarks>
class FindUserInfo : public ValueClass {
	/// <summary>
	/// Find by user name.
	/// </summary>
	/// <remarks>
	/// Search over {@link UserInfo#name}.
	/// </remarks>
	protected: ::std::wstring name;
	/// <summary>
	/// Find by user description.
	/// </summary>
	/// <remarks>
	/// Search over {@link UserInfo#desc}.
	/// </remarks>
	protected: ::std::wstring desc;
	/// <summary>
	/// Find by an user property.
	/// </summary>
	/// <remarks>
	/// Search over all {@link UserInfo#userProps}. The key element in property is the index in the array {@link UserInfo#userProps}.
	/// <p>
	/// Example:
	/// <pre><code class="example">
	/// FindUserInfo findInfo = new FindUserInfo();
	/// KeyValue property = new KeyValue();
	/// property.setKey(Integer.toString(UserInfoC.PROP_NAME_EMAIL));
	/// property.setValue("maria.fritz@alpha.com");
	/// </code></pre>
	/// </p>
	/// </remarks>
	protected: PKeyValue property;
	/// <summary>
	/// Find by a LDAP property.
	/// </summary>
	/// <remarks>
	/// Search over all {@link UserInfo#ldapProperties}. The key element in property is the key in the map {@link UserInfo#ldapProperties}.
	/// </remarks>
	protected: PKeyValue ldapProperty;
	/// <summary>
	/// Search for users only.
	/// </summary>
	protected: bool onlyUsers;
	/// <summary>
	/// Search for groups only.
	/// </summary>
	protected: bool onlyGroups;
	/// <summary>
	/// Return entire information about each user.
	/// </summary>
	/// <remarks>
	/// If true, {@link UserInfo} objects are returned in {@link FindResult#userInfos}.
	/// If false, {@link UserName} objects are returned in {@link FindResult#userNames}.
	/// </remarks>
	protected: bool returnUserInfoMap;
	/// <summary>
	/// User IDs related to {@link #checkoutUsersZ}.
	/// </summary>
	protected: PArrayString userIds;
	/// <summary>
	/// Filter users as in {@link IXServicePortIF#checkoutUsers(ClientInfo, String[], CheckoutUsersZ, LockZ)}.
	/// </summary>
	protected: PCheckoutUsersZ checkoutUsersZ;
	/// <summary>
	/// Select only users that have all of this {@link UserInfo#flags} set.
	/// </summary>
	/// <remarks>
	/// A value of 0 is ignored.
	/// The selected users are found by testing (UserInfo#flags & hasFlags) == hasFlags.
	/// </remarks>
	protected: int32_t hasFlags;
	/// <summary>
	/// Select only users that have non this {@link UserInfo#flags} set.
	/// </summary>
	/// <remarks>
	/// The selected users are found by testing (UserInfo#flags & hasNotFlags) == 0.
	/// </remarks>
	protected: int32_t hasNotFlags;
	/// <summary>
	/// Select only users that have all of this {@link UserInfo#flags2} set.
	/// </summary>
	/// <remarks>
	/// A value of 0 is ignored.
	/// The selected users are found by testing (UserInfo#flags2 & hasFlags2) == hasFlags2.
	/// </remarks>
	protected: int32_t hasFlags2;
	/// <summary>
	/// Select only users that have none this {@link UserInfo#flags2} set.
	/// </summary>
	/// <remarks>
	/// The selected users are found by testing (UserInfo#flags2 & hasNotFlags2) == 0.
	/// </remarks>
	protected: int32_t hasNotFlags2;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: FindUserInfo();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: FindUserInfo(const ::std::wstring& name, const ::std::wstring& desc, const PKeyValue& property, const PKeyValue& ldapProperty, bool onlyUsers, bool onlyGroups, bool returnUserInfoMap, const PArrayString& userIds, const PCheckoutUsersZ& checkoutUsersZ, int32_t hasFlags, int32_t hasNotFlags, int32_t hasFlags2, int32_t hasNotFlags2);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: ::std::wstring getName() { return name; }
	public: void setName(::std::wstring v);
	public: ::std::wstring getDesc() { return desc; }
	public: void setDesc(::std::wstring v);
	public: PKeyValue getProperty() { return property; }
	public: void setProperty(PKeyValue v);
	public: PKeyValue getLdapProperty() { return ldapProperty; }
	public: void setLdapProperty(PKeyValue v);
	public: bool getOnlyUsers() { return onlyUsers; }
	public: void setOnlyUsers(bool v);
	public: bool getOnlyGroups() { return onlyGroups; }
	public: void setOnlyGroups(bool v);
	public: bool getReturnUserInfoMap() { return returnUserInfoMap; }
	public: void setReturnUserInfoMap(bool v);
	public: PArrayString getUserIds() { return userIds; }
	public: void setUserIds(PArrayString v);
	public: PCheckoutUsersZ getCheckoutUsersZ() { return checkoutUsersZ; }
	public: void setCheckoutUsersZ(PCheckoutUsersZ v);
	public: int32_t getHasFlags() { return hasFlags; }
	public: void setHasFlags(int32_t v);
	public: int32_t getHasNotFlags() { return hasNotFlags; }
	public: void setHasNotFlags(int32_t v);
	public: int32_t getHasFlags2() { return hasFlags2; }
	public: void setHasFlags2(int32_t v);
	public: int32_t getHasNotFlags2() { return hasNotFlags2; }
	public: void setHasNotFlags2(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// FindWorkflowInfo
// typeId=1768797010

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// This class contains the search criteria for selecting workflows.
/// </summary>
/// <remarks>
/// <p>
/// Copyright: Copyright (c) 2008, 2010
/// </p>
/// <p>
/// Organisation: ELO Digital Office GmbH
/// </p>
/// </remarks>
class FindWorkflowInfo : public ValueClass {
	/// <summary>
	/// Collect workflows for this users.
	/// </summary>
	/// <remarks>
	/// For every given user or group in this list, those workflows are returned where
	/// the user or her or his groups or her or his substituted users has any
	/// node assigned.
	/// If this value is null or empty and the current user is a workflow administrator,
	/// the returned list of workflows is not constrained to any user ID.
	/// If this value is null or empty and the current user is not a workflow administrator,
	/// workflows for the current user inclusive her or his groups and inclusive her or his substituted users are returned.
	/// A Workflow administrator (privilege AccessC.FLAG_EDITWF) can specify
	/// any user or group ID here. Another user can only specify her or his user ID
	/// or her or his groups or her or his substituted users.
	/// </remarks>
	protected: PArrayString userIds;
	/// <summary>
	/// Workflow name.
	/// </summary>
	/// <remarks>
	/// If not null and not empty, it the search is restricted to workflows named like this value.
	/// It may contain wildcards, e. g. *bill*.
	/// </remarks>
	protected: ::std::wstring name;
	/// <summary>
	/// Workflow type.
	/// </summary>
	/// <remarks>
	/// This parameter controls the search for nodes of either active or
	/// finished workflows. If this parameter is null, the search is performed on active workflows.
	/// </remarks>
	protected: PWFTypeZ type;
	/// <summary>
	/// Collect only WFs that exceeded the time limit.
	/// </summary>
	/// <remarks>
	/// The entire WF or one of its nodes must be over time.
	/// </remarks>
	protected: bool overTimeLimit;
	/// <summary>
	/// Object ID.
	/// </summary>
	/// <remarks>
	/// Active and finished workflows only.
	/// If not null and not empty, only workflows assigned to this object are returned.
	/// </remarks>
	protected: ::std::wstring objId;
	/// <summary>
	/// Start date.
	/// </summary>
	/// <remarks>
	/// If not null and not empty, workflows started at this date or in this date range are returned.
	/// It can be a single date value or a time span of two ISO dates separated by "...". To
	/// return workflows with a start date up to a given time, set startDateIso="..."+time
	/// (the first time value can be omitted).
	/// </remarks>
	protected: ::std::wstring startDateIso;
	/// <summary>
	/// Completion date.
	/// </summary>
	/// <remarks>
	/// If not null and not empty, workflows completed at this date or in this date range are returned.
	/// Only valid if <code>wfType=FINISHED</code>.
	/// A time span can be specified by using "...".
	/// </remarks>
	protected: ::std::wstring completionDateIso;
	/// <summary>
	/// Workflow template ID or name.
	/// </summary>
	/// <remarks>
	/// If not null and not empty, the result is constrained to workflows based on this workflow template.
	/// </remarks>
	protected: ::std::wstring templateId;
	/// <summary>
	/// Only template workflows: include deleted templates.
	/// </summary>
	protected: bool inclDeleted;
	/// <summary>
	/// List with ownerIds.
	/// </summary>
	/// <remarks>
	/// If not null and not empty only the workflows with these owners will be returned.
	/// </remarks>
	protected: PArrayString ownerIds;
	/// <summary>
	/// List with userIds.
	/// </summary>
	/// <remarks>
	/// If not null and not empty only the workflows with this active users will be returned.
	/// ActiveUsers are the users of the active workflow node.
	/// </remarks>
	protected: PArrayString activeUserIds;
	/// <summary>
	/// If true, include hidden/technical workflows with the result.
	/// </summary>
	protected: bool inclHidden;
	/// <summary>
	/// Return the associated Sord objects to the selected workflows.
	/// </summary>
	/// <remarks>
	/// If this member is not null, the Sord objects to the selected workflows are read from the database.
	/// The Sord objects can be found in {@link FindResult#sords} in a random order.
	/// A Sord object is returned only once, even if there are more workflows assigned to the Sord.
	/// The Sord objects contain the elements defined in this element selector as valid members.
	/// </remarks>
	protected: PSordZ sordZ;
	/// <summary>
	/// If true, only select workflows of the users.
	/// </summary>
	/// <remarks>
	/// The group workflows are excluded.
	/// </remarks>
	protected: bool excludeUserGroups;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: FindWorkflowInfo();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: FindWorkflowInfo(const PArrayString& userIds, const ::std::wstring& name, const PWFTypeZ& type, bool overTimeLimit, const ::std::wstring& objId, const ::std::wstring& startDateIso, const ::std::wstring& completionDateIso, const ::std::wstring& templateId, bool inclDeleted, const PArrayString& ownerIds, const PArrayString& activeUserIds, bool inclHidden, const PSordZ& sordZ, bool excludeUserGroups);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: PArrayString getUserIds() { return userIds; }
	public: void setUserIds(PArrayString v);
	public: ::std::wstring getName() { return name; }
	public: void setName(::std::wstring v);
	public: PWFTypeZ getType() { return type; }
	public: void setType(PWFTypeZ v);
	public: bool getOverTimeLimit() { return overTimeLimit; }
	public: void setOverTimeLimit(bool v);
	public: ::std::wstring getObjId() { return objId; }
	public: void setObjId(::std::wstring v);
	public: ::std::wstring getStartDateIso() { return startDateIso; }
	public: void setStartDateIso(::std::wstring v);
	public: ::std::wstring getCompletionDateIso() { return completionDateIso; }
	public: void setCompletionDateIso(::std::wstring v);
	public: ::std::wstring getTemplateId() { return templateId; }
	public: void setTemplateId(::std::wstring v);
	public: bool getInclDeleted() { return inclDeleted; }
	public: void setInclDeleted(bool v);
	public: PArrayString getOwnerIds() { return ownerIds; }
	public: void setOwnerIds(PArrayString v);
	public: PArrayString getActiveUserIds() { return activeUserIds; }
	public: void setActiveUserIds(PArrayString v);
	public: bool getInclHidden() { return inclHidden; }
	public: void setInclHidden(bool v);
	public: PSordZ getSordZ() { return sordZ; }
	public: void setSordZ(PSordZ v);
	public: bool getExcludeUserGroups() { return excludeUserGroups; }
	public: void setExcludeUserGroups(bool v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// FontInfo
// typeId=1478273890

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// This class describes a font.
/// </summary>
class FontInfo : public BSerializable {
	/// <summary>
	/// Font face name
	/// </summary>
	protected: ::std::wstring faceName;
	/// <summary>
	/// Bold
	/// </summary>
	protected: bool bold;
	/// <summary>
	/// Italic
	/// </summary>
	protected: bool italic;
	/// <summary>
	/// Strike out
	/// </summary>
	protected: bool strikeOut;
	/// <summary>
	/// Underline
	/// </summary>
	protected: bool underline;
	/// <summary>
	/// Read-green-blue value.
	/// </summary>
	/// <remarks>
	/// On byte each color.
	/// Read is at the lowest significant byte.
	/// </remarks>
	protected: int32_t RGB;
	/// <summary>
	/// Font heigth.
	/// </summary>
	protected: int32_t height;
	/// <summary>
	/// The font height is related to the cell height of the font rather than the
	/// character heigth.
	/// </summary>
	protected: bool heightPerCell;
	/// <summary>
	/// Specifies the angle, in tenths of degrees, between the escapement vector and the x-axis of the device.
	/// </summary>
	/// <remarks>
	/// The escapement vector is parallel to the base line of a row of text.
	/// </remarks>
	protected: int32_t escapement;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: FontInfo();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: FontInfo(const ::std::wstring& faceName, bool bold, bool italic, bool strikeOut, bool underline, int32_t RGB, int32_t height, bool heightPerCell, int32_t escapement);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: ::std::wstring getFaceName() { return faceName; }
	public: void setFaceName(::std::wstring v);
	public: bool getBold() { return bold; }
	public: void setBold(bool v);
	public: bool getItalic() { return italic; }
	public: void setItalic(bool v);
	public: bool getStrikeOut() { return strikeOut; }
	public: void setStrikeOut(bool v);
	public: bool getUnderline() { return underline; }
	public: void setUnderline(bool v);
	public: int32_t getRGB() { return RGB; }
	public: void setRGB(int32_t v);
	public: int32_t getHeight() { return height; }
	public: void setHeight(int32_t v);
	public: bool getHeightPerCell() { return heightPerCell; }
	public: void setHeightPerCell(bool v);
	public: int32_t getEscapement() { return escapement; }
	public: void setEscapement(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// ForwardWorkflowNodeInfo
// typeId=523867474

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// This class controls workflow node forwarding in {@link IXServicePortIF#forwardWorkflowNode(ClientInfo, int, int, ForwardWorkflowNodeInfo, LockZ)}.
/// </summary>
class ForwardWorkflowNodeInfo : public ValueClass {
	/// <summary>
	/// Terminate the workflow instead of forwarding.
	/// </summary>
	/// <remarks>
	/// If this member is true, {@link #successorNodesToActivate} and {@link #node} are ignored.
	/// </remarks>
	protected: bool terminateWorkflow;
	/// <summary>
	/// List of successor nodes to be activated.
	/// </summary>
	/// <remarks>
	/// Set this member as null, if only node data should be changed. In this case, the the workflow is not forwarded.
	/// </remarks>
	protected: byps::PVectorInteger successorNodesToActivate;
	/// <summary>
	/// Workflow node to forward.
	/// </summary>
	/// <remarks>
	/// The following members of this value are taken into account and update the related database values:
	/// {@link WFNode#name}, {@link WFNode#comment}, {@link WFNode#prio}.
	/// </remarks>
	protected: PWFNode node;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: ForwardWorkflowNodeInfo();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: ForwardWorkflowNodeInfo(bool terminateWorkflow, const byps::PVectorInteger& successorNodesToActivate, const PWFNode& node);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: bool getTerminateWorkflow() { return terminateWorkflow; }
	public: void setTerminateWorkflow(bool v);
	public: byps::PVectorInteger getSuccessorNodesToActivate() { return successorNodesToActivate; }
	public: void setSuccessorNodesToActivate(byps::PVectorInteger v);
	public: PWFNode getNode() { return node; }
	public: void setNode(PWFNode v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// ForwardWorkflowNodeResult
// typeId=1699606509

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

class ForwardWorkflowNodeResult : public ValueClass {
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: ForwardWorkflowNodeResult();
	
	public: virtual BTYPEID BSerializable_getTypeId();
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// FulltextConfig
// typeId=239574905

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// This class provides information about the configuration of the fulltext database.
/// </summary>
class FulltextConfig : public ValueClass {
	/// <summary>
	/// One of the FulltextConfigC.SOURCE_* constants.
	/// </summary>
	protected: int32_t source;
	/// <summary>
	/// A combination of FulltextConfigC.FLAG_* constants.
	/// </summary>
	protected: int32_t flags;
	/// <summary>
	/// URL of the Knowlege Map service.
	/// </summary>
	/// <remarks>
	/// Only valid for iSearch.
	/// </remarks>
	protected: ::std::wstring knowlegeMapUrl;
	protected: de::elo::ix::client::search::PSearchIndexerConfig indexerConfig;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: FulltextConfig();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: FulltextConfig(int32_t source, int32_t flags, const ::std::wstring& knowlegeMapUrl, const de::elo::ix::client::search::PSearchIndexerConfig& indexerConfig);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getSource() { return source; }
	public: void setSource(int32_t v);
	public: int32_t getFlags() { return flags; }
	public: void setFlags(int32_t v);
	public: ::std::wstring getKnowlegeMapUrl() { return knowlegeMapUrl; }
	public: void setKnowlegeMapUrl(::std::wstring v);
	public: de::elo::ix::client::search::PSearchIndexerConfig getIndexerConfig() { return indexerConfig; }
	public: void setIndexerConfig(de::elo::ix::client::search::PSearchIndexerConfig v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// FulltextConfigC
// typeId=2025824562

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Constants for class FulltextConfig.
/// </summary>
class FulltextConfigC : public BSerializable {
	/// <summary>
	/// Use fulltext information from inverse index stored in the archive database.
	/// </summary>
	public: const static int32_t SOURCE_CLASSIC = 0;
	/// <summary>
	/// Use fulltext information from Microsoft SQL-Server fulltext catalog.
	/// </summary>
	public: const static int32_t SOURCE_FTCAT = 1;
	/// <summary>
	/// Use fulltext information from iSearch.
	/// </summary>
	public: const static int32_t SOURCE_ISEARCH = 2;
	/// <summary>
	/// Use fulltext information from Elasticsearch.
	/// </summary>
	public: const static int32_t SOURCE_ELASTICSEARCH = 3;
	/// <summary>
	/// Evaluate suggestions for similar terms (= corrections)
	/// </summary>
	public: const static int32_t FLAG_ISEARCH_DID_YOU_MEAN = 1;
	/// <summary>
	/// Perform a search for each pressed key (= completion)
	/// </summary>
	public: const static int32_t FLAG_ISEARCH_SEARCH_AS_YOU_TYPE = 2;
	/// <summary>
	/// Retrieve a summary text for each word.
	/// </summary>
	public: const static int32_t FLAG_ISEARCH_SUMMARY = 4;
	/// <summary>
	/// Use the thesaurus of the company.
	/// </summary>
	public: const static int32_t FLAG_ISEARCH_COMPANY_THESAURUS = 8;
	/// <summary>
	/// Use the extension "Knowlege Map".
	/// </summary>
	public: const static int32_t FLAG_ISEARCH_KNOWLEGE_MAP = 16;
	/// <summary>
	/// Use the extension "Ontology Net".
	/// </summary>
	public: const static int32_t FLAG_ISEARCH_ONTOLOGY_NET = 32;
	/// <summary>
	/// Use thesaurus provided by ELO (= synonyms)
	/// </summary>
	public: const static int32_t FLAG_ISEARCH_ELO_THESAURUS = 64;
	/// <summary>
	/// Turn off all search options (if 0 or not in db,
	/// a default set of search options (correction,
	/// synonyms, search terms) is turned on).
	/// </summary>
	/// <remarks>
	/// If combined with other flags, the other options
	/// are turned on.
	/// </remarks>
	public: const static int32_t FLAG_ISEARCH_OPTIONSOFF = 128;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: FulltextConfigC();
	
	public: virtual BTYPEID BSerializable_getTypeId();
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// GetWebDAVPathOptions
// typeId=1410517836

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Parameter class for the function {@link IXServicePortIF#getWebDAVPathFromObjID2}
/// </summary>
class GetWebDAVPathOptions : public ValueClass {
	/// <summary>
	/// If true, the ticket is inserted in the path.
	/// </summary>
	protected: bool tickketInPath;
	/// <summary>
	/// ObjectId or GUID of the sord to get the path.
	/// </summary>
	protected: ::std::wstring objId;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: GetWebDAVPathOptions();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: GetWebDAVPathOptions(bool tickketInPath, const ::std::wstring& objId);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: bool getTickketInPath() { return tickketInPath; }
	public: void setTickketInPath(bool v);
	public: ::std::wstring getObjId() { return objId; }
	public: void setObjId(::std::wstring v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// GetWebDAVPathResult
// typeId=148564345

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Class for the result of the IX function {@link IXServicePortIF#getWebDAVPathFromObjID2}
/// </summary>
class GetWebDAVPathResult : public ValueClass {
	/// <summary>
	/// The generated WEBDAV path.
	/// </summary>
	protected: ::std::wstring path;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: GetWebDAVPathResult();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: GetWebDAVPathResult(const ::std::wstring& path);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: ::std::wstring getPath() { return path; }
	public: void setPath(::std::wstring v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// HttpRequestInfo
// typeId=1892343155

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// This class contains information from the HttpServletRequest received by the Indexserver servlet
/// </summary>
class HttpRequestInfo : public ValueClass {
	/// <summary>
	/// HTTP Headers
	/// </summary>
	protected: PArrayKeyValue headers;
	/// <summary>
	/// HTTP Cookies
	/// </summary>
	protected: PArrayKeyValue cookies;
	/// <summary>
	/// Request parameters.
	/// </summary>
	protected: PArrayKeyValue requestParams;
	/// <summary>
	/// Value of the request URI.
	/// </summary>
	/// <remarks>
	/// HttpServletRequest.getRequestURI()
	/// </remarks>
	protected: ::std::wstring requestURI;
	/// <summary>
	/// Value of the request URL.
	/// </summary>
	/// <remarks>
	/// HttpServletRequest.getRequestURL()
	/// </remarks>
	protected: ::std::wstring requestURL;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: HttpRequestInfo();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: HttpRequestInfo(const PArrayKeyValue& headers, const PArrayKeyValue& cookies, const PArrayKeyValue& requestParams, const ::std::wstring& requestURI, const ::std::wstring& requestURL);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: PArrayKeyValue getHeaders() { return headers; }
	public: void setHeaders(PArrayKeyValue v);
	public: PArrayKeyValue getCookies() { return cookies; }
	public: void setCookies(PArrayKeyValue v);
	public: PArrayKeyValue getRequestParams() { return requestParams; }
	public: void setRequestParams(PArrayKeyValue v);
	public: ::std::wstring getRequestURI() { return requestURI; }
	public: void setRequestURI(::std::wstring v);
	public: ::std::wstring getRequestURL() { return requestURL; }
	public: void setRequestURL(::std::wstring v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// HttpResponseInfo
// typeId=1552189905

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// This class contains information for the HttpServletResponse object to be sent by the Indexserver servlet.
/// </summary>
class HttpResponseInfo : public ValueClass {
	/// <summary>
	/// Content type header.
	/// </summary>
	/// <remarks>
	/// HttpServletResponse.setContentType()
	/// </remarks>
	public: ::std::wstring contentType;
	/// <summary>
	/// Response text.
	/// </summary>
	/// <remarks>
	/// Written to HttpServletResponse.getOutputStream()
	/// </remarks>
	public: ::std::wstring responseString;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: HttpResponseInfo();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: HttpResponseInfo(const ::std::wstring& contentType, const ::std::wstring& responseString);	
	public: virtual BTYPEID BSerializable_getTypeId();
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// IXExceptionC
// typeId=1204588365

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// This class contains constant definitions for IndexServer error numbers used
/// in IndexServer exceptions.
/// </summary>
/// <remarks>
/// <p>Copyright: Copyright (c) 2004</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </remarks>
class IXExceptionC : public BSerializable {
	/// <summary>
	/// Problem in the server configuration.
	/// </summary>
	public: const static int32_t SERVER_ERROR = 1000;
	/// <summary>
	/// Unsupported protocol version.
	/// </summary>
	/// <remarks>
	/// This error is thrown, if the protocol version cannot be negotiated.
	/// A reason for this can be different major release versions of client and server.
	/// </remarks>
	public: const static int32_t UNSUPPORTED_PROTOCOL_VERSION = 1001;
	/// <summary>
	/// Invalid parameter was given.
	/// </summary>
	public: const static int32_t INVALID_PARAM = 2000;
	/// <summary>
	/// Session is not (or no longer) valid.
	/// </summary>
	public: const static int32_t INVALID_SESSION = 2001;
	/// <summary>
	/// Temporarily problem, a later try should succeed.
	/// </summary>
	/// <remarks>
	/// The value of TEMP_PROBLEM must be changed in IX 8.00.054, because the current client
	/// libraries recognize it as an exception where relogin is required. This could lead
	/// to the effect described in TTS001661.
	/// </remarks>
	public: const static int32_t TEMP_PROBLEM_OLD = 2002;
	/// <summary>
	/// Temporarily problem, a later try should succeed.
	/// </summary>
	public: const static int32_t TEMP_PROBLEM = 2003;
	/// <summary>
	/// Encryption key must be set before documents can be encrypted.
	/// </summary>
	public: const static int32_t INVALID_CRYPT_KEY = 2004;
	/// <summary>
	/// Syntax error e.g. in search request.
	/// </summary>
	public: const static int32_t SYNTAX_ERROR = 2007;
	/// <summary>
	/// The given password violates the password rules.
	/// </summary>
	/// <remarks>
	/// The passord rules are stored in the user profile value {@link UserProfileC#KEY_PASSWORD_RULES}.
	/// </remarks>
	public: const static int32_t PASSWORD_DENIED = 3007;
	/// <summary>
	/// Specified object to be created already exists.
	/// </summary>
	public: const static int32_t ALREADY_EXISTS = 5005;
	/// <summary>
	/// Specified data is locked.
	/// </summary>
	public: const static int32_t LOCKED = 5022;
	/// <summary>
	/// Specified data could not be found.
	/// </summary>
	public: const static int32_t NOT_FOUND = 5023;
	/// <summary>
	/// Access to the specified object was denied, there are rights missing.
	/// </summary>
	public: const static int32_t ACCESS_DENIED = 5024;
	/// <summary>
	/// Specified data could not be found.
	/// </summary>
	public: const static int32_t NOT_EMPTY = 5066;
	/// <summary>
	/// An error thrown in a script file is passed to the client application with this error code.
	/// </summary>
	/// <remarks>
	/// E.g. [ELOIX:6000] "Message text thrown in script".
	/// </remarks>
	public: const static int32_t SCRIPT_ERROR = 6000;
	/// <summary>
	/// Not a ELO IX Exception
	/// </summary>
	public: const static int32_t NOT_IX = -1;
	/// <summary>
	/// Internal error.
	/// </summary>
	public: const static int32_t INTERNAL = 9000;
	/// <summary>
	/// Function is not currently supported.
	/// </summary>
	public: const static int32_t UNSUPPORTED_FUNCTION = 9999;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: IXExceptionC();
	
	public: virtual BTYPEID BSerializable_getTypeId();
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// IXExceptionData
// typeId=784089396

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// This class describes an exception that can occur during the execution of an
/// Index server function.
/// </summary>
/// <remarks>
/// <p>Copyright: Copyright (c) 2004</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </remarks>
class IXExceptionData : public ValueClass {
	/// <summary>
	/// String containing the ClientInfo.callId for the ClientInfo object.
	/// </summary>
	/// <remarks>
	/// This is
	/// given to the function which triggered/caused the error.
	/// </remarks>
	protected: ::std::wstring callId;
	/// <summary>
	/// Detail text for the exception.
	/// </summary>
	protected: ::std::wstring details;
	/// <summary>
	/// This is the type of exception.
	/// </summary>
	/// <remarks>
	/// This is one of the constants from IXExceptionC.
	/// </remarks>
	protected: int32_t exceptionType;
	/// <summary>
	/// The error message text for the exception.
	/// </summary>
	protected: ::std::wstring message;
	/// <summary>
	/// Ticket given to the function.
	/// </summary>
	protected: ::std::wstring ticket;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: IXExceptionData();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: IXExceptionData(const ::std::wstring& callId, const ::std::wstring& details, int32_t exceptionType, const ::std::wstring& message, const ::std::wstring& ticket);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: ::std::wstring getCallId() { return callId; }
	public: void setCallId(::std::wstring v);
	public: ::std::wstring getDetails() { return details; }
	public: void setDetails(::std::wstring v);
	public: int32_t getExceptionType() { return exceptionType; }
	public: void setExceptionType(int32_t v);
	public: ::std::wstring getMessage() { return message; }
	public: void setMessage(::std::wstring v);
	public: ::std::wstring getTicket() { return ticket; }
	public: void setTicket(::std::wstring v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// IXServerEventsC
// typeId=1963572851

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

class IXServerEventsC : public BSerializable {
	/// <summary>
	/// Version information used in serialization with IxDataStream
	/// </summary>
	public: const static ::std::wstring STREAM_VERSION;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: IXServerEventsC();
	
	public: virtual BTYPEID BSerializable_getTypeId();
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// IXServerEventsContext
// typeId=956691491

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

class IXServerEventsContext : public ValueClass {
	/// <summary>
	/// IndexServer URL.
	/// </summary>
	protected: ::std::wstring url;
	/// <summary>
	/// ClientInfo object including session ticket
	/// </summary>
	protected: PClientInfo ci;
	/// <summary>
	/// Current user
	/// </summary>
	protected: PUserInfo user;
	/// <summary>
	/// SessionOptions associated to this connection.
	/// </summary>
	protected: byps::PMapStringString sessionOptions;
	/// <summary>
	/// Parameter clientComputer from login function.
	/// </summary>
	protected: ::std::wstring clientComputer;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: IXServerEventsContext();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: IXServerEventsContext(const ::std::wstring& url, const PClientInfo& ci, const PUserInfo& user, const byps::PMapStringString& sessionOptions, const ::std::wstring& clientComputer);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: ::std::wstring getUrl() { return url; }
	public: void setUrl(::std::wstring v);
	public: PClientInfo getCi() { return ci; }
	public: void setCi(PClientInfo v);
	public: PUserInfo getUser() { return user; }
	public: void setUser(PUserInfo v);
	public: byps::PMapStringString getSessionOptions() { return sessionOptions; }
	public: void setSessionOptions(byps::PMapStringString v);
	public: ::std::wstring getClientComputer() { return clientComputer; }
	public: void setClientComputer(::std::wstring v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// IXServicePortC
// typeId=1264954948

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// <p>Constants for options and classes used by IndexServer.
/// </summary>
/// <remarks>
/// </p>
/// 
/// <p>Copyright: Copyright (c) 2004</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </remarks>
class IXServicePortC : public BSerializable {
	/// <summary>
	/// Version information used in serialization with IxDataStream
	/// </summary>
	public: const static ::std::wstring STREAM_VERSION;
	/// <summary>
	/// Constants for access rights.
	/// </summary>
	protected: PAccessC ACCESS;
	/// <summary>
	/// Constants for access control lists.
	/// </summary>
	protected: PAclItemC ACL_ITEM;
	/// <summary>
	/// Constants for Activities
	/// </summary>
	protected: PActivityC ACTIVITY;
	/// <summary>
	/// Constants for Activity project options.
	/// </summary>
	protected: PActivityProjectC ACTIVITY_PROJECT;
	/// <summary>
	/// Constants for Alerts (messages).
	/// </summary>
	protected: PAlertC ALERT;
	/// <summary>
	/// Archiving modes like version controlled, read-only,...
	/// </summary>
	protected: PArchivingModeC ARCHIVING_MODE;
	/// <summary>
	/// Options for the <code>checkinUsers</code> function.
	/// </summary>
	protected: PCheckinUsersC CHECKIN_USERS;
	/// <summary>
	/// Options for the <code>checkoutUsers</code> function.
	/// </summary>
	protected: PCheckoutUsersC CHECKOUT_USERS;
	/// <summary>
	/// Constants for colours
	/// </summary>
	protected: PColorDataC COLOR;
	/// <summary>
	/// Constanst for ConfigFile.
	/// </summary>
	protected: PConfigFileC CONFIG_FILE;
	/// <summary>
	/// Constants (options) for the <code>copySord</code> function.
	/// </summary>
	protected: PCopySordC COPY_SORD;
	/// <summary>
	/// Constants for CounterInfo.
	/// </summary>
	protected: PCounterInfoC COUNTER_INFO;
	/// <summary>
	/// Constants for storage masks.
	/// </summary>
	protected: PDocMaskC DOC_MASK;
	/// <summary>
	/// Constants for storage mask index lines.
	/// </summary>
	protected: PDocMaskLineC DOC_MASK_LINE;
	/// <summary>
	/// Constants for document or attachment version history.
	/// </summary>
	protected: PDocVersionC DOC_VERSION;
	/// <summary>
	/// Constants for editing indexing information and documents.
	/// </summary>
	protected: PEditInfoC EDIT_INFO;
	/// <summary>
	/// Export options constants.
	/// </summary>
	protected: PExportOptionsC EXPORT_OPTIONS;
	/// <summary>
	/// Import options constants.
	/// </summary>
	protected: PImportOptionsC IMPORT_OPTIONS;
	/// <summary>
	/// Error numbers used in IndexServer exceptions.
	/// </summary>
	protected: PIXExceptionC IXEXCEPTION;
	/// <summary>
	/// Keyword constants.
	/// </summary>
	protected: PKeywordC KEYWORD;
	/// <summary>
	/// Constants for linkSords
	/// </summary>
	protected: PLinkSordC LINK_SORD;
	/// <summary>
	/// Constants to lock and unlock data against concurrent modification.
	/// </summary>
	protected: PLockC LOCK;
	/// <summary>
	/// Constants for navigation information.
	/// </summary>
	protected: PNavigationInfoC NAV_INFO;
	/// <summary>
	/// Note.
	/// </summary>
	protected: PNoteC NOTE;
	/// <summary>
	/// Index lines of indexing information.
	/// </summary>
	protected: PObjKeyC OBJ_KEY;
	/// <summary>
	/// Constants for process information
	/// </summary>
	protected: PProcessInfoC PROCESS_INFO;
	/// <summary>
	/// Constants for reminders.
	/// </summary>
	protected: PReminderC REMINDER;
	/// <summary>
	/// Constants for replication set names.
	/// </summary>
	protected: PReplSetNameC REPL_SET_NAME;
	/// <summary>
	/// Constants for report.
	/// </summary>
	protected: PReportC REPORT;
	/// <summary>
	/// ReportInfo constants including report action codes.
	/// </summary>
	protected: PReportInfoC REPORT_INFO;
	/// <summary>
	/// Constants for report modes (no, limited, verbose, full).
	/// </summary>
	protected: PReportModeC REPORT_MODE;
	/// <summary>
	/// Constants for report options containing report erp codes
	/// </summary>
	protected: PReportOptionsC REPORT_OPTIONS;
	/// <summary>
	/// Constants for find options.
	/// </summary>
	protected: PSearchModeC SEARCH_MODE;
	/// <summary>
	/// Constants for server state providing the status of server modules.
	/// </summary>
	protected: PServerStateC SERVER_STATE;
	/// <summary>
	/// Constants for session options.
	/// </summary>
	protected: PSessionOptionsC SESSION_OPTIONS;
	/// <summary>
	/// Constants for the indexing information (Sord object).
	/// </summary>
	protected: PSordC SORD;
	/// <summary>
	/// Constants for sord history.
	/// </summary>
	protected: PSordHistC SORD_HIST;
	/// <summary>
	/// Constants for sord history entries.
	/// </summary>
	protected: PSordHistKeyC SORD_HIST_KEY;
	/// <summary>
	/// Constants for sord type.
	/// </summary>
	protected: PSordTypeC SORD_TYPE;
	/// <summary>
	/// Sort orders like manually, alphabetically, ...
	/// </summary>
	protected: PSortOrderC SORT_ORDER;
	/// <summary>
	/// Constants for store info.
	/// </summary>
	protected: PStoreInfoC STORE_INFO;
	/// <summary>
	/// Constants for take node.
	/// </summary>
	protected: PWFTakeNodeC TAKE_NODE;
	/// <summary>
	/// Constants for thesaurus.
	/// </summary>
	protected: PThesaurusC THESAURUS;
	/// <summary>
	/// Constants for user information.
	/// </summary>
	protected: PUserInfoC USER_INFO;
	/// <summary>
	/// Constants for user profile.
	/// </summary>
	protected: PUserProfileC USER_PROFILE;
	/// <summary>
	/// Priority constants.
	/// </summary>
	protected: PUserTaskPriorityC USER_TASK_PRIORITY;
	/// <summary>
	/// Sort order used when collecting tasks.
	/// </summary>
	protected: PUserTaskSortOrderC USER_TASK_SORT_ORDER;
	/// <summary>
	/// Constants for the control of the fulltext service.
	/// </summary>
	protected: PVtDocC VT_DOC;
	/// <summary>
	/// Constants for Workflows
	/// </summary>
	protected: PWFDiagramC WORKFLOW;
	/// <summary>
	/// Constants for workflow nodes
	/// </summary>
	protected: PWFNodeC WORKFLOW_NODE;
	/// <summary>
	/// Constants for workflow node association types used by WFNodeMatrix
	/// </summary>
	protected: PWFNodeMatrixC WORKFLOW_NODE_ASSOC_TYPE;
	/// <summary>
	/// Constants for workflows
	/// </summary>
	protected: PWFTypeC WORKFLOW_TYPE;
	/// <summary>
	/// Constants for function invalidateCache.
	/// </summary>
	protected: PInvalidateCacheC INVALIDATE_CACHE;
	/// <summary>
	/// Constants for WFVersion.
	/// </summary>
	protected: PWFVersionC WORKFLOW_VERSION;
	/// <summary>
	/// Constants for NoteTemplate
	/// </summary>
	protected: PNoteTemplateC NOTE_TEMPLATE;
	/// <summary>
	/// Constants for NoteFreehand
	/// </summary>
	protected: PNoteFreehandC NOTE_FREEHAND;
	/// <summary>
	/// Constants for getArchiveStatistics
	/// </summary>
	protected: PArchiveStatisticsOptionsC ARCHIVE_STATISTICS_OPTIONS;
	/// <summary>
	/// Constants for MapDomain, checkoutMap etc.
	/// </summary>
	protected: PMapDomainC MAP_CONFIG;
	/// <summary>
	/// Constants for MapDomain, checkoutMap etc.
	/// </summary>
	protected: PMapDomainC MAP_DOMAIN;
	/// <summary>
	/// Constants for IndexServer options.
	/// </summary>
	protected: PEloIxOptC ELO_IX_OPT;
	/// <summary>
	/// Constants for class Any.
	/// </summary>
	protected: PAnyC ANY;
	/// <summary>
	/// Constants for {@link IXServicePortIF#getSearchTerms(ClientInfo, FindInfo, int)}.
	/// </summary>
	protected: PSearchTermsC SEARCH_TERMS;
	/// <summary>
	/// Constants for the administration mode.
	/// </summary>
	protected: PAdminModeC ADMIN_MODE;
	/// <summary>
	/// Constanst for the fulltext configuration.
	/// </summary>
	protected: PFulltextConfigC FULLTEXT_CONFIG;
	/// <summary>
	/// Constants for the class ServerInfoDM.
	/// </summary>
	protected: PServerInfoDMC SERVER_INFO_DM;
	/// <summary>
	/// Constants for the class FindDirect.
	/// </summary>
	protected: PFindDirectC FIND_DIRECT;
	/// <summary>
	/// Constants for feed actions.
	/// </summary>
	protected: de::elo::ix::client::feed::PActionC ACTION;
	/// <summary>
	/// Constants for document feed.
	/// </summary>
	protected: de::elo::ix::client::feed::PFeedC FEED;
	/// <summary>
	/// Constants for translate term.
	/// </summary>
	protected: PTranslateTermC TRANSLATE_TERM;
	/// <summary>
	/// Constants for event busses.
	/// </summary>
	protected: PEventBusC EVENT_BUS;
	/// <summary>
	/// Constants for preview image info.
	/// </summary>
	protected: PPreviewImageInfoC PREVIEW_IMAGE_INFO;
	/// <summary>
	/// Constants for resolving rights.
	/// </summary>
	protected: PResolveRightsResultC RESOLVE_RIGHTS;
	/// <summary>
	/// Constants for {@link de.elo.ix.client.feed.FeedService#findFirstActions(ClientInfo, de.elo.ix.client.feed.FindActionsInfo, int, de.elo.ix.client.feed.ActionZ)}.
	/// </summary>
	protected: de::elo::ix::client::feed::PFindActionsInfoC FIND_ACTIONS_INFO;
	/// <summary>
	/// Constants for Subscription
	/// </summary>
	protected: PSubscriptionC SUBSCRIPTION;
	/// <summary>
	/// Constants for MapData
	/// </summary>
	protected: PMapDataC MAP_DATA;
	/// <summary>
	/// Constants for class MapHist.
	/// </summary>
	protected: PMapHistC MAP_HIST;
	/// <summary>
	/// Constants for function {@link IXServicePortIF#exportWorkflow(ClientInfo, WorkflowExportOptions)}.
	/// </summary>
	protected: PWorkflowExportOptionsC WORKFLOW_EXPORT_OPTIONS;
	/// <summary>
	/// Constants for workflow history.
	/// </summary>
	protected: PWFNodeHistoryC WORKFLOW_NODE_HISTORY;
	/// <summary>
	/// Constants for storage mask index line templates.
	/// </summary>
	protected: PDocMaskLineTemplateC DOC_MASK_LINE_TEMPLATE;
	/// <summary>
	/// Constants for public download.
	/// </summary>
	protected: PPublicDownloadC PUBLIC_DOWNLOAD;
	/// <summary>
	/// Constants for FileDataC.
	/// </summary>
	protected: PFileDataC FILE_DATA;
	/// <summary>
	/// Constants for OcrInfoC.
	/// </summary>
	protected: POcrInfoC OCR_INFO;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: IXServicePortC();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: IXServicePortC(const ::std::wstring& STREAM_VERSION, const PAccessC& ACCESS, const PAclItemC& ACL_ITEM, const PActivityC& ACTIVITY, const PActivityProjectC& ACTIVITY_PROJECT, const PAlertC& ALERT, const PArchivingModeC& ARCHIVING_MODE, const PCheckinUsersC& CHECKIN_USERS, const PCheckoutUsersC& CHECKOUT_USERS, const PColorDataC& COLOR, const PConfigFileC& CONFIG_FILE, const PCopySordC& COPY_SORD, const PCounterInfoC& COUNTER_INFO, const PDocMaskC& DOC_MASK, const PDocMaskLineC& DOC_MASK_LINE, const PDocVersionC& DOC_VERSION, const PEditInfoC& EDIT_INFO, const PExportOptionsC& EXPORT_OPTIONS, const PImportOptionsC& IMPORT_OPTIONS, const PIXExceptionC& IXEXCEPTION, const PKeywordC& KEYWORD, const PLinkSordC& LINK_SORD, const PLockC& LOCK, const PNavigationInfoC& NAV_INFO, const PNoteC& NOTE, const PObjKeyC& OBJ_KEY, const PProcessInfoC& PROCESS_INFO, const PReminderC& REMINDER, const PReplSetNameC& REPL_SET_NAME, const PReportC& REPORT, const PReportInfoC& REPORT_INFO, const PReportModeC& REPORT_MODE, const PReportOptionsC& REPORT_OPTIONS, const PSearchModeC& SEARCH_MODE, const PServerStateC& SERVER_STATE, const PSessionOptionsC& SESSION_OPTIONS, const PSordC& SORD, const PSordHistC& SORD_HIST, const PSordHistKeyC& SORD_HIST_KEY, const PSordTypeC& SORD_TYPE, const PSortOrderC& SORT_ORDER, const PStoreInfoC& STORE_INFO, const PWFTakeNodeC& TAKE_NODE, const PThesaurusC& THESAURUS, const PUserInfoC& USER_INFO, const PUserProfileC& USER_PROFILE, const PUserTaskPriorityC& USER_TASK_PRIORITY, const PUserTaskSortOrderC& USER_TASK_SORT_ORDER, const PVtDocC& VT_DOC, const PWFDiagramC& WORKFLOW, const PWFNodeC& WORKFLOW_NODE, const PWFNodeMatrixC& WORKFLOW_NODE_ASSOC_TYPE, const PWFTypeC& WORKFLOW_TYPE, const PInvalidateCacheC& INVALIDATE_CACHE, const PWFVersionC& WORKFLOW_VERSION, const PNoteTemplateC& NOTE_TEMPLATE, const PNoteFreehandC& NOTE_FREEHAND, const PArchiveStatisticsOptionsC& ARCHIVE_STATISTICS_OPTIONS, const PMapDomainC& MAP_CONFIG, const PMapDomainC& MAP_DOMAIN, const PEloIxOptC& ELO_IX_OPT, const PAnyC& ANY, const PSearchTermsC& SEARCH_TERMS, const PAdminModeC& ADMIN_MODE, const PFulltextConfigC& FULLTEXT_CONFIG, const PServerInfoDMC& SERVER_INFO_DM, const PFindDirectC& FIND_DIRECT, const de::elo::ix::client::feed::PActionC& ACTION, const de::elo::ix::client::feed::PFeedC& FEED, const PTranslateTermC& TRANSLATE_TERM, const PEventBusC& EVENT_BUS, const PPreviewImageInfoC& PREVIEW_IMAGE_INFO, const PResolveRightsResultC& RESOLVE_RIGHTS, const de::elo::ix::client::feed::PFindActionsInfoC& FIND_ACTIONS_INFO, const PSubscriptionC& SUBSCRIPTION, const PMapDataC& MAP_DATA, const PMapHistC& MAP_HIST, const PWorkflowExportOptionsC& WORKFLOW_EXPORT_OPTIONS, const PWFNodeHistoryC& WORKFLOW_NODE_HISTORY, const PDocMaskLineTemplateC& DOC_MASK_LINE_TEMPLATE, const PPublicDownloadC& PUBLIC_DOWNLOAD, const PFileDataC& FILE_DATA, const POcrInfoC& OCR_INFO);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: PAccessC getACCESS() { return ACCESS; }
	public: void setACCESS(PAccessC v);
	public: PAclItemC getACL_ITEM() { return ACL_ITEM; }
	public: void setACL_ITEM(PAclItemC v);
	public: PActivityC getACTIVITY() { return ACTIVITY; }
	public: void setACTIVITY(PActivityC v);
	public: PActivityProjectC getACTIVITY_PROJECT() { return ACTIVITY_PROJECT; }
	public: void setACTIVITY_PROJECT(PActivityProjectC v);
	public: PAlertC getALERT() { return ALERT; }
	public: void setALERT(PAlertC v);
	public: PArchivingModeC getARCHIVING_MODE() { return ARCHIVING_MODE; }
	public: void setARCHIVING_MODE(PArchivingModeC v);
	public: PCheckinUsersC getCHECKIN_USERS() { return CHECKIN_USERS; }
	public: void setCHECKIN_USERS(PCheckinUsersC v);
	public: PCheckoutUsersC getCHECKOUT_USERS() { return CHECKOUT_USERS; }
	public: void setCHECKOUT_USERS(PCheckoutUsersC v);
	public: PColorDataC getCOLOR() { return COLOR; }
	public: void setCOLOR(PColorDataC v);
	public: PConfigFileC getCONFIG_FILE() { return CONFIG_FILE; }
	public: void setCONFIG_FILE(PConfigFileC v);
	public: PCopySordC getCOPY_SORD() { return COPY_SORD; }
	public: void setCOPY_SORD(PCopySordC v);
	public: PCounterInfoC getCOUNTER_INFO() { return COUNTER_INFO; }
	public: void setCOUNTER_INFO(PCounterInfoC v);
	public: PDocMaskC getDOC_MASK() { return DOC_MASK; }
	public: void setDOC_MASK(PDocMaskC v);
	public: PDocMaskLineC getDOC_MASK_LINE() { return DOC_MASK_LINE; }
	public: void setDOC_MASK_LINE(PDocMaskLineC v);
	public: PDocVersionC getDOC_VERSION() { return DOC_VERSION; }
	public: void setDOC_VERSION(PDocVersionC v);
	public: PEditInfoC getEDIT_INFO() { return EDIT_INFO; }
	public: void setEDIT_INFO(PEditInfoC v);
	public: PExportOptionsC getEXPORT_OPTIONS() { return EXPORT_OPTIONS; }
	public: void setEXPORT_OPTIONS(PExportOptionsC v);
	public: PImportOptionsC getIMPORT_OPTIONS() { return IMPORT_OPTIONS; }
	public: void setIMPORT_OPTIONS(PImportOptionsC v);
	public: PIXExceptionC getIXEXCEPTION() { return IXEXCEPTION; }
	public: void setIXEXCEPTION(PIXExceptionC v);
	public: PKeywordC getKEYWORD() { return KEYWORD; }
	public: void setKEYWORD(PKeywordC v);
	public: PLinkSordC getLINK_SORD() { return LINK_SORD; }
	public: void setLINK_SORD(PLinkSordC v);
	public: PLockC getLOCK() { return LOCK; }
	public: void setLOCK(PLockC v);
	public: PNavigationInfoC getNAV_INFO() { return NAV_INFO; }
	public: void setNAV_INFO(PNavigationInfoC v);
	public: PNoteC getNOTE() { return NOTE; }
	public: void setNOTE(PNoteC v);
	public: PObjKeyC getOBJ_KEY() { return OBJ_KEY; }
	public: void setOBJ_KEY(PObjKeyC v);
	public: PProcessInfoC getPROCESS_INFO() { return PROCESS_INFO; }
	public: void setPROCESS_INFO(PProcessInfoC v);
	public: PReminderC getREMINDER() { return REMINDER; }
	public: void setREMINDER(PReminderC v);
	public: PReplSetNameC getREPL_SET_NAME() { return REPL_SET_NAME; }
	public: void setREPL_SET_NAME(PReplSetNameC v);
	public: PReportC getREPORT() { return REPORT; }
	public: void setREPORT(PReportC v);
	public: PReportInfoC getREPORT_INFO() { return REPORT_INFO; }
	public: void setREPORT_INFO(PReportInfoC v);
	public: PReportModeC getREPORT_MODE() { return REPORT_MODE; }
	public: void setREPORT_MODE(PReportModeC v);
	public: PReportOptionsC getREPORT_OPTIONS() { return REPORT_OPTIONS; }
	public: void setREPORT_OPTIONS(PReportOptionsC v);
	public: PSearchModeC getSEARCH_MODE() { return SEARCH_MODE; }
	public: void setSEARCH_MODE(PSearchModeC v);
	public: PServerStateC getSERVER_STATE() { return SERVER_STATE; }
	public: void setSERVER_STATE(PServerStateC v);
	public: PSessionOptionsC getSESSION_OPTIONS() { return SESSION_OPTIONS; }
	public: void setSESSION_OPTIONS(PSessionOptionsC v);
	public: PSordC getSORD() { return SORD; }
	public: void setSORD(PSordC v);
	public: PSordHistC getSORD_HIST() { return SORD_HIST; }
	public: void setSORD_HIST(PSordHistC v);
	public: PSordHistKeyC getSORD_HIST_KEY() { return SORD_HIST_KEY; }
	public: void setSORD_HIST_KEY(PSordHistKeyC v);
	public: PSordTypeC getSORD_TYPE() { return SORD_TYPE; }
	public: void setSORD_TYPE(PSordTypeC v);
	public: PSortOrderC getSORT_ORDER() { return SORT_ORDER; }
	public: void setSORT_ORDER(PSortOrderC v);
	public: PStoreInfoC getSTORE_INFO() { return STORE_INFO; }
	public: void setSTORE_INFO(PStoreInfoC v);
	public: PWFTakeNodeC getTAKE_NODE() { return TAKE_NODE; }
	public: void setTAKE_NODE(PWFTakeNodeC v);
	public: PThesaurusC getTHESAURUS() { return THESAURUS; }
	public: void setTHESAURUS(PThesaurusC v);
	public: PUserInfoC getUSER_INFO() { return USER_INFO; }
	public: void setUSER_INFO(PUserInfoC v);
	public: PUserProfileC getUSER_PROFILE() { return USER_PROFILE; }
	public: void setUSER_PROFILE(PUserProfileC v);
	public: PUserTaskPriorityC getUSER_TASK_PRIORITY() { return USER_TASK_PRIORITY; }
	public: void setUSER_TASK_PRIORITY(PUserTaskPriorityC v);
	public: PUserTaskSortOrderC getUSER_TASK_SORT_ORDER() { return USER_TASK_SORT_ORDER; }
	public: void setUSER_TASK_SORT_ORDER(PUserTaskSortOrderC v);
	public: PVtDocC getVT_DOC() { return VT_DOC; }
	public: void setVT_DOC(PVtDocC v);
	public: PWFDiagramC getWORKFLOW() { return WORKFLOW; }
	public: void setWORKFLOW(PWFDiagramC v);
	public: PWFNodeC getWORKFLOW_NODE() { return WORKFLOW_NODE; }
	public: void setWORKFLOW_NODE(PWFNodeC v);
	public: PWFNodeMatrixC getWORKFLOW_NODE_ASSOC_TYPE() { return WORKFLOW_NODE_ASSOC_TYPE; }
	public: void setWORKFLOW_NODE_ASSOC_TYPE(PWFNodeMatrixC v);
	public: PWFTypeC getWORKFLOW_TYPE() { return WORKFLOW_TYPE; }
	public: void setWORKFLOW_TYPE(PWFTypeC v);
	public: PInvalidateCacheC getINVALIDATE_CACHE() { return INVALIDATE_CACHE; }
	public: void setINVALIDATE_CACHE(PInvalidateCacheC v);
	public: PWFVersionC getWORKFLOW_VERSION() { return WORKFLOW_VERSION; }
	public: void setWORKFLOW_VERSION(PWFVersionC v);
	public: PNoteTemplateC getNOTE_TEMPLATE() { return NOTE_TEMPLATE; }
	public: void setNOTE_TEMPLATE(PNoteTemplateC v);
	public: PNoteFreehandC getNOTE_FREEHAND() { return NOTE_FREEHAND; }
	public: void setNOTE_FREEHAND(PNoteFreehandC v);
	public: PArchiveStatisticsOptionsC getARCHIVE_STATISTICS_OPTIONS() { return ARCHIVE_STATISTICS_OPTIONS; }
	public: void setARCHIVE_STATISTICS_OPTIONS(PArchiveStatisticsOptionsC v);
	public: PMapDomainC getMAP_CONFIG() { return MAP_CONFIG; }
	public: void setMAP_CONFIG(PMapDomainC v);
	public: PMapDomainC getMAP_DOMAIN() { return MAP_DOMAIN; }
	public: void setMAP_DOMAIN(PMapDomainC v);
	public: PEloIxOptC getELO_IX_OPT() { return ELO_IX_OPT; }
	public: void setELO_IX_OPT(PEloIxOptC v);
	public: PAnyC getANY() { return ANY; }
	public: void setANY(PAnyC v);
	public: PSearchTermsC getSEARCH_TERMS() { return SEARCH_TERMS; }
	public: void setSEARCH_TERMS(PSearchTermsC v);
	public: PAdminModeC getADMIN_MODE() { return ADMIN_MODE; }
	public: void setADMIN_MODE(PAdminModeC v);
	public: PFulltextConfigC getFULLTEXT_CONFIG() { return FULLTEXT_CONFIG; }
	public: void setFULLTEXT_CONFIG(PFulltextConfigC v);
	public: PServerInfoDMC getSERVER_INFO_DM() { return SERVER_INFO_DM; }
	public: void setSERVER_INFO_DM(PServerInfoDMC v);
	public: PFindDirectC getFIND_DIRECT() { return FIND_DIRECT; }
	public: void setFIND_DIRECT(PFindDirectC v);
	public: de::elo::ix::client::feed::PActionC getACTION() { return ACTION; }
	public: void setACTION(de::elo::ix::client::feed::PActionC v);
	public: de::elo::ix::client::feed::PFeedC getFEED() { return FEED; }
	public: void setFEED(de::elo::ix::client::feed::PFeedC v);
	public: PTranslateTermC getTRANSLATE_TERM() { return TRANSLATE_TERM; }
	public: void setTRANSLATE_TERM(PTranslateTermC v);
	public: PEventBusC getEVENT_BUS() { return EVENT_BUS; }
	public: void setEVENT_BUS(PEventBusC v);
	public: PPreviewImageInfoC getPREVIEW_IMAGE_INFO() { return PREVIEW_IMAGE_INFO; }
	public: void setPREVIEW_IMAGE_INFO(PPreviewImageInfoC v);
	public: PResolveRightsResultC getRESOLVE_RIGHTS() { return RESOLVE_RIGHTS; }
	public: void setRESOLVE_RIGHTS(PResolveRightsResultC v);
	public: de::elo::ix::client::feed::PFindActionsInfoC getFIND_ACTIONS_INFO() { return FIND_ACTIONS_INFO; }
	public: void setFIND_ACTIONS_INFO(de::elo::ix::client::feed::PFindActionsInfoC v);
	public: PSubscriptionC getSUBSCRIPTION() { return SUBSCRIPTION; }
	public: void setSUBSCRIPTION(PSubscriptionC v);
	public: PMapDataC getMAP_DATA() { return MAP_DATA; }
	public: void setMAP_DATA(PMapDataC v);
	public: PMapHistC getMAP_HIST() { return MAP_HIST; }
	public: void setMAP_HIST(PMapHistC v);
	public: PWorkflowExportOptionsC getWORKFLOW_EXPORT_OPTIONS() { return WORKFLOW_EXPORT_OPTIONS; }
	public: void setWORKFLOW_EXPORT_OPTIONS(PWorkflowExportOptionsC v);
	public: PWFNodeHistoryC getWORKFLOW_NODE_HISTORY() { return WORKFLOW_NODE_HISTORY; }
	public: void setWORKFLOW_NODE_HISTORY(PWFNodeHistoryC v);
	public: PDocMaskLineTemplateC getDOC_MASK_LINE_TEMPLATE() { return DOC_MASK_LINE_TEMPLATE; }
	public: void setDOC_MASK_LINE_TEMPLATE(PDocMaskLineTemplateC v);
	public: PPublicDownloadC getPUBLIC_DOWNLOAD() { return PUBLIC_DOWNLOAD; }
	public: void setPUBLIC_DOWNLOAD(PPublicDownloadC v);
	public: PFileDataC getFILE_DATA() { return FILE_DATA; }
	public: void setFILE_DATA(PFileDataC v);
	public: POcrInfoC getOCR_INFO() { return OCR_INFO; }
	public: void setOCR_INFO(POcrInfoC v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// IdName
// typeId=381683845

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// <p>Contains an numeric ID value, a GUID value in string format and a name.
/// </summary>
/// <remarks>
/// </p>
/// 
/// <p>Copyright: Copyright (c) 2004</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </remarks>
class IdName : public ValueClass {
	/// <summary>
	/// GUID.
	/// </summary>
	protected: ::std::wstring guid;
	/// <summary>
	/// Numeric ID.
	/// </summary>
	protected: int32_t id;
	/// <summary>
	/// Name.
	/// </summary>
	protected: ::std::wstring name;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: IdName();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: IdName(const ::std::wstring& guid, int32_t id, const ::std::wstring& name);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: ::std::wstring getGuid() { return guid; }
	public: void setGuid(::std::wstring v);
	public: int32_t getId() { return id; }
	public: void setId(int32_t v);
	public: ::std::wstring getName() { return name; }
	public: void setName(::std::wstring v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// ImportOptionsC
// typeId=1908370444

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Defines the Options of an Import.
/// </summary>
/// <remarks>
/// Each Option is represented by one bit. Several Options can be
/// put together by a bit-logic and.
/// 
/// <p>Copyright: Copyright (c) 2004</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </remarks>
class ImportOptionsC : public BSerializable {
	/// <summary>
	/// Import all data in a new structure.
	/// </summary>
	public: const static int64_t CREATE_SEPARATE_STRUCTURE = 2LL;
	/// <summary>
	/// Keep guids on import, generate new guid if guid is already used.
	/// </summary>
	public: const static int64_t GUIDS_KEEP = 1LL;
	/// <summary>
	/// import only guids that are not already used.
	/// </summary>
	public: const static int64_t GUIDS_KEEP_AND_SKIP = 2LL;
	/// <summary>
	/// generate new guids during import.
	/// </summary>
	public: const static int64_t GUIDS_NEW = 0LL;
	/// <summary>
	/// make a new version for document with this guid.
	/// </summary>
	public: const static int64_t GUIDS_SCRIPT = 3LL;
	/// <summary>
	/// Use original filing-date (Sord.iDateIso saved in export) when filing during import.
	/// </summary>
	public: const static int64_t KEEP_FILING_DATE = 4LL;
	/// <summary>
	/// Use original filing-path for import (original path of exporting archive was saved during
	/// export)
	/// </summary>
	public: const static int64_t USE_EXPORTED_PATH = 1LL;
	/// <summary>
	/// Import keywords
	/// </summary>
	public: const static int64_t IMPORT_KEYWORDS = 8LL;
	/// <summary>
	/// Use parent's ACL in archive
	/// </summary>
	public: const static int64_t USE_PARENT_ACL = 16LL;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: ImportOptionsC();
	
	public: virtual BTYPEID BSerializable_getTypeId();
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// IndexServerForArchive
// typeId=145656220

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// <p>Association between IndexServer URL and archive name.
/// </summary>
/// <remarks>
/// </p>
/// <p>Copyright: Copyright (c) 2004</p>
/// <p>Organisation: ELO Digital Office GmbH </p>
/// </remarks>
class IndexServerForArchive : public ValueClass {
	/// <summary>
	/// Archive name.
	/// </summary>
	protected: ::std::wstring arcName;
	/// <summary>
	/// Index Server URL.
	/// </summary>
	protected: ::std::wstring url;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: IndexServerForArchive();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: IndexServerForArchive(const ::std::wstring& arcName, const ::std::wstring& url);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: ::std::wstring getArcName() { return arcName; }
	public: void setArcName(::std::wstring v);
	public: ::std::wstring getUrl() { return url; }
	public: void setUrl(::std::wstring v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// InvalidateCacheC
// typeId=320503229

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Constants for cache invalidation.
/// </summary>
/// <remarks>
/// This constans can be used as bit combination in function invalidateCache.
/// </remarks>
class InvalidateCacheC : public BSerializable {
	/// <summary>
	/// Flag used to specify that the cached DocMask objects are invalid.
	/// </summary>
	public: const static int32_t MASKS = 1;
	/// <summary>
	/// Flag used to specify that the cached ColorData objects are invalid.
	/// </summary>
	public: const static int32_t MARKERS = 2;
	/// <summary>
	/// Flag used to specify that the cached Path objects are invalid.
	/// </summary>
	public: const static int32_t PATHS = 4;
	/// <summary>
	/// Flag used to specify that the cached SordType objects are invalid.
	/// </summary>
	public: const static int32_t SORD_TYPES = 8;
	/// <summary>
	/// Flag used to specify that the cached ReplName objects are invalid.
	/// </summary>
	public: const static int32_t REPL_NAMES = 16;
	/// <summary>
	/// Flag used to specify that the cached crypt keys are invalid.
	/// </summary>
	public: const static int32_t CRYPT_INFO = 32;
	/// <summary>
	/// Flag used to specify that the cached users are invalid.
	/// </summary>
	public: const static int32_t USERS = 64;
	/// <summary>
	/// Flag used to specify that the cached keys are invalid.
	/// </summary>
	public: const static int32_t KEYS = 128;
	/// <summary>
	/// Flag used to specify that the translate terms are invalid.
	/// </summary>
	public: const static int32_t TRANSLATE_TERMS = 256;
	/// <summary>
	/// Flag used to specify that the note and cold background images are invalid.
	/// </summary>
	public: const static int32_t NOTE_AND_COLD_IMAGES = 512;
	/// <summary>
	/// Flag used to specify that the workflow cache is invalid.
	/// </summary>
	public: const static int32_t WORKFLOWS = 1024;
	/// <summary>
	/// Flag used to specify that the subscription cache is invalid.
	/// </summary>
	public: const static int32_t SUBSCRIPTIONS = 2048;
	/// <summary>
	/// Flag used to specify that the hashtag count cache is invalid.
	/// </summary>
	public: const static int32_t HASHTAGCOUNT = 4096;
	/// <summary>
	/// Do not invalidate the caches of the other servers.
	/// </summary>
	public: const static int32_t NO_FORWARD_TO_OTHER_IXS = 65536;
	/// <summary>
	/// Flag used to specify that all cached objects are invalid.
	/// </summary>
	public: const static int32_t ALL = 65535;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: InvalidateCacheC();
	
	public: virtual BTYPEID BSerializable_getTypeId();
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// InvalidateCacheInfo
// typeId=1441686860

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// This class contains the parameters for the API function invalidateCache2
/// </summary>
class InvalidateCacheInfo : public ValueClass {
	/// <summary>
	/// A combination of bits defined in InvalidateCacheC.
	/// </summary>
	protected: int32_t flags;
	/// <summary>
	/// A numeric ID to specify an object, workflow etc.
	/// </summary>
	/// <remarks>
	/// If <code>flags</code> contains <code>InvalidateC.WORKFLOWS</code> this element defines the ID
	/// of the active workflow to be updated in the cache.
	/// </remarks>
	protected: int32_t id;
	protected: PVectorInvalidateCacheInfoParam parameters;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: InvalidateCacheInfo();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: InvalidateCacheInfo(int32_t flags, int32_t id, const PVectorInvalidateCacheInfoParam& parameters);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getFlags() { return flags; }
	public: void setFlags(int32_t v);
	public: int32_t getId() { return id; }
	public: void setId(int32_t v);
	public: PVectorInvalidateCacheInfoParam getParameters() { return parameters; }
	public: void setParameters(PVectorInvalidateCacheInfoParam v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// InvalidateCacheInfoParam
// typeId=102205772

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// ParamObject for InvalidateCacheInfo
/// </summary>
class InvalidateCacheInfoParam : public ValueClass {
	protected: ::std::wstring guid;
	protected: int32_t flag;
	protected: int32_t count;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: InvalidateCacheInfoParam();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: InvalidateCacheInfoParam(const ::std::wstring& guid, int32_t flag, int32_t count);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: ::std::wstring getGuid() { return guid; }
	public: void setGuid(::std::wstring v);
	public: int32_t getFlag() { return flag; }
	public: void setFlag(int32_t v);
	public: int32_t getCount() { return count; }
	public: void setCount(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// InvalidateCacheResult
// typeId=1712381166

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// This class contains the result of a invalidateCache2 call.
/// </summary>
class InvalidateCacheResult : public ValueClass {
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: InvalidateCacheResult();
	
	public: virtual BTYPEID BSerializable_getTypeId();
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// JobState
// typeId=1436376940

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Objects of this class provide information on the state of any background processes.
/// </summary>
/// <remarks>
/// <p>Copyright: Copyright (c) 2004</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </remarks>
class JobState : public ValueClass {
	/// <summary>
	/// Error status information.
	/// </summary>
	protected: int64_t countErrors;
	/// <summary>
	/// Estimated maximum amount.
	/// </summary>
	protected: int64_t countEstimatedMax;
	/// <summary>
	/// Progress status information.
	/// </summary>
	protected: int64_t countProcessed;
	/// <summary>
	/// When the information expires (milliseconds): (jobEnd + expires &lt; current-date).
	/// </summary>
	protected: int64_t expires;
	/// <summary>
	/// End or termination of the job.
	/// </summary>
	protected: ::std::wstring jobEnd;
	/// <summary>
	/// Job identifier.
	/// </summary>
	protected: ::std::wstring jobGuid;
	/// <summary>
	/// Thread name.
	/// </summary>
	protected: ::std::wstring jobName;
	/// <summary>
	/// Set to true while the job is being executed.
	/// </summary>
	protected: bool jobRunning;
	/// <summary>
	/// Start of job.
	/// </summary>
	protected: ::std::wstring jobStart;
	/// <summary>
	/// Status information for GUIDs.
	/// </summary>
	protected: ::std::wstring lastGuid;
	/// <summary>
	/// Status information for integer IDs.
	/// </summary>
	protected: int32_t lastID;
	/// <summary>
	/// The standard process-by-SORD job list.
	/// </summary>
	protected: PProcessInfo procInfo;
	/// <summary>
	/// Result of the count process.
	/// </summary>
	protected: PCountResult countResult;
	/// <summary>
	/// Job-defined message string.
	/// </summary>
	protected: ::std::wstring strMsg;
	/// <summary>
	/// Tell the IndexServer to cancel the job.
	/// </summary>
	protected: bool doCancelJob;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: JobState();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: JobState(int64_t countErrors, int64_t countEstimatedMax, int64_t countProcessed, int64_t expires, const ::std::wstring& jobEnd, const ::std::wstring& jobGuid, const ::std::wstring& jobName, bool jobRunning, const ::std::wstring& jobStart, const ::std::wstring& lastGuid, int32_t lastID, const PProcessInfo& procInfo, const PCountResult& countResult, const ::std::wstring& strMsg, bool doCancelJob);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int64_t getCountErrors() { return countErrors; }
	public: void setCountErrors(int64_t v);
	public: int64_t getCountEstimatedMax() { return countEstimatedMax; }
	public: void setCountEstimatedMax(int64_t v);
	public: int64_t getCountProcessed() { return countProcessed; }
	public: void setCountProcessed(int64_t v);
	public: int64_t getExpires() { return expires; }
	public: void setExpires(int64_t v);
	public: ::std::wstring getJobEnd() { return jobEnd; }
	public: void setJobEnd(::std::wstring v);
	public: ::std::wstring getJobGuid() { return jobGuid; }
	public: void setJobGuid(::std::wstring v);
	public: ::std::wstring getJobName() { return jobName; }
	public: void setJobName(::std::wstring v);
	public: bool getJobRunning() { return jobRunning; }
	public: void setJobRunning(bool v);
	public: ::std::wstring getJobStart() { return jobStart; }
	public: void setJobStart(::std::wstring v);
	public: ::std::wstring getLastGuid() { return lastGuid; }
	public: void setLastGuid(::std::wstring v);
	public: int32_t getLastID() { return lastID; }
	public: void setLastID(int32_t v);
	public: PProcessInfo getProcInfo() { return procInfo; }
	public: void setProcInfo(PProcessInfo v);
	public: PCountResult getCountResult() { return countResult; }
	public: void setCountResult(PCountResult v);
	public: ::std::wstring getStrMsg() { return strMsg; }
	public: void setStrMsg(::std::wstring v);
	public: bool getDoCancelJob() { return doCancelJob; }
	public: void setDoCancelJob(bool v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// KeyInfo
// typeId=1537059480

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// <p>Contains information about a key object: ID and name.
/// </summary>
/// <remarks>
/// </p>
/// 
/// <p>Copyright: Copyright (c) 2004</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </remarks>
class KeyInfo : public ValueClass {
	/// <summary>
	/// Key ID.
	/// </summary>
	protected: int32_t id;
	/// <summary>
	/// Key name.
	/// </summary>
	protected: ::std::wstring name;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: KeyInfo();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: KeyInfo(int32_t id, const ::std::wstring& name);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getId() { return id; }
	public: void setId(int32_t v);
	public: ::std::wstring getName() { return name; }
	public: void setName(::std::wstring v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// KeyValue
// typeId=516301248

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// This class contains a name and an associated value.
/// </summary>
/// <remarks>
/// <p>Copyright: Copyright (c) 2004</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </remarks>
class KeyValue : public ValueClass {
	/// <summary>
	/// Key or identifying name.
	/// </summary>
	protected: ::std::wstring key;
	/// <summary>
	/// Associated value.
	/// </summary>
	protected: ::std::wstring value;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: KeyValue();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: KeyValue(const ::std::wstring& key, const ::std::wstring& value);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: ::std::wstring getKey() { return key; }
	public: void setKey(::std::wstring v);
	public: ::std::wstring getValue() { return value; }
	public: void setValue(::std::wstring v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// Keyword
// typeId=1426243550

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

class Keyword : public ValueClass {
	/// <summary>
	/// <p>Prefix the text of a child keyword with the text of this keyword.
	/// </summary>
	/// <remarks>
	/// This member is interpreted in <code>cookKeywords</code>.
	/// The following relationship exists between the members <code>enabled, add, raw</code></p>
	/// <table border="2">
	/// <tr><td>condition</td><td>conclusion</td></tr>
	/// <tr><td><code>add=true</code></td><td><code>enabled=false, raw=true</code></td></tr>
	/// <tr><td><code>enabled=true</code></td><td><code>add=false, raw=any</code></td></tr>
	/// </table>
	/// </remarks>
	protected: bool add;
	/// <summary>
	/// Child array.
	/// </summary>
	protected: PArrayKeyword children;
	/// <summary>
	/// If true, this keyword can be used as a value for an index property.
	/// </summary>
	/// <remarks>
	/// Otherwise its only purpose is to structure the keyword hierachy.
	/// </remarks>
	protected: bool enabled;
	/// <summary>
	/// Keyword ID.
	/// </summary>
	/// <remarks>
	/// Consists of: groupid + orderid, orderid begins with a ".".
	/// </remarks>
	protected: ::std::wstring id;
	/// <summary>
	/// The function <code>cookKeyword()</code> must be called for this keyword in
	/// order to use it for an index property.
	/// </summary>
	/// <remarks>
	/// This is because it contains placeholders
	/// that must be substituted or one of the parent keywords should be added.
	/// </remarks>
	protected: bool raw;
	/// <summary>
	/// Keyword text.
	/// </summary>
	/// <remarks>
	/// This term is assigned to an index property. The member
	/// <code>raw</code> should be checked before this term is used.
	/// This text can be translated into reps. from the users language:
	/// set <code>SessionOptionsC.TRANSLATE_TERM</code>.
	/// </remarks>
	protected: ::std::wstring text;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: Keyword();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: Keyword(bool add, const PArrayKeyword& children, bool enabled, const ::std::wstring& id, bool raw, const ::std::wstring& text);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: bool getAdd() { return add; }
	public: void setAdd(bool v);
	public: PArrayKeyword getChildren() { return children; }
	public: void setChildren(PArrayKeyword v);
	public: bool getEnabled() { return enabled; }
	public: void setEnabled(bool v);
	public: ::std::wstring getId() { return id; }
	public: void setId(::std::wstring v);
	public: bool getRaw() { return raw; }
	public: void setRaw(bool v);
	public: ::std::wstring getText() { return text; }
	public: void setText(::std::wstring v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// KeywordC
// typeId=1338796818

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

class KeywordC : public BSerializable {
	/// <summary>
	/// Root ID of standard keyword list.
	/// </summary>
	public: const static ::std::wstring KWID_STANDARD_LIST;
	/// <summary>
	/// Root ID of keyword list used for version numbers.
	/// </summary>
	public: const static ::std::wstring KWID_VERSION;
	/// <summary>
	/// Root ID of keyword list used for version comments.
	/// </summary>
	public: const static ::std::wstring KWID_VERSION_COMMENT;
	/// <summary>
	/// Root ID of keyword list used for workflows.
	/// </summary>
	public: const static ::std::wstring KWID_WORKFLOW;
	/// <summary>
	/// Root ID of user keyword list.
	/// </summary>
	public: const static ::std::wstring KWID_USER_LIST;
	/// <summary>
	/// Placeholder for current date.
	/// </summary>
	/// <remarks>
	/// The format depends on the date format <code>UserProfileC.SORD_DATE_FORMAT</code>
	/// specified in the user or standard profile.
	/// </remarks>
	public: const static ::std::wstring PLACEHOLDER_DATE;
	/// <summary>
	/// Placeholder for year (4 digits).
	/// </summary>
	public: const static ::std::wstring PLACEHOLDER_YEAR;
	/// <summary>
	/// Placeholder for month (2 digits).
	/// </summary>
	public: const static ::std::wstring PLACEHOLDER_MONTH;
	/// <summary>
	/// Placeholder for day of month (2 digits).
	/// </summary>
	public: const static ::std::wstring PLACEHOLDER_DAY;
	/// <summary>
	/// Placeholder for current user name.
	/// </summary>
	public: const static ::std::wstring PLACEHOLDER_USER_NAME;
	/// <summary>
	/// Placeholder for the value of the specified counter name.
	/// </summary>
	/// <remarks>
	/// The counter name follows the place holder and is suffixed with an extra "%".
	/// E. g. <code>text=PLACEHOLDER_COUNTER_BEGIN + "myRecordCounter" + PLACEHOLDER_COUNTER_END + ". record"</code> is expanded to
	/// <code>text="17. record"</code> assuming myRecordCounter has value 17.
	/// </remarks>
	public: const static ::std::wstring PLACEHOLDER_COUNTER_BEGIN;
	/// <summary>
	/// End of placeholder for counter name.
	/// </summary>
	public: const static ::std::wstring PLACEHOLDER_COUNTER_END;
	/// <summary>
	/// Return raw text in <code>checkoutKeywords</code>.
	/// </summary>
	/// <remarks>
	/// Placeholders are not substituted.
	/// </remarks>
	public: const static int64_t mbRawText = 2LL;
	/// <summary>
	/// Return raw text in <code>checkoutKeywords</code>.
	/// </summary>
	/// <remarks>
	/// Placeholders except counters are substituted.
	/// </remarks>
	public: const static int64_t mbPreCookedText = 4LL;
	/// <summary>
	/// The purpose of this constant object is to control the behavior of
	/// <code>checkoutKeywords</code>.
	/// </summary>
	/// <remarks>
	/// Supplying it, <code>checkoutKeywords</code>
	/// will return the raw text (including placeholders) in the returned Keyword
	/// objects. Use this constant, if you want to read keywords into an editor.
	/// </remarks>
	public: const static PKeywordZ mbEdit;
	/// <summary>
	/// The purpose of this constant object is to control the behavior of
	/// <code>checkoutKeywords</code>.
	/// </summary>
	/// <remarks>
	/// Supplying it, <code>checkoutKeywords</code>
	/// will return substituted placeholders in the text members of the returned
	/// Keyword objects. Use this constant, if you want to read keywords into a
	/// dialog that lets the user select one of it.
	/// </remarks>
	public: const static PKeywordZ mbView;
	/// <summary>
	/// The maximum number of children per keyword.
	/// </summary>
	/// <remarks>
	/// This value is valid for all
	/// keyword lists except the user keyword list (<code>KWID_USER_LIST</code>).
	/// The user keyword list might contain more children below a keyword node.
	/// </remarks>
	public: const static int32_t MAX_CHILDREN = 676;
	/// <summary>
	/// Maximum depth of a keyword tree.
	/// </summary>
	/// <remarks>
	/// This value is valid for all
	/// keyword lists except the user keyword list (<code>KWID_USER_LIST</code>).
	/// The user keyword list might contain a deeper tree.
	/// </remarks>
	public: const static int32_t MAX_TREE_DEPTH = 15;
	/// <summary>
	/// Maximum length of a root keyword ID.
	/// </summary>
	/// <remarks>
	/// If a new keyword list is checked in,
	/// the ID of the root keyword must not exceed this length.
	/// </remarks>
	protected: int32_t lnRootId;
	/// <summary>
	/// Maximum length of keyword ID.
	/// </summary>
	protected: int32_t lnId;
	/// <summary>
	/// Maximum length of keyword text.
	/// </summary>
	protected: int32_t lnText;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: KeywordC();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: KeywordC(const ::std::wstring& KWID_STANDARD_LIST, const ::std::wstring& KWID_VERSION, const ::std::wstring& KWID_VERSION_COMMENT, const ::std::wstring& KWID_WORKFLOW, const ::std::wstring& KWID_USER_LIST, const ::std::wstring& PLACEHOLDER_DATE, const ::std::wstring& PLACEHOLDER_YEAR, const ::std::wstring& PLACEHOLDER_MONTH, const ::std::wstring& PLACEHOLDER_DAY, const ::std::wstring& PLACEHOLDER_USER_NAME, const ::std::wstring& PLACEHOLDER_COUNTER_BEGIN, const ::std::wstring& PLACEHOLDER_COUNTER_END, int64_t mbRawText, int64_t mbPreCookedText, const PKeywordZ& mbEdit, const PKeywordZ& mbView, int32_t MAX_CHILDREN, int32_t MAX_TREE_DEPTH, int32_t lnRootId, int32_t lnId, int32_t lnText);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getLnRootId() { return lnRootId; }
	public: void setLnRootId(int32_t v);
	public: int32_t getLnId() { return lnId; }
	public: void setLnId(int32_t v);
	public: int32_t getLnText() { return lnText; }
	public: void setLnText(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// KeywordList
// typeId=1495731174

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// This class provides general informations for a keyword list.
/// </summary>
class KeywordList : public ValueClass {
	/// <summary>
	/// ID
	/// </summary>
	protected: ::std::wstring id;
	/// <summary>
	/// GUID
	/// </summary>
	protected: ::std::wstring guid;
	/// <summary>
	/// Last modified, ISO - UTC
	/// Read-only.
	/// </summary>
	protected: ::std::wstring tStamp;
	/// <summary>
	/// RESERVED
	/// </summary>
	protected: bool deleted;
	/// <summary>
	/// ID of the user that has written the keyword list at last.
	/// </summary>
	/// <remarks>
	/// Read-only.
	/// </remarks>
	protected: int32_t userId;
	/// <summary>
	/// Name of the user that has written the keyword list at last.
	/// </summary>
	/// <remarks>
	/// Read-only.
	/// </remarks>
	protected: ::std::wstring userName;
	/// <summary>
	/// The keyword list entries.
	/// </summary>
	protected: PArrayKeyword children;
	/// <summary>
	/// ID of the user who holds a lock on the keyword list.
	/// </summary>
	protected: int32_t lockId;
	/// <summary>
	/// Timestamp of this object's last export by the replication.
	/// </summary>
	protected: ::std::wstring TStampSync;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: KeywordList();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: KeywordList(const ::std::wstring& id, const ::std::wstring& guid, const ::std::wstring& tStamp, bool deleted, int32_t userId, const ::std::wstring& userName, const PArrayKeyword& children, int32_t lockId, const ::std::wstring& TStampSync);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: ::std::wstring getId() { return id; }
	public: void setId(::std::wstring v);
	public: ::std::wstring getGuid() { return guid; }
	public: void setGuid(::std::wstring v);
	public: ::std::wstring getTStamp() { return tStamp; }
	public: void setTStamp(::std::wstring v);
	public: bool getDeleted() { return deleted; }
	public: void setDeleted(bool v);
	public: int32_t getUserId() { return userId; }
	public: void setUserId(int32_t v);
	public: ::std::wstring getUserName() { return userName; }
	public: void setUserName(::std::wstring v);
	public: PArrayKeyword getChildren() { return children; }
	public: void setChildren(PArrayKeyword v);
	public: int32_t getLockId() { return lockId; }
	public: void setLockId(int32_t v);
	public: ::std::wstring getTStampSync() { return TStampSync; }
	public: void setTStampSync(::std::wstring v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// KeywordListC
// typeId=1333073168

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// <p>Bit constants for members of KeywordList</p>
/// <p>Copyright: Copyright (c) 2003</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </summary>
class KeywordListC : public BSerializable {
	/// <summary>
	/// DB column: swlstatus
	/// </summary>
	public: const static int64_t mbStatus = 1LL;
	/// <summary>
	/// Member bit: ID
	/// DB column: swlgroupid
	/// </summary>
	public: const static int64_t mbId = 2LL;
	/// <summary>
	/// Column length: ID
	/// DB column: swlgroupid
	/// </summary>
	protected: int32_t lnId;
	/// <summary>
	/// Member bit: GUID
	/// DB column: swlguid
	/// </summary>
	public: const static int64_t mbGuid = 4LL;
	/// <summary>
	/// Column length: GUID
	/// DB column: swlguid
	/// </summary>
	protected: int32_t lnGuid;
	/// <summary>
	/// Member bit: Last modified, ISO - UTC
	/// DB column: swltstamp
	/// </summary>
	public: const static int64_t mbTStamp = 8LL;
	/// <summary>
	/// Column length: Last modified, ISO - UTC
	/// DB column: swltstamp
	/// </summary>
	protected: int32_t lnTStamp;
	/// <summary>
	/// Member bit: ID of the user that has written the keyword list at last.
	/// </summary>
	/// <remarks>
	/// DB column: swluser
	/// </remarks>
	public: const static int64_t mbUserId = 16LL;
	/// <summary>
	/// Member bit: ID of the user who holds a lock on the keyword list.
	/// </summary>
	/// <remarks>
	/// DB column: swllock
	/// </remarks>
	public: const static int64_t mbLockId = 32LL;
	/// <summary>
	/// Member bit: Timestamp of this object's last export by the replication.
	/// </summary>
	/// <remarks>
	/// DB column: swltstampsync
	/// </remarks>
	public: const static int64_t mbTStampSync = 64LL;
	/// <summary>
	/// Column length: Timestamp of this object's last export by the replication.
	/// </summary>
	/// <remarks>
	/// DB column: swltstampsync
	/// </remarks>
	protected: int32_t lnTStampSync;
	/// <summary>
	/// All valid member bits.
	/// </summary>
	public: const static int64_t mbAllMembers = 127LL;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: KeywordListC();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: KeywordListC(int64_t mbStatus, int64_t mbId, int32_t lnId, int64_t mbGuid, int32_t lnGuid, int64_t mbTStamp, int32_t lnTStamp, int64_t mbUserId, int64_t mbLockId, int64_t mbTStampSync, int32_t lnTStampSync, int64_t mbAllMembers);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getLnId() { return lnId; }
	public: void setLnId(int32_t v);
	public: int32_t getLnGuid() { return lnGuid; }
	public: void setLnGuid(int32_t v);
	public: int32_t getLnTStamp() { return lnTStamp; }
	public: void setLnTStamp(int32_t v);
	public: int32_t getLnTStampSync() { return lnTStampSync; }
	public: void setLnTStampSync(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// KeywordZ
// typeId=450335637

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// This class encapsulates the constants of KeywordC.
/// </summary>
/// <remarks>
/// <p>Copyright: Copyright (c) 2004</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </remarks>
class KeywordZ : public ValueClass {
	/// <summary>
	/// Bitset field for constants from KeywordC class.
	/// </summary>
	protected: int64_t bset;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: KeywordZ();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: KeywordZ(int64_t bset);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int64_t getBset() { return bset; }
	public: void setBset(int64_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// KeywordsDynamicInfo
// typeId=2008405893

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// This Class contains parameters for the IX call
/// {@link IXServicePortIF#checkoutKeywordsDynamic(ClientInfo, KeywordsDynamicInfo)}
/// .
/// </summary>
/// <remarks>
/// <p>
/// There are two ways to execute the script for dynamic keyword lists. According
/// to the parameter in this class, the one way or the other is chosen. The first
/// way is to specify {@link KeywordsDynamicInfo#sord} and
/// {@link KeywordsDynamicInfo#maskLineFocus}. Then, the IX passes these
/// parameters to the script via the script-function open(ec, sord, fieldName).
/// The other parameters will be overwritten by <code>null</code> and completely
/// ignored. The other way is to set the fields
/// {@link KeywordsDynamicInfo#mapData}, {@link KeywordsDynamicInfo#mapLineFocus}
/// and {@link KeywordsDynamicInfo#mapScriptName}. In this case, the IX passes
/// these parameters to the scripting function openMap(ec, data, fieldName). To
/// achieve this, <code>sord</code> as well as <code>maskLineFocus</code> must be
/// <code>null</code>.
/// </p>
/// </remarks>
class KeywordsDynamicInfo : public ValueClass {
	/// <summary>
	/// <p>
	/// This value contains data gathered by the client.
	/// </summary>
	/// <remarks>
	/// The contents of sord will
	/// be given to the script to execute.
	/// </p>
	/// </remarks>
	protected: PSord sord;
	/// <summary>
	/// <p>
	/// At the client, set this value to the mask line that currently has the
	/// focus.
	/// </summary>
	/// <remarks>
	/// This value determines the server script to be executed. The server
	/// only reads the members maskId and id. For the server-side processing
	/// necessary residual values are read from the database.
	/// </p>
	/// <p>
	/// The focused mask line is passed to the script to execute. Ignoring this
	/// value in the script is a valid use case.
	/// </p>
	/// </remarks>
	protected: PDocMaskLine maskLineFocus;
	/// <summary>
	/// Determines the script to execute.
	/// </summary>
	/// <remarks>
	/// <p>
	/// This value has only an effect if sord and maskLineFocus are set to null.
	/// Setting this value requires to set the values mapLineFocus and mapData
	/// also.
	/// </p>
	/// </remarks>
	protected: ::std::wstring mapScriptName;
	/// <summary>
	/// Represents the id of a field in a form.
	/// </summary>
	protected: ::std::wstring mapLineFocus;
	/// <summary>
	/// Represents the input data of a form.
	/// </summary>
	/// <remarks>
	/// <p>
	/// The script to execute uses the values in this map to filter the resulting
	/// data set.
	/// </p>
	/// </remarks>
	protected: byps::PMapStringString mapData;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: KeywordsDynamicInfo();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: KeywordsDynamicInfo(const PSord& sord, const PDocMaskLine& maskLineFocus, const ::std::wstring& mapScriptName, const ::std::wstring& mapLineFocus, const byps::PMapStringString& mapData);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: PSord getSord() { return sord; }
	public: void setSord(PSord v);
	public: PDocMaskLine getMaskLineFocus() { return maskLineFocus; }
	public: void setMaskLineFocus(PDocMaskLine v);
	public: ::std::wstring getMapScriptName() { return mapScriptName; }
	public: void setMapScriptName(::std::wstring v);
	public: ::std::wstring getMapLineFocus() { return mapLineFocus; }
	public: void setMapLineFocus(::std::wstring v);
	public: byps::PMapStringString getMapData() { return mapData; }
	public: void setMapData(byps::PMapStringString v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// KeywordsDynamicResult
// typeId=1552114559

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// <p>
/// The class KeywordsDynamicResult defines the return value of the IX call
/// {@link IXServicePortIF#checkoutKeywordsDynamic(ClientInfo, KeywordsDynamicInfo)}
/// .
/// </summary>
/// <remarks>
/// </p>
/// </remarks>
class KeywordsDynamicResult : public ValueClass {
	/// <summary>
	/// <p>
	/// This value contains the result set as a table.
	/// </summary>
	/// <remarks>
	/// Each entry of the outer list
	/// represents a row in the table. Thus, the entry <b>i</b> of an inner list
	/// represents the value of the <b>i</b>. column of the actual row. The length
	/// of each inner list is identical to the total amount of columns. Entries
	/// without a value are represented by an empty string.
	/// </p>
	/// </remarks>
	protected: byps_ptr< ::std::vector< byps::PVectorString > > table;
	/// <summary>
	/// <p>
	/// This list contains the column descriptions to be displayed as the header of
	/// the <code>table</code> at the client.
	/// </summary>
	/// <remarks>
	/// The size of this list matches the
	/// amount of columns in <code>table</code>. The value at index <b>i</b>
	/// represents the column description of the column <b>i</b>. The first column
	/// index is 0. Columns without a header value must be represented by an empty
	/// or undefined string.
	/// </p>
	/// </remarks>
	protected: byps::PVectorString header;
	/// <summary>
	/// <p>
	/// List of key names.
	/// </summary>
	/// <remarks>
	/// The size of this list equals to <code>header</code>. In
	/// this list, columns without a key name are represented by null or an empty
	/// String.
	/// </p>
	/// </remarks>
	protected: byps::PVectorString keyNames;
	/// <summary>
	/// <p>
	/// The executed script may provide additional informations to the client such
	/// as "Please fill field XYZ".
	/// </summary>
	/// <remarks>
	/// Such informations are stored in the value
	/// <code>message</code>. The script has to provide the translation to the
	/// client's language.
	/// </p>
	/// </remarks>
	protected: ::std::wstring message;
	/// <summary>
	/// <p>
	/// Is true if there are more results.
	/// </summary>
	/// <remarks>
	/// </p>
	/// </remarks>
	protected: bool moreResults;
	/// <summary>
	/// <p>
	/// A brief and succinctly description about the represented data.
	/// </summary>
	/// <remarks>
	/// The script
	/// developer must provide a title, otherwise an exception is thrown.
	/// </p>
	/// </remarks>
	protected: ::std::wstring title;
	/// <summary>
	/// <p>
	/// List of column properties.
	/// </summary>
	/// <remarks>
	/// The size of this list equals to
	/// <code>header</code>. If the value at position <i>i</i> is null, the client
	/// will use a default value for the properties of column <i>i</i>.
	/// </p>
	/// </remarks>
	protected: byps_ptr< ::std::vector< byps::PMapStringString > > columnProperties;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: KeywordsDynamicResult();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: KeywordsDynamicResult(const byps_ptr< ::std::vector< byps::PVectorString > >& table, const byps::PVectorString& header, const byps::PVectorString& keyNames, const ::std::wstring& message, bool moreResults, const ::std::wstring& title, const byps_ptr< ::std::vector< byps::PMapStringString > >& columnProperties);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: byps_ptr< ::std::vector< byps::PVectorString > > getTable() { return table; }
	public: void setTable(byps_ptr< ::std::vector< byps::PVectorString > > v);
	public: byps::PVectorString getHeader() { return header; }
	public: void setHeader(byps::PVectorString v);
	public: byps::PVectorString getKeyNames() { return keyNames; }
	public: void setKeyNames(byps::PVectorString v);
	public: ::std::wstring getMessage() { return message; }
	public: void setMessage(::std::wstring v);
	public: bool getMoreResults() { return moreResults; }
	public: void setMoreResults(bool v);
	public: ::std::wstring getTitle() { return title; }
	public: void setTitle(::std::wstring v);
	public: byps_ptr< ::std::vector< byps::PMapStringString > > getColumnProperties() { return columnProperties; }
	public: void setColumnProperties(byps_ptr< ::std::vector< byps::PMapStringString > > v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// License
// typeId=1330120264

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// <p>This class contains license information.
/// </summary>
/// <remarks>
/// </p>
/// <p>Copyright: Copyright (c) 2004</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </remarks>
class License : public ValueClass {
	/// <summary>
	/// Backup enabled.
	/// </summary>
	protected: bool backup;
	/// <summary>
	/// COLD
	/// </summary>
	protected: bool cold;
	/// <summary>
	/// Demo version.
	/// </summary>
	protected: bool demoVersion;
	/// <summary>
	/// Dispatch folder (Versendemappe)
	/// </summary>
	protected: bool dispatchFolder;
	/// <summary>
	/// DOMEA
	/// </summary>
	protected: bool domea;
	/// <summary>
	/// EMail
	/// </summary>
	protected: bool emailOnly;
	/// <summary>
	/// Binary coded license information
	/// </summary>
	protected: PArrayInt features;
	/// <summary>
	/// Fulltext enabled.
	/// </summary>
	protected: bool fultext;
	/// <summary>
	/// HTTP DocServer
	/// </summary>
	protected: bool httpServer;
	/// <summary>
	/// IndexServer
	/// </summary>
	protected: bool indexServer;
	/// <summary>
	/// Limited Internet Gateway
	/// </summary>
	protected: bool limitedIg;
	/// <summary>
	/// Limited version.
	/// </summary>
	protected: bool limitedVersion;
	/// <summary>
	/// Number of ELO Internet Gateway users.
	/// </summary>
	protected: int32_t nbOfIgLicenses;
	/// <summary>
	/// Number of server licenses.
	/// </summary>
	protected: int32_t nbOfServerLicenses;
	/// <summary>
	/// True for ELOprofessional
	/// </summary>
	protected: bool professional;
	/// <summary>
	/// Replication enabled.
	/// </summary>
	protected: bool replication;
	/// <summary>
	/// SAPALINK interface
	/// </summary>
	protected: bool sapALink;
	/// <summary>
	/// License key.
	/// </summary>
	protected: ::std::wstring serno;
	/// <summary>
	/// SIGNATURE
	/// </summary>
	protected: bool signature;
	/// <summary>
	/// STACK
	/// </summary>
	protected: bool stack;
	/// <summary>
	/// Tobit
	/// </summary>
	protected: bool tobid;
	/// <summary>
	/// XML-Import
	/// </summary>
	protected: bool xmlImport;
	/// <summary>
	/// Number of languages for which linguistic processing can be used during fulltext indexing.
	/// </summary>
	protected: int32_t nbOfFulltextLangs;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: License();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: License(bool backup, bool cold, bool demoVersion, bool dispatchFolder, bool domea, bool emailOnly, const PArrayInt& features, bool fultext, bool httpServer, bool indexServer, bool limitedIg, bool limitedVersion, int32_t nbOfIgLicenses, int32_t nbOfServerLicenses, bool professional, bool replication, bool sapALink, const ::std::wstring& serno, bool signature, bool stack, bool tobid, bool xmlImport, int32_t nbOfFulltextLangs);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: bool getBackup() { return backup; }
	public: void setBackup(bool v);
	public: bool getCold() { return cold; }
	public: void setCold(bool v);
	public: bool getDemoVersion() { return demoVersion; }
	public: void setDemoVersion(bool v);
	public: bool getDispatchFolder() { return dispatchFolder; }
	public: void setDispatchFolder(bool v);
	public: bool getDomea() { return domea; }
	public: void setDomea(bool v);
	public: bool getEmailOnly() { return emailOnly; }
	public: void setEmailOnly(bool v);
	public: PArrayInt getFeatures() { return features; }
	public: void setFeatures(PArrayInt v);
	public: bool getFultext() { return fultext; }
	public: void setFultext(bool v);
	public: bool getHttpServer() { return httpServer; }
	public: void setHttpServer(bool v);
	public: bool getIndexServer() { return indexServer; }
	public: void setIndexServer(bool v);
	public: bool getLimitedIg() { return limitedIg; }
	public: void setLimitedIg(bool v);
	public: bool getLimitedVersion() { return limitedVersion; }
	public: void setLimitedVersion(bool v);
	public: int32_t getNbOfIgLicenses() { return nbOfIgLicenses; }
	public: void setNbOfIgLicenses(int32_t v);
	public: int32_t getNbOfServerLicenses() { return nbOfServerLicenses; }
	public: void setNbOfServerLicenses(int32_t v);
	public: bool getProfessional() { return professional; }
	public: void setProfessional(bool v);
	public: bool getReplication() { return replication; }
	public: void setReplication(bool v);
	public: bool getSapALink() { return sapALink; }
	public: void setSapALink(bool v);
	public: ::std::wstring getSerno() { return serno; }
	public: void setSerno(::std::wstring v);
	public: bool getSignature() { return signature; }
	public: void setSignature(bool v);
	public: bool getStack() { return stack; }
	public: void setStack(bool v);
	public: bool getTobid() { return tobid; }
	public: void setTobid(bool v);
	public: bool getXmlImport() { return xmlImport; }
	public: void setXmlImport(bool v);
	public: int32_t getNbOfFulltextLangs() { return nbOfFulltextLangs; }
	public: void setNbOfFulltextLangs(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// LicenseInfo
// typeId=2024296158

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// License information to be checked with {@link IXServicePortIF#checkLicense(ClientInfo, LicenseInfo)}.
/// </summary>
class LicenseInfo : public ValueClass {
	/// <summary>
	/// Customer name.
	/// </summary>
	protected: ::std::wstring customerName;
	/// <summary>
	/// Module name.
	/// </summary>
	protected: ::std::wstring moduleName;
	/// <summary>
	/// License key.
	/// </summary>
	protected: ::std::wstring licenseKey;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: LicenseInfo();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: LicenseInfo(const ::std::wstring& customerName, const ::std::wstring& moduleName, const ::std::wstring& licenseKey);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: ::std::wstring getCustomerName() { return customerName; }
	public: void setCustomerName(::std::wstring v);
	public: ::std::wstring getModuleName() { return moduleName; }
	public: void setModuleName(::std::wstring v);
	public: ::std::wstring getLicenseKey() { return licenseKey; }
	public: void setLicenseKey(::std::wstring v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// LicenseResult
// typeId=545905411

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Result of license check.
/// </summary>
/// <remarks>
/// An object of this class is returned by {@link IXServicePortIF#checkLicense(ClientInfo, LicenseInfo)} if the
/// given license information is valid.
/// </remarks>
class LicenseResult : public ValueClass {
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: LicenseResult();
	
	public: virtual BTYPEID BSerializable_getTypeId();
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// LinkSordC
// typeId=4981037

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Constants for linkSord(...).
/// </summary>
/// <remarks>
/// <p>Copyright: Copyright (c) 2004</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </remarks>
class LinkSordC : public BSerializable {
	/// <summary>
	/// Used as standard in linkSord(...).
	/// </summary>
	protected: PLinkSordZ NOTHING;
	/// <summary>
	/// Link Sord objects in PAIR.
	/// </summary>
	public: const static PLinkSordZ PAIR;
	/// <summary>
	/// Link each Sord to each other Sord.
	/// </summary>
	public: const static PLinkSordZ CROSS_LINK;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: LinkSordC();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: LinkSordC(const PLinkSordZ& NOTHING, const PLinkSordZ& PAIR, const PLinkSordZ& CROSS_LINK);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: PLinkSordZ getNOTHING() { return NOTHING; }
	public: void setNOTHING(PLinkSordZ v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// LinkSordInfo
// typeId=1427691295

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Additional parameters for function {@link IXServicePortIF#linkSords2}
/// </summary>
class LinkSordInfo : public BSerializable {
	/// <summary>
	/// If true, Sords will be linked permanently.
	/// </summary>
	/// <remarks>
	/// The new links between the
	/// provided Sords cannot be deleted.
	/// </remarks>
	protected: bool linkPermanent;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: LinkSordInfo();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: LinkSordInfo(bool linkPermanent);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: bool getLinkPermanent() { return linkPermanent; }
	public: void setLinkPermanent(bool v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// LinkSordZ
// typeId=1473512051

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// This class encapsulates the constants of LinkSordC.
/// </summary>
/// <remarks>
/// <p>Copyright: Copyright (c) 2004</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </remarks>
class LinkSordZ : public ValueClass {
	/// <summary>
	/// Bitset field for constants from the LinkSordC class.
	/// </summary>
	protected: int64_t bset;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: LinkSordZ();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: LinkSordZ(int64_t bset);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int64_t getBset() { return bset; }
	public: void setBset(int64_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// LockC
// typeId=837669511

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// <p>Constants to lock data against concurrent modification.
/// </summary>
/// <remarks>
/// </p>
/// </remarks>
class LockC : public BSerializable {
	public: const static int64_t bsetNO = 0LL;
	public: const static int64_t bsetYES = 1LL;
	public: const static int64_t bsetFORCE = 2LL;
	public: const static int64_t bsetIF_FREE = 4LL;
	public: const static int64_t bsetSORD = 8LL;
	public: const static int64_t bsetDOC = 16LL;
	/// <summary>
	/// Do not lock the requested record(s).
	/// </summary>
	public: const static PLockZ NO;
	/// <summary>
	/// Lock or unlock.
	/// </summary>
	/// <remarks>
	/// The lock is set, if the record is unlocked or
	/// locked by the current user. With respect to locking the indexing
	/// information (LockC.SORD) and document versions (LockC.DOC), LockC.YES
	/// locks and unlocks both since ELO 10. In order to successfully complete an
	/// operation with this type of Lock, another user must not hold even one of
	/// them.
	/// </remarks>
	public: const static PLockZ YES;
	/// <summary>
	/// Lock or unlock regardless of whether the data is locked by another user.
	/// </summary>
	/// <remarks>
	/// This requires main adminstration privilleges in most cases.
	/// </remarks>
	public: const static PLockZ FORCE;
	/// <summary>
	/// A lock is only set, if the record is unlocked.
	/// </summary>
	/// <remarks>
	/// A lock request is refused too, if the record is already a lock by the
	/// current user.
	/// </remarks>
	public: const static PLockZ IF_FREE;
	/// <summary>
	/// Lock or unlock the indexing information.
	/// </summary>
	/// <remarks>
	/// Works like {@link LockC#YES} but
	/// is only valid at check*Sord() and check*Doc() respectively.
	/// </remarks>
	public: const static PLockZ SORD;
	/// <summary>
	/// Lock or unlock document versions.
	/// </summary>
	/// <remarks>
	/// Works like {@link LockC#YES} but
	/// is only valid at check*Sord() and check*Doc() respectively.
	/// </remarks>
	public: const static PLockZ DOC;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: LockC();
	
	public: virtual BTYPEID BSerializable_getTypeId();
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// LockZ
// typeId=1407753312

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// This class encapsulates the constants of the LockC class.
/// </summary>
/// <remarks>
/// <p>Copyright: Copyright (c) 2004</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </remarks>
class LockZ : public ValueClass {
	/// <summary>
	/// Bitset field for constants from the LockC class.
	/// </summary>
	protected: int64_t bset;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: LockZ();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: LockZ(int64_t bset);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int64_t getBset() { return bset; }
	public: void setBset(int64_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// LoginResult
// typeId=777531606

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// <p>Object returned when logging in to the IX.
/// </summary>
/// <remarks>
/// This class contains the
/// information required after the login has been carried out.</p>
/// 
/// <p>Copyright: Copyright (c) 2004</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </remarks>
class LoginResult : public ValueClass {
	/// <summary>
	/// <p>ClientInfo object returned by the IX when the login is carried out.
	/// </summary>
	/// <remarks>
	/// Contains information about the client settings.</p>
	/// </remarks>
	protected: PClientInfo clientInfo;
	/// <summary>
	/// <p>Contains the lifetime of the ticket in seconds.
	/// </summary>
	/// <remarks>
	/// The connection
	/// is terminated once this lifetime has expired.</p>
	/// </remarks>
	protected: int32_t ticketLifetime;
	/// <summary>
	/// <p>Contains the data detailling the user used to login to the IX.
	/// </summary>
	/// <remarks>
	/// </p>
	/// </remarks>
	protected: PUserInfo user;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: LoginResult();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: LoginResult(const PClientInfo& clientInfo, int32_t ticketLifetime, const PUserInfo& user);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: PClientInfo getClientInfo() { return clientInfo; }
	public: void setClientInfo(PClientInfo v);
	public: int32_t getTicketLifetime() { return ticketLifetime; }
	public: void setTicketLifetime(int32_t v);
	public: PUserInfo getUser() { return user; }
	public: void setUser(PUserInfo v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// LoginScriptOptions
// typeId=1536364115

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Options for function
/// {@link IXServerEvents#onBeforeLogin(IXServerEventsContext, String, LoginScriptOptions)}
/// </summary>
class LoginScriptOptions : public ValueClass {
	/// <summary>
	/// Unified Name for the client application.
	/// </summary>
	/// <remarks>
	/// The value of this field must be
	/// one value of {{@link LoginScriptOptionsC}.CLIENT_NAME_*}.
	/// </remarks>
	protected: ::std::wstring clientName;
	/// <summary>
	/// User name used for authentication.
	/// </summary>
	/// <remarks>
	/// This member is only valid for run-as logins. It contains the name of the technical user used for authentication.
	/// </remarks>
	protected: ::std::wstring techUser;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: LoginScriptOptions();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: LoginScriptOptions(const ::std::wstring& clientName, const ::std::wstring& techUser);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: ::std::wstring getClientName() { return clientName; }
	public: void setClientName(::std::wstring v);
	public: ::std::wstring getTechUser() { return techUser; }
	public: void setTechUser(::std::wstring v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// LoginScriptOptionsC
// typeId=1002222217

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Constants for {@link LoginScriptOptions}.
/// </summary>
class LoginScriptOptionsC : public BSerializable {
	/// <summary>
	/// Constant for the name of the Windows/Java Client.
	/// </summary>
	public: const static ::std::wstring CLIENT_NAME_FULLCLIENT;
	/// <summary>
	/// Constant for the name of the Web and Mobile Client.
	/// </summary>
	public: const static ::std::wstring CLIENT_NAME_WEBCLIENT;
	/// <summary>
	/// Constant for the name ELO applications.
	/// </summary>
	public: const static ::std::wstring CLIENT_NAME_ELOAPP;
	/// <summary>
	/// Constant for the name of partner applications.
	/// </summary>
	public: const static ::std::wstring CLIENT_NAME_PARTNERAPP;
	/// <summary>
	/// DMS Desktop
	/// </summary>
	public: const static ::std::wstring CLIENT_NAME_DMS_DESKTOP;
	/// <summary>
	/// Mobile client (Android, iOS)
	/// </summary>
	public: const static ::std::wstring CLIENT_NAME_MOBILE_CLIENT;
	/// <summary>
	/// Windows Client
	/// </summary>
	public: const static ::std::wstring CLIENT_NAME_WINDOWS_CLIENT;
	/// <summary>
	/// Constant for the name of unknown type.
	/// </summary>
	public: const static ::std::wstring CLIENT_NAME_UNKNOWN;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: LoginScriptOptionsC();
	
	public: virtual BTYPEID BSerializable_getTypeId();
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// MapData
// typeId=2011132580

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// This class represents a map which contains
/// user defined key-value pairs.
/// </summary>
class MapData : public ValueClass {
	/// <summary>
	/// Map domain name.
	/// </summary>
	/// <remarks>
	/// An arbitary name or one of the predefined names in MapDomainC.
	/// </remarks>
	protected: ::std::wstring domainName;
	/// <summary>
	/// Map ID.
	/// </summary>
	/// <remarks>
	/// If the map belongs to a Sord ID, this value is equal to the member objId.
	/// </remarks>
	protected: ::std::wstring id;
	/// <summary>
	/// Object ID.
	/// </summary>
	/// <remarks>
	/// The ID of the associated Sord object or 0, if the map does not belong to a Sord object.
	/// </remarks>
	protected: int32_t objId;
	/// <summary>
	/// User ID of the user that owns the lock on the map.
	/// </summary>
	/// <remarks>
	/// If the map is not locked, this value is -1.
	/// </remarks>
	protected: int32_t lockId;
	/// <summary>
	/// User name of the user that owns the lock no the map.
	/// </summary>
	/// <remarks>
	/// If the map is not locked, this value is an empty string.
	/// </remarks>
	protected: ::std::wstring lockName;
	/// <summary>
	/// Timestamp
	/// </summary>
	protected: ::std::wstring TStamp;
	/// <summary>
	/// Map items.
	/// </summary>
	/// <remarks>
	/// Since stream version 10.00.020.007, the items of this array can be cased to {@link MapValue},
	/// in order to access BLOB data.
	/// </remarks>
	protected: PArrayKeyValue items;
	/// <summary>
	/// GUID
	/// </summary>
	protected: ::std::wstring guid;
	/// <summary>
	/// Map items represented by class MapValue which gives access to BLOB values.
	/// </summary>
	protected: PMapStringMapValue mapItems;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: MapData();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: MapData(const ::std::wstring& domainName, const ::std::wstring& id, int32_t objId, int32_t lockId, const ::std::wstring& lockName, const ::std::wstring& TStamp, const PArrayKeyValue& items, const ::std::wstring& guid, const PMapStringMapValue& mapItems);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: ::std::wstring getDomainName() { return domainName; }
	public: void setDomainName(::std::wstring v);
	public: ::std::wstring getId() { return id; }
	public: void setId(::std::wstring v);
	public: int32_t getObjId() { return objId; }
	public: void setObjId(int32_t v);
	public: int32_t getLockId() { return lockId; }
	public: void setLockId(int32_t v);
	public: ::std::wstring getLockName() { return lockName; }
	public: void setLockName(::std::wstring v);
	public: ::std::wstring getTStamp() { return TStamp; }
	public: void setTStamp(::std::wstring v);
	public: PArrayKeyValue getItems() { return items; }
	public: void setItems(PArrayKeyValue v);
	public: ::std::wstring getGuid() { return guid; }
	public: void setGuid(::std::wstring v);
	public: PMapStringMapValue getMapItems() { return mapItems; }
	public: void setMapItems(PMapStringMapValue v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// MapDataC
// typeId=1277095765

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Constant class for MapData
/// </summary>
class MapDataC : public BSerializable {
	/// <summary>
	/// Maximum length of map item value.
	/// </summary>
	protected: int32_t lnValue;
	/// <summary>
	/// Maximum length of map item key.
	/// </summary>
	protected: int32_t lnKey;
	/// <summary>
	/// Maximum length of map id.
	/// </summary>
	protected: int32_t lnId;
	/// <summary>
	/// Maximum length of blob value.
	/// 1048576 Bytes
	/// </summary>
	protected: int32_t lnBlob;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: MapDataC();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: MapDataC(int32_t lnValue, int32_t lnKey, int32_t lnId, int32_t lnBlob);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getLnValue() { return lnValue; }
	public: void setLnValue(int32_t v);
	public: int32_t getLnKey() { return lnKey; }
	public: void setLnKey(int32_t v);
	public: int32_t getLnId() { return lnId; }
	public: void setLnId(int32_t v);
	public: int32_t getLnBlob() { return lnBlob; }
	public: void setLnBlob(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// MapDomain
// typeId=42339713

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// This class contains the information of a map domain.
/// </summary>
/// <remarks>
/// A map is a set of key value pairs and can be addressed
/// by a map domain name and a map ID.
/// All maps with the same domain name are stored in the same
/// database tables. These maps are distinguished by their
/// ID, which can be an arbitary string.
/// A map can be attached to a Sord object by setting
/// the map ID to the Sord ID. Attached maps are deleted,
/// when the Sord object is finally deleted. Furthermore
/// they can be copied with the Sord object.
/// </remarks>
class MapDomain : public ValueClass {
	/// <summary>
	/// Map domain name.
	/// </summary>
	/// <remarks>
	/// This can be a user definined name or one of the predefined names in MapDomainC.
	/// The value is internally used as part of a database table name. Thus only alphanumeric
	/// characters are allowed.
	/// </remarks>
	protected: ::std::wstring name;
	/// <summary>
	/// This value is true, if the map items should be copied when the
	/// associated Sord object is copied.
	/// </summary>
	protected: bool copy;
	/// <summary>
	/// This value is true, if the map items should be replicated
	/// with the associated Sord object.
	/// </summary>
	protected: bool replicate;
	/// <summary>
	/// This value is true, if a history should be maintained for map items.
	/// </summary>
	/// <remarks>
	/// A history is always available for {@link MapDomainC#DOMAIN_SORD} and {@link MapDomainC#DOMAIN_WORKFLOW_ACTIVE}.
	/// </remarks>
	protected: bool history;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: MapDomain();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: MapDomain(const ::std::wstring& name, bool copy, bool replicate, bool history);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: ::std::wstring getName() { return name; }
	public: void setName(::std::wstring v);
	public: bool getCopy() { return copy; }
	public: void setCopy(bool v);
	public: bool getReplicate() { return replicate; }
	public: void setReplicate(bool v);
	public: bool getHistory() { return history; }
	public: void setHistory(bool v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// MapDomainDataC
// typeId=915355095

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// <p>Bit constants for members of MapDomain</p>
/// <p>Copyright: Copyright (c) 2003</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </summary>
class MapDomainDataC : public BSerializable {
	/// <summary>
	/// DB column: mapdflags
	/// </summary>
	public: const static int64_t mbFlags = 1LL;
	/// <summary>
	/// DB column: mapdname
	/// </summary>
	public: const static int64_t mbName = 2LL;
	/// <summary>
	/// DB column: mapdname
	/// </summary>
	protected: int32_t lnName;
	/// <summary>
	/// All valid member bits.
	/// </summary>
	public: const static int64_t mbAllMembers = 3LL;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: MapDomainDataC();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: MapDomainDataC(int64_t mbFlags, int64_t mbName, int32_t lnName, int64_t mbAllMembers);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getLnName() { return lnName; }
	public: void setLnName(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// MapDomainC
// typeId=47433043

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// This class defines constants for the predefined map tables.
/// </summary>
class MapDomainC : public MapDomainDataC {
	public: const static ::std::wstring DOMAIN_SORD;
	public: const static ::std::wstring DOMAIN_WORKFLOW_ACTIVE;
	public: const static ::std::wstring DOMAIN_WORKFLOW_FINISHED;
	public: const static ::std::wstring DOMAIN_IX_OPTIONS;
	public: const static ::std::wstring DOMAIN_DM_OPTIONS;
	public: const static ::std::wstring DOMAIN_FT_OPTIONS;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: MapDomainC();
	
	public: virtual BTYPEID BSerializable_getTypeId();
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// MapHead
// typeId=1379783697

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Internal class.
/// </summary>
class MapHead : public ValueClass {
	/// <summary>
	/// Map id.
	/// </summary>
	protected: ::std::wstring id;
	/// <summary>
	/// Lock status
	/// </summary>
	/// <remarks>
	/// .
	/// -1: unlocked, &gt;=0 user-ID.
	/// </remarks>
	protected: int32_t lockId;
	/// <summary>
	/// Associated object ID or 0.
	/// </summary>
	protected: int32_t objId;
	/// <summary>
	/// Timestamp.
	/// </summary>
	protected: ::std::wstring TStamp;
	/// <summary>
	/// GUID.
	/// </summary>
	protected: ::std::wstring guid;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: MapHead();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: MapHead(const ::std::wstring& id, int32_t lockId, int32_t objId, const ::std::wstring& TStamp, const ::std::wstring& guid);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: ::std::wstring getId() { return id; }
	public: void setId(::std::wstring v);
	public: int32_t getLockId() { return lockId; }
	public: void setLockId(int32_t v);
	public: int32_t getObjId() { return objId; }
	public: void setObjId(int32_t v);
	public: ::std::wstring getTStamp() { return TStamp; }
	public: void setTStamp(::std::wstring v);
	public: ::std::wstring getGuid() { return guid; }
	public: void setGuid(::std::wstring v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// MapHeadC
// typeId=812078539

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// <p>Bit constants for members of MapHead</p>
/// <p>Copyright: Copyright (c) 2003</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </summary>
class MapHeadC : public BSerializable {
	/// <summary>
	/// DB column: mapid
	/// </summary>
	public: const static int64_t mbId = 1LL;
	/// <summary>
	/// DB column: mapid
	/// </summary>
	protected: int32_t lnId;
	/// <summary>
	/// DB column: maplockid
	/// </summary>
	public: const static int64_t mbLockId = 2LL;
	/// <summary>
	/// DB column: mapobjid
	/// </summary>
	public: const static int64_t mbObjId = 4LL;
	/// <summary>
	/// DB column: maptstamp
	/// </summary>
	public: const static int64_t mbTStamp = 8LL;
	/// <summary>
	/// DB column: maptstamp
	/// </summary>
	protected: int32_t lnTStamp;
	/// <summary>
	/// DB column: mapguid
	/// </summary>
	public: const static int64_t mbGuid = 16LL;
	/// <summary>
	/// DB column: mapguid
	/// </summary>
	protected: int32_t lnGuid;
	/// <summary>
	/// All valid member bits.
	/// </summary>
	public: const static int64_t mbAllMembers = 31LL;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: MapHeadC();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: MapHeadC(int64_t mbId, int32_t lnId, int64_t mbLockId, int64_t mbObjId, int64_t mbTStamp, int32_t lnTStamp, int64_t mbGuid, int32_t lnGuid, int64_t mbAllMembers);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getLnId() { return lnId; }
	public: void setLnId(int32_t v);
	public: int32_t getLnTStamp() { return lnTStamp; }
	public: void setLnTStamp(int32_t v);
	public: int32_t getLnGuid() { return lnGuid; }
	public: void setLnGuid(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// MapHist
// typeId=303505086

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Version history for maps.
/// </summary>
class MapHist : public ValueClass {
	/// <summary>
	/// GUID of the SordHist object.
	/// </summary>
	protected: ::std::wstring histGuid;
	/// <summary>
	/// Identifies the application with which changes were made to the keywording.
	/// </summary>
	protected: int32_t histSource;
	/// <summary>
	/// GUID of the map object.
	/// </summary>
	protected: ::std::wstring mapGuid;
	/// <summary>
	/// Timestamp of the change in the timezone of the client.
	/// </summary>
	/// <remarks>
	/// The format is JJJJ.MM.DD.hh.mm.ss
	/// </remarks>
	protected: ::std::wstring timeStampLocal;
	/// <summary>
	/// Timestamp of the change in the timezone of the client, in UTC form.
	/// </summary>
	/// <remarks>
	/// The format is JJJJ.MM.DD.hh.mm.ss
	/// </remarks>
	protected: ::std::wstring timeStampUTC;
	/// <summary>
	/// The name of the user who carried out the changes.
	/// </summary>
	protected: ::std::wstring userName;
	/// <summary>
	/// The user who carried out the changes.
	/// </summary>
	protected: int32_t userId;
	/// <summary>
	/// The name of the computer from which the change was carried out.
	/// </summary>
	/// <remarks>
	/// This is the parameter
	/// clientComputer which is provided by the ix.login function.
	/// </remarks>
	protected: ::std::wstring workStation;
	/// <summary>
	/// An array of the keywording changes.
	/// </summary>
	protected: PArrayMapHistItem histItems;
	/// <summary>
	/// ID of the map object.
	/// </summary>
	protected: ::std::wstring mapId;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: MapHist();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: MapHist(const ::std::wstring& histGuid, int32_t histSource, const ::std::wstring& mapGuid, const ::std::wstring& timeStampLocal, const ::std::wstring& timeStampUTC, const ::std::wstring& userName, int32_t userId, const ::std::wstring& workStation, const PArrayMapHistItem& histItems, const ::std::wstring& mapId);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: ::std::wstring getHistGuid() { return histGuid; }
	public: void setHistGuid(::std::wstring v);
	public: int32_t getHistSource() { return histSource; }
	public: void setHistSource(int32_t v);
	public: ::std::wstring getMapGuid() { return mapGuid; }
	public: void setMapGuid(::std::wstring v);
	public: ::std::wstring getTimeStampLocal() { return timeStampLocal; }
	public: void setTimeStampLocal(::std::wstring v);
	public: ::std::wstring getTimeStampUTC() { return timeStampUTC; }
	public: void setTimeStampUTC(::std::wstring v);
	public: ::std::wstring getUserName() { return userName; }
	public: void setUserName(::std::wstring v);
	public: int32_t getUserId() { return userId; }
	public: void setUserId(int32_t v);
	public: ::std::wstring getWorkStation() { return workStation; }
	public: void setWorkStation(::std::wstring v);
	public: PArrayMapHistItem getHistItems() { return histItems; }
	public: void setHistItems(PArrayMapHistItem v);
	public: ::std::wstring getMapId() { return mapId; }
	public: void setMapId(::std::wstring v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// MapHistHeadC
// typeId=812099209

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// <p>Bit constants for members of MapHist</p>
/// <p>Copyright: Copyright (c) 2003</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </summary>
class MapHistHeadC : public BSerializable {
	/// <summary>
	/// Member bit: Serialisation version ID
	/// DB column: maphistguid
	/// </summary>
	public: const static int64_t mbHistGuid = 1LL;
	/// <summary>
	/// Column length: Serialisation version ID
	/// DB column: maphistguid
	/// </summary>
	protected: int32_t lnHistGuid;
	/// <summary>
	/// DB column: maphistts
	/// </summary>
	public: const static int64_t mbTimeStampUTC = 2LL;
	/// <summary>
	/// DB column: maphistts
	/// </summary>
	protected: int32_t lnTimeStampUTC;
	/// <summary>
	/// DB column: mapguid
	/// </summary>
	public: const static int64_t mbMapGuid = 4LL;
	/// <summary>
	/// DB column: mapguid
	/// </summary>
	protected: int32_t lnMapGuid;
	/// <summary>
	/// DB column: mapuser
	/// </summary>
	public: const static int64_t mbUserId = 8LL;
	/// <summary>
	/// DB column: mapusername
	/// </summary>
	public: const static int64_t mbUserName = 16LL;
	/// <summary>
	/// DB column: mapusername
	/// </summary>
	protected: int32_t lnUserName;
	/// <summary>
	/// DB column: maphistsrc
	/// </summary>
	public: const static int64_t mbHistSource = 32LL;
	/// <summary>
	/// DB column: maphistlocts
	/// </summary>
	public: const static int64_t mbTimeStampLocal = 64LL;
	/// <summary>
	/// DB column: maphistlocts
	/// </summary>
	protected: int32_t lnTimeStampLocal;
	/// <summary>
	/// DB column: maphistwks
	/// </summary>
	public: const static int64_t mbWorkStation = 128LL;
	/// <summary>
	/// DB column: maphistwks
	/// </summary>
	protected: int32_t lnWorkStation;
	/// <summary>
	/// All valid member bits.
	/// </summary>
	public: const static int64_t mbAllMembers = 255LL;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: MapHistHeadC();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: MapHistHeadC(int64_t mbHistGuid, int32_t lnHistGuid, int64_t mbTimeStampUTC, int32_t lnTimeStampUTC, int64_t mbMapGuid, int32_t lnMapGuid, int64_t mbUserId, int64_t mbUserName, int32_t lnUserName, int64_t mbHistSource, int64_t mbTimeStampLocal, int32_t lnTimeStampLocal, int64_t mbWorkStation, int32_t lnWorkStation, int64_t mbAllMembers);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getLnHistGuid() { return lnHistGuid; }
	public: void setLnHistGuid(int32_t v);
	public: int32_t getLnTimeStampUTC() { return lnTimeStampUTC; }
	public: void setLnTimeStampUTC(int32_t v);
	public: int32_t getLnMapGuid() { return lnMapGuid; }
	public: void setLnMapGuid(int32_t v);
	public: int32_t getLnUserName() { return lnUserName; }
	public: void setLnUserName(int32_t v);
	public: int32_t getLnTimeStampLocal() { return lnTimeStampLocal; }
	public: void setLnTimeStampLocal(int32_t v);
	public: int32_t getLnWorkStation() { return lnWorkStation; }
	public: void setLnWorkStation(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// MapHistC
// typeId=379654790

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Element selectors for class MapHist.
/// </summary>
class MapHistC : public MapHistHeadC {
	public: const static int64_t mbHistItems = 1048576LL;
	public: const static int64_t mbAllMembers = 2097151LL;
	public: const static int64_t mbAllMembersNoItems = 1048575LL;
	/// <summary>
	/// All members.
	/// </summary>
	public: const static PMapHistZ mbAll;
	/// <summary>
	/// All members but without {@link MapHist#histItems}.
	/// </summary>
	public: const static PMapHistZ mbAllNoItems;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: MapHistC();
	
	public: virtual BTYPEID BSerializable_getTypeId();
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// MapHistItem
// typeId=342049067

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// This class provides the version information for a map attribute
/// that has been modified.
/// </summary>
class MapHistItem : public ValueClass {
	/// <summary>
	/// GUID of the assigned SordHist object.
	/// </summary>
	protected: ::std::wstring histGuid;
	/// <summary>
	/// Map key.
	/// </summary>
	protected: ::std::wstring key;
	/// <summary>
	/// Map value.
	/// </summary>
	/// <remarks>
	/// An empty value means, that the map item has been deleted.
	/// </remarks>
	protected: ::std::wstring value;
	/// <summary>
	/// BLOB value.
	/// </summary>
	protected: PFileData blobValue;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: MapHistItem();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: MapHistItem(const ::std::wstring& histGuid, const ::std::wstring& key, const ::std::wstring& value, const PFileData& blobValue);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: ::std::wstring getHistGuid() { return histGuid; }
	public: void setHistGuid(::std::wstring v);
	public: ::std::wstring getKey() { return key; }
	public: void setKey(::std::wstring v);
	public: ::std::wstring getValue() { return value; }
	public: void setValue(::std::wstring v);
	public: PFileData getBlobValue() { return blobValue; }
	public: void setBlobValue(PFileData v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// MapHistItemC
// typeId=1314989638

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// <p>Bit constants for members of MapHistItem</p>
/// <p>Copyright: Copyright (c) 2003</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </summary>
class MapHistItemC : public BSerializable {
	/// <summary>
	/// Member bit: Serialisation version ID
	/// DB column: maphistguid
	/// </summary>
	public: const static int64_t mbHistGuid = 1LL;
	/// <summary>
	/// Column length: Serialisation version ID
	/// DB column: maphistguid
	/// </summary>
	protected: int32_t lnHistGuid;
	/// <summary>
	/// DB column: mapkey
	/// </summary>
	public: const static int64_t mbKey = 2LL;
	/// <summary>
	/// DB column: mapkey
	/// </summary>
	protected: int32_t lnKey;
	/// <summary>
	/// DB column: mapvalue
	/// </summary>
	public: const static int64_t mbValue = 4LL;
	/// <summary>
	/// DB column: mapvalue
	/// </summary>
	protected: int32_t lnValue;
	/// <summary>
	/// DB column: mapcontenttype
	/// </summary>
	public: const static int64_t mbContentType = 8LL;
	/// <summary>
	/// DB column: mapcontenttype
	/// </summary>
	protected: int32_t lnContentType;
	/// <summary>
	/// DB column: mapblob
	/// </summary>
	public: const static int64_t mbBlobData = 16LL;
	/// <summary>
	/// DB column: mapblob
	/// </summary>
	protected: int32_t lnBlobData;
	/// <summary>
	/// All valid member bits.
	/// </summary>
	public: const static int64_t mbAllMembers = 31LL;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: MapHistItemC();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: MapHistItemC(int64_t mbHistGuid, int32_t lnHistGuid, int64_t mbKey, int32_t lnKey, int64_t mbValue, int32_t lnValue, int64_t mbContentType, int32_t lnContentType, int64_t mbBlobData, int32_t lnBlobData, int64_t mbAllMembers);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getLnHistGuid() { return lnHistGuid; }
	public: void setLnHistGuid(int32_t v);
	public: int32_t getLnKey() { return lnKey; }
	public: void setLnKey(int32_t v);
	public: int32_t getLnValue() { return lnValue; }
	public: void setLnValue(int32_t v);
	public: int32_t getLnContentType() { return lnContentType; }
	public: void setLnContentType(int32_t v);
	public: int32_t getLnBlobData() { return lnBlobData; }
	public: void setLnBlobData(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// MapHistZ
// typeId=1505340976

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

class MapHistZ : public ValueClass {
	protected: int64_t bset;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: MapHistZ();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: MapHistZ(int64_t bset);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int64_t getBset() { return bset; }
	public: void setBset(int64_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// MapItem
// typeId=1461301521

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Internal class.
/// </summary>
class MapItem : public ValueClass {
	/// <summary>
	/// Map id.
	/// </summary>
	protected: ::std::wstring id;
	/// <summary>
	/// Map key.
	/// </summary>
	protected: ::std::wstring key;
	/// <summary>
	/// Map value.
	/// </summary>
	protected: ::std::wstring value;
	/// <summary>
	/// Content Type.
	/// </summary>
	protected: ::std::wstring contentType;
	/// <summary>
	/// Blob data.
	/// </summary>
	protected: PContentStream blobData;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: MapItem();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: MapItem(const ::std::wstring& id, const ::std::wstring& key, const ::std::wstring& value, const ::std::wstring& contentType, const PContentStream& blobData);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: ::std::wstring getId() { return id; }
	public: void setId(::std::wstring v);
	public: ::std::wstring getKey() { return key; }
	public: void setKey(::std::wstring v);
	public: ::std::wstring getValue() { return value; }
	public: void setValue(::std::wstring v);
	public: ::std::wstring getContentType() { return contentType; }
	public: void setContentType(::std::wstring v);
	public: PContentStream getBlobData() { return blobData; }
	public: void setBlobData(PContentStream v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// MapItemC
// typeId=812006040

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// <p>Bit constants for members of MapItem</p>
/// <p>Copyright: Copyright (c) 2003</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </summary>
class MapItemC : public BSerializable {
	/// <summary>
	/// DB column: mapid
	/// </summary>
	public: const static int64_t mbId = 1LL;
	/// <summary>
	/// DB column: mapid
	/// </summary>
	protected: int32_t lnId;
	/// <summary>
	/// DB column: mapkey
	/// </summary>
	public: const static int64_t mbKey = 2LL;
	/// <summary>
	/// DB column: mapkey
	/// </summary>
	protected: int32_t lnKey;
	/// <summary>
	/// DB column: mapvalue
	/// </summary>
	public: const static int64_t mbValue = 4LL;
	/// <summary>
	/// DB column: mapvalue
	/// </summary>
	protected: int32_t lnValue;
	/// <summary>
	/// Member bit: Content Type.
	/// </summary>
	/// <remarks>
	/// DB column: mapcontenttype
	/// </remarks>
	public: const static int64_t mbContentType = 8LL;
	/// <summary>
	/// Column length: Content Type.
	/// </summary>
	/// <remarks>
	/// DB column: mapcontenttype
	/// </remarks>
	protected: int32_t lnContentType;
	/// <summary>
	/// Member bit: Blob data.
	/// </summary>
	/// <remarks>
	/// DB column: mapblob
	/// </remarks>
	public: const static int64_t mbBlobData = 16LL;
	/// <summary>
	/// Column length: Blob data.
	/// </summary>
	/// <remarks>
	/// DB column: mapblob
	/// </remarks>
	protected: int32_t lnBlobData;
	/// <summary>
	/// All valid member bits.
	/// </summary>
	public: const static int64_t mbAllMembers = 31LL;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: MapItemC();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: MapItemC(int64_t mbId, int32_t lnId, int64_t mbKey, int32_t lnKey, int64_t mbValue, int32_t lnValue, int64_t mbContentType, int32_t lnContentType, int64_t mbBlobData, int32_t lnBlobData, int64_t mbAllMembers);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getLnId() { return lnId; }
	public: void setLnId(int32_t v);
	public: int32_t getLnKey() { return lnKey; }
	public: void setLnKey(int32_t v);
	public: int32_t getLnValue() { return lnValue; }
	public: void setLnValue(int32_t v);
	public: int32_t getLnContentType() { return lnContentType; }
	public: void setLnContentType(int32_t v);
	public: int32_t getLnBlobData() { return lnBlobData; }
	public: void setLnBlobData(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// MapValue
// typeId=408347242

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// This class represents map values.
/// </summary>
/// <remarks>
/// A map value is either a string, stored in member {@link KeyValue#value} of the super class.
/// Or a map value is a BLOB available in {@link #blobValue}.
/// </remarks>
class MapValue : public KeyValue {
	/// <summary>
	/// BLOB value.
	/// </summary>
	protected: PFileData blobValue;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: MapValue();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: MapValue(const PFileData& blobValue);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: PFileData getBlobValue() { return blobValue; }
	public: void setBlobValue(PFileData v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// MaskName
// typeId=458953805

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Mask name object.
/// </summary>
/// <remarks>
/// <p>Copyright: Copyright (c) 2004</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </remarks>
class MaskName : public ValueClass {
	/// <summary>
	/// Mask can be used as storage mask for indexing.
	/// </summary>
	protected: bool documentMask;
	/// <summary>
	/// Mask ID.
	/// </summary>
	protected: int32_t id;
	/// <summary>
	/// Mask name.
	/// </summary>
	protected: ::std::wstring name;
	/// <summary>
	/// Mask can be used for searching.
	/// </summary>
	protected: bool searchMask;
	/// <summary>
	/// Mask can be used as storage mask for folders.
	/// </summary>
	protected: bool folderMask;
	/// <summary>
	/// GUID
	/// </summary>
	protected: ::std::wstring guid;
	/// <summary>
	/// Access mode for the current user.
	/// </summary>
	/// <remarks>
	/// A combination of AccessC.LUR_* constants.
	/// </remarks>
	protected: int32_t access;
	/// <summary>
	/// Mask has a barcode definition.
	/// </summary>
	protected: bool barcodeMask;
	/// <summary>
	/// Translation-keyword for {@link MaskName#name}.
	/// </summary>
	protected: ::std::wstring nameTranslationKey;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: MaskName();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: MaskName(bool documentMask, int32_t id, const ::std::wstring& name, bool searchMask, bool folderMask, const ::std::wstring& guid, int32_t access, bool barcodeMask, const ::std::wstring& nameTranslationKey);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: bool getDocumentMask() { return documentMask; }
	public: void setDocumentMask(bool v);
	public: int32_t getId() { return id; }
	public: void setId(int32_t v);
	public: ::std::wstring getName() { return name; }
	public: void setName(::std::wstring v);
	public: bool getSearchMask() { return searchMask; }
	public: void setSearchMask(bool v);
	public: bool getFolderMask() { return folderMask; }
	public: void setFolderMask(bool v);
	public: ::std::wstring getGuid() { return guid; }
	public: void setGuid(::std::wstring v);
	public: int32_t getAccess() { return access; }
	public: void setAccess(int32_t v);
	public: bool getBarcodeMask() { return barcodeMask; }
	public: void setBarcodeMask(bool v);
	public: ::std::wstring getNameTranslationKey() { return nameTranslationKey; }
	public: void setNameTranslationKey(::std::wstring v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// MoveDocumentsInfo
// typeId=2016315141

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Parameter class of the function {@link IXServicePortIF#moveDocuments(ClientInfo, MoveDocumentsInfo)}.
/// </summary>
class MoveDocumentsInfo : public ValueClass {
	/// <summary>
	/// ID of the source storage path.
	/// </summary>
	protected: ::std::wstring sourcePathId;
	/// <summary>
	/// ID of the target storage path.
	/// </summary>
	protected: ::std::wstring targetPathId;
	/// <summary>
	/// Start date.
	/// </summary>
	protected: ::std::wstring startDate;
	/// <summary>
	/// End date.
	/// </summary>
	protected: ::std::wstring endDate;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: MoveDocumentsInfo();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: MoveDocumentsInfo(const ::std::wstring& sourcePathId, const ::std::wstring& targetPathId, const ::std::wstring& startDate, const ::std::wstring& endDate);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: ::std::wstring getSourcePathId() { return sourcePathId; }
	public: void setSourcePathId(::std::wstring v);
	public: ::std::wstring getTargetPathId() { return targetPathId; }
	public: void setTargetPathId(::std::wstring v);
	public: ::std::wstring getStartDate() { return startDate; }
	public: void setStartDate(::std::wstring v);
	public: ::std::wstring getEndDate() { return endDate; }
	public: void setEndDate(::std::wstring v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// NavigationInfo
// typeId=1953181452

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// NavigationInfo is used as traversal information for structured bulk
/// operations restricting specific processsing, e.g. pooled jobs, to scalable amounts.
/// </summary>
/// <remarks>
/// It provides parameters controlling the traversal.
/// 
/// <p>Copyright: Copyright (c) 2004</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </remarks>
class NavigationInfo : public ValueClass {
	/// <summary>
	/// ignore the navigation of documents
	/// </summary>
	protected: bool ignoreDocuments;
	/// <summary>
	/// maxCount is the overall maximum amount of visited nodes and is independent of successful processing.
	/// </summary>
	/// <remarks>
	/// maxCount does not depend on successful processing to be incremented, and it can stop the traversal
	/// before any of the other limits have been reached.
	/// Passing maxCount &lt; 1 will turn off this limit.
	/// </remarks>
	protected: int32_t maxCount;
	/// <summary>
	/// The maximum depth of the tree walk.
	/// </summary>
	/// <remarks>
	/// Passing maxDepth &lt; 1 turns off this limit.
	/// </remarks>
	protected: int32_t maxDepth;
	/// <summary>
	/// The maximum number of siblings for one tree level.
	/// </summary>
	/// <remarks>
	/// This limit is most
	/// useful for ignoring the contents of large folders. Passing maxSiblings
	/// &lt; 1 will turn the limit off.
	/// </remarks>
	protected: int32_t maxSiblings;
	/// <summary>
	/// The starting points for the tree walk.
	/// </summary>
	/// <remarks>
	/// Interdepending nodes will only be
	/// traversed once. Providing null causes an invalid parameter exception,
	/// while unresolvable IDs or GUIDs will simply be ignored.
	/// </remarks>
	protected: PArrayString startIDs;
	/// <summary>
	/// Specify additional filters for the tree walk.
	/// </summary>
	/// <remarks>
	/// <p>
	/// Please note that specifying a custom findInfo always leads to a second
	/// search for each directory decreasing the overall performance. Use this
	/// only if processFindResult is not suitable.
	/// </p>
	/// <p>
	/// Then, not every feature is supported which findInfo offers. Firstly, the
	/// member findChildren will be overwritten during the tree walk. Secondly, as
	/// a fulltext or direct search respectively influence the search for children,
	/// they are unsupported also.
	/// </p>
	/// </remarks>
	protected: PFindInfo findInfo;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: NavigationInfo();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: NavigationInfo(bool ignoreDocuments, int32_t maxCount, int32_t maxDepth, int32_t maxSiblings, const PArrayString& startIDs, const PFindInfo& findInfo);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: bool getIgnoreDocuments() { return ignoreDocuments; }
	public: void setIgnoreDocuments(bool v);
	public: int32_t getMaxCount() { return maxCount; }
	public: void setMaxCount(int32_t v);
	public: int32_t getMaxDepth() { return maxDepth; }
	public: void setMaxDepth(int32_t v);
	public: int32_t getMaxSiblings() { return maxSiblings; }
	public: void setMaxSiblings(int32_t v);
	public: PArrayString getStartIDs() { return startIDs; }
	public: void setStartIDs(PArrayString v);
	public: PFindInfo getFindInfo() { return findInfo; }
	public: void setFindInfo(PFindInfo v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// NavigationInfoC
// typeId=1520348158

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Constants class for the NavigationInfo class.
/// </summary>
/// <remarks>
/// <p>Copyright: Copyright (c) 2004</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </remarks>
class NavigationInfoC : public BSerializable {
	/// <summary>
	/// The minimum depth for tree walks.
	/// </summary>
	public: const static int32_t MIN_NAV_DEPTH = 1;
	/// <summary>
	/// The overall limit for any visited element.
	/// </summary>
	public: const static int32_t MIN_NAV_MAX_COUNT = 1;
	/// <summary>
	/// The minimum amount of collected siblings.
	/// </summary>
	public: const static int32_t MIN_NAV_SIBLINGS = 1;
	/// <summary>
	/// This constant is used to override the navigation limit.
	/// </summary>
	public: const static int32_t SKIP_NAV_LIMIT = 0;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: NavigationInfoC();
	
	public: virtual BTYPEID BSerializable_getTypeId();
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// Note
// typeId=937420667

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// <p>This helper class inherits all members from <code>NoteData</code> and
/// adds a static member to access the bit constants for the <code>NoteData</code>
/// members.
/// </summary>
/// <remarks>
/// </p>
/// </remarks>
class Note : public ValueClass {
	/// <summary>
	/// Timestamp of the last change to the note.
	/// </summary>
	/// <remarks>
	/// The format is JJJJ.MM.DD.hh.mm.ss
	/// </remarks>
	protected: ::std::wstring TStamp;
	/// <summary>
	/// The position in the x axis when the note is displayed on a document in ELO.
	/// </summary>
	/// <remarks>
	/// Taken from the top left corner of the document.
	/// <p>
	/// For NoteC.TYPE_ANNOTATION_FREEHAND and NoteC.TYPE_ANNOTATION_HORIZONTAL_LINE
	/// the values XPos, YPos, Width, Height describe the enveloping rectangle
	/// of the line including the line width. This values are computed by the IndexServer
	/// if the note is stored.
	/// </p>
	/// </remarks>
	protected: int32_t XPos;
	/// <summary>
	/// The position in the Y axis when the note is displayed on a document in ELO.
	/// </summary>
	/// <remarks>
	/// Taken from the top left corner of the document.
	/// </remarks>
	protected: int32_t YPos;
	/// <summary>
	/// The text for the note.
	/// </summary>
	protected: ::std::wstring desc;
	/// <summary>
	/// The GUID for the note.
	/// </summary>
	protected: ::std::wstring guid;
	/// <summary>
	/// The height of the note (y axis), when displayed on a document in ELO.
	/// </summary>
	protected: int32_t height;
	/// <summary>
	/// The unique id for the note.
	/// </summary>
	protected: int32_t id;
	/// <summary>
	/// The ID of the user who created the note.
	/// </summary>
	/// <remarks>
	/// Administrators can set the ownerId to an arbitary user ID in checkinNotes.
	/// Set ownerName=&quot;&quot; in this case.
	/// </remarks>
	protected: int32_t ownerId;
	/// <summary>
	/// The page number to which the note is attached.
	/// </summary>
	protected: int32_t pageNo;
	/// <summary>
	/// The note type.
	/// </summary>
	protected: int32_t type;
	/// <summary>
	/// Width ( x axis) of the note when displayed on a document in ELO.
	/// </summary>
	protected: int32_t width;
	/// <summary>
	/// ISO encoded external (user defined) date.
	/// </summary>
	protected: ::std::wstring createDateIso;
	/// <summary>
	/// True if the note is deleted, otherwise false.
	/// </summary>
	protected: bool deleted;
	/// <summary>
	/// The ID of the user that holds the lock or -1, if the note is not locked.
	/// </summary>
	protected: int32_t lockId;
	/// <summary>
	/// The user name that holds the lock or an empty string if the note is not locked.
	/// </summary>
	protected: ::std::wstring lockName;
	/// <summary>
	/// Object ID of the associated Sord object or any of the  ID specifiers that
	/// are valid for checkoutSord too.
	/// </summary>
	/// <remarks>
	/// Functions createNote and checkoutNotes return only numerical object IDs.
	/// </remarks>
	protected: ::std::wstring objId;
	/// <summary>
	/// The name of the user that has created the note.
	/// </summary>
	/// <remarks>
	/// Administrators can set the ownerName to an arbitary user name in checkinNotes.
	/// Set ownerId=-1 in this case.
	/// </remarks>
	protected: ::std::wstring ownerName;
	/// <summary>
	/// Access control list.
	/// </summary>
	/// <remarks>
	/// Only used for notes of type TYPE_ANNOTATION_MARKER.
	/// Set member aclItems=null on check in otherwise it is ignored.
	/// </remarks>
	protected: ::std::wstring acl;
	/// <summary>
	/// Access control list as item array.
	/// </summary>
	/// <remarks>
	/// Only used for notes of type TYPE_ANNOTATION_MARKER.
	/// If this member is not null, member acl is ignored on check in.
	/// </remarks>
	protected: PArrayAclItem aclItems;
	/// <summary>
	/// RGB value.
	/// </summary>
	/// <remarks>
	/// Undefined for notes of type TYPE_ANNOTATION_STAMP and TYPE_ANNOTATION_NOTE_WITHFONT.
	/// </remarks>
	protected: int32_t color;
	/// <summary>
	/// Additional information for textual stamps.
	/// </summary>
	/// <remarks>
	/// Valid only for notes of type
	/// TYPE_ANNOTATION_NOTE, TYPE_ANNOTATION_STAMP and TYPE_ANNOTATION_NOTE_WITHFONT.
	/// Either desc, noteText, noteImage or noteFreehand can be set.
	/// </remarks>
	protected: PNoteText noteText;
	/// <summary>
	/// Additional information for image stamps.
	/// </summary>
	/// <remarks>
	/// Valid only for notes of type TYPE_ANNOTATION_STAMP.
	/// Either desc, noteText, noteImage or noteFreehand can be set.
	/// </remarks>
	protected: PNoteImage noteImage;
	/// <summary>
	/// Point information for a freehand line.
	/// </summary>
	/// <remarks>
	/// Valid only for notes of type TYPE_ANNOTATION_FREEHAND and TYPE_ANNOTATION_HORIZONTAL_LINE.
	/// Either desc, noteText, noteImage or noteFreehand can be set.
	/// </remarks>
	protected: PNoteFreehand noteFreehand;
	/// <summary>
	/// Access rights for the current user.
	/// </summary>
	/// <remarks>
	/// Read-only.
	/// </remarks>
	protected: int32_t access;
	/// <summary>
	/// The Note is deleted at this date.
	/// </summary>
	/// <remarks>
	/// ClientInfo determines the Timezone.
	/// <p>Is undefined if isDeleted() returns false.</p>
	/// </remarks>
	protected: ::std::wstring deleteDateIso;
	/// <summary>
	/// Timestamp of this object's last export by the replication.
	/// </summary>
	protected: ::std::wstring TStampSync;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: Note();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: Note(const ::std::wstring& TStamp, int32_t XPos, int32_t YPos, const ::std::wstring& desc, const ::std::wstring& guid, int32_t height, int32_t id, int32_t ownerId, int32_t pageNo, int32_t type, int32_t width, const ::std::wstring& createDateIso, bool deleted, int32_t lockId, const ::std::wstring& lockName, const ::std::wstring& objId, const ::std::wstring& ownerName, const ::std::wstring& acl, const PArrayAclItem& aclItems, int32_t color, const PNoteText& noteText, const PNoteImage& noteImage, const PNoteFreehand& noteFreehand, int32_t access, const ::std::wstring& deleteDateIso, const ::std::wstring& TStampSync);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: ::std::wstring getTStamp() { return TStamp; }
	public: void setTStamp(::std::wstring v);
	public: int32_t getXPos() { return XPos; }
	public: void setXPos(int32_t v);
	public: int32_t getYPos() { return YPos; }
	public: void setYPos(int32_t v);
	public: ::std::wstring getDesc() { return desc; }
	public: void setDesc(::std::wstring v);
	public: ::std::wstring getGuid() { return guid; }
	public: void setGuid(::std::wstring v);
	public: int32_t getHeight() { return height; }
	public: void setHeight(int32_t v);
	public: int32_t getId() { return id; }
	public: void setId(int32_t v);
	public: int32_t getOwnerId() { return ownerId; }
	public: void setOwnerId(int32_t v);
	public: int32_t getPageNo() { return pageNo; }
	public: void setPageNo(int32_t v);
	public: int32_t getType() { return type; }
	public: void setType(int32_t v);
	public: int32_t getWidth() { return width; }
	public: void setWidth(int32_t v);
	public: ::std::wstring getCreateDateIso() { return createDateIso; }
	public: void setCreateDateIso(::std::wstring v);
	public: bool getDeleted() { return deleted; }
	public: void setDeleted(bool v);
	public: int32_t getLockId() { return lockId; }
	public: void setLockId(int32_t v);
	public: ::std::wstring getLockName() { return lockName; }
	public: void setLockName(::std::wstring v);
	public: ::std::wstring getObjId() { return objId; }
	public: void setObjId(::std::wstring v);
	public: ::std::wstring getOwnerName() { return ownerName; }
	public: void setOwnerName(::std::wstring v);
	public: ::std::wstring getAcl() { return acl; }
	public: void setAcl(::std::wstring v);
	public: PArrayAclItem getAclItems() { return aclItems; }
	public: void setAclItems(PArrayAclItem v);
	public: int32_t getColor() { return color; }
	public: void setColor(int32_t v);
	public: PNoteText getNoteText() { return noteText; }
	public: void setNoteText(PNoteText v);
	public: PNoteImage getNoteImage() { return noteImage; }
	public: void setNoteImage(PNoteImage v);
	public: PNoteFreehand getNoteFreehand() { return noteFreehand; }
	public: void setNoteFreehand(PNoteFreehand v);
	public: int32_t getAccess() { return access; }
	public: void setAccess(int32_t v);
	public: ::std::wstring getDeleteDateIso() { return deleteDateIso; }
	public: void setDeleteDateIso(::std::wstring v);
	public: ::std::wstring getTStampSync() { return TStampSync; }
	public: void setTStampSync(::std::wstring v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// NoteDataC
// typeId=1521483547

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// <p>Bit constants for members of Note</p>
/// <p>Copyright: Copyright (c) 2003</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </summary>
class NoteDataC : public BSerializable {
	/// <summary>
	/// DB column: noteid
	/// </summary>
	public: const static int64_t mbId = 1LL;
	/// <summary>
	/// DB column: parentid
	/// </summary>
	public: const static int64_t mbParentId = 2LL;
	/// <summary>
	/// DB column: pageno
	/// </summary>
	public: const static int64_t mbPageNo = 4LL;
	/// <summary>
	/// DB column: xpos
	/// </summary>
	public: const static int64_t mbXPos = 8LL;
	/// <summary>
	/// DB column: ypos
	/// </summary>
	public: const static int64_t mbYPos = 16LL;
	/// <summary>
	/// DB column: userid
	/// </summary>
	public: const static int64_t mbOwnerId = 32LL;
	/// <summary>
	/// DB column: notetype
	/// </summary>
	public: const static int64_t mbType = 64LL;
	/// <summary>
	/// DB column: hlock
	/// </summary>
	public: const static int64_t mbHLock = 128LL;
	/// <summary>
	/// DB column: createdate
	/// </summary>
	public: const static int64_t mbCreateDate = 256LL;
	/// <summary>
	/// DB column: pidesc
	/// </summary>
	public: const static int64_t mbDesc = 512LL;
	/// <summary>
	/// DB column: pidesc
	/// </summary>
	protected: int32_t lnDesc;
	/// <summary>
	/// DB column: noteguid
	/// </summary>
	public: const static int64_t mbGuid = 1024LL;
	/// <summary>
	/// DB column: noteguid
	/// </summary>
	protected: int32_t lnGuid;
	/// <summary>
	/// DB column: notetstamp
	/// </summary>
	public: const static int64_t mbTStamp = 2048LL;
	/// <summary>
	/// DB column: notetstamp
	/// </summary>
	protected: int32_t lnTStamp;
	/// <summary>
	/// DB column: notestatus
	/// </summary>
	public: const static int64_t mbStatus = 4096LL;
	/// <summary>
	/// DB column: width
	/// </summary>
	public: const static int64_t mbWidth = 8192LL;
	/// <summary>
	/// DB column: height
	/// </summary>
	public: const static int64_t mbHeight = 16384LL;
	/// <summary>
	/// DB column: noteacl
	/// </summary>
	public: const static int64_t mbAcl = 32768LL;
	/// <summary>
	/// DB column: noteacl
	/// </summary>
	protected: int32_t lnAcl;
	/// <summary>
	/// DB column: color
	/// </summary>
	public: const static int64_t mbColor = 65536LL;
	/// <summary>
	/// Member bit: The Note is deleted at this date.
	/// </summary>
	/// <remarks>
	/// ClientInfo determines the Timezone.
	/// DB column: deletedate
	/// </remarks>
	public: const static int64_t mbDeleteDate = 131072LL;
	/// <summary>
	/// Member bit: Timestamp of this object's last export by the replication.
	/// </summary>
	/// <remarks>
	/// DB column: notetstampsync
	/// </remarks>
	public: const static int64_t mbTStampSync = 262144LL;
	/// <summary>
	/// Column length: Timestamp of this object's last export by the replication.
	/// </summary>
	/// <remarks>
	/// DB column: notetstampsync
	/// </remarks>
	protected: int32_t lnTStampSync;
	/// <summary>
	/// All valid member bits.
	/// </summary>
	public: const static int64_t mbAllMembers = 524287LL;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: NoteDataC();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: NoteDataC(int64_t mbId, int64_t mbParentId, int64_t mbPageNo, int64_t mbXPos, int64_t mbYPos, int64_t mbOwnerId, int64_t mbType, int64_t mbHLock, int64_t mbCreateDate, int64_t mbDesc, int32_t lnDesc, int64_t mbGuid, int32_t lnGuid, int64_t mbTStamp, int32_t lnTStamp, int64_t mbStatus, int64_t mbWidth, int64_t mbHeight, int64_t mbAcl, int32_t lnAcl, int64_t mbColor, int64_t mbDeleteDate, int64_t mbTStampSync, int32_t lnTStampSync, int64_t mbAllMembers);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getLnDesc() { return lnDesc; }
	public: void setLnDesc(int32_t v);
	public: int32_t getLnGuid() { return lnGuid; }
	public: void setLnGuid(int32_t v);
	public: int32_t getLnTStamp() { return lnTStamp; }
	public: void setLnTStamp(int32_t v);
	public: int32_t getLnAcl() { return lnAcl; }
	public: void setLnAcl(int32_t v);
	public: int32_t getLnTStampSync() { return lnTStampSync; }
	public: void setLnTStampSync(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// NoteC
// typeId=1319955249

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// <p>Constants for notes.
/// </summary>
/// <remarks>
/// </p>
/// </remarks>
class NoteC : public NoteDataC {
	/// <summary>
	/// Member objId.
	/// </summary>
	public: const static int64_t mbObjId = 2LL;
	/// <summary>
	/// Member lockId
	/// </summary>
	public: const static int64_t mbLockId = 128LL;
	/// <summary>
	/// Member noteText
	/// </summary>
	public: const static int64_t mbNoteText = 512LL;
	/// <summary>
	/// Member noteImage
	/// </summary>
	public: const static int64_t mbNoteImage = 512LL;
	/// <summary>
	/// Member noteFreehand
	/// </summary>
	public: const static int64_t mbNoteFreehand = 512LL;
	/// <summary>
	/// All members.
	/// </summary>
	public: const static PNoteZ mbAll;
	/// <summary>
	/// All members but without note text.
	/// </summary>
	public: const static PNoteZ mbNoDesc;
	/// <summary>
	/// Only remove or set lock.
	/// </summary>
	public: const static PNoteZ mbOnlyLock;
	public: const static int64_t mbDeleted = 4096LL;
	public: const static int64_t mbAclItems = 32768LL;
	public: const static int64_t mbCreateDateIso = 256LL;
	/// <summary>
	/// Note type: highlighting rectange (filled) on the document.
	/// </summary>
	/// <remarks>
	/// <p>If the note is assigned the colour 0xC0C0C0 the note will be interpreted by ELODM. In this case
	/// a black rectangle will painted on the document, using the note coordinates supplied,
	/// if the note ACL does not contain sufficient read access rights for the current user.
	/// This allows document contact to be blacked out for certain users
	/// The document must be a graphic based document, eg. tiff, bmp etc.</p>
	/// </remarks>
	public: const static int32_t TYPE_ANNOTATION_MARKER = 10;
	/// <summary>
	/// Use TYPE_ANNOTATION_MARKER
	/// </summary>
	public: const static int32_t TYPE_ANOTEW_MARKER = 10;
	/// <summary>
	/// Note type: annotation text
	/// </summary>
	public: const static int32_t TYPE_ANNOTATION_NOTE = 11;
	/// <summary>
	/// Use TYPE_ANNOTATION_NOTE
	/// </summary>
	public: const static int32_t TYPE_ANOTEWG_NOTE = 11;
	/// <summary>
	/// Note type: freehand line.
	/// </summary>
	public: const static int32_t TYPE_ANNOTATION_FREEHAND = 12;
	/// <summary>
	/// Note type: reserved
	/// </summary>
	public: const static int32_t TYPE_ANNOTATION_RECTANGLE = 13;
	/// <summary>
	/// Note type: draws a filled coloured box on the document, over the existing document.
	/// </summary>
	public: const static int32_t TYPE_ANNOTATION_FILLEDRECTANGLE = 14;
	/// <summary>
	/// Note type: draws a hollow rectangle (frame) on a document.
	/// </summary>
	public: const static int32_t TYPE_ANNOTATION_HOLLOWRECTANGLE = 15;
	/// <summary>
	/// Note type: reserved
	/// </summary>
	public: const static int32_t TYPE_ANNOTATION_LINE = 16;
	/// <summary>
	/// Annotation with text but without a rectangle.
	/// </summary>
	/// <remarks>
	/// <p>The font size in the client application has to be computed by FontInfo.height * 3.7 * resolution_in_dpi/100 </p>
	/// </remarks>
	public: const static int32_t TYPE_ANNOTATION_TEXT = 17;
	/// <summary>
	/// Note type: reserved
	/// </summary>
	public: const static int32_t TYPE_ANNOTATION_FILETEXT = 18;
	/// <summary>
	/// Adds a stamp, such as a received date for example, to a document.
	/// </summary>
	/// <remarks>
	/// <p>The font size in the client application has to be computed by FontInfo.height * 3.7 * resolution_in_dpi/100 </p>
	/// </remarks>
	public: const static int32_t TYPE_ANNOTATION_STAMP = 19;
	/// <summary>
	/// Draws a filled rectangular box on a document and displays text in the box.
	/// </summary>
	public: const static int32_t TYPE_ANNOTATION_NOTE_WITHFONT = 20;
	/// <summary>
	/// Note type: horizontal line.
	/// </summary>
	public: const static int32_t TYPE_ANNOTATION_HORIZONTAL_LINE = 21;
	/// <summary>
	/// Note type: strike out text
	/// </summary>
	public: const static int32_t TYPE_ANNOTATION_STRIKEOUT = 22;
	/// <summary>
	/// Note type: adds a stamp, such as a received date for example, to a document.
	/// </summary>
	/// <remarks>
	/// <p>The font size in the client application has to be computed by FontInfo.height * 2.2 * resolution_in_dpi/100 </p>
	/// </remarks>
	public: const static int32_t TYPE_ANNOTATION_STAMP_NEW = 23;
	/// <summary>
	/// Note type: needed in FindByNotes to indicate typeless filtering
	/// </summary>
	public: const static int32_t TYPE_NONE = 0;
	/// <summary>
	/// Note type: standard yellow note
	/// </summary>
	public: const static int32_t TYPE_NORMAL = 1;
	/// <summary>
	/// Note type: standard green note
	/// </summary>
	public: const static int32_t TYPE_PERSONAL = 2;
	/// <summary>
	/// Note type: standard red note
	/// </summary>
	public: const static int32_t TYPE_STAMP = 3;
	/// <summary>
	/// Note type: standard ACL
	/// </summary>
	public: const static int32_t TYPE_NORMAL_ACL = 7;
	/// <summary>
	/// This color is used for notes of type TYPE_ANNOTATION_MARKER
	/// to specify a black rectangle that is painted on the document
	/// by Document Manager.
	/// </summary>
	public: const static int32_t COLOR_ANNOTATION_MARKER_DM = 12632256;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: NoteC();
	
	public: virtual BTYPEID BSerializable_getTypeId();
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// NoteFreehand
// typeId=611837980

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// This class describes a freehand line annotation.
/// </summary>
class NoteFreehand : public BSerializable {
	/// <summary>
	/// Line width.
	/// </summary>
	protected: int32_t width;
	/// <summary>
	/// Points.
	/// </summary>
	protected: PArrayPointInfo points;
	/// <summary>
	/// Line width for strikeout pen (only TYPE_ANNOTATION_STRIKEOUT).
	/// </summary>
	protected: int32_t strikeoutWidth;
	/// <summary>
	/// Color for strikeout pen (only TYPE_ANNOTATION_STRIKEOUT).
	/// </summary>
	protected: int32_t strikeoutColor;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: NoteFreehand();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: NoteFreehand(int32_t width, const PArrayPointInfo& points, int32_t strikeoutWidth, int32_t strikeoutColor);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getWidth() { return width; }
	public: void setWidth(int32_t v);
	public: PArrayPointInfo getPoints() { return points; }
	public: void setPoints(PArrayPointInfo v);
	public: int32_t getStrikeoutWidth() { return strikeoutWidth; }
	public: void setStrikeoutWidth(int32_t v);
	public: int32_t getStrikeoutColor() { return strikeoutColor; }
	public: void setStrikeoutColor(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// NoteFreehandC
// typeId=1034219603

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Constants for NoteFreehand
/// </summary>
class NoteFreehandC : public BSerializable {
	/// <summary>
	/// Maximum number of points in NoteFreehand.
	/// </summary>
	public: const static int32_t MAX_POINTS = 400;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: NoteFreehandC();
	
	public: virtual BTYPEID BSerializable_getTypeId();
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// NoteImage
// typeId=1753613701

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// This class contains additional information for image stamps.
/// </summary>
class NoteImage : public BSerializable {
	/// <summary>
	/// Image file name.
	/// </summary>
	protected: ::std::wstring fileName;
	/// <summary>
	/// Image file content.
	/// </summary>
	/// <remarks>
	/// Read only.
	/// </remarks>
	protected: PFileData fileData;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: NoteImage();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: NoteImage(const ::std::wstring& fileName, const PFileData& fileData);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: ::std::wstring getFileName() { return fileName; }
	public: void setFileName(::std::wstring v);
	public: PFileData getFileData() { return fileData; }
	public: void setFileData(PFileData v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// NoteTemplate
// typeId=1995912373

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// This class describes the template information for a stamp.
/// </summary>
class NoteTemplate : public ValueClass {
	/// <summary>
	/// Stamp ID.
	/// </summary>
	protected: int32_t id;
	/// <summary>
	/// Stamp name.
	/// </summary>
	protected: ::std::wstring name;
	/// <summary>
	/// User ID or name.
	/// </summary>
	/// <remarks>
	/// NoteTemplate objects can be defined for all users and for a specific user.
	/// </remarks>
	protected: ::std::wstring userId;
	/// <summary>
	/// Text information, if this is a textual stamp.
	/// </summary>
	/// <remarks>
	/// The text information can contain the placeholders defined in NoteTemplateC.
	/// Either noteText or noteImage can be set.
	/// class NoteTemplateC
	/// </remarks>
	protected: PNoteText noteText;
	/// <summary>
	/// Image information, if this is stamp is an image.
	/// </summary>
	/// <remarks>
	/// Either noteText or noteImage can be set.
	/// </remarks>
	protected: PNoteImage noteImage;
	/// <summary>
	/// ACL.
	/// </summary>
	/// <remarks>
	/// Member aclItems has preceedence on checkin.
	/// </remarks>
	protected: ::std::wstring acl;
	/// <summary>
	/// ACL as an array of AclItem objects.
	/// </summary>
	protected: PArrayAclItem aclItems;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: NoteTemplate();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: NoteTemplate(int32_t id, const ::std::wstring& name, const ::std::wstring& userId, const PNoteText& noteText, const PNoteImage& noteImage, const ::std::wstring& acl, const PArrayAclItem& aclItems);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getId() { return id; }
	public: void setId(int32_t v);
	public: ::std::wstring getName() { return name; }
	public: void setName(::std::wstring v);
	public: ::std::wstring getUserId() { return userId; }
	public: void setUserId(::std::wstring v);
	public: PNoteText getNoteText() { return noteText; }
	public: void setNoteText(PNoteText v);
	public: PNoteImage getNoteImage() { return noteImage; }
	public: void setNoteImage(PNoteImage v);
	public: ::std::wstring getAcl() { return acl; }
	public: void setAcl(::std::wstring v);
	public: PArrayAclItem getAclItems() { return aclItems; }
	public: void setAclItems(PArrayAclItem v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// NoteTemplateC
// typeId=240897408

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Constants for class NoteTemplate
/// </summary>
class NoteTemplateC : public BSerializable {
	/// <summary>
	/// Member bit: id
	/// </summary>
	public: const static int64_t mbId = 1LL;
	/// <summary>
	/// Member bit: name
	/// </summary>
	public: const static int64_t mbName = 2LL;
	/// <summary>
	/// Member bit: UserId
	/// </summary>
	public: const static int64_t mbUserId = 4LL;
	/// <summary>
	/// Member bit: noteText
	/// </summary>
	public: const static int64_t mbNoteText = 8LL;
	/// <summary>
	/// Member bit: noteImage
	/// </summary>
	public: const static int64_t mbNoteImage = 16LL;
	/// <summary>
	/// Member bit: acl, aclItems
	/// </summary>
	public: const static int64_t mbAcl = 32LL;
	/// <summary>
	/// Member bit: all members
	/// </summary>
	public: const static int64_t mbAllMembers = 63LL;
	/// <summary>
	/// Elementselector: mbId
	/// </summary>
	public: const static PNoteTemplateZ mbMin;
	/// <summary>
	/// Elementselector: mbAllMembers
	/// </summary>
	public: const static PNoteTemplateZ mbAll;
	/// <summary>
	/// Placeholder for user name.
	/// </summary>
	/// <remarks>
	/// This constant can be used in NoteTemplate.textInfo.text as
	/// a placeholder for the current user name.
	/// </remarks>
	public: const static ::std::wstring PLACEHOLDER_USERNAME;
	/// <summary>
	/// Placeholder for date.
	/// </summary>
	/// <remarks>
	/// This constant can be used in NoteTemplate.textInfo.text as
	/// a placeholder for the current date.
	/// </remarks>
	public: const static ::std::wstring PLACEHOLDER_DATE;
	/// <summary>
	/// Placeholder for time.
	/// </summary>
	/// <remarks>
	/// This constant can be used in NoteTemplate.textInfo.text as
	/// a placeholder for the current time.
	/// </remarks>
	public: const static ::std::wstring PLACEHOLDER_TIME;
	/// <summary>
	/// Read/write note template visible for all users
	/// </summary>
	public: const static ::std::wstring USERID_ALL;
	/// <summary>
	/// Separates the values in the raw data representation.
	/// </summary>
	public: const static ::std::wstring RAW_ITEM_SEPARATOR;
	/// <summary>
	/// Separates the values of the subitems in the raw data representation.
	/// </summary>
	public: const static ::std::wstring RAW_SUBITEM_SEPARATOR;
	/// <summary>
	/// Separates the values of the name and text in the raw data representation.
	/// </summary>
	public: const static ::std::wstring RAW_STAMPINFO_SEPARATOR;
	/// <summary>
	/// Length of note template name.
	/// </summary>
	protected: int32_t lnName;
	/// <summary>
	/// Length of text in class NoteText.
	/// </summary>
	protected: int32_t lnText;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: NoteTemplateC();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: NoteTemplateC(int64_t mbId, int64_t mbName, int64_t mbUserId, int64_t mbNoteText, int64_t mbNoteImage, int64_t mbAcl, int64_t mbAllMembers, const PNoteTemplateZ& mbMin, const PNoteTemplateZ& mbAll, const ::std::wstring& PLACEHOLDER_USERNAME, const ::std::wstring& PLACEHOLDER_DATE, const ::std::wstring& PLACEHOLDER_TIME, const ::std::wstring& USERID_ALL, const ::std::wstring& RAW_ITEM_SEPARATOR, const ::std::wstring& RAW_SUBITEM_SEPARATOR, const ::std::wstring& RAW_STAMPINFO_SEPARATOR, int32_t lnName, int32_t lnText);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getLnName() { return lnName; }
	public: void setLnName(int32_t v);
	public: int32_t getLnText() { return lnText; }
	public: void setLnText(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// NoteTemplateDataC
// typeId=1775437403

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// <p>Bit constants for members of NoteTemplate</p>
/// <p>Copyright: Copyright (c) 2003</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </summary>
class NoteTemplateDataC : public BSerializable {
	/// <summary>
	/// DB column: userid
	/// </summary>
	public: const static int64_t mbUserIdInt = 1LL;
	/// <summary>
	/// DB column: optkey
	/// </summary>
	public: const static int64_t mbOptKey = 2LL;
	/// <summary>
	/// DB column: optkey
	/// </summary>
	protected: int32_t lnOptKey;
	/// <summary>
	/// DB column: optvalue
	/// </summary>
	public: const static int64_t mbOptValue = 4LL;
	/// <summary>
	/// DB column: optvalue
	/// </summary>
	protected: int32_t lnOptValue;
	/// <summary>
	/// All valid member bits.
	/// </summary>
	public: const static int64_t mbAllMembers = 7LL;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: NoteTemplateDataC();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: NoteTemplateDataC(int64_t mbUserIdInt, int64_t mbOptKey, int32_t lnOptKey, int64_t mbOptValue, int32_t lnOptValue, int64_t mbAllMembers);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getLnOptKey() { return lnOptKey; }
	public: void setLnOptKey(int32_t v);
	public: int32_t getLnOptValue() { return lnOptValue; }
	public: void setLnOptValue(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// NoteTemplateZ
// typeId=1483878971

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

class NoteTemplateZ : public BSerializable {
	protected: int64_t bset;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: NoteTemplateZ();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: NoteTemplateZ(int64_t bset);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int64_t getBset() { return bset; }
	public: void setBset(int64_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// NoteText
// typeId=669464920

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// This class conatins additional information for textual notes.
/// </summary>
/// <remarks>
/// NoteText objects can be used in NoteTemplate and Note objects.
/// </remarks>
class NoteText : public BSerializable {
	/// <summary>
	/// Font.
	/// </summary>
	/// <remarks>
	/// This member is null for type NoteC.TYPE_ANNOTATION_NOTE.
	/// </remarks>
	protected: PFontInfo fontInfo;
	/// <summary>
	/// Stamp text.
	/// </summary>
	/// <remarks>
	/// The maximum length is NoteDataC.lnDesc - 50, if the NoteText object is used in
	/// a Note object. The length for a text of a NoteTemplate object is defined by
	/// NoteTemplateC.lnText
	/// </remarks>
	protected: ::std::wstring text;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: NoteText();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: NoteText(const PFontInfo& fontInfo, const ::std::wstring& text);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: PFontInfo getFontInfo() { return fontInfo; }
	public: void setFontInfo(PFontInfo v);
	public: ::std::wstring getText() { return text; }
	public: void setText(::std::wstring v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// NoteZ
// typeId=2137405429

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// This class encapsulates the constants of the NoteC class.
/// </summary>
/// <remarks>
/// <p>Copyright: Copyright (c) 2004</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </remarks>
class NoteZ : public ValueClass {
	/// <summary>
	/// Bitset field for constants from the NoteC class.
	/// </summary>
	protected: int64_t bset;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: NoteZ();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: NoteZ(int64_t bset);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int64_t getBset() { return bset; }
	public: void setBset(int64_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// Notification
// typeId=494610451

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Objects of this class represent a change notification.
/// </summary>
/// <remarks>
/// This class is used internally.
/// </remarks>
class Notification : public ValueClass {
	/// <summary>
	/// GUID of user who should receive this notification.
	/// </summary>
	protected: ::std::wstring userGuid;
	/// <summary>
	/// GUID of changed Object.
	/// </summary>
	protected: ::std::wstring watchGuid;
	/// <summary>
	/// Create date of the notification.
	/// </summary>
	protected: ::std::wstring createDateIso;
	/// <summary>
	/// Indicates if the Notification is marked as important
	/// </summary>
	protected: int32_t prio;
	/// <summary>
	/// Indicates the type of the watched Element.
	/// 0 - Action.
	/// 1 - HashTag.
	/// </summary>
	protected: int32_t what;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: Notification();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: Notification(const ::std::wstring& userGuid, const ::std::wstring& watchGuid, const ::std::wstring& createDateIso, int32_t prio, int32_t what);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: ::std::wstring getUserGuid() { return userGuid; }
	public: void setUserGuid(::std::wstring v);
	public: ::std::wstring getWatchGuid() { return watchGuid; }
	public: void setWatchGuid(::std::wstring v);
	public: ::std::wstring getCreateDateIso() { return createDateIso; }
	public: void setCreateDateIso(::std::wstring v);
	public: int32_t getPrio() { return prio; }
	public: void setPrio(int32_t v);
	public: int32_t getWhat() { return what; }
	public: void setWhat(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// NotificationDataC
// typeId=2010056196

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// <p>Bit constants for members of Notification</p>
/// <p>Copyright: Copyright (c) 2003</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </summary>
class NotificationDataC : public BSerializable {
	/// <summary>
	/// Member bit: GUID of user who should receive this notification.
	/// </summary>
	/// <remarks>
	/// DB column: userguid
	/// </remarks>
	public: const static int64_t mbUserGuid = 1LL;
	/// <summary>
	/// Column length: GUID of user who should receive this notification.
	/// </summary>
	/// <remarks>
	/// DB column: userguid
	/// </remarks>
	protected: int32_t lnUserGuid;
	/// <summary>
	/// Member bit: GUID of changed Object.
	/// </summary>
	/// <remarks>
	/// DB column: watchguid
	/// </remarks>
	public: const static int64_t mbWatchGuid = 2LL;
	/// <summary>
	/// Column length: GUID of changed Object.
	/// </summary>
	/// <remarks>
	/// DB column: watchguid
	/// </remarks>
	protected: int32_t lnWatchGuid;
	/// <summary>
	/// Member bit: Create date of the notification.
	/// </summary>
	/// <remarks>
	/// DB column: createdateiso
	/// </remarks>
	public: const static int64_t mbCreateDateIso = 4LL;
	/// <summary>
	/// Column length: Create date of the notification.
	/// </summary>
	/// <remarks>
	/// DB column: createdateiso
	/// </remarks>
	protected: int32_t lnCreateDateIso;
	/// <summary>
	/// Member bit: Indicates if the Notification is marked as important
	/// DB column: prio
	/// </summary>
	public: const static int64_t mbPrio = 8LL;
	/// <summary>
	/// Member bit: Indicates the type of the watched Element.
	/// </summary>
	/// <remarks>
	/// DB column: what
	/// </remarks>
	public: const static int64_t mbWhat = 16LL;
	/// <summary>
	/// All valid member bits.
	/// </summary>
	public: const static int64_t mbAllMembers = 31LL;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: NotificationDataC();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: NotificationDataC(int64_t mbUserGuid, int32_t lnUserGuid, int64_t mbWatchGuid, int32_t lnWatchGuid, int64_t mbCreateDateIso, int32_t lnCreateDateIso, int64_t mbPrio, int64_t mbWhat, int64_t mbAllMembers);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getLnUserGuid() { return lnUserGuid; }
	public: void setLnUserGuid(int32_t v);
	public: int32_t getLnWatchGuid() { return lnWatchGuid; }
	public: void setLnWatchGuid(int32_t v);
	public: int32_t getLnCreateDateIso() { return lnCreateDateIso; }
	public: void setLnCreateDateIso(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// NotificationC
// typeId=1070921523

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Constants for class Notification.
/// </summary>
/// <remarks>
/// This class is used internally.
/// </remarks>
class NotificationC : public NotificationDataC {
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: NotificationC();
	
	public: virtual BTYPEID BSerializable_getTypeId();
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// NotificationZ
// typeId=1624160439

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// <p>This class encapsulates the constants of <code>NotificationC</code></p>
/// 
/// <p>Copyright: Copyright (c) 2015</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </summary>
class NotificationZ : public ValueClass {
	/// <summary>
	/// Bitset field for constants from the NotificationC class.
	/// </summary>
	protected: int64_t bset;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: NotificationZ();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: NotificationZ(int64_t bset);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int64_t getBset() { return bset; }
	public: void setBset(int64_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// NotifyServerInfo
// typeId=539899885

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// This class is used in IXServicePortIF.notifyServer to describe which
/// operation(s) has (have) been processed by the client application.
/// </summary>
class NotifyServerInfo : public ValueClass {
	/// <summary>
	/// The number of scanned documents.
	/// </summary>
	protected: int32_t scanCount;
	/// <summary>
	/// The number of documents for which OCR was processed.
	/// </summary>
	protected: int32_t ocrCount;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: NotifyServerInfo();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: NotifyServerInfo(int32_t scanCount, int32_t ocrCount);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getScanCount() { return scanCount; }
	public: void setScanCount(int32_t v);
	public: int32_t getOcrCount() { return ocrCount; }
	public: void setOcrCount(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// NotifyServerResult
// typeId=810727301

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// This class is used as a return value of IXServicPortIF.notifyServer.
/// </summary>
class NotifyServerResult : public ValueClass {
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: NotifyServerResult();
	
	public: virtual BTYPEID BSerializable_getTypeId();
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// ObjChange
// typeId=753146

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Internal class.
/// </summary>
class ObjChange : public ValueClass {
	/// <summary>
	/// DB column: chgobjid
	/// </summary>
	protected: ::std::wstring objId;
	/// <summary>
	/// DB column: chgtstamp
	/// </summary>
	protected: ::std::wstring tStamp;
	/// <summary>
	/// DB column: chgcode
	/// </summary>
	protected: int32_t code;
	/// <summary>
	/// DB column: chgparam
	/// </summary>
	protected: int32_t param;
	/// <summary>
	/// DB column: chgparam2
	/// </summary>
	protected: ::std::wstring param2;
	/// <summary>
	/// DB column: chguser
	/// </summary>
	protected: int32_t user;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: ObjChange();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: ObjChange(const ::std::wstring& objId, const ::std::wstring& tStamp, int32_t code, int32_t param, const ::std::wstring& param2, int32_t user);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: ::std::wstring getObjId() { return objId; }
	public: void setObjId(::std::wstring v);
	public: ::std::wstring getTStamp() { return tStamp; }
	public: void setTStamp(::std::wstring v);
	public: int32_t getCode() { return code; }
	public: void setCode(int32_t v);
	public: int32_t getParam() { return param; }
	public: void setParam(int32_t v);
	public: ::std::wstring getParam2() { return param2; }
	public: void setParam2(::std::wstring v);
	public: int32_t getUser() { return user; }
	public: void setUser(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// ObjChangeC
// typeId=1100272528

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// <p>Bit constants for members of ObjChange</p>
/// <p>Copyright: Copyright (c) 2003</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </summary>
class ObjChangeC : public BSerializable {
	/// <summary>
	/// DB column: chgobjid
	/// </summary>
	public: const static int64_t mbObjId = 1LL;
	/// <summary>
	/// DB column: chgobjid
	/// </summary>
	protected: int32_t lnObjId;
	/// <summary>
	/// DB column: chgtstamp
	/// </summary>
	public: const static int64_t mbTStamp = 2LL;
	/// <summary>
	/// DB column: chgtstamp
	/// </summary>
	protected: int32_t lnTStamp;
	/// <summary>
	/// DB column: chgcode
	/// </summary>
	public: const static int64_t mbCode = 4LL;
	/// <summary>
	/// DB column: chgparam
	/// </summary>
	public: const static int64_t mbParam = 8LL;
	/// <summary>
	/// DB column: chgparam2
	/// </summary>
	public: const static int64_t mbParam2 = 16LL;
	/// <summary>
	/// DB column: chgparam2
	/// </summary>
	protected: int32_t lnParam2;
	/// <summary>
	/// DB column: chguser
	/// </summary>
	public: const static int64_t mbUser = 32LL;
	/// <summary>
	/// All valid member bits.
	/// </summary>
	public: const static int64_t mbAllMembers = 63LL;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: ObjChangeC();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: ObjChangeC(int64_t mbObjId, int32_t lnObjId, int64_t mbTStamp, int32_t lnTStamp, int64_t mbCode, int64_t mbParam, int64_t mbParam2, int32_t lnParam2, int64_t mbUser, int64_t mbAllMembers);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getLnObjId() { return lnObjId; }
	public: void setLnObjId(int32_t v);
	public: int32_t getLnTStamp() { return lnTStamp; }
	public: void setLnTStamp(int32_t v);
	public: int32_t getLnParam2() { return lnParam2; }
	public: void setLnParam2(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// ObjDataC
// typeId=1521332903

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// <p>Bit constants for members of Sord</p>
/// <p>Copyright: Copyright (c) 2003</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </summary>
class ObjDataC : public BSerializable {
	/// <summary>
	/// Member bit: Serialisation version ID
	/// DB column: objid
	/// </summary>
	public: const static int64_t mbId = 1LL;
	/// <summary>
	/// DB column: objguid
	/// </summary>
	public: const static int64_t mbGuid = 2LL;
	/// <summary>
	/// DB column: objguid
	/// </summary>
	protected: int32_t lnGuid;
	/// <summary>
	/// DB column: objparent
	/// </summary>
	public: const static int64_t mbParentId = 4LL;
	/// <summary>
	/// DB column: objtype
	/// </summary>
	public: const static int64_t mbType = 8LL;
	/// <summary>
	/// DB column: objflags
	/// </summary>
	public: const static int64_t mbFlags = 16LL;
	/// <summary>
	/// DB column: objshort
	/// </summary>
	public: const static int64_t mbName = 32LL;
	/// <summary>
	/// DB column: objshort
	/// </summary>
	protected: int32_t lnName;
	/// <summary>
	/// DB column: objsreg
	/// </summary>
	public: const static int64_t mbSReg = 64LL;
	/// <summary>
	/// DB column: objsreg
	/// </summary>
	protected: int32_t lnSReg;
	/// <summary>
	/// DB column: objidate
	/// </summary>
	public: const static int64_t mbIDate = 128LL;
	/// <summary>
	/// DB column: objxdate
	/// </summary>
	public: const static int64_t mbXDate = 256LL;
	/// <summary>
	/// DB column: objkey
	/// </summary>
	public: const static int64_t mbKey = 512LL;
	/// <summary>
	/// DB column: objkind
	/// </summary>
	public: const static int64_t mbKind = 1024LL;
	/// <summary>
	/// DB column: objpath
	/// </summary>
	public: const static int64_t mbPath = 2048LL;
	/// <summary>
	/// DB column: objinfo
	/// </summary>
	public: const static int64_t mbInfo = 4096LL;
	/// <summary>
	/// DB column: objmask
	/// </summary>
	public: const static int64_t mbMask = 8192LL;
	/// <summary>
	/// DB column: objdoc
	/// </summary>
	public: const static int64_t mbDoc = 16384LL;
	/// <summary>
	/// DB column: objakey1
	/// </summary>
	public: const static int64_t mbSig = 32768LL;
	/// <summary>
	/// DB column: objattach
	/// </summary>
	public: const static int64_t mbAtt = 65536LL;
	/// <summary>
	/// DB column: objuser
	/// </summary>
	public: const static int64_t mbOwnerId = 131072LL;
	/// <summary>
	/// DB column: objlock
	/// </summary>
	public: const static int64_t mbLockId = 262144LL;
	/// <summary>
	/// DB column: objstatus
	/// </summary>
	public: const static int64_t mbStatus = 524288LL;
	/// <summary>
	/// DB column: objhistcount
	/// </summary>
	public: const static int64_t mbHistCount = 1048576LL;
	/// <summary>
	/// DB column: objdesc
	/// </summary>
	public: const static int64_t mbInternalDesc = 2097152LL;
	/// <summary>
	/// DB column: objdesc
	/// </summary>
	protected: int32_t lnInternalDesc;
	/// <summary>
	/// DB column: objchildcount
	/// </summary>
	public: const static int64_t mbChildCount = 4194304LL;
	/// <summary>
	/// DB column: objdeldate
	/// </summary>
	public: const static int64_t mbDelDate = 8388608LL;
	/// <summary>
	/// DB column: objsyncdateloc
	/// </summary>
	public: const static int64_t mbSyncDateLoc = 16777216LL;
	/// <summary>
	/// DB column: objsyncdaterem
	/// </summary>
	public: const static int64_t mbSyncDateRem = 33554432LL;
	/// <summary>
	/// DB column: objvtrep
	/// </summary>
	public: const static int64_t mbVtRep = 67108864LL;
	/// <summary>
	/// DB column: objacl
	/// </summary>
	public: const static int64_t mbAcl = 134217728LL;
	/// <summary>
	/// DB column: objacl
	/// </summary>
	protected: int32_t lnAcl;
	/// <summary>
	/// DB column: objtstamp
	/// </summary>
	public: const static int64_t mbTStamp = 268435456LL;
	/// <summary>
	/// DB column: objtstamp
	/// </summary>
	protected: int32_t lnTStamp;
	/// <summary>
	/// DB column: objsdata_off
	/// </summary>
	public: const static int64_t mbSName = 536870912LL;
	/// <summary>
	/// DB column: objsdata_off
	/// </summary>
	protected: int32_t lnSName;
	/// <summary>
	/// DB column: objsdesc_off
	/// </summary>
	public: const static int64_t mbSDesc = 1073741824LL;
	/// <summary>
	/// DB column: objsdesc_off
	/// </summary>
	protected: int32_t lnSDesc;
	/// <summary>
	/// Member bit: The Sord is deleted at this date.
	/// </summary>
	/// <remarks>
	/// ClientInfo determines the Timezone.
	/// DB column: deletedate
	/// </remarks>
	public: const static int64_t mbDeleteDate = 2147483648LL;
	/// <summary>
	/// Member bit: This is the id of the user who has a lock on the object (not the document).
	/// </summary>
	/// <remarks>
	/// DB column: objlock_off
	/// </remarks>
	public: const static int64_t mbLockIdSord = 4294967296LL;
	/// <summary>
	/// Member bit: This is the id of the user who has a lock on the document (not the object).
	/// </summary>
	/// <remarks>
	/// DB column: doclock
	/// </remarks>
	public: const static int64_t mbLockIdDoc = 8589934592LL;
	/// <summary>
	/// Member bit: Timestamp of this object's last export by the replication.
	/// </summary>
	/// <remarks>
	/// DB column: objtstampsync
	/// </remarks>
	public: const static int64_t mbTStampSync = 17179869184LL;
	/// <summary>
	/// Column length: Timestamp of this object's last export by the replication.
	/// </summary>
	/// <remarks>
	/// DB column: objtstampsync
	/// </remarks>
	protected: int32_t lnTStampSync;
	/// <summary>
	/// Member bit: Timestamp of the last ACL change.
	/// </summary>
	/// <remarks>
	/// DB column: objtstampacl
	/// </remarks>
	public: const static int64_t mbTStampAcl = 34359738368LL;
	/// <summary>
	/// Column length: Timestamp of the last ACL change.
	/// </summary>
	/// <remarks>
	/// DB column: objtstampacl
	/// </remarks>
	protected: int32_t lnTStampAcl;
	/// <summary>
	/// Member bit: Timestamp of this object's ACLs last export by the replication.
	/// </summary>
	/// <remarks>
	/// DB column: objtstampaclsync
	/// </remarks>
	public: const static int64_t mbTStampAclSync = 68719476736LL;
	/// <summary>
	/// Column length: Timestamp of this object's ACLs last export by the replication.
	/// </summary>
	/// <remarks>
	/// DB column: objtstampaclsync
	/// </remarks>
	protected: int32_t lnTStampAclSync;
	/// <summary>
	/// Member bit: The Sord is deleted at this user.
	/// </summary>
	/// <remarks>
	/// DB column: deleteuser
	/// </remarks>
	public: const static int64_t mbDeleteUser = 137438953472LL;
	/// <summary>
	/// All valid member bits.
	/// </summary>
	public: const static int64_t mbAllMembers = 274877906943LL;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: ObjDataC();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: ObjDataC(int64_t mbId, int64_t mbGuid, int32_t lnGuid, int64_t mbParentId, int64_t mbType, int64_t mbFlags, int64_t mbName, int32_t lnName, int64_t mbSReg, int32_t lnSReg, int64_t mbIDate, int64_t mbXDate, int64_t mbKey, int64_t mbKind, int64_t mbPath, int64_t mbInfo, int64_t mbMask, int64_t mbDoc, int64_t mbSig, int64_t mbAtt, int64_t mbOwnerId, int64_t mbLockId, int64_t mbStatus, int64_t mbHistCount, int64_t mbInternalDesc, int32_t lnInternalDesc, int64_t mbChildCount, int64_t mbDelDate, int64_t mbSyncDateLoc, int64_t mbSyncDateRem, int64_t mbVtRep, int64_t mbAcl, int32_t lnAcl, int64_t mbTStamp, int32_t lnTStamp, int64_t mbSName, int32_t lnSName, int64_t mbSDesc, int32_t lnSDesc, int64_t mbDeleteDate, int64_t mbLockIdSord, int64_t mbLockIdDoc, int64_t mbTStampSync, int32_t lnTStampSync, int64_t mbTStampAcl, int32_t lnTStampAcl, int64_t mbTStampAclSync, int32_t lnTStampAclSync, int64_t mbDeleteUser, int64_t mbAllMembers);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getLnGuid() { return lnGuid; }
	public: void setLnGuid(int32_t v);
	public: int32_t getLnName() { return lnName; }
	public: void setLnName(int32_t v);
	public: int32_t getLnSReg() { return lnSReg; }
	public: void setLnSReg(int32_t v);
	public: int32_t getLnInternalDesc() { return lnInternalDesc; }
	public: void setLnInternalDesc(int32_t v);
	public: int32_t getLnAcl() { return lnAcl; }
	public: void setLnAcl(int32_t v);
	public: int32_t getLnTStamp() { return lnTStamp; }
	public: void setLnTStamp(int32_t v);
	public: int32_t getLnSName() { return lnSName; }
	public: void setLnSName(int32_t v);
	public: int32_t getLnSDesc() { return lnSDesc; }
	public: void setLnSDesc(int32_t v);
	public: int32_t getLnTStampSync() { return lnTStampSync; }
	public: void setLnTStampSync(int32_t v);
	public: int32_t getLnTStampAcl() { return lnTStampAcl; }
	public: void setLnTStampAcl(int32_t v);
	public: int32_t getLnTStampAclSync() { return lnTStampAclSync; }
	public: void setLnTStampAclSync(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// ObjHistC
// typeId=1015803641

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// <p>Bit constants for members of SordHist</p>
/// <p>Copyright: Copyright (c) 2003</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </summary>
class ObjHistC : public BSerializable {
	/// <summary>
	/// Member bit: Serialisation version ID
	/// DB column: objhistguid
	/// </summary>
	public: const static int64_t mbHistGuid = 1LL;
	/// <summary>
	/// Column length: Serialisation version ID
	/// DB column: objhistguid
	/// </summary>
	protected: int32_t lnHistGuid;
	/// <summary>
	/// DB column: objhistts
	/// </summary>
	public: const static int64_t mbTimeStampUTC = 2LL;
	/// <summary>
	/// DB column: objhistts
	/// </summary>
	protected: int32_t lnTimeStampUTC;
	/// <summary>
	/// DB column: objguid
	/// </summary>
	public: const static int64_t mbObjGuid = 4LL;
	/// <summary>
	/// DB column: objguid
	/// </summary>
	protected: int32_t lnObjGuid;
	/// <summary>
	/// DB column: objuser
	/// </summary>
	public: const static int64_t mbUserNo = 8LL;
	/// <summary>
	/// DB column: username
	/// </summary>
	public: const static int64_t mbUserName = 16LL;
	/// <summary>
	/// DB column: username
	/// </summary>
	protected: int32_t lnUserName;
	/// <summary>
	/// DB column: objhistsrc
	/// </summary>
	public: const static int64_t mbHistSource = 32LL;
	/// <summary>
	/// DB column: objhistlocts
	/// </summary>
	public: const static int64_t mbTimeStampLocal = 64LL;
	/// <summary>
	/// DB column: objhistlocts
	/// </summary>
	protected: int32_t lnTimeStampLocal;
	/// <summary>
	/// DB column: objhistwks
	/// </summary>
	public: const static int64_t mbWorkStation = 128LL;
	/// <summary>
	/// DB column: objhistwks
	/// </summary>
	protected: int32_t lnWorkStation;
	/// <summary>
	/// All valid member bits.
	/// </summary>
	public: const static int64_t mbAllMembers = 255LL;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: ObjHistC();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: ObjHistC(int64_t mbHistGuid, int32_t lnHistGuid, int64_t mbTimeStampUTC, int32_t lnTimeStampUTC, int64_t mbObjGuid, int32_t lnObjGuid, int64_t mbUserNo, int64_t mbUserName, int32_t lnUserName, int64_t mbHistSource, int64_t mbTimeStampLocal, int32_t lnTimeStampLocal, int64_t mbWorkStation, int32_t lnWorkStation, int64_t mbAllMembers);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getLnHistGuid() { return lnHistGuid; }
	public: void setLnHistGuid(int32_t v);
	public: int32_t getLnTimeStampUTC() { return lnTimeStampUTC; }
	public: void setLnTimeStampUTC(int32_t v);
	public: int32_t getLnObjGuid() { return lnObjGuid; }
	public: void setLnObjGuid(int32_t v);
	public: int32_t getLnUserName() { return lnUserName; }
	public: void setLnUserName(int32_t v);
	public: int32_t getLnTimeStampLocal() { return lnTimeStampLocal; }
	public: void setLnTimeStampLocal(int32_t v);
	public: int32_t getLnWorkStation() { return lnWorkStation; }
	public: void setLnWorkStation(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// ObjHistKeyC
// typeId=1013854536

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// <p>Bit constants for members of SordHistKey</p>
/// <p>Copyright: Copyright (c) 2003</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </summary>
class ObjHistKeyC : public BSerializable {
	/// <summary>
	/// Member bit: Serialisation version ID
	/// DB column: objhistguid
	/// </summary>
	public: const static int64_t mbHistGuid = 1LL;
	/// <summary>
	/// Column length: Serialisation version ID
	/// DB column: objhistguid
	/// </summary>
	protected: int32_t lnHistGuid;
	/// <summary>
	/// DB column: okeyno
	/// </summary>
	public: const static int64_t mbKeyNo = 2LL;
	/// <summary>
	/// DB column: okeyname
	/// </summary>
	public: const static int64_t mbKeyName = 4LL;
	/// <summary>
	/// DB column: okeyname
	/// </summary>
	protected: int32_t lnKeyName;
	/// <summary>
	/// DB column: okeydata
	/// </summary>
	public: const static int64_t mbKeyData = 8LL;
	/// <summary>
	/// DB column: okeydata
	/// </summary>
	protected: int32_t lnKeyData;
	/// <summary>
	/// Member bit: Internal helper column for memo text.
	/// </summary>
	/// <remarks>
	/// DB column: objdesc
	/// </remarks>
	public: const static int64_t mbKeyDataDesc = 16LL;
	/// <summary>
	/// Column length: Internal helper column for memo text.
	/// </summary>
	/// <remarks>
	/// DB column: objdesc
	/// </remarks>
	protected: int32_t lnKeyDataDesc;
	/// <summary>
	/// All valid member bits.
	/// </summary>
	public: const static int64_t mbAllMembers = 31LL;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: ObjHistKeyC();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: ObjHistKeyC(int64_t mbHistGuid, int32_t lnHistGuid, int64_t mbKeyNo, int64_t mbKeyName, int32_t lnKeyName, int64_t mbKeyData, int32_t lnKeyData, int64_t mbKeyDataDesc, int32_t lnKeyDataDesc, int64_t mbAllMembers);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getLnHistGuid() { return lnHistGuid; }
	public: void setLnHistGuid(int32_t v);
	public: int32_t getLnKeyName() { return lnKeyName; }
	public: void setLnKeyName(int32_t v);
	public: int32_t getLnKeyData() { return lnKeyData; }
	public: void setLnKeyData(int32_t v);
	public: int32_t getLnKeyDataDesc() { return lnKeyDataDesc; }
	public: void setLnKeyDataDesc(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// ObjKey
// typeId=237417996

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// This class wraps the ObjKeyData class to provide a convenient way to access
/// the index lines that have multiple columns.
/// </summary>
/// <remarks>
/// Unlike ObjKeyData the getData and
/// setData functions work with String arrays inspite of single String objects.
/// 
/// <p>Copyright: Copyright (c) 2004</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </remarks>
class ObjKey : public ValueClass {
	/// <summary>
	/// Internal data array.
	/// </summary>
	/// <remarks>
	/// The values can be translated into resp. from the system language, if
	/// <code>SessionOptionsC.TRANSLATE_TERMS</code> is set and the corresponding
	/// <code>DocMaskLine</code> has set the property <code>translate</code>.
	/// </remarks>
	protected: PArrayString data;
	/// <summary>
	/// ID of the index line
	/// </summary>
	protected: int32_t id;
	/// <summary>
	/// The group name of the index line
	/// </summary>
	protected: ::std::wstring name;
	/// <summary>
	/// The ELO object ID this object belongs to
	/// </summary>
	protected: int32_t objId;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: ObjKey();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: ObjKey(const PArrayString& data, int32_t id, const ::std::wstring& name, int32_t objId);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: PArrayString getData() { return data; }
	public: void setData(PArrayString v);
	public: int32_t getId() { return id; }
	public: void setId(int32_t v);
	public: ::std::wstring getName() { return name; }
	public: void setName(::std::wstring v);
	public: int32_t getObjId() { return objId; }
	public: void setObjId(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// ObjKeyDataC
// typeId=2463451

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// <p>Bit constants for members of ObjKeyData</p>
/// <p>Copyright: Copyright (c) 2003</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </summary>
class ObjKeyDataC : public BSerializable {
	/// <summary>
	/// DB column: parentid
	/// </summary>
	public: const static int64_t mbObjId = 1LL;
	/// <summary>
	/// DB column: okeyno
	/// </summary>
	public: const static int64_t mbId = 2LL;
	/// <summary>
	/// DB column: okeyname
	/// </summary>
	public: const static int64_t mbName = 4LL;
	/// <summary>
	/// DB column: okeyname
	/// </summary>
	protected: int32_t lnName;
	/// <summary>
	/// DB column: okeydata
	/// </summary>
	public: const static int64_t mbData = 8LL;
	/// <summary>
	/// DB column: okeydata
	/// </summary>
	protected: int32_t lnData;
	/// <summary>
	/// DB column: okeyudata
	/// </summary>
	public: const static int64_t mbUdata = 16LL;
	/// <summary>
	/// DB column: okeyudata
	/// </summary>
	protected: int32_t lnUdata;
	/// <summary>
	/// DB column: okeysdata_off
	/// </summary>
	public: const static int64_t mbSdata = 32LL;
	/// <summary>
	/// DB column: okeysdata_off
	/// </summary>
	protected: int32_t lnSdata;
	/// <summary>
	/// Member bit: DB column: odouble
	/// DB column: okeydouble
	/// </summary>
	public: const static int64_t mbOdouble = 64LL;
	/// <summary>
	/// Column length: DB column: odouble
	/// DB column: okeydouble
	/// </summary>
	protected: int32_t lnOdouble;
	/// <summary>
	/// All valid member bits.
	/// </summary>
	public: const static int64_t mbAllMembers = 127LL;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: ObjKeyDataC();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: ObjKeyDataC(int64_t mbObjId, int64_t mbId, int64_t mbName, int32_t lnName, int64_t mbData, int32_t lnData, int64_t mbUdata, int32_t lnUdata, int64_t mbSdata, int32_t lnSdata, int64_t mbOdouble, int32_t lnOdouble, int64_t mbAllMembers);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getLnName() { return lnName; }
	public: void setLnName(int32_t v);
	public: int32_t getLnData() { return lnData; }
	public: void setLnData(int32_t v);
	public: int32_t getLnUdata() { return lnUdata; }
	public: void setLnUdata(int32_t v);
	public: int32_t getLnSdata() { return lnSdata; }
	public: void setLnSdata(int32_t v);
	public: int32_t getLnOdouble() { return lnOdouble; }
	public: void setLnOdouble(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// ObjKeyC
// typeId=711473895

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// <p>Constants for the ObjKey class.
/// </summary>
/// <remarks>
/// </p>
/// 
/// <p>Copyright: Copyright (c) 2004</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </remarks>
class ObjKeyC : public ObjKeyDataC {
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: ObjKeyC();
	
	public: virtual BTYPEID BSerializable_getTypeId();
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// ObjKeyData
// typeId=1508164560

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// <p>Internal use.
/// </summary>
/// <remarks>
/// </p>
/// </remarks>
class ObjKeyData : public ValueClass {
	/// <summary>
	/// DB column: parentid
	/// </summary>
	protected: int32_t objId;
	/// <summary>
	/// DB column: okeyno
	/// </summary>
	protected: int32_t id;
	/// <summary>
	/// DB column: okeyname
	/// </summary>
	protected: ::std::wstring name;
	/// <summary>
	/// DB column: okeydata
	/// </summary>
	protected: ::std::wstring data;
	/// <summary>
	/// DB column: okeyudata
	/// </summary>
	protected: ::std::wstring udata;
	/// <summary>
	/// DB column: okeysdata
	/// </summary>
	protected: ::std::wstring sdata;
	/// <summary>
	/// DB column: odouble
	/// </summary>
	protected: double odouble;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: ObjKeyData();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: ObjKeyData(int32_t objId, int32_t id, const ::std::wstring& name, const ::std::wstring& data, const ::std::wstring& udata, const ::std::wstring& sdata, double odouble);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getObjId() { return objId; }
	public: void setObjId(int32_t v);
	public: int32_t getId() { return id; }
	public: void setId(int32_t v);
	public: ::std::wstring getName() { return name; }
	public: void setName(::std::wstring v);
	public: ::std::wstring getData() { return data; }
	public: void setData(::std::wstring v);
	public: ::std::wstring getUdata() { return udata; }
	public: void setUdata(::std::wstring v);
	public: ::std::wstring getSdata() { return sdata; }
	public: void setSdata(::std::wstring v);
	public: double getOdouble() { return odouble; }
	public: void setOdouble(double v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// ObjLinkC
// typeId=1015668161

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// <p>Bit constants for members of SordLink</p>
/// <p>Copyright: Copyright (c) 2003</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </summary>
class ObjLinkC : public BSerializable {
	/// <summary>
	/// DB column: objguidparent
	/// </summary>
	public: const static int64_t mbParentId = 1LL;
	/// <summary>
	/// DB column: objguidparent
	/// </summary>
	protected: int32_t lnParentId;
	/// <summary>
	/// DB column: objguidtarget
	/// </summary>
	public: const static int64_t mbId = 2LL;
	/// <summary>
	/// DB column: objguidtarget
	/// </summary>
	protected: int32_t lnId;
	/// <summary>
	/// DB column: linkguid
	/// </summary>
	public: const static int64_t mbLinkId = 4LL;
	/// <summary>
	/// DB column: linkguid
	/// </summary>
	protected: int32_t lnLinkId;
	/// <summary>
	/// DB column: linktstamp
	/// </summary>
	public: const static int64_t mbTStamp = 8LL;
	/// <summary>
	/// DB column: linktstamp
	/// </summary>
	protected: int32_t lnTStamp;
	/// <summary>
	/// DB column: linkflags
	/// </summary>
	public: const static int64_t mbFlags = 16LL;
	/// <summary>
	/// All valid member bits.
	/// </summary>
	public: const static int64_t mbAllMembers = 31LL;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: ObjLinkC();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: ObjLinkC(int64_t mbParentId, int32_t lnParentId, int64_t mbId, int32_t lnId, int64_t mbLinkId, int32_t lnLinkId, int64_t mbTStamp, int32_t lnTStamp, int64_t mbFlags, int64_t mbAllMembers);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getLnParentId() { return lnParentId; }
	public: void setLnParentId(int32_t v);
	public: int32_t getLnId() { return lnId; }
	public: void setLnId(int32_t v);
	public: int32_t getLnLinkId() { return lnLinkId; }
	public: void setLnLinkId(int32_t v);
	public: int32_t getLnTStamp() { return lnTStamp; }
	public: void setLnTStamp(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// OcrInfo
// typeId=1803060225

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// This class defines the properties of an OCR request.
/// </summary>
class OcrInfo : public ValueClass {
	/// <summary>
	/// Return OCR result over this event bus.
	/// </summary>
	/// <remarks>
	/// If the OCR request should be performed asynchronously,
	/// this value must contain the event bus ID on which the result event is sent.
	/// If this value is 0, the OCR request is performed synchronously.
	/// </remarks>
	protected: int64_t busId;
	/// <summary>
	/// OCR result should be sent in an event with this event ID.
	/// </summary>
	/// <remarks>
	/// This member helps to map the OCR request to the OCR result.
	/// Optional.
	/// </remarks>
	protected: int64_t eventId;
	/// <summary>
	/// Language of error messages produced by the OCR engine.
	/// </summary>
	/// <remarks>
	/// One of the OcrInfoC.MESSAGES_LANGUAGE_ constants.
	/// Optional.
	/// </remarks>
	protected: int32_t messagesLanguage;
	/// <summary>
	/// Recognize file information.
	/// </summary>
	/// <remarks>
	/// Set this member in order to process OCR on a file or an archive document.
	/// Optional.
	/// </remarks>
	protected: POcrInfoRecognizeFile recognizeFile;
	/// <summary>
	/// This member is set in order to query the languages supported by the OCR engine.
	/// </summary>
	/// <remarks>
	/// Optional.
	/// </remarks>
	protected: POcrInfoQueryLanguages queryLanguages;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: OcrInfo();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: OcrInfo(int64_t busId, int64_t eventId, int32_t messagesLanguage, const POcrInfoRecognizeFile& recognizeFile, const POcrInfoQueryLanguages& queryLanguages);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int64_t getBusId() { return busId; }
	public: void setBusId(int64_t v);
	public: int64_t getEventId() { return eventId; }
	public: void setEventId(int64_t v);
	public: int32_t getMessagesLanguage() { return messagesLanguage; }
	public: void setMessagesLanguage(int32_t v);
	public: POcrInfoRecognizeFile getRecognizeFile() { return recognizeFile; }
	public: void setRecognizeFile(POcrInfoRecognizeFile v);
	public: POcrInfoQueryLanguages getQueryLanguages() { return queryLanguages; }
	public: void setQueryLanguages(POcrInfoQueryLanguages v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// OcrInfoC
// typeId=1068350778

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Constants for OCR processing.
/// </summary>
class OcrInfoC : public BSerializable {
	/// <summary>
	/// PDF output.
	/// </summary>
	/// <remarks>
	/// OCR will convert the output in a PDF format.
	/// </remarks>
	public: const static int32_t PDF = 4;
	/// <summary>
	/// Text output.
	/// </summary>
	/// <remarks>
	/// The OCR result is a UTF-16LE character stream.
	/// </remarks>
	public: const static int32_t TEXT = 6;
	/// <summary>
	/// XML output.
	/// </summary>
	/// <remarks>
	/// The OCR result is a xml style layout.
	/// </remarks>
	public: const static int32_t XML = 7;
	/// <summary>
	/// Compute character positions.
	/// </summary>
	/// <remarks>
	/// The OCR result is a binary stream of subsequent records of this layout:
	/// <br/>
	/// <table>
	/// <tr><td>UTF-16 Character</td><td>2 Bytes</td></tr>
	/// <tr><td>Horizontal position of upper left corner</td><td>4 Bytes (Integer)</td></tr>
	/// <tr><td>Vertical position of upper left corner</td><td>4 Bytes (Integer)</td></tr>
	/// <tr><td>Horizontal position of bottom right corner</td><td>4 Bytes (Integer)</td></tr>
	/// <tr><td>Vertical position of bottom right corner</td><td>4 Bytes (Integer)</td></tr>
	/// <tr><td>Confidence in percent</td><td>4 Bytes (Integer)</td></tr>
	/// <tr><td>Original UTF-16 Character</td><td>2 Bytes</td></tr>
	/// </table>
	/// <p>
	/// The character and integer byte order is Little Endian.
	/// </p><p>
	/// If the recognition confidence is lower than {@link OcrInfoRecognizeFile#minCharConfidence},
	/// the UTF-16 character is equal to {@link OcrInfoRecognizeFile#replaceChar}.
	/// </p><p>
	/// The rectangle coordinates are measured in points. The vertical axis points to the bottom in positive direction.
	/// </remarks>
	public: const static int32_t CHAR_AND_RECT = 9;
	/// <summary>
	/// Compute character positions.
	/// </summary>
	/// <remarks>
	/// The OCR result is a binary stream as defined in {@link #CHAR_AND_RECT}
	/// prefixed by a header of this layout:
	/// <table>
	/// <tr><td>Magic</td><td>4 Bytes (Integer)</td></tr>
	/// <tr><td>Version</td><td>4 Bytes (Integer)</td></tr>
	/// <tr><td>Skew Angle</td><td>8 Bytes (Double)</td></tr>
	/// <tr><td>Width</td><td>4 Bytes (Integer)</td></tr>
	/// <tr><td>Height</td><td>4 Bytes (Integer)</td></tr>
	/// </table>
	/// The value of Magic is 0x52434F45.
	/// The value of Version is 1.
	/// The Integer and Double byte order is Little Endian.
	/// The Double value format is IEEE 754.
	/// </remarks>
	public: const static int32_t CHAR_AND_RECT_EX = 12;
	/// <summary>
	/// Compute character positions and return XML format.
	/// </summary>
	public: const static int32_t CHAR_AND_RECT_XML = 10;
	public: const static int32_t MESSAGES_LANGUAGE_ENGLISH = 0;
	public: const static int32_t MESSAGES_LANGUAGE_RUSSIAN = 1;
	public: const static int32_t MESSAGES_LANGUAGE_GERMAN = 2;
	public: const static int32_t MESSAGES_LANGUAGE_FRENCH = 3;
	public: const static int32_t MESSAGES_LANGUAGE_UKRAINIAN = 4;
	public: const static int32_t MESSAGES_LANGUAGE_SPANISH = 5;
	public: const static int32_t MESSAGES_LANGUAGE_ITALIAN = 6;
	public: const static int32_t MESSAGES_LANGUAGE_DUTCHSTANDARD = 7;
	public: const static int32_t MESSAGES_LANGUAGE_PORTUGUESE = 8;
	public: const static int32_t MESSAGES_LANGUAGE_SLOVAK = 9;
	public: const static int32_t MESSAGES_LANGUAGE_POLISH = 10;
	public: const static int32_t MESSAGES_LANGUAGE_CZECH = 11;
	public: const static int32_t MESSAGES_LANGUAGE_HUNGARIAN = 12;
	public: const static int32_t MESSAGES_LANGUAGE_LITHUANIAN = 13;
	public: const static int32_t MESSAGES_LANGUAGE_LATVIAN = 14;
	public: const static int32_t MESSAGES_LANGUAGE_ESTONIAN = 15;
	public: const static int32_t MESSAGES_LANGUAGE_BULGARIAN = 16;
	public: const static int32_t UNIT_POINT = 1;
	public: const static int32_t UNIT_MILLIMETER = 2;
	public: const static int32_t UNIT_INCH = 3;
	public: const static int32_t UNIT_PER_THOUSAND = 4;
	/// <summary>
	/// Used in SingleCoulmnMode.
	/// </summary>
	/// <remarks>
	/// All words are separated by one blank.
	/// </remarks>
	public: const static int32_t SPACES_NORMAL = 1;
	/// <summary>
	/// Used in SingleCoulmnMode.
	/// </summary>
	/// <remarks>
	/// If the words are separated by a larger distance, a second blank is inserted.
	/// </remarks>
	public: const static int32_t SPACES_TWOSPACES = 2;
	/// <summary>
	/// Used in SingleCoulmnMode.
	/// </summary>
	/// <remarks>
	/// The OCR tries to insert the correct number of blanks.
	/// </remarks>
	public: const static int32_t SPACES_EXACT = 3;
	/// <summary>
	/// OCR will process all pages of the given document.
	/// </summary>
	public: const static int32_t ALL_PAGES = -1;
	/// <summary>
	/// Internal Use only.
	/// </summary>
	/// <remarks>
	/// OCR will process all even pages of the given document.
	/// </remarks>
	public: const static int32_t EVEN_PAGES = -2;
	/// <summary>
	/// Internal Use only.
	/// </summary>
	/// <remarks>
	/// OCR will process all odd pages of the given document.
	/// </remarks>
	public: const static int32_t ODD_PAGES = -3;
	public: const static int32_t ENCODING_UTF8 = 1;
	public: const static int32_t ENCODING_UTF16 = 2;
	public: const static int32_t ENCODING_UTF16LE = 3;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: OcrInfoC();
	
	public: virtual BTYPEID BSerializable_getTypeId();
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// OcrInfoQueryLanguages
// typeId=648095775

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// This class describes a request for querying the supported languages of the OCR.
/// </summary>
class OcrInfoQueryLanguages : public ValueClass {
	/// <summary>
	/// Reserved.
	/// </summary>
	protected: int32_t ctrl;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: OcrInfoQueryLanguages();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: OcrInfoQueryLanguages(int32_t ctrl);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getCtrl() { return ctrl; }
	public: void setCtrl(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// OcrInfoRecognizeFile
// typeId=701419851

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// This class describes an OCR analysis request.
/// </summary>
class OcrInfoRecognizeFile : public ValueClass {
	/// <summary>
	/// Image file content.
	/// </summary>
	/// <remarks>
	/// Either imageData or objId must be set.
	/// </remarks>
	protected: PFileData imageData;
	/// <summary>
	/// Object ID of an archived document to be analyzed.
	/// </summary>
	/// <remarks>
	/// Either imageData or objId must be set.
	/// </remarks>
	protected: ::std::wstring objId;
	/// <summary>
	/// Page number.
	/// </summary>
	/// <remarks>
	/// The first page number is 0.
	/// If all pages should be analyzed, set pageNo = -1.
	/// </remarks>
	protected: int32_t pageNo;
	/// <summary>
	/// Array of page numbers which should be analysed by the OCR.
	/// </summary>
	/// <remarks>
	/// The first page number is 0.
	/// The following constants can be used:
	/// {@link OcrInfoC#ALL_PAGES}, {@link OcrInfoC#EVEN_PAGES}, {@link OcrInfoC#ODD_PAGES}
	/// </remarks>
	protected: PArrayInt pageNumbers;
	/// <summary>
	/// The image data is of this language(s).
	/// </summary>
	/// <remarks>
	/// The supported languages can be requested by a call to {@link IXServicePortIF#processOcr(ClientInfo, OcrInfo)}.
	/// The OcrInfo parameter must have member {@link OcrInfo#queryLanguages} set. Use the internal languages
	/// returned in {@link OcrResult#queryLanguages} for this member.
	/// At least one language must be set. The String is case sensitive.
	/// </remarks>
	protected: PArrayString recognizeLangs;
	/// <summary>
	/// Constrain recognition to this rectangles.
	/// </summary>
	/// <remarks>
	/// Optional.
	/// </remarks>
	protected: PArrayOcrRect recognizeRects;
	/// <summary>
	/// Rectangle coordinates are based on this unit.
	/// </summary>
	/// <remarks>
	/// Use on of the constants OcrInfoC.UNIT_*.
	/// Optional.
	/// </remarks>
	protected: int32_t rectUnit;
	/// <summary>
	/// Recognition timeout.
	/// </summary>
	/// <remarks>
	/// Cancel recognition if it least longer than this number of seconds.
	/// Optional.
	/// </remarks>
	protected: int32_t timeoutSeconds;
	/// <summary>
	/// Recognition timeout for a single page.
	/// </summary>
	/// <remarks>
	/// Cancel recognition if it least longer than this number of seconds.
	/// Optional.
	/// </remarks>
	protected: int32_t pageTimeout;
	/// <summary>
	/// Minimum confidence of character recognition in percent.
	/// </summary>
	/// <remarks>
	/// Characters that are recognized with a lower confidence are replaced by {@link #replaceChar}.
	/// Optional.
	/// </remarks>
	protected: int32_t minCharConfidence;
	/// <summary>
	/// Replacement for characters.
	/// </summary>
	/// <remarks>
	/// Characters that are recognized with a lower confidence than {@link #minCharConfidence} are replaced this character.
	/// Optional.
	/// </remarks>
	protected: int32_t replaceChar;
	/// <summary>
	/// Recognition accuracy.
	/// </summary>
	/// <remarks>
	/// A value of 0 activates the fast mode, a value of 1 activates the exact mode.
	/// </remarks>
	protected: int32_t accuracy;
	/// <summary>
	/// Disable table recognition.
	/// </summary>
	/// <remarks>
	/// Set this member to true, if the OCR should not try to recognized columns and rows of tables.
	/// Optional.
	/// </remarks>
	protected: bool singleColumnMode;
	/// <summary>
	/// OcrInfoC.NORMAL/TWOSPACES/EXACT
	/// </summary>
	protected: int32_t spaces;
	/// <summary>
	/// OcrInfoC.ENCODING_UTF8 / _UTF16 / _UTF16LE
	/// </summary>
	protected: int32_t encoding;
	/// <summary>
	/// Output format.
	/// </summary>
	/// <remarks>
	/// Must be one of the following:
	/// {@link OcrInfoC#TEXT}, {@link OcrInfoC#CHAR_AND_RECT}, {@link OcrInfoC#CHAR_AND_RECT_EX}
	/// {@link OcrInfoC#PDF}, {@link OcrInfoC#XML}
	/// </remarks>
	protected: int32_t outputFormat;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: OcrInfoRecognizeFile();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: OcrInfoRecognizeFile(const PFileData& imageData, const ::std::wstring& objId, int32_t pageNo, const PArrayInt& pageNumbers, const PArrayString& recognizeLangs, const PArrayOcrRect& recognizeRects, int32_t rectUnit, int32_t timeoutSeconds, int32_t pageTimeout, int32_t minCharConfidence, int32_t replaceChar, int32_t accuracy, bool singleColumnMode, int32_t spaces, int32_t encoding, int32_t outputFormat);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: PFileData getImageData() { return imageData; }
	public: void setImageData(PFileData v);
	public: ::std::wstring getObjId() { return objId; }
	public: void setObjId(::std::wstring v);
	public: int32_t getPageNo() { return pageNo; }
	public: void setPageNo(int32_t v);
	public: PArrayInt getPageNumbers() { return pageNumbers; }
	public: void setPageNumbers(PArrayInt v);
	public: PArrayString getRecognizeLangs() { return recognizeLangs; }
	public: void setRecognizeLangs(PArrayString v);
	public: PArrayOcrRect getRecognizeRects() { return recognizeRects; }
	public: void setRecognizeRects(PArrayOcrRect v);
	public: int32_t getRectUnit() { return rectUnit; }
	public: void setRectUnit(int32_t v);
	public: int32_t getTimeoutSeconds() { return timeoutSeconds; }
	public: void setTimeoutSeconds(int32_t v);
	public: int32_t getPageTimeout() { return pageTimeout; }
	public: void setPageTimeout(int32_t v);
	public: int32_t getMinCharConfidence() { return minCharConfidence; }
	public: void setMinCharConfidence(int32_t v);
	public: int32_t getReplaceChar() { return replaceChar; }
	public: void setReplaceChar(int32_t v);
	public: int32_t getAccuracy() { return accuracy; }
	public: void setAccuracy(int32_t v);
	public: bool getSingleColumnMode() { return singleColumnMode; }
	public: void setSingleColumnMode(bool v);
	public: int32_t getSpaces() { return spaces; }
	public: void setSpaces(int32_t v);
	public: int32_t getEncoding() { return encoding; }
	public: void setEncoding(int32_t v);
	public: int32_t getOutputFormat() { return outputFormat; }
	public: void setOutputFormat(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// OcrRect
// typeId=1044855049

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// This class contains the coordinates of a rectangle and is used by the {@link OcrInfoRecognizeFile} class.
/// </summary>
class OcrRect : public ValueClass {
	protected: int32_t left;
	protected: int32_t top;
	protected: int32_t right;
	protected: int32_t bottom;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: OcrRect();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: OcrRect(int32_t left, int32_t top, int32_t right, int32_t bottom);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getLeft() { return left; }
	public: void setLeft(int32_t v);
	public: int32_t getTop() { return top; }
	public: void setTop(int32_t v);
	public: int32_t getRight() { return right; }
	public: void setRight(int32_t v);
	public: int32_t getBottom() { return bottom; }
	public: void setBottom(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// OcrResult
// typeId=998509414

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// This class contains the informations about an OCR result.
/// </summary>
class OcrResult : public ValueClass {
	/// <summary>
	/// Event ID.
	/// </summary>
	/// <remarks>
	/// The same value as submitted in {@link OcrInfo#eventId}.
	/// </remarks>
	protected: int64_t eventId;
	/// <summary>
	/// Error message.
	/// </summary>
	/// <remarks>
	/// Null or empty, if no error has occurred.
	/// This value is used only in asynchronous processing in order to inform the client application,
	/// that an error has occured. In synchronous processing, the error is thrown as an exception.
	/// </remarks>
	protected: ::std::wstring exception;
	/// <summary>
	/// Error id.
	/// 0, if no error has occurred
	/// </summary>
	protected: int32_t exceptionID;
	/// <summary>
	/// Recognize file result.
	/// </summary>
	/// <remarks>
	/// This member is returned, if {@link OcrInfo#recognizeFile} was set.
	/// </remarks>
	protected: POcrResultRecognizeFile recognizeFile;
	/// <summary>
	/// Supported languages.
	/// </summary>
	/// <remarks>
	/// This member is returned, if {@link OcrInfo#queryLanguages} was set.
	/// </remarks>
	protected: POcrResultQueryLanguages queryLanguages;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: OcrResult();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: OcrResult(int64_t eventId, const ::std::wstring& exception, int32_t exceptionID, const POcrResultRecognizeFile& recognizeFile, const POcrResultQueryLanguages& queryLanguages);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int64_t getEventId() { return eventId; }
	public: void setEventId(int64_t v);
	public: ::std::wstring getException() { return exception; }
	public: void setException(::std::wstring v);
	public: int32_t getExceptionID() { return exceptionID; }
	public: void setExceptionID(int32_t v);
	public: POcrResultRecognizeFile getRecognizeFile() { return recognizeFile; }
	public: void setRecognizeFile(POcrResultRecognizeFile v);
	public: POcrResultQueryLanguages getQueryLanguages() { return queryLanguages; }
	public: void setQueryLanguages(POcrResultQueryLanguages v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// OcrResultQueryLanguages
// typeId=916614291

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// This class contains the result of a OcrInfoQueryLanguages request.
/// </summary>
class OcrResultQueryLanguages : public ValueClass {
	protected: PArrayString externalLangs;
	protected: PArrayString internalLangs;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: OcrResultQueryLanguages();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: OcrResultQueryLanguages(const PArrayString& externalLangs, const PArrayString& internalLangs);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: PArrayString getExternalLangs() { return externalLangs; }
	public: void setExternalLangs(PArrayString v);
	public: PArrayString getInternalLangs() { return internalLangs; }
	public: void setInternalLangs(PArrayString v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// OcrResultRecognizeFile
// typeId=1533562699

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// This class contains the result of an OCR analysis.
/// </summary>
class OcrResultRecognizeFile : public ValueClass {
	/// <summary>
	/// Binary data.
	/// </summary>
	/// <remarks>
	/// This member is set, if {@link OcrInfoRecognizeFile#outputFormat} was set to {@link OcrInfoC#CHAR_AND_RECT}.
	/// </remarks>
	protected: PFileData textData;
	/// <summary>
	/// Recognized text.
	/// </summary>
	/// <remarks>
	/// This member is set, if {@link OcrInfoRecognizeFile#outputFormat} was set to {@link OcrInfoC#TEXT}.
	/// </remarks>
	protected: ::std::wstring text;
	/// <summary>
	/// Skew angle.
	/// </summary>
	/// <remarks>
	/// Only valid if a single page was analyzed, see {@link OcrInfoRecognizeFile#pageNo}.
	/// </remarks>
	protected: double skewAngle;
	/// <summary>
	/// Page width.
	/// </summary>
	/// <remarks>
	/// Only valid if a single page was analyzed, see {@link OcrInfoRecognizeFile#pageNo}.
	/// </remarks>
	protected: int32_t width;
	/// <summary>
	/// Page height.
	/// </summary>
	/// <remarks>
	/// Only valid if a single page was analyzed, see {@link OcrInfoRecognizeFile#pageNo}.
	/// </remarks>
	protected: int32_t height;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: OcrResultRecognizeFile();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: OcrResultRecognizeFile(const PFileData& textData, const ::std::wstring& text, double skewAngle, int32_t width, int32_t height);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: PFileData getTextData() { return textData; }
	public: void setTextData(PFileData v);
	public: ::std::wstring getText() { return text; }
	public: void setText(::std::wstring v);
	public: double getSkewAngle() { return skewAngle; }
	public: void setSkewAngle(double v);
	public: int32_t getWidth() { return width; }
	public: void setWidth(int32_t v);
	public: int32_t getHeight() { return height; }
	public: void setHeight(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// OcrWorker
// typeId=730157667

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// This class is used to describe an OCR worker process.
/// </summary>
class OcrWorker : public ValueClass {
	/// <summary>
	/// The worker process listens on this bus ID for events of type {@link EventBusC#EVENT_OCR_REQUEST}.
	/// </summary>
	protected: int64_t busId;
	/// <summary>
	/// The worker process is identified by this subscriber ID on the event bus.
	/// </summary>
	protected: int64_t subsId;
	/// <summary>
	/// Worker state.
	/// </summary>
	protected: int32_t state;
	/// <summary>
	/// Reserved.
	/// </summary>
	protected: int64_t lastUsed;
	/// <summary>
	/// Reserved.
	/// </summary>
	protected: int64_t reserved;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: OcrWorker();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: OcrWorker(int64_t busId, int64_t subsId, int32_t state, int64_t lastUsed, int64_t reserved);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int64_t getBusId() { return busId; }
	public: void setBusId(int64_t v);
	public: int64_t getSubsId() { return subsId; }
	public: void setSubsId(int64_t v);
	public: int32_t getState() { return state; }
	public: void setState(int32_t v);
	public: int64_t getLastUsed() { return lastUsed; }
	public: void setLastUsed(int64_t v);
	public: int64_t getReserved() { return reserved; }
	public: void setReserved(int64_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// OcrWorkerC
// typeId=45899817

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

class OcrWorkerC : public BSerializable {
	public: const static int32_t REGISTERED = 1;
	public: const static int32_t UNREGISTERED = 2;
	public: const static int32_t BUSY = 3;
	public: const static int32_t IDLE = 4;
	public: const static int32_t DEAD = 5;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: OcrWorkerC();
	
	public: virtual BTYPEID BSerializable_getTypeId();
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// OrgUnitInfo
// typeId=413918850

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// <p>Data class containing organizational unit information data.
/// </summary>
/// <remarks>
/// Information includes ID, name, etc.</p>
/// <p>Copyright: Copyright (c) 2013</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </remarks>
class OrgUnitInfo : public ValueClass {
	/// <summary>
	/// OU identifier
	/// </summary>
	protected: int32_t id;
	/// <summary>
	/// OU name
	/// </summary>
	protected: ::std::wstring name;
	/// <summary>
	/// OU description.
	/// </summary>
	protected: ::std::wstring desc;
	/// <summary>
	/// Additional OU properties
	/// Index this array with constants named PROP_* in class OrgUnitInfoC.
	/// </summary>
	protected: PArrayString ouProps;
	/// <summary>
	/// Timestamp
	/// The format is JJJJ.MM.DD.hh.mm.ss
	/// </summary>
	protected: ::std::wstring tStamp;
	/// <summary>
	/// GUID
	/// </summary>
	protected: ::std::wstring guid;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: OrgUnitInfo();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: OrgUnitInfo(int32_t id, const ::std::wstring& name, const ::std::wstring& desc, const PArrayString& ouProps, const ::std::wstring& tStamp, const ::std::wstring& guid);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getId() { return id; }
	public: void setId(int32_t v);
	public: ::std::wstring getName() { return name; }
	public: void setName(::std::wstring v);
	public: ::std::wstring getDesc() { return desc; }
	public: void setDesc(::std::wstring v);
	public: PArrayString getOuProps() { return ouProps; }
	public: void setOuProps(PArrayString v);
	public: ::std::wstring getTStamp() { return tStamp; }
	public: void setTStamp(::std::wstring v);
	public: ::std::wstring getGuid() { return guid; }
	public: void setGuid(::std::wstring v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// OrgUnitInfoC
// typeId=864257789

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// <p>Constants related to organizational unit information.
/// </summary>
/// <remarks>
/// </p>
/// <p>Copyright: Copyright (c) 2013</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </remarks>
class OrgUnitInfoC : public BSerializable {
	/// <summary>
	/// Maximum number of OU properties.
	/// </summary>
	public: const static int32_t MAX_OU_PROP = 4;
	/// <summary>
	/// Maximum number of OUs.
	/// </summary>
	public: const static int32_t MAX_ORG_UNITS = 10000;
	/// <summary>
	/// Maximum OU name length
	/// </summary>
	protected: int32_t lnName;
	/// <summary>
	/// Maximum OU desc length
	/// </summary>
	protected: int32_t lnDesc;
	/// <summary>
	/// Maximum OU property length
	/// </summary>
	protected: int32_t lnOuProp;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: OrgUnitInfoC();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: OrgUnitInfoC(int32_t MAX_OU_PROP, int32_t MAX_ORG_UNITS, int32_t lnName, int32_t lnDesc, int32_t lnOuProp);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getLnName() { return lnName; }
	public: void setLnName(int32_t v);
	public: int32_t getLnDesc() { return lnDesc; }
	public: void setLnDesc(int32_t v);
	public: int32_t getLnOuProp() { return lnOuProp; }
	public: void setLnOuProp(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// OrgUnitName
// typeId=427676481

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// <p>Data class containing some organizational unit information data:
/// name and ID</p>
/// <p>Copyright: Copyright (c) 2013</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </summary>
class OrgUnitName : public ValueClass {
	/// <summary>
	/// OU identifier
	/// </summary>
	protected: int32_t id;
	/// <summary>
	/// OU name
	/// </summary>
	protected: ::std::wstring name;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: OrgUnitName();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: OrgUnitName(int32_t id, const ::std::wstring& name);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getId() { return id; }
	public: void setId(int32_t v);
	public: ::std::wstring getName() { return name; }
	public: void setName(::std::wstring v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// PhysDel
// typeId=124345500

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// This class represents one row in the database table physdel.
/// </summary>
/// <remarks>
/// This table contains the guids of physically deleted objects.
/// Those objects can be any objects with a guid: e.g.
/// folders, documents, versions, users, workflows...
/// </remarks>
class PhysDel : public ValueClass {
	/// <summary>
	/// GUID of deleted object.
	/// </summary>
	protected: ::std::wstring guid;
	/// <summary>
	/// Type of deleted object.
	/// </summary>
	protected: int32_t type;
	/// <summary>
	/// The object is deleted at this timestamp.
	/// </summary>
	/// <remarks>
	/// Measured in the UTC time-zone.
	/// </remarks>
	protected: ::std::wstring TStamp;
	/// <summary>
	/// Timestamp of this object's last export by the replication.
	/// </summary>
	protected: ::std::wstring TStampSync;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: PhysDel();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: PhysDel(const ::std::wstring& guid, int32_t type, const ::std::wstring& TStamp, const ::std::wstring& TStampSync);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: ::std::wstring getGuid() { return guid; }
	public: void setGuid(::std::wstring v);
	public: int32_t getType() { return type; }
	public: void setType(int32_t v);
	public: ::std::wstring getTStamp() { return TStamp; }
	public: void setTStamp(::std::wstring v);
	public: ::std::wstring getTStampSync() { return TStampSync; }
	public: void setTStampSync(::std::wstring v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// PhysDelDataC
// typeId=448931954

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// <p>Bit constants for members of PhysDel</p>
/// <p>Copyright: Copyright (c) 2003</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </summary>
class PhysDelDataC : public BSerializable {
	/// <summary>
	/// DB column: pdguid
	/// </summary>
	public: const static int64_t mbGuid = 1LL;
	/// <summary>
	/// DB column: pdguid
	/// </summary>
	protected: int32_t lnGuid;
	/// <summary>
	/// DB column: pdtype
	/// </summary>
	public: const static int64_t mbType = 2LL;
	/// <summary>
	/// DB column: pdtstamp
	/// </summary>
	public: const static int64_t mbTStamp = 4LL;
	/// <summary>
	/// DB column: pdtstamp
	/// </summary>
	protected: int32_t lnTStamp;
	/// <summary>
	/// Member bit: Timestamp of this object's last export by the replication.
	/// </summary>
	/// <remarks>
	/// DB column: tstampsync
	/// </remarks>
	public: const static int64_t mbTStampSync = 8LL;
	/// <summary>
	/// Column length: Timestamp of this object's last export by the replication.
	/// </summary>
	/// <remarks>
	/// DB column: tstampsync
	/// </remarks>
	protected: int32_t lnTStampSync;
	/// <summary>
	/// All valid member bits.
	/// </summary>
	public: const static int64_t mbAllMembers = 15LL;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: PhysDelDataC();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: PhysDelDataC(int64_t mbGuid, int32_t lnGuid, int64_t mbType, int64_t mbTStamp, int32_t lnTStamp, int64_t mbTStampSync, int32_t lnTStampSync, int64_t mbAllMembers);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getLnGuid() { return lnGuid; }
	public: void setLnGuid(int32_t v);
	public: int32_t getLnTStamp() { return lnTStamp; }
	public: void setLnTStamp(int32_t v);
	public: int32_t getLnTStampSync() { return lnTStampSync; }
	public: void setLnTStampSync(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// PhysDelC
// typeId=278631137

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Constants for the PhysDel.type member.
/// </summary>
class PhysDelC : public PhysDelDataC {
	/// <summary>
	/// Unknown object type deleted.
	/// </summary>
	public: const static int32_t ERROR = 0;
	/// <summary>
	/// User deleted.
	/// </summary>
	public: const static int32_t USER = 1;
	/// <summary>
	/// Keywording form deleted.
	/// </summary>
	public: const static int32_t MASK = 2;
	/// <summary>
	/// Color deleted.
	/// </summary>
	public: const static int32_t COLOR = 3;
	/// <summary>
	/// Keyword list deleted.
	/// </summary>
	public: const static int32_t KEYWORDLIST = 4;
	/// <summary>
	/// Folder or document deleted.
	/// </summary>
	public: const static int32_t SORD = 20;
	/// <summary>
	/// Relation deleted.
	/// </summary>
	public: const static int32_t RELATION = 21;
	/// <summary>
	/// Document version or attachment deleted.
	/// </summary>
	public: const static int32_t VERSION = 22;
	/// <summary>
	/// Note or annotation deleted.
	/// </summary>
	public: const static int32_t NOTE = 23;
	/// <summary>
	/// Activity deleted.
	/// </summary>
	public: const static int32_t ACTIVITY = 24;
	/// <summary>
	/// Workflow deleted.
	/// </summary>
	public: const static int32_t WORKFLOW = 25;
	/// <summary>
	/// Map deleted.
	/// </summary>
	public: const static int32_t MAP = 26;
	/// <summary>
	/// Link deleted.
	/// </summary>
	public: const static int32_t LINK = 27;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: PhysDelC();
	
	public: virtual BTYPEID BSerializable_getTypeId();
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// PhysDelDocs
// typeId=855528761

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Internal class.
/// </summary>
class PhysDelDocs : public ValueClass {
	/// <summary>
	/// DB column: objid
	/// </summary>
	protected: int32_t objId;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: PhysDelDocs();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: PhysDelDocs(int32_t objId);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getObjId() { return objId; }
	public: void setObjId(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// PhysDelDocsC
// typeId=434896477

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// <p>Bit constants for members of PhysDelDocs</p>
/// <p>Copyright: Copyright (c) 2003</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </summary>
class PhysDelDocsC : public BSerializable {
	/// <summary>
	/// DB column: objid
	/// </summary>
	public: const static int64_t mbObjId = 1LL;
	/// <summary>
	/// All valid member bits.
	/// </summary>
	public: const static int64_t mbAllMembers = 1LL;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: PhysDelDocsC();
	
	public: virtual BTYPEID BSerializable_getTypeId();
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// PointInfo
// typeId=1225068828

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// This class describes a 2D point.
/// </summary>
class PointInfo : public BSerializable {
	/// <summary>
	/// X coordinate
	/// </summary>
	protected: int32_t x;
	/// <summary>
	/// Y coordinate
	/// </summary>
	protected: int32_t y;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: PointInfo();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: PointInfo(int32_t x, int32_t y);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getX() { return x; }
	public: void setX(int32_t v);
	public: int32_t getY() { return y; }
	public: void setY(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// PreviewImageInfo
// typeId=1006046685

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

class PreviewImageInfo : public ValueClass {
	/// <summary>
	/// <p>
	/// ID of the objects to query preview images for.
	/// </summary>
	/// <remarks>
	/// The ID must point to a
	/// document. Otherwise, an exception is thrown.
	/// </p>
	/// </remarks>
	protected: ::std::wstring objectId;
	/// <summary>
	/// <p>
	/// Id of the document(-version) to query preview images for.
	/// </summary>
	/// <remarks>
	/// If set,
	/// <code>objectId</code> is ignored.
	/// </p>
	/// </remarks>
	protected: ::std::wstring documentId;
	/// <summary>
	/// <p>
	/// First page number of the document to process a preview image for.
	/// </summary>
	/// <remarks>
	/// The
	/// number of the first page of a document is 1. If this value is &le; 0, 1 is
	/// assumed.
	/// </p>
	/// </remarks>
	protected: int32_t startPage;
	/// <summary>
	/// <p>
	/// Last page number of the document to process a preview image for.
	/// </summary>
	/// <remarks>
	/// If this
	/// value is &le; 0, all pages of the document &ge; startPage are process. If 0
	/// &lt; endPage &le; startPage holds, only the startPage will be processed.
	/// </p>
	/// </remarks>
	protected: int32_t endPage;
	/// <summary>
	/// Desired size of the preview images.
	/// </summary>
	/// <remarks>
	/// Valid values are defined in
	/// {@link PreviewImageInfoC}.
	/// </remarks>
	protected: int32_t previewSize;
	/// <summary>
	/// <p>
	/// If processDocument is true, not only the URLs for each page are generated
	/// but also preview images are processed for the pages (startPage+1) to
	/// endPage in the background.
	/// </summary>
	/// <remarks>
	/// </p>
	/// </remarks>
	protected: bool processDocument;
	/// <summary>
	/// <p>
	/// Enables rendering of annotations.
	/// </summary>
	/// <remarks>
	/// If <code>renderAnnotations</code> is
	/// <b>true</b>, the preview images will also contain the annotations. If the
	/// preview images should contain the annotations but not the preview of the
	/// document page itself, also set <code>renderOnlyAnnotations</code> to
	/// <b>true</b>.
	/// </p>
	/// </remarks>
	protected: bool renderAnnotations;
	/// <summary>
	/// <p>
	/// Does only has an effect, if <code>renderAnnotations</code> is <b>true</b>.
	/// </summary>
	/// <remarks>
	/// If set to <b>true</b> the annotations will be rendered but the rendering of
	/// document pages will be omitted.
	/// </p>
	/// </remarks>
	protected: bool renderAnnotationsOnly;
	/// <summary>
	/// <p>
	/// Does only has an effect, if <code>renderAnnotations</code> is <b>true</b>.
	/// </summary>
	/// <remarks>
	/// If set to <b>true</b> there will be details rendered near the annotations.
	/// Details are the annotation's author and create date.
	/// </p>
	/// </remarks>
	protected: bool renderAnnotationsData;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: PreviewImageInfo();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: PreviewImageInfo(const ::std::wstring& objectId, const ::std::wstring& documentId, int32_t startPage, int32_t endPage, int32_t previewSize, bool processDocument, bool renderAnnotations, bool renderAnnotationsOnly, bool renderAnnotationsData);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: ::std::wstring getObjectId() { return objectId; }
	public: void setObjectId(::std::wstring v);
	public: ::std::wstring getDocumentId() { return documentId; }
	public: void setDocumentId(::std::wstring v);
	public: int32_t getStartPage() { return startPage; }
	public: void setStartPage(int32_t v);
	public: int32_t getEndPage() { return endPage; }
	public: void setEndPage(int32_t v);
	public: int32_t getPreviewSize() { return previewSize; }
	public: void setPreviewSize(int32_t v);
	public: bool getProcessDocument() { return processDocument; }
	public: void setProcessDocument(bool v);
	public: bool getRenderAnnotations() { return renderAnnotations; }
	public: void setRenderAnnotations(bool v);
	public: bool getRenderAnnotationsOnly() { return renderAnnotationsOnly; }
	public: void setRenderAnnotationsOnly(bool v);
	public: bool getRenderAnnotationsData() { return renderAnnotationsData; }
	public: void setRenderAnnotationsData(bool v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// PreviewImageInfoC
// typeId=407268655

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

class PreviewImageInfoC : public BSerializable {
	/// <summary>
	/// Default dots per inch for scalable vector graphics.
	/// </summary>
	public: const static int32_t DEFAULT_DPI = 300;
	/// <summary>
	/// Flag that signalizes the server to process preview images in the size of
	/// the original document.
	/// </summary>
	/// <remarks>
	/// In case scalable documents sources like PDF,
	/// {@link PreviewImageInfoC#DEFAULT_DPI} is used.
	/// </remarks>
	public: const static int32_t SIZE_ORIGINAL = 65536;
	/// <summary>
	/// Flag that signalizes the server to process preview images in a size for
	/// thumbnails.
	/// </summary>
	public: const static int32_t SIZE_TINY = 131072;
	/// <summary>
	/// Flag that signalizes the server to process preview images in a medium size.
	/// </summary>
	/// <remarks>
	/// Images of this size are optimized in memory usage. They lack readability of
	/// text smaller than 10 points.
	/// </remarks>
	public: const static int32_t SIZE_MEDIUM = 262144;
	/// <summary>
	/// Flag that signalizes the server to process preview images in a size for
	/// tiny thumbnails.
	/// </summary>
	/// <remarks>
	/// The maximum length of an edge will be 100 pixels.
	/// </remarks>
	public: const static int32_t SIZE_TINIER = 524288;
	/// <summary>
	/// Flag that signalizes the server to scale down preview images to a size
	/// suitable for most browser's canvas element.
	/// </summary>
	/// <remarks>
	/// Choosing this settings will
	/// scale down only very large images.
	/// </remarks>
	public: const static int32_t SIZE_LARGE = 1048576;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: PreviewImageInfoC();
	
	public: virtual BTYPEID BSerializable_getTypeId();
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// PreviewImageResult
// typeId=661820173

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

class PreviewImageResult : public BSerializable {
	/// <summary>
	/// List of URLs pointing to the requested preview images.
	/// </summary>
	/// <remarks>
	/// The URL at the first
	/// index in the list points to the lexicographic ordered first requested page.
	/// </remarks>
	protected: byps::PVectorString urls;
	/// <summary>
	/// Dots per inch of the requested preview images.
	/// </summary>
	/// <remarks>
	/// If the document source is a
	/// multi-page file, this value holds for every requested pages.
	/// </remarks>
	protected: int32_t dpi;
	/// <summary>
	/// Width of first page.
	/// </summary>
	/// <remarks>
	/// Use this value to get an idea about the dimensions of
	/// the preview image in general. While this value is exact for the first page,
	/// following pages may have different dimension (e.g. different orientation,
	/// image as a whole page in a PDF document, ...)
	/// </remarks>
	protected: int32_t dimensionWidth;
	/// <summary>
	/// Height of the first page.
	/// </summary>
	/// <remarks>
	/// Please consider the hints at
	/// {@link PreviewImageResult#dimensionWidth} with respect to multi-page
	/// documents.
	/// </remarks>
	protected: int32_t dimensionHeight;
	/// <summary>
	/// Current progress of processing at the server.
	/// </summary>
	/// <remarks>
	/// Processing is finished at
	/// server side when this value equals {@link PreviewImageResult#progressMax}.
	/// </remarks>
	protected: int32_t progress;
	/// <summary>
	/// Estimated value about the workload at the server.
	/// </summary>
	/// <remarks>
	/// There is a chance that
	/// the server is finished with the processing of the request when progress
	/// reaches this estimated value. In repeated requests progresMax can increase
	/// in comparison to calls in earlier times.
	/// </remarks>
	protected: int32_t progressMax;
	/// <summary>
	/// Status message about the current processing of preview images at the
	/// server.
	/// </summary>
	protected: ::std::wstring statusMessage;
	/// <summary>
	/// Number of pages.
	/// </summary>
	protected: int32_t pages;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: PreviewImageResult();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: PreviewImageResult(const byps::PVectorString& urls, int32_t dpi, int32_t dimensionWidth, int32_t dimensionHeight, int32_t progress, int32_t progressMax, const ::std::wstring& statusMessage, int32_t pages);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: byps::PVectorString getUrls() { return urls; }
	public: void setUrls(byps::PVectorString v);
	public: int32_t getDpi() { return dpi; }
	public: void setDpi(int32_t v);
	public: int32_t getDimensionWidth() { return dimensionWidth; }
	public: void setDimensionWidth(int32_t v);
	public: int32_t getDimensionHeight() { return dimensionHeight; }
	public: void setDimensionHeight(int32_t v);
	public: int32_t getProgress() { return progress; }
	public: void setProgress(int32_t v);
	public: int32_t getProgressMax() { return progressMax; }
	public: void setProgressMax(int32_t v);
	public: ::std::wstring getStatusMessage() { return statusMessage; }
	public: void setStatusMessage(::std::wstring v);
	public: int32_t getPages() { return pages; }
	public: void setPages(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// ProcessAcl
// typeId=402225782

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// This class is used to assign or remove ACLs to an object.
/// </summary>
/// <remarks>
/// <p>Copyright: Copyright (c) 2004</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </remarks>
class ProcessAcl : public ValueClass {
	/// <summary>
	/// ACL to be added.
	/// </summary>
	protected: PArrayAclItem addAclItems;
	/// <summary>
	/// ACL to be intersected with.
	/// </summary>
	protected: PArrayAclItem andAclItems;
	/// <summary>
	/// ACL to be set directly overriding any former settings.
	/// </summary>
	protected: PArrayAclItem setAclItems;
	/// <summary>
	/// ACL to be subtracted.
	/// </summary>
	protected: PArrayAclItem subAclItems;
	/// <summary>
	/// ACL to be added in raw database format.
	/// </summary>
	/// <remarks>
	/// Ignored, if addAclItems is not null.
	/// </remarks>
	protected: ::std::wstring addAcl;
	/// <summary>
	/// ACL to be added in raw database format.
	/// </summary>
	/// <remarks>
	/// Ignored, if subAclItems is not null.
	/// </remarks>
	protected: ::std::wstring subAcl;
	/// <summary>
	/// ACL to be added in raw database format.
	/// </summary>
	/// <remarks>
	/// Ignored, if andAclItems is not null.
	/// </remarks>
	protected: ::std::wstring andAcl;
	/// <summary>
	/// ACL to be added in raw database format.
	/// </summary>
	/// <remarks>
	/// Ignored, if setAclItems is not null.
	/// </remarks>
	protected: ::std::wstring setAcl;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: ProcessAcl();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: ProcessAcl(const PArrayAclItem& addAclItems, const PArrayAclItem& andAclItems, const PArrayAclItem& setAclItems, const PArrayAclItem& subAclItems, const ::std::wstring& addAcl, const ::std::wstring& subAcl, const ::std::wstring& andAcl, const ::std::wstring& setAcl);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: PArrayAclItem getAddAclItems() { return addAclItems; }
	public: void setAddAclItems(PArrayAclItem v);
	public: PArrayAclItem getAndAclItems() { return andAclItems; }
	public: void setAndAclItems(PArrayAclItem v);
	public: PArrayAclItem getSetAclItems() { return setAclItems; }
	public: void setSetAclItems(PArrayAclItem v);
	public: PArrayAclItem getSubAclItems() { return subAclItems; }
	public: void setSubAclItems(PArrayAclItem v);
	public: ::std::wstring getAddAcl() { return addAcl; }
	public: void setAddAcl(::std::wstring v);
	public: ::std::wstring getSubAcl() { return subAcl; }
	public: void setSubAcl(::std::wstring v);
	public: ::std::wstring getAndAcl() { return andAcl; }
	public: void setAndAcl(::std::wstring v);
	public: ::std::wstring getSetAcl() { return setAcl; }
	public: void setSetAcl(::std::wstring v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// ProcessCopyElements
// typeId=147051188

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Copy archive elements in other position in the archive.
/// </summary>
/// <remarks>
/// <p>
/// Copyright: Copyright (c) 2009
/// </p>
/// <p>
/// Organisation: ELO Digital Office GmbH
/// </p>
/// </remarks>
class ProcessCopyElements : public ValueClass {
	/// <summary>
	/// Options for the copy-process
	/// </summary>
	protected: PCopyOptions copyOptions;
	/// <summary>
	/// If createMapping is true, at the copyResult, the maps source-id to copy-id
	/// will be filled.
	/// </summary>
	/// <remarks>
	/// Defaults to false.
	/// </remarks>
	protected: bool createMapping;
	/// <summary>
	/// Result of copy process.
	/// </summary>
	protected: PCopyResult copyResult;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: ProcessCopyElements();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: ProcessCopyElements(const PCopyOptions& copyOptions, bool createMapping, const PCopyResult& copyResult);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: PCopyOptions getCopyOptions() { return copyOptions; }
	public: void setCopyOptions(PCopyOptions v);
	public: bool getCreateMapping() { return createMapping; }
	public: void setCreateMapping(bool v);
	public: PCopyResult getCopyResult() { return copyResult; }
	public: void setCopyResult(PCopyResult v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// ProcessCountElements
// typeId=1130489422

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// This class make possible the count of the archive elements.
/// </summary>
/// <remarks>
/// <p>Copyright: Copyright (c) 2008</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </remarks>
class ProcessCountElements : public ValueClass {
	/// <summary>
	/// Result of the countprocess.
	/// </summary>
	protected: PCountResult countResult;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: ProcessCountElements();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: ProcessCountElements(const PCountResult& countResult);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: PCountResult getCountResult() { return countResult; }
	public: void setCountResult(PCountResult v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// ProcessFulltext
// typeId=1125907212

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Fulltext-Property to be added to/removed from an object.
/// </summary>
/// <remarks>
/// <p>Copyright: Copyright (c) 2008</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </remarks>
class ProcessFulltext : public ValueClass {
	/// <summary>
	/// Add to the fulltext-service
	/// </summary>
	protected: bool addToFulltext;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: ProcessFulltext();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: ProcessFulltext(bool addToFulltext);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: bool getAddToFulltext() { return addToFulltext; }
	public: void setAddToFulltext(bool v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// ProcessInfo
// typeId=1037318967

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Specific processing information for each node of processTrees(...) or processFindResults(...).
/// </summary>
/// <remarks>
/// The operations will be for existence (not null) in order of their appearance in ProcessInfo.
/// Some of the underlying structures may allow toggling between prefix and postfix processing
/// when used with processTrees.
/// 
/// <p>Copyright: Copyright (c) 2004</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </remarks>
class ProcessInfo : public ValueClass {
	/// <summary>
	/// pass 0 for valid (undeleted) nodes, &gt;0 otherwise.
	/// </summary>
	protected: int32_t delStatus;
	/// <summary>
	/// Holds the user defined description of a specific call.
	/// </summary>
	/// <remarks>
	/// This member
	/// must not be null or empty.
	/// </remarks>
	protected: ::std::wstring desc;
	/// <summary>
	/// From ProcessInfoC: ERRORMODE_ALL, ERRORMODE_SKIP_SUBTREE,
	/// ERRORMODE_SKIP_PROCINFO or ERRORMODE_CRITICAL_ONLY.
	/// </summary>
	protected: int32_t errorMode;
	/// <summary>
	/// processing flag for documents.
	/// </summary>
	protected: bool ignoreDocuments;
	/// <summary>
	/// processing flag for structure elements.
	/// </summary>
	protected: bool ignoreStructures;
	/// <summary>
	/// Use this parameter to access potentially locked nodes.
	/// </summary>
	protected: PLockZ lockZ;
	/// <summary>
	/// Prefix processing, valid ProcessAcl data.
	/// </summary>
	protected: PProcessAcl procAcl;
	/// <summary>
	/// Prefix processing, valid ProcessFulltext data.
	/// </summary>
	protected: PProcessFulltext procFulltext;
	/// <summary>
	/// Prefix processing count all elements
	/// </summary>
	protected: PProcessCountElements procCountElem;
	/// <summary>
	/// Move documents to storage path.
	/// </summary>
	protected: PProcessMoveDocumentsToStoragePath procMoveDocumentsToStoragePath;
	/// <summary>
	/// Copy the elements into other archive location.
	/// </summary>
	protected: PProcessCopyElements procCopyElements;
	/// <summary>
	/// Maximum amount of recorded errors in procMsgs; from ProcessInfoC: PROCMSGMAX.
	/// </summary>
	protected: int32_t procMsgMax;
	/// <summary>
	/// Recorded error messages; specify their amount using procMsgMax.
	/// </summary>
	protected: PArrayString procMsgs;
	/// <summary>
	/// Prefix processing, valid ProcessReplSet data.
	/// </summary>
	protected: PProcessReplSet procReplSet;
	/// <summary>
	/// Either prefix or postfix processing.
	/// </summary>
	protected: PProcessScript procScript;
	/// <summary>
	/// Defines, if the data allways have to be written
	/// </summary>
	protected: bool forceOperation;
	/// <summary>
	/// Process references (logical copies) too.
	/// </summary>
	protected: bool inclReferences;
	/// <summary>
	/// Release the locks on processed elements.
	/// </summary>
	protected: PProcessReleaseLock procReleaseLock;
	/// <summary>
	/// Inherit keywording.
	/// </summary>
	protected: PProcessInheritKeywording procInheritKeywording;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: ProcessInfo();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: ProcessInfo(int32_t delStatus, const ::std::wstring& desc, int32_t errorMode, bool ignoreDocuments, bool ignoreStructures, const PLockZ& lockZ, const PProcessAcl& procAcl, const PProcessFulltext& procFulltext, const PProcessCountElements& procCountElem, const PProcessMoveDocumentsToStoragePath& procMoveDocumentsToStoragePath, const PProcessCopyElements& procCopyElements, int32_t procMsgMax, const PArrayString& procMsgs, const PProcessReplSet& procReplSet, const PProcessScript& procScript, bool forceOperation, bool inclReferences, const PProcessReleaseLock& procReleaseLock, const PProcessInheritKeywording& procInheritKeywording);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getDelStatus() { return delStatus; }
	public: void setDelStatus(int32_t v);
	public: ::std::wstring getDesc() { return desc; }
	public: void setDesc(::std::wstring v);
	public: int32_t getErrorMode() { return errorMode; }
	public: void setErrorMode(int32_t v);
	public: bool getIgnoreDocuments() { return ignoreDocuments; }
	public: void setIgnoreDocuments(bool v);
	public: bool getIgnoreStructures() { return ignoreStructures; }
	public: void setIgnoreStructures(bool v);
	public: PLockZ getLockZ() { return lockZ; }
	public: void setLockZ(PLockZ v);
	public: PProcessAcl getProcAcl() { return procAcl; }
	public: void setProcAcl(PProcessAcl v);
	public: PProcessFulltext getProcFulltext() { return procFulltext; }
	public: void setProcFulltext(PProcessFulltext v);
	public: PProcessCountElements getProcCountElem() { return procCountElem; }
	public: void setProcCountElem(PProcessCountElements v);
	public: PProcessMoveDocumentsToStoragePath getProcMoveDocumentsToStoragePath() { return procMoveDocumentsToStoragePath; }
	public: void setProcMoveDocumentsToStoragePath(PProcessMoveDocumentsToStoragePath v);
	public: PProcessCopyElements getProcCopyElements() { return procCopyElements; }
	public: void setProcCopyElements(PProcessCopyElements v);
	public: int32_t getProcMsgMax() { return procMsgMax; }
	public: void setProcMsgMax(int32_t v);
	public: PArrayString getProcMsgs() { return procMsgs; }
	public: void setProcMsgs(PArrayString v);
	public: PProcessReplSet getProcReplSet() { return procReplSet; }
	public: void setProcReplSet(PProcessReplSet v);
	public: PProcessScript getProcScript() { return procScript; }
	public: void setProcScript(PProcessScript v);
	public: bool getForceOperation() { return forceOperation; }
	public: void setForceOperation(bool v);
	public: bool getInclReferences() { return inclReferences; }
	public: void setInclReferences(bool v);
	public: PProcessReleaseLock getProcReleaseLock() { return procReleaseLock; }
	public: void setProcReleaseLock(PProcessReleaseLock v);
	public: PProcessInheritKeywording getProcInheritKeywording() { return procInheritKeywording; }
	public: void setProcInheritKeywording(PProcessInheritKeywording v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// ProcessInfoC
// typeId=659513392

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Constants class for the ProcessInfo class.
/// </summary>
/// <remarks>
/// Errors:
/// The error modes are ordered by increasing failure tolerance. In most cases a tree walk will traverse nodes in prefix mode
/// except scripts, that may have an user defined processing position, so the operational success of a given node directly
/// influences further processing. ERRORMODE_ALL, the zero failure tolerance, stops the job (nearly) immediately, while
/// ERRORMODE_SKIP_SUBTREE just skips subtree traversals, but continues with lists or siblings. If you pass ERRORMODE_SKIP_PROCINFO
/// the sequence of ProcessInfo members will be executed completely, whether errors occur or not. The most tolerant mode is
/// ERRORMODE_SKIP_PROCINFO where only errors impeding further traversing stop the job.
/// 
/// <p>Copyright: Copyright (c) 2004</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </remarks>
class ProcessInfoC : public BSerializable {
	/// <summary>
	/// Do not filter by SORD status.
	/// </summary>
	public: const static int32_t DELSTATUS_ALL = -1;
	/// <summary>
	/// filter ony deleted SORDs.
	/// </summary>
	public: const static int32_t DELSTATUS_DELETED = 1;
	/// <summary>
	/// Filter only undeleted SORDs.
	/// </summary>
	public: const static int32_t DELSTATUS_VALID = 0;
	/// <summary>
	/// Processing will be stopped when an error occurs, regardless of the error type.
	/// </summary>
	public: const static int32_t ERRORMODE_ALL = 0;
	/// <summary>
	/// Stop only on non-recoverable errors.
	/// </summary>
	public: const static int32_t ERRORMODE_CRITICAL_ONLY = 3;
	/// <summary>
	/// Stop the ProcessInfo sequence for the current Node.
	/// </summary>
	public: const static int32_t ERRORMODE_SKIP_PROCINFO = 2;
	/// <summary>
	/// Stop the subtree processing (processTrees only), but continue with list
	/// elements respectively siblings.
	/// </summary>
	public: const static int32_t ERRORMODE_SKIP_SUBTREE = 1;
	/// <summary>
	/// Maximum allowed amount of error messages.
	/// </summary>
	public: const static int32_t PROCMSGMAX = 100;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: ProcessInfoC();
	
	public: virtual BTYPEID BSerializable_getTypeId();
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// ProcessInheritKeywording
// typeId=1130489423

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// This class  of keywording.
/// </summary>
class ProcessInheritKeywording : public ValueClass {
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: ProcessInheritKeywording();
	
	public: virtual BTYPEID BSerializable_getTypeId();
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// ProcessMoveDocumentsToStoragePath
// typeId=3376635

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// This class specifies the options for moving a document into another storage path.
/// </summary>
/// <remarks>
/// It is used as member in <code>ProcessInfo</code> and is interpreted in the functions
/// <code>processFindResult</code> and <code>processTrees</code>.
/// </remarks>
class ProcessMoveDocumentsToStoragePath : public ValueClass {
	/// <summary>
	/// Name or ID of the storage path
	/// </summary>
	protected: ::std::wstring pathId;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: ProcessMoveDocumentsToStoragePath();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: ProcessMoveDocumentsToStoragePath(const ::std::wstring& pathId);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: ::std::wstring getPathId() { return pathId; }
	public: void setPathId(::std::wstring v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// ProcessReleaseLock
// typeId=1270934212

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Releases the locks on archive elements.
/// </summary>
class ProcessReleaseLock : public ValueClass {
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: ProcessReleaseLock();
	
	public: virtual BTYPEID BSerializable_getTypeId();
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// ProcessReplSet
// typeId=712209598

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Replication sets to be added to/removed from an object.
/// </summary>
/// <remarks>
/// The replication set parameter must refer to existing objects that may contain empty lists. Null values are not allowed.
/// 
/// <p>Copyright: Copyright (c) 2004</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </remarks>
class ProcessReplSet : public ValueClass {
	/// <summary>
	/// Replication sets to be added.
	/// </summary>
	protected: PArrayIdName addReplSets;
	/// <summary>
	/// Replication sets to be intersected with.
	/// </summary>
	protected: PArrayIdName andReplSets;
	/// <summary>
	/// Replication sets to be set directly overriding any former settings.
	/// </summary>
	protected: PArrayIdName setReplSets;
	/// <summary>
	/// Replication sets to be subtracted.
	/// </summary>
	protected: PArrayIdName subReplSets;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: ProcessReplSet();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: ProcessReplSet(const PArrayIdName& addReplSets, const PArrayIdName& andReplSets, const PArrayIdName& setReplSets, const PArrayIdName& subReplSets);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: PArrayIdName getAddReplSets() { return addReplSets; }
	public: void setAddReplSets(PArrayIdName v);
	public: PArrayIdName getAndReplSets() { return andReplSets; }
	public: void setAndReplSets(PArrayIdName v);
	public: PArrayIdName getSetReplSets() { return setReplSets; }
	public: void setSetReplSets(PArrayIdName v);
	public: PArrayIdName getSubReplSets() { return subReplSets; }
	public: void setSubReplSets(PArrayIdName v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// ProcessScript
// typeId=1122555546

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// NOT CURRENTLY SUPPORTED
/// 
/// <p>Copyright: Copyright (c) 2004</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </summary>
class ProcessScript : public ValueClass {
	/// <summary>
	/// Script name.
	/// </summary>
	protected: ::std::wstring name;
	/// <summary>
	/// execution position in tree walks.
	/// </summary>
	protected: bool processPostfix;
	/// <summary>
	/// user defined tag.
	/// </summary>
	protected: ::std::wstring tag;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: ProcessScript();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: ProcessScript(const ::std::wstring& name, bool processPostfix, const ::std::wstring& tag);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: ::std::wstring getName() { return name; }
	public: void setName(::std::wstring v);
	public: bool getProcessPostfix() { return processPostfix; }
	public: void setProcessPostfix(bool v);
	public: ::std::wstring getTag() { return tag; }
	public: void setTag(::std::wstring v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// PublicDownload
// typeId=2062827124

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// This class describes the public download information.
/// </summary>
/// <remarks>
/// <p>
/// Internal use.
/// </p>
/// </remarks>
class PublicDownload : public ValueClass {
	/// <summary>
	/// The download ID.
	/// </summary>
	protected: ::std::wstring id;
	/// <summary>
	/// The download count.
	/// </summary>
	protected: int32_t remaining;
	/// <summary>
	/// The expired time.
	/// </summary>
	protected: ::std::wstring expiration;
	/// <summary>
	/// The time stamp.
	/// </summary>
	protected: ::std::wstring timeStamp;
	/// <summary>
	/// The document ID.
	/// </summary>
	protected: int32_t docId;
	/// <summary>
	/// The object ID.
	/// </summary>
	protected: int32_t objId;
	/// <summary>
	/// The user ID.
	/// </summary>
	protected: int32_t userId;
	/// <summary>
	/// The download URL
	/// </summary>
	protected: ::std::wstring url;
	/// <summary>
	/// The fileName in the download url.
	/// </summary>
	/// <remarks>
	/// It is readonly.
	/// </remarks>
	protected: ::std::wstring fileName;
	/// <summary>
	/// Indicates whether the download is inline or as attachment.
	/// </summary>
	protected: ::std::wstring attachmentCode;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: PublicDownload();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: PublicDownload(const ::std::wstring& id, int32_t remaining, const ::std::wstring& expiration, const ::std::wstring& timeStamp, int32_t docId, int32_t objId, int32_t userId, const ::std::wstring& url, const ::std::wstring& fileName, const ::std::wstring& attachmentCode);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: ::std::wstring getId() { return id; }
	public: void setId(::std::wstring v);
	public: int32_t getRemaining() { return remaining; }
	public: void setRemaining(int32_t v);
	public: ::std::wstring getExpiration() { return expiration; }
	public: void setExpiration(::std::wstring v);
	public: ::std::wstring getTimeStamp() { return timeStamp; }
	public: void setTimeStamp(::std::wstring v);
	public: int32_t getDocId() { return docId; }
	public: void setDocId(int32_t v);
	public: int32_t getObjId() { return objId; }
	public: void setObjId(int32_t v);
	public: int32_t getUserId() { return userId; }
	public: void setUserId(int32_t v);
	public: ::std::wstring getUrl() { return url; }
	public: void setUrl(::std::wstring v);
	public: ::std::wstring getFileName() { return fileName; }
	public: void setFileName(::std::wstring v);
	public: ::std::wstring getAttachmentCode() { return attachmentCode; }
	public: void setAttachmentCode(::std::wstring v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// PublicDownloadDataC
// typeId=1639180602

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// <p>Bit constants for members of PublicDownload</p>
/// <p>Copyright: Copyright (c) 2003</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </summary>
class PublicDownloadDataC : public BSerializable {
	/// <summary>
	/// DB column: guid
	/// </summary>
	public: const static int64_t mbId = 1LL;
	/// <summary>
	/// DB column: guid
	/// </summary>
	protected: int32_t lnId;
	/// <summary>
	/// DB column: tstamp
	/// </summary>
	public: const static int64_t mbTimeStamp = 2LL;
	/// <summary>
	/// DB column: tstamp
	/// </summary>
	protected: int32_t lnTimeStamp;
	/// <summary>
	/// DB column: remaining
	/// </summary>
	public: const static int64_t mbRemaining = 4LL;
	/// <summary>
	/// DB column: expiration
	/// </summary>
	public: const static int64_t mbExpiration = 8LL;
	/// <summary>
	/// DB column: expiration
	/// </summary>
	protected: int32_t lnExpiration;
	/// <summary>
	/// DB column: docid
	/// </summary>
	public: const static int64_t mbDocId = 16LL;
	/// <summary>
	/// DB column: userid
	/// </summary>
	public: const static int64_t mbUserId = 32LL;
	/// <summary>
	/// DB column: objid
	/// </summary>
	public: const static int64_t mbObjId = 64LL;
	/// <summary>
	/// Member bit: The fileName in the download url.
	/// </summary>
	/// <remarks>
	/// It is readonly.
	/// DB column: fname
	/// </remarks>
	public: const static int64_t mbFileName = 128LL;
	/// <summary>
	/// Column length: The fileName in the download url.
	/// </summary>
	/// <remarks>
	/// It is readonly.
	/// DB column: fname
	/// </remarks>
	protected: int32_t lnFileName;
	/// <summary>
	/// Member bit: Indicates whether the download is inline or as attachment.
	/// </summary>
	/// <remarks>
	/// DB column: acode
	/// </remarks>
	public: const static int64_t mbAttachmentCode = 256LL;
	/// <summary>
	/// Column length: Indicates whether the download is inline or as attachment.
	/// </summary>
	/// <remarks>
	/// DB column: acode
	/// </remarks>
	protected: int32_t lnAttachmentCode;
	/// <summary>
	/// All valid member bits.
	/// </summary>
	public: const static int64_t mbAllMembers = 511LL;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: PublicDownloadDataC();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: PublicDownloadDataC(int64_t mbId, int32_t lnId, int64_t mbTimeStamp, int32_t lnTimeStamp, int64_t mbRemaining, int64_t mbExpiration, int32_t lnExpiration, int64_t mbDocId, int64_t mbUserId, int64_t mbObjId, int64_t mbFileName, int32_t lnFileName, int64_t mbAttachmentCode, int32_t lnAttachmentCode, int64_t mbAllMembers);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getLnId() { return lnId; }
	public: void setLnId(int32_t v);
	public: int32_t getLnTimeStamp() { return lnTimeStamp; }
	public: void setLnTimeStamp(int32_t v);
	public: int32_t getLnExpiration() { return lnExpiration; }
	public: void setLnExpiration(int32_t v);
	public: int32_t getLnFileName() { return lnFileName; }
	public: void setLnFileName(int32_t v);
	public: int32_t getLnAttachmentCode() { return lnAttachmentCode; }
	public: void setLnAttachmentCode(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// PublicDownloadC
// typeId=1919187163

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Constants for class PublicDownload.
/// </summary>
class PublicDownloadC : public PublicDownloadDataC {
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: PublicDownloadC();
	
	public: virtual BTYPEID BSerializable_getTypeId();
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// PublicDownloadOptions
// typeId=252853324

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// This class contains several options that are used to get the public
/// downloads.
/// </summary>
/// <remarks>
/// <p>
/// Copyright: Copyright (c) 2014
/// </p>
/// <p>
/// Organisation: ELO Digital Office GmbH
/// </p>
/// </remarks>
class PublicDownloadOptions : public ValueClass {
	/// <summary>
	/// The download IDs to retrieve the public downloads.
	/// </summary>
	protected: PArrayString downloadIds;
	/// <summary>
	/// The expired time.
	/// </summary>
	protected: ::std::wstring expiration;
	/// <summary>
	/// The remaining download.
	/// </summary>
	protected: int32_t remaining;
	/// <summary>
	/// The doc id.
	/// </summary>
	protected: ::std::wstring docId;
	/// <summary>
	/// The obj id.
	/// </summary>
	protected: ::std::wstring objId;
	/// <summary>
	/// If true, the short description of the sord is used as file name in the download URL.
	/// </summary>
	/// <remarks>
	/// Otherwise the original file name is used.
	/// </remarks>
	protected: bool fileNameFromSordName;
	/// <summary>
	/// If true, the document is downloaded as an attachment.
	/// </summary>
	/// <remarks>
	/// Otherwise it content is shown in-line in the browser.
	/// </remarks>
	protected: bool contentDispositionAttachment;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: PublicDownloadOptions();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: PublicDownloadOptions(const PArrayString& downloadIds, const ::std::wstring& expiration, int32_t remaining, const ::std::wstring& docId, const ::std::wstring& objId, bool fileNameFromSordName, bool contentDispositionAttachment);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: PArrayString getDownloadIds() { return downloadIds; }
	public: void setDownloadIds(PArrayString v);
	public: ::std::wstring getExpiration() { return expiration; }
	public: void setExpiration(::std::wstring v);
	public: int32_t getRemaining() { return remaining; }
	public: void setRemaining(int32_t v);
	public: ::std::wstring getDocId() { return docId; }
	public: void setDocId(::std::wstring v);
	public: ::std::wstring getObjId() { return objId; }
	public: void setObjId(::std::wstring v);
	public: bool getFileNameFromSordName() { return fileNameFromSordName; }
	public: void setFileNameFromSordName(bool v);
	public: bool getContentDispositionAttachment() { return contentDispositionAttachment; }
	public: void setContentDispositionAttachment(bool v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// PurgeSettings
// typeId=1576340510

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// This class represents the purge settings of the ELOdm purge task
/// </summary>
class PurgeSettings : public ValueClass {
	/// <summary>
	/// Original documents older than the specified number of days are deleted
	/// (0 or higher), e.g. 0 for no limit, 1 for 24 hours, 365 for a year
	/// </summary>
	protected: int32_t dayLimit;
	/// <summary>
	/// Possible path restriction for filing paths: <br>
	/// 0: include all paths <br>
	/// 1 and higher: only include a path with this ID where documents should be
	/// deleted
	/// </summary>
	protected: int32_t pathId;
	/// <summary>
	/// The original and the backup document can be compared before cleanup.
	/// </summary>
	/// <remarks>
	/// Possible values (1 to 3) are defined in PurgeSettingsC.
	/// </remarks>
	protected: int32_t fileCheckMode;
	/// <summary>
	/// When processing should take place: <br>
	/// START_EVERY_HOUR: when the purge task is starting and then every 60 minutes <br>
	/// 0 to 23: hour of the day, such as 8:00 p.m.
	/// </summary>
	protected: int32_t startHour;
	/// <summary>
	/// List of path ids to exclude from purging if pathId=0 is set.
	/// </summary>
	protected: byps::PVectorInteger excludePathIds;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: PurgeSettings();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: PurgeSettings(int32_t dayLimit, int32_t pathId, int32_t fileCheckMode, int32_t startHour, const byps::PVectorInteger& excludePathIds);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getDayLimit() { return dayLimit; }
	public: void setDayLimit(int32_t v);
	public: int32_t getPathId() { return pathId; }
	public: void setPathId(int32_t v);
	public: int32_t getFileCheckMode() { return fileCheckMode; }
	public: void setFileCheckMode(int32_t v);
	public: int32_t getStartHour() { return startHour; }
	public: void setStartHour(int32_t v);
	public: byps::PVectorInteger getExcludePathIds() { return excludePathIds; }
	public: void setExcludePathIds(byps::PVectorInteger v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// PurgeSettingsC
// typeId=1865968564

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Constants for class PurgeSettings
/// </summary>
class PurgeSettingsC : public ValueClass {
	/// <summary>
	/// for startHour: when the purge task is starting and then every 60 minutes
	/// </summary>
	public: const static int32_t START_EVERY_HOUR = -1;
	/// <summary>
	/// for fileCheckMode: no file comparison (not recommended)
	/// </summary>
	public: const static int32_t COMPARE_OFF = 1;
	/// <summary>
	/// for fileCheckMode: file comparison by file size
	/// </summary>
	public: const static int32_t COMPARE_SIZE = 2;
	/// <summary>
	/// for fileCheckMode: file comparision by file content
	/// </summary>
	public: const static int32_t COMPARE_CONTENT = 3;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: PurgeSettingsC();
	
	public: virtual BTYPEID BSerializable_getTypeId();
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// PurgeStatus
// typeId=2053888643

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// This class represents the status of the ELOdm purge task
/// </summary>
class PurgeStatus : public ValueClass {
	/// <summary>
	/// if the ELOdm purge task is running (it can only run in combination with the
	/// backup task)
	/// </summary>
	protected: bool isRunning;
	/// <summary>
	/// number of purged documents
	/// </summary>
	protected: int32_t numberOfDocsPurged;
	/// <summary>
	/// last purge work time (ISO UTC date and time without dots)
	/// If no purge has been done yet, the variable is empty.
	/// </summary>
	protected: ::std::wstring lastPurgeTime;
	/// <summary>
	/// an error message, if an error occured, else an empty String
	/// </summary>
	protected: ::std::wstring errorMessage;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: PurgeStatus();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: PurgeStatus(bool isRunning, int32_t numberOfDocsPurged, const ::std::wstring& lastPurgeTime, const ::std::wstring& errorMessage);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: bool getIsRunning() { return isRunning; }
	public: void setIsRunning(bool v);
	public: int32_t getNumberOfDocsPurged() { return numberOfDocsPurged; }
	public: void setNumberOfDocsPurged(int32_t v);
	public: ::std::wstring getLastPurgeTime() { return lastPurgeTime; }
	public: void setLastPurgeTime(::std::wstring v);
	public: ::std::wstring getErrorMessage() { return errorMessage; }
	public: void setErrorMessage(::std::wstring v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// QueryJobProtocolC
// typeId=1764906979

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// <p>
/// Constants for querying log messages of background jobs.
/// </summary>
/// <remarks>
/// </p>
/// </remarks>
class QueryJobProtocolC : public BSerializable {
	/// <summary>
	/// Return only errors.
	/// </summary>
	public: const static int32_t LOG_LEVEL_ERROR = 4096;
	/// <summary>
	/// Return only warnings.
	/// </summary>
	public: const static int32_t LOG_LEVEL_WARN = 2048;
	/// <summary>
	/// Return only normal informations.
	/// </summary>
	public: const static int32_t LOG_LEVEL_INFO = 1024;
	/// <summary>
	/// This value indicates that the object-ID is not set.
	/// </summary>
	public: const static int32_t OBJID_NOT_SET = -1;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: QueryJobProtocolC();
	
	public: virtual BTYPEID BSerializable_getTypeId();
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// QueryJobProtocolEvent
// typeId=892520690

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// <p>
/// A {@link QueryJobProtocolEvent} represents a event
/// </p>
/// </summary>
class QueryJobProtocolEvent : public ValueClass {
	/// <summary>
	/// The time of generating this event.
	/// </summary>
	protected: ::std::wstring date;
	/// <summary>
	/// Message of this LogRow.
	/// </summary>
	protected: ::std::wstring message;
	/// <summary>
	/// The level of log messages to query.
	/// </summary>
	/// <remarks>
	/// Use the | operator to select multiple
	/// levels.
	/// </remarks>
	protected: int32_t level;
	/// <summary>
	/// The id of the object currently being processed at the time of this events
	/// creation.
	/// </summary>
	/// <remarks>
	/// If the objId is not known/available, its value is set to
	/// {@link QueryJobProtocolC#OBJID_NOT_SET}.
	/// </remarks>
	protected: int32_t objId;
	/// <summary>
	/// The id of this QueryJobProtocolEvent.
	/// </summary>
	/// <remarks>
	/// The eventId's value is unique for one
	/// background thread. The value of a background thread's first eventId is 0.
	/// The second one is 1 and so on.
	/// </remarks>
	protected: int32_t eventId;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: QueryJobProtocolEvent();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: QueryJobProtocolEvent(const ::std::wstring& date, const ::std::wstring& message, int32_t level, int32_t objId, int32_t eventId);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: ::std::wstring getDate() { return date; }
	public: void setDate(::std::wstring v);
	public: ::std::wstring getMessage() { return message; }
	public: void setMessage(::std::wstring v);
	public: int32_t getLevel() { return level; }
	public: void setLevel(int32_t v);
	public: int32_t getObjId() { return objId; }
	public: void setObjId(int32_t v);
	public: int32_t getEventId() { return eventId; }
	public: void setEventId(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// QueryJobProtocolInfo
// typeId=1362638222

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// This class contains the parameters for the interface function
/// {@link IXServicePortIF#queryJobProtocol(ClientInfo, QueryJobProtocolInfo)}.
/// </summary>
class QueryJobProtocolInfo : public ValueClass {
	/// <summary>
	/// The GUID of the background thread to query the log informations.
	/// </summary>
	/// <remarks>
	/// Mandatory.
	/// </remarks>
	protected: ::std::wstring jobGuid;
	/// <summary>
	/// Marks the earliest date at which log information has to be reported.
	/// </summary>
	/// <remarks>
	/// As
	/// only cached values are returned, the value is ignored, if the oldest cached
	/// log information is younger that that date. Optional.
	/// </remarks>
	protected: ::std::wstring startDateISO;
	/// <summary>
	/// If the value of startEventId is &ge;0, only eventIds &ge; that value will
	/// be returned.
	/// </summary>
	/// <remarks>
	/// Optional.
	/// </remarks>
	protected: int32_t startEventId;
	/// <summary>
	/// Filter for the level of log messages.
	/// </summary>
	/// <remarks>
	/// If set, it has to be one of
	/// {@link QueryJobProtocolC#LOG_LEVEL_ERROR},
	/// {@link QueryJobProtocolC#LOG_LEVEL_WARN}, or
	/// {@link QueryJobProtocolC#LOG_LEVEL_INFO}. Multiple values can be set via
	/// the bit operation "|". If not set, only messages of LOG_LEVEL_ERROR are
	/// returned.
	/// </remarks>
	protected: int32_t level;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: QueryJobProtocolInfo();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: QueryJobProtocolInfo(const ::std::wstring& jobGuid, const ::std::wstring& startDateISO, int32_t startEventId, int32_t level);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: ::std::wstring getJobGuid() { return jobGuid; }
	public: void setJobGuid(::std::wstring v);
	public: ::std::wstring getStartDateISO() { return startDateISO; }
	public: void setStartDateISO(::std::wstring v);
	public: int32_t getStartEventId() { return startEventId; }
	public: void setStartEventId(int32_t v);
	public: int32_t getLevel() { return level; }
	public: void setLevel(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// QueryJobProtocolResult
// typeId=222450704

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// <p>
/// This class contains the results from querying the protocol of a background
/// thread.
/// </summary>
/// <remarks>
/// </p>
/// </remarks>
class QueryJobProtocolResult : public ValueClass {
	/// <summary>
	/// This String contains a URL where the whole protocol can be downloaded.
	/// </summary>
	/// <remarks>
	/// Empty, if no protocol file exists.
	/// </remarks>
	protected: ::std::wstring downloadUrl;
	/// <summary>
	/// Contains the all events by a background job that are cached at the
	/// IndexServer.
	/// </summary>
	protected: PArrayQueryJobProtocolEvent events;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: QueryJobProtocolResult();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: QueryJobProtocolResult(const ::std::wstring& downloadUrl, const PArrayQueryJobProtocolEvent& events);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: ::std::wstring getDownloadUrl() { return downloadUrl; }
	public: void setDownloadUrl(::std::wstring v);
	public: PArrayQueryJobProtocolEvent getEvents() { return events; }
	public: void setEvents(PArrayQueryJobProtocolEvent v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// Relation
// typeId=837810375

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Internal class.
/// </summary>
class Relation : public ValueClass {
	/// <summary>
	/// DB column: parentid
	/// </summary>
	protected: int32_t parentId;
	/// <summary>
	/// DB column: objectid
	/// </summary>
	protected: int32_t objId;
	/// <summary>
	/// DB column: ordinal
	/// </summary>
	protected: int32_t ordinal;
	/// <summary>
	/// DB column: relstatus
	/// </summary>
	protected: int32_t status;
	/// <summary>
	/// DB column: reltstamp
	/// </summary>
	protected: ::std::wstring tStamp;
	/// <summary>
	/// GUID
	/// </summary>
	protected: ::std::wstring guid;
	/// <summary>
	/// The Relation is deleted at this date.
	/// </summary>
	/// <remarks>
	/// ClientInfo determines the Timezone.
	/// <p>
	/// Is undefined if status==0.
	/// </p>
	/// </remarks>
	protected: ::std::wstring deleteDateIso;
	/// <summary>
	/// This Relation represents the main relation of an object, if this value is
	/// <code>true</code>.
	/// </summary>
	protected: bool mainRelation;
	/// <summary>
	/// Timestamp of this object's last export by the replication.
	/// </summary>
	protected: ::std::wstring TStampSync;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: Relation();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: Relation(int32_t parentId, int32_t objId, int32_t ordinal, int32_t status, const ::std::wstring& tStamp, const ::std::wstring& guid, const ::std::wstring& deleteDateIso, bool mainRelation, const ::std::wstring& TStampSync);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getParentId() { return parentId; }
	public: void setParentId(int32_t v);
	public: int32_t getObjId() { return objId; }
	public: void setObjId(int32_t v);
	public: int32_t getOrdinal() { return ordinal; }
	public: void setOrdinal(int32_t v);
	public: int32_t getStatus() { return status; }
	public: void setStatus(int32_t v);
	public: ::std::wstring getTStamp() { return tStamp; }
	public: void setTStamp(::std::wstring v);
	public: ::std::wstring getGuid() { return guid; }
	public: void setGuid(::std::wstring v);
	public: ::std::wstring getDeleteDateIso() { return deleteDateIso; }
	public: void setDeleteDateIso(::std::wstring v);
	public: bool getMainRelation() { return mainRelation; }
	public: void setMainRelation(bool v);
	public: ::std::wstring getTStampSync() { return TStampSync; }
	public: void setTStampSync(::std::wstring v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// RelationC
// typeId=1203469035

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// <p>Bit constants for members of Relation</p>
/// <p>Copyright: Copyright (c) 2003</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </summary>
class RelationC : public BSerializable {
	/// <summary>
	/// DB column: parentid
	/// </summary>
	public: const static int64_t mbParentId = 1LL;
	/// <summary>
	/// DB column: objectid
	/// </summary>
	public: const static int64_t mbObjId = 2LL;
	/// <summary>
	/// DB column: ordinal
	/// </summary>
	public: const static int64_t mbOrdinal = 4LL;
	/// <summary>
	/// DB column: relstatus
	/// </summary>
	public: const static int64_t mbStatus = 8LL;
	/// <summary>
	/// DB column: reltstamp
	/// </summary>
	public: const static int64_t mbTStamp = 16LL;
	/// <summary>
	/// DB column: reltstamp
	/// </summary>
	protected: int32_t lnTStamp;
	/// <summary>
	/// Member bit: GUID
	/// DB column: relguid
	/// </summary>
	public: const static int64_t mbGuid = 32LL;
	/// <summary>
	/// Column length: GUID
	/// DB column: relguid
	/// </summary>
	protected: int32_t lnGuid;
	/// <summary>
	/// Member bit: The Relation is deleted at this date.
	/// </summary>
	/// <remarks>
	/// ClientInfo determines the Timezone.
	/// DB column: reldeletedate
	/// </remarks>
	public: const static int64_t mbDeleteDate = 64LL;
	/// <summary>
	/// Member bit: This Relation represents the main relation of an object, if this value is
	/// DB column: relmain
	/// </summary>
	public: const static int64_t mbRelMain = 128LL;
	/// <summary>
	/// Member bit: Timestamp of this object's last export by the replication.
	/// </summary>
	/// <remarks>
	/// DB column: reltstampsync
	/// </remarks>
	public: const static int64_t mbTStampSync = 256LL;
	/// <summary>
	/// Column length: Timestamp of this object's last export by the replication.
	/// </summary>
	/// <remarks>
	/// DB column: reltstampsync
	/// </remarks>
	protected: int32_t lnTStampSync;
	/// <summary>
	/// All valid member bits.
	/// </summary>
	public: const static int64_t mbAllMembers = 511LL;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: RelationC();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: RelationC(int64_t mbParentId, int64_t mbObjId, int64_t mbOrdinal, int64_t mbStatus, int64_t mbTStamp, int32_t lnTStamp, int64_t mbGuid, int32_t lnGuid, int64_t mbDeleteDate, int64_t mbRelMain, int64_t mbTStampSync, int32_t lnTStampSync, int64_t mbAllMembers);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getLnTStamp() { return lnTStamp; }
	public: void setLnTStamp(int32_t v);
	public: int32_t getLnGuid() { return lnGuid; }
	public: void setLnGuid(int32_t v);
	public: int32_t getLnTStampSync() { return lnTStampSync; }
	public: void setLnTStampSync(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// Reminder
// typeId=256674679

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

class Reminder : public ValueClass {
	/// <summary>
	/// Memo text
	/// </summary>
	protected: ::std::wstring desc;
	/// <summary>
	/// Reminder ID
	/// </summary>
	protected: int32_t id;
	/// <summary>
	/// ID of user who has locked the reminder record in DB
	/// </summary>
	protected: int32_t lockId;
	/// <summary>
	/// Short description visible in the task list.
	/// </summary>
	protected: ::std::wstring name;
	/// <summary>
	/// Reminder is linked to this Sord.
	/// </summary>
	protected: int32_t objId;
	/// <summary>
	/// Sord type.
	/// </summary>
	protected: int32_t objType;
	/// <summary>
	/// Priority: 0...high, 1...medium, 2...low
	/// </summary>
	protected: int32_t prio;
	/// <summary>
	/// Reminder was created for this user.
	/// </summary>
	protected: int32_t receiverId;
	/// <summary>
	/// Reminder was created by this user.
	/// </summary>
	protected: int32_t senderId;
	/// <summary>
	/// Reminder was created at this date.
	/// </summary>
	protected: ::std::wstring createDateIso;
	/// <summary>
	/// Reminder is deleted logically if set.
	/// </summary>
	/// <remarks>
	/// Read-only.
	/// </remarks>
	protected: bool deleted;
	/// <summary>
	/// On this date the receiver has seen the reminder.
	/// </summary>
	protected: ::std::wstring dueDateIso;
	/// <summary>
	/// Reminder is locked by this user.
	/// </summary>
	protected: ::std::wstring lockName;
	/// <summary>
	/// Notify sender if receiver deletes the reminder.
	/// </summary>
	protected: bool notifyOnDelete;
	/// <summary>
	/// Notify sender if receiver views the reminder.
	/// </summary>
	protected: bool notifyOnView;
	/// <summary>
	/// Sord GUID.
	/// </summary>
	protected: ::std::wstring objGuid;
	/// <summary>
	/// At this Date the reminder should be made visible to the receiver.
	/// </summary>
	protected: ::std::wstring promptDateIso;
	/// <summary>
	/// Reminder was created for this user.
	/// </summary>
	protected: ::std::wstring receiverName;
	/// <summary>
	/// Reminder was created by this user.
	/// </summary>
	protected: ::std::wstring senderName;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: Reminder();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: Reminder(const ::std::wstring& desc, int32_t id, int32_t lockId, const ::std::wstring& name, int32_t objId, int32_t objType, int32_t prio, int32_t receiverId, int32_t senderId, const ::std::wstring& createDateIso, bool deleted, const ::std::wstring& dueDateIso, const ::std::wstring& lockName, bool notifyOnDelete, bool notifyOnView, const ::std::wstring& objGuid, const ::std::wstring& promptDateIso, const ::std::wstring& receiverName, const ::std::wstring& senderName);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: ::std::wstring getDesc() { return desc; }
	public: void setDesc(::std::wstring v);
	public: int32_t getId() { return id; }
	public: void setId(int32_t v);
	public: int32_t getLockId() { return lockId; }
	public: void setLockId(int32_t v);
	public: ::std::wstring getName() { return name; }
	public: void setName(::std::wstring v);
	public: int32_t getObjId() { return objId; }
	public: void setObjId(int32_t v);
	public: int32_t getObjType() { return objType; }
	public: void setObjType(int32_t v);
	public: int32_t getPrio() { return prio; }
	public: void setPrio(int32_t v);
	public: int32_t getReceiverId() { return receiverId; }
	public: void setReceiverId(int32_t v);
	public: int32_t getSenderId() { return senderId; }
	public: void setSenderId(int32_t v);
	public: ::std::wstring getCreateDateIso() { return createDateIso; }
	public: void setCreateDateIso(::std::wstring v);
	public: bool getDeleted() { return deleted; }
	public: void setDeleted(bool v);
	public: ::std::wstring getDueDateIso() { return dueDateIso; }
	public: void setDueDateIso(::std::wstring v);
	public: ::std::wstring getLockName() { return lockName; }
	public: void setLockName(::std::wstring v);
	public: bool getNotifyOnDelete() { return notifyOnDelete; }
	public: void setNotifyOnDelete(bool v);
	public: bool getNotifyOnView() { return notifyOnView; }
	public: void setNotifyOnView(bool v);
	public: ::std::wstring getObjGuid() { return objGuid; }
	public: void setObjGuid(::std::wstring v);
	public: ::std::wstring getPromptDateIso() { return promptDateIso; }
	public: void setPromptDateIso(::std::wstring v);
	public: ::std::wstring getReceiverName() { return receiverName; }
	public: void setReceiverName(::std::wstring v);
	public: ::std::wstring getSenderName() { return senderName; }
	public: void setSenderName(::std::wstring v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// ReminderDataC
// typeId=1099169893

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// <p>Bit constants for members of Reminder</p>
/// <p>Copyright: Copyright (c) 2003</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </summary>
class ReminderDataC : public BSerializable {
	/// <summary>
	/// DB column: wvident
	/// </summary>
	public: const static int64_t mbId = 1LL;
	/// <summary>
	/// DB column: parentid
	/// </summary>
	public: const static int64_t mbObjId = 2LL;
	/// <summary>
	/// DB column: userowner
	/// </summary>
	public: const static int64_t mbReceiverId = 4LL;
	/// <summary>
	/// DB column: userfrom
	/// </summary>
	public: const static int64_t mbSenderId = 8LL;
	/// <summary>
	/// DB column: wvdate
	/// </summary>
	public: const static int64_t mbPromptDate = 16LL;
	/// <summary>
	/// DB column: createdate
	/// </summary>
	public: const static int64_t mbCreateDate = 32LL;
	/// <summary>
	/// DB column: duedate
	/// </summary>
	public: const static int64_t mbDueDate = 64LL;
	/// <summary>
	/// DB column: prio
	/// </summary>
	public: const static int64_t mbPrio = 128LL;
	/// <summary>
	/// DB column: action
	/// </summary>
	public: const static int64_t mbActionCode = 256LL;
	/// <summary>
	/// DB column: wvlock
	/// </summary>
	public: const static int64_t mbLockId = 512LL;
	/// <summary>
	/// DB column: parenttype
	/// </summary>
	public: const static int64_t mbObjType = 1024LL;
	/// <summary>
	/// DB column: short
	/// </summary>
	public: const static int64_t mbName = 2048LL;
	/// <summary>
	/// DB column: short
	/// </summary>
	protected: int32_t lnName;
	/// <summary>
	/// DB column: wvdesc
	/// </summary>
	public: const static int64_t mbDesc = 4096LL;
	/// <summary>
	/// DB column: wvdesc
	/// </summary>
	protected: int32_t lnDesc;
	/// <summary>
	/// All valid member bits.
	/// </summary>
	public: const static int64_t mbAllMembers = 8191LL;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: ReminderDataC();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: ReminderDataC(int64_t mbId, int64_t mbObjId, int64_t mbReceiverId, int64_t mbSenderId, int64_t mbPromptDate, int64_t mbCreateDate, int64_t mbDueDate, int64_t mbPrio, int64_t mbActionCode, int64_t mbLockId, int64_t mbObjType, int64_t mbName, int32_t lnName, int64_t mbDesc, int32_t lnDesc, int64_t mbAllMembers);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getLnName() { return lnName; }
	public: void setLnName(int32_t v);
	public: int32_t getLnDesc() { return lnDesc; }
	public: void setLnDesc(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// ReminderC
// typeId=1431555044

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

class ReminderC : public ReminderDataC {
	/// <summary>
	/// Sord guid.
	/// </summary>
	public: const static int64_t mbObjGuid = 1048576LL;
	/// <summary>
	/// All valid member bits.
	/// </summary>
	public: const static int64_t mbAll = 2097151LL;
	public: const static int64_t mbCreateDateIso = 32LL;
	public: const static int64_t mbDeleted = 512LL;
	public: const static int64_t mbPromptDateIso = 16LL;
	public: const static int64_t mbDueDateIso = 64LL;
	public: const static int64_t mbLockName = 512LL;
	public: const static int64_t mbNotifyOnDelete = 256LL;
	public: const static int64_t mbNotifyOnView = 256LL;
	public: const static int64_t mbReceiverName = 4LL;
	public: const static int64_t mbSenderName = 8LL;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: ReminderC();
	
	public: virtual BTYPEID BSerializable_getTypeId();
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// ReplCode
// typeId=1235558040

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Constants for replication codes.
/// </summary>
class ReplCode : public BSerializable {
	/// <summary>
	/// Change code: Modify the indexing information (without
	/// <code>Sord.getObjKeys()</code>) of an archive entry (<code>Sord</code>).
	/// </summary>
	public: const static int32_t ARCR_OBJECT_DATA = 2;
	public: const static ::std::wstring ARCR_OBJECT_DATA_S;
	/// <summary>
	/// Change code: Modify the indexing information (only
	/// <code>Sord.getObjKeys()</code>) of an archive entry (<code>Sord</code>).
	/// </summary>
	public: const static int32_t ARCR_OBJECT_KEYS = 4;
	public: const static ::std::wstring ARCR_OBJECT_KEYS_S;
	/// <summary>
	/// Change code: Create or modify a note.
	/// </summary>
	public: const static int32_t ARCR_NOTE_DATA = 8;
	public: const static ::std::wstring ARCR_NOTE_DATA_S;
	/// <summary>
	/// Change code: Delete a note.
	/// </summary>
	public: const static int32_t ARCR_NOTE_DELETE = 16;
	public: const static ::std::wstring ARCR_NOTE_DELETE_S;
	/// <summary>
	/// Change code: Changed document comment
	/// </summary>
	public: const static int32_t ARCR_VERSION_COMMENT = 32;
	public: const static ::std::wstring ARCR_VERSION_COMMENT_S;
	/// <summary>
	/// Change code: Change all references to children.
	/// </summary>
	public: const static int32_t ARCR_OBJECT_RELATIONS = 64;
	public: const static ::std::wstring ARCR_OBJECT_RELATIONS_S;
	/// <summary>
	/// Change code: Insert a (logical) reference inside an archive entry.
	/// </summary>
	public: const static int32_t ARCR_OBJECT_INSERT_REF = 128;
	public: const static ::std::wstring ARCR_OBJECT_INSERT_REF_S;
	/// <summary>
	/// Change code: Delete a (logical) reference inside an archive entry.
	/// </summary>
	public: const static int32_t ARCR_OBJECT_DELETE_REF = 256;
	public: const static ::std::wstring ARCR_OBJECT_DELETE_REF_S;
	/// <summary>
	/// Change code: Insert a document and change the work version of the
	/// associated archive entry.
	/// </summary>
	public: const static int32_t ARCR_DOCUMENT_DATA = 512;
	public: const static ::std::wstring ARCR_DOCUMENT_DATA_S;
	/// <summary>
	/// Change code: Insert a document but do not change the work version of the
	/// associated archive entry.
	/// </summary>
	public: const static int32_t ARCR_DOCUMENT_INSERT = 1024;
	public: const static ::std::wstring ARCR_DOCUMENT_INSERT_S;
	/// <summary>
	/// Change code: Select another work version from the document history.
	/// </summary>
	public: const static int32_t ARCR_DOCUMENT_SWITCH = 2048;
	public: const static ::std::wstring ARCR_DOCUMENT_SWITCH_S;
	/// <summary>
	/// Change code: Insert or change an attachment.
	/// </summary>
	public: const static int32_t ARCR_ATTACHMENT_DATA = 4096;
	public: const static ::std::wstring ARCR_ATTACHMENT_DATA_S;
	/// <summary>
	/// Change code: Create a document signature
	/// </summary>
	public: const static int32_t ARCR_SIGNATURE_DATA = 8192;
	public: const static ::std::wstring ARCR_SIGNATURE_DATA_S;
	/// <summary>
	/// Change code: Ignore the optional broker optimization anyway a) selective
	/// export b) VDS
	/// </summary>
	public: const static int32_t ARCR_IGNORE_BROKER_OPTZ = 16384;
	public: const static ::std::wstring ARCR_IGNORE_BROKER_OPTZ_S;
	/// <summary>
	/// Change code: Document flags and/or document delete status have been changed
	/// </summary>
	public: const static int32_t ARCR_DOCUMENT_STATUS = 32768;
	public: const static ::std::wstring ARCR_DOCUMENT_STATUS_S;
	/// <summary>
	/// Change code: Master data.
	/// </summary>
	/// <remarks>
	/// Exports the names of storage masks, keys, users.
	/// </remarks>
	public: const static int32_t ARCR_BASEDATA_VERIFY = 65536;
	public: const static ::std::wstring ARCR_BASEDATA_VERIFY_S;
	/// <summary>
	/// Change code: Exports the storage masks.
	/// </summary>
	public: const static int32_t ARCR_DOCMASKS_DATA = 131072;
	public: const static ::std::wstring ARCR_DOCMASKS_DATA_S;
	/// <summary>
	/// Change code: Delete object finally.
	/// </summary>
	public: const static int32_t ARCR_OBJECT_DELETE_PHYS = 262144;
	public: const static ::std::wstring ARCR_OBJECT_DELETE_PHYS_S;
	/// <summary>
	/// Change code: Change the replication sets of an archive entry.
	/// </summary>
	public: const static int32_t ARCR_OBJECT_REPLSET = 524288;
	public: const static ::std::wstring ARCR_OBJECT_REPLSET_S;
	/// <summary>
	/// Change code: Change a workflow.
	/// </summary>
	public: const static int32_t ARCR_WORKFLOW_DATA = 1048576;
	public: const static ::std::wstring ARCR_WORKFLOW_DATA_S;
	/// <summary>
	/// Change flag: This flag is added to ARCR_OBJECT_DATA if replication performs
	/// a full export.
	/// </summary>
	public: const static int32_t ARCR_INITIAL_DATA = 2097152;
	public: const static ::std::wstring ARCR_INITIAL_DATA_S;
	/// <summary>
	/// Change code: Set a replication marker.
	/// </summary>
	public: const static int32_t ARCR_MARKER = 4194304;
	public: const static ::std::wstring ARCR_MARKER_S;
	/// <summary>
	/// Change code: Create a new entry for the object history
	/// </summary>
	public: const static int32_t ARCR_OBJECT_HIST = 8388608;
	public: const static ::std::wstring ARCR_OBJECT_HIST_S;
	/// <summary>
	/// Change flag: This flag is contained in some change codes to extend the
	/// number of possible change codes.
	/// </summary>
	public: const static int32_t ARCR_SET2 = 16777216;
	/// <summary>
	/// Change flag: This flag is contained in some change codes to extend the
	/// number of possible change codes.
	/// </summary>
	public: const static int32_t ARCR_SET16 = 234881024;
	/// <summary>
	/// Change flags: Bits of this value are contained in some change codes to
	/// extend the number of possible change codes.
	/// </summary>
	public: const static int32_t ARCR_EXTENDED_SET = 251658240;
	/// <summary>
	/// Change code: Insert, modify, delete activities.
	/// </summary>
	public: const static int32_t ARCR_ACTION = 16777217;
	public: const static ::std::wstring ARCR_ACTION_S;
	/// <summary>
	/// Change code: Insert or modify user data.
	/// </summary>
	public: const static int32_t ARCR_USER_DATA = 16777218;
	public: const static ::std::wstring ARCR_USER_DATA_S;
	/// <summary>
	/// Change code: Delete a user.
	/// </summary>
	public: const static int32_t ARCR_USER_DELETE = 16777219;
	public: const static ::std::wstring ARCR_USER_DELETE_S;
	/// <summary>
	/// Change code: Insert or modify storage mask data.
	/// </summary>
	/// <remarks>
	/// (reserved)
	/// </remarks>
	public: const static int32_t ARCR_TRANSLATION = 16777220;
	public: const static ::std::wstring ARCR_TRANSLATION_S;
	/// <summary>
	/// Change code: Delete a storage mask.
	/// </summary>
	/// <remarks>
	/// (reserved)
	/// </remarks>
	public: const static int32_t ARCR_DOCMASK_DELETE = 16777221;
	public: const static ::std::wstring ARCR_DOCMASK_DELETE_S;
	public: const static int32_t ARCR_DOCUMENT_FEED = 16777224;
	public: const static ::std::wstring ARCR_DOCUMENT_FEED_S;
	public: const static int32_t ARCR_LINK = 16777232;
	public: const static ::std::wstring ARCR_LINK_S;
	/// <summary>
	/// Change code: map changed
	/// </summary>
	public: const static int32_t ARCR_MAP_CHANGED = 16777221;
	public: const static ::std::wstring ARCR_MAP_CHANGED_S;
	/// <summary>
	/// Change code: A keyword list has been modified Param: 1 fÃ¼r Stichwortliste
	/// geÃ¤ndert, 2 fÃ¼r Stichwortliste gelÃ¶scht
	/// </summary>
	public: const static int32_t ARCR_SWL_DATA = 16777222;
	public: const static ::std::wstring ARCR_SWL_DATA_S;
	public: const static int32_t PARAM_SWL_UPDATED = 1;
	public: const static int32_t PARAM_SWL_DELETED = 2;
	/// <summary>
	/// Change code: A VDS has been created
	/// </summary>
	public: const static int32_t ARCR_CONTROL_VDS = 16777223;
	public: const static ::std::wstring ARCR_CONTROL_VDS_S;
	/// <summary>
	/// Change code: Transformation table for master data (broker-to-broker
	/// replication).
	/// </summary>
	public: const static int32_t ARCR_TRAFO = 1073741824;
	public: const static ::std::wstring ARCR_TRAFO_S;
	/// <summary>
	/// Change flag: This flag marks a change record to be a control record for the
	/// broker.
	/// </summary>
	public: const static int32_t ARCR_BROKER = 0-2147483648;
	public: const static ::std::wstring ARCR_BROKER_S;
	public: const static ::std::wstring ARCR_CODE_SEP;
	public: const static ::std::wstring ARCR_EXT_CODE_UNDEF_S;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: ReplCode();
	
	public: virtual BTYPEID BSerializable_getTypeId();
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// ReplSet
// typeId=1124529321

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// <p>Objects of this class store the replication information of archive entries.
/// </summary>
/// <remarks>
/// </p>
/// <p>Copyright: Copyright (c) 2004</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </remarks>
class ReplSet : public ValueClass {
	/// <summary>
	/// Bitset of replication IDs.
	/// </summary>
	protected: PArrayInt dw;
	/// <summary>
	/// This replication information belongs to the archive entry with ID <code>objId</code>
	/// </summary>
	protected: int32_t objId;
	/// <summary>
	/// Timestamp of the last alteration of replication sets for the corresponding
	/// archive entry.
	/// </summary>
	/// <remarks>
	/// The format is JJJJ.MM.DD.hh.mm.ss
	/// </remarks>
	protected: ::std::wstring TStamp;
	/// <summary>
	/// Timestamp of this object's last export by the replication.
	/// </summary>
	protected: ::std::wstring TStampSync;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: ReplSet();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: ReplSet(const PArrayInt& dw, int32_t objId, const ::std::wstring& TStamp, const ::std::wstring& TStampSync);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: PArrayInt getDw() { return dw; }
	public: void setDw(PArrayInt v);
	public: int32_t getObjId() { return objId; }
	public: void setObjId(int32_t v);
	public: ::std::wstring getTStamp() { return TStamp; }
	public: void setTStamp(::std::wstring v);
	public: ::std::wstring getTStampSync() { return TStampSync; }
	public: void setTStampSync(::std::wstring v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// ReplSetCombination
// typeId=2078338937

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Internal class.
/// </summary>
class ReplSetCombination : public ValueClass {
	protected: ::std::wstring guid;
	protected: PBytes combi;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: ReplSetCombination();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: ReplSetCombination(const ::std::wstring& guid, const PBytes& combi);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: ::std::wstring getGuid() { return guid; }
	public: void setGuid(::std::wstring v);
	public: PBytes getCombi() { return combi; }
	public: void setCombi(PBytes v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// ReplSetCombinationC
// typeId=897151349

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// <p>Bit constants for members of ReplSetCombination</p>
/// <p>Copyright: Copyright (c) 2003</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </summary>
class ReplSetCombinationC : public BSerializable {
	/// <summary>
	/// DB column: combiid
	/// </summary>
	public: const static int64_t mbCombiGuid = 1LL;
	/// <summary>
	/// DB column: combiid
	/// </summary>
	protected: int32_t lnCombiGuid;
	/// <summary>
	/// DB column: dw
	/// </summary>
	public: const static int64_t mbCombi = 2LL;
	/// <summary>
	/// DB column: dw
	/// </summary>
	protected: int32_t lnCombi;
	/// <summary>
	/// All valid member bits.
	/// </summary>
	public: const static int64_t mbAllMembers = 3LL;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: ReplSetCombinationC();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: ReplSetCombinationC(int64_t mbCombiGuid, int32_t lnCombiGuid, int64_t mbCombi, int32_t lnCombi, int64_t mbAllMembers);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getLnCombiGuid() { return lnCombiGuid; }
	public: void setLnCombiGuid(int32_t v);
	public: int32_t getLnCombi() { return lnCombi; }
	public: void setLnCombi(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// ReplSetName
// typeId=755067340

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Properties of a replication set.
/// </summary>
/// <remarks>
/// <p>Copyright: Copyright (c) 2004</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </remarks>
class ReplSetName : public ValueClass {
	/// <summary>
	/// Timestamp of the last change.
	/// </summary>
	/// <remarks>
	/// The format is JJJJ.MM.DD.hh.mm.ss
	/// </remarks>
	protected: ::std::wstring TStamp;
	/// <summary>
	/// Descriptive text for the replication set.
	/// </summary>
	protected: ::std::wstring desc;
	/// <summary>
	/// Identifier for the replication set.
	/// </summary>
	protected: int32_t id;
	/// <summary>
	/// Image used for the replication set in list function in the client application.
	/// </summary>
	protected: int32_t image;
	/// <summary>
	/// Replication set is used for archive synchronisation(ELO MOBIL).
	/// </summary>
	protected: int32_t mobile;
	/// <summary>
	/// Name of the replication set.
	/// </summary>
	protected: ::std::wstring name;
	/// <summary>
	/// Timestamp of this object's last export by the replication.
	/// </summary>
	protected: ::std::wstring TStampSync;
	/// <summary>
	/// Priority of this replication set.
	/// </summary>
	protected: int32_t priority;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: ReplSetName();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: ReplSetName(const ::std::wstring& TStamp, const ::std::wstring& desc, int32_t id, int32_t image, int32_t mobile, const ::std::wstring& name, const ::std::wstring& TStampSync, int32_t priority);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: ::std::wstring getTStamp() { return TStamp; }
	public: void setTStamp(::std::wstring v);
	public: ::std::wstring getDesc() { return desc; }
	public: void setDesc(::std::wstring v);
	public: int32_t getId() { return id; }
	public: void setId(int32_t v);
	public: int32_t getImage() { return image; }
	public: void setImage(int32_t v);
	public: int32_t getMobile() { return mobile; }
	public: void setMobile(int32_t v);
	public: ::std::wstring getName() { return name; }
	public: void setName(::std::wstring v);
	public: ::std::wstring getTStampSync() { return TStampSync; }
	public: void setTStampSync(::std::wstring v);
	public: int32_t getPriority() { return priority; }
	public: void setPriority(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// ReplSetNameC
// typeId=969246601

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// <p>Bit constants for members of ReplSetName</p>
/// <p>Copyright: Copyright (c) 2003</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </summary>
class ReplSetNameC : public BSerializable {
	/// <summary>
	/// DB column: rsid
	/// </summary>
	public: const static int64_t mbId = 1LL;
	/// <summary>
	/// DB column: rsimage
	/// </summary>
	public: const static int64_t mbImage = 2LL;
	/// <summary>
	/// DB column: rsname
	/// </summary>
	public: const static int64_t mbName = 4LL;
	/// <summary>
	/// DB column: rsname
	/// </summary>
	protected: int32_t lnName;
	/// <summary>
	/// DB column: rsdesc
	/// </summary>
	public: const static int64_t mbDesc = 8LL;
	/// <summary>
	/// DB column: rsdesc
	/// </summary>
	protected: int32_t lnDesc;
	/// <summary>
	/// DB column: rststamp
	/// </summary>
	public: const static int64_t mbTStamp = 16LL;
	/// <summary>
	/// DB column: rststamp
	/// </summary>
	protected: int32_t lnTStamp;
	/// <summary>
	/// DB column: rsmobile
	/// </summary>
	public: const static int64_t mbMobile = 32LL;
	/// <summary>
	/// Member bit: Timestamp of this object's last export by the replication.
	/// </summary>
	/// <remarks>
	/// DB column: rststampsync
	/// </remarks>
	public: const static int64_t mbTStampSync = 64LL;
	/// <summary>
	/// Column length: Timestamp of this object's last export by the replication.
	/// </summary>
	/// <remarks>
	/// DB column: rststampsync
	/// </remarks>
	protected: int32_t lnTStampSync;
	/// <summary>
	/// Member bit: Priority of this replication set.
	/// </summary>
	/// <remarks>
	/// DB column: rsprio
	/// </remarks>
	public: const static int64_t mbPriority = 128LL;
	/// <summary>
	/// All valid member bits.
	/// </summary>
	public: const static int64_t mbAllMembers = 255LL;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: ReplSetNameC();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: ReplSetNameC(int64_t mbId, int64_t mbImage, int64_t mbName, int32_t lnName, int64_t mbDesc, int32_t lnDesc, int64_t mbTStamp, int32_t lnTStamp, int64_t mbMobile, int64_t mbTStampSync, int32_t lnTStampSync, int64_t mbPriority, int64_t mbAllMembers);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getLnName() { return lnName; }
	public: void setLnName(int32_t v);
	public: int32_t getLnDesc() { return lnDesc; }
	public: void setLnDesc(int32_t v);
	public: int32_t getLnTStamp() { return lnTStamp; }
	public: void setLnTStamp(int32_t v);
	public: int32_t getLnTStampSync() { return lnTStampSync; }
	public: void setLnTStampSync(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// RepliHist
// typeId=899503054

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Internal class
/// </summary>
class RepliHist : public ValueClass {
	/// <summary>
	/// DB column: rhrowid
	/// </summary>
	protected: int32_t id;
	/// <summary>
	/// DB column: rhtsdate
	/// </summary>
	protected: ::std::wstring tSDate;
	/// <summary>
	/// DB column: rhimex
	/// </summary>
	protected: int32_t imEx;
	/// <summary>
	/// DB column: rhsucc
	/// </summary>
	protected: int32_t succ;
	/// <summary>
	/// DB column: rharcguid
	/// </summary>
	protected: ::std::wstring arcGuid;
	/// <summary>
	/// DB column: rharcshort
	/// </summary>
	protected: ::std::wstring arcShort;
	/// <summary>
	/// DB column: rharcdesc
	/// </summary>
	protected: ::std::wstring arcDesc;
	/// <summary>
	/// DB column: rhtsbegin
	/// </summary>
	protected: ::std::wstring tSBegin;
	/// <summary>
	/// DB column: rhtsend
	/// </summary>
	protected: ::std::wstring tSEnd;
	protected: int32_t arcPriorityLocal;
	protected: int32_t arcPriorityRemote;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: RepliHist();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: RepliHist(int32_t id, const ::std::wstring& tSDate, int32_t imEx, int32_t succ, const ::std::wstring& arcGuid, const ::std::wstring& arcShort, const ::std::wstring& arcDesc, const ::std::wstring& tSBegin, const ::std::wstring& tSEnd, int32_t arcPriorityLocal, int32_t arcPriorityRemote);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getId() { return id; }
	public: void setId(int32_t v);
	public: ::std::wstring getTSDate() { return tSDate; }
	public: void setTSDate(::std::wstring v);
	public: int32_t getImEx() { return imEx; }
	public: void setImEx(int32_t v);
	public: int32_t getSucc() { return succ; }
	public: void setSucc(int32_t v);
	public: ::std::wstring getArcGuid() { return arcGuid; }
	public: void setArcGuid(::std::wstring v);
	public: ::std::wstring getArcShort() { return arcShort; }
	public: void setArcShort(::std::wstring v);
	public: ::std::wstring getArcDesc() { return arcDesc; }
	public: void setArcDesc(::std::wstring v);
	public: ::std::wstring getTSBegin() { return tSBegin; }
	public: void setTSBegin(::std::wstring v);
	public: ::std::wstring getTSEnd() { return tSEnd; }
	public: void setTSEnd(::std::wstring v);
	public: int32_t getArcPriorityLocal() { return arcPriorityLocal; }
	public: void setArcPriorityLocal(int32_t v);
	public: int32_t getArcPriorityRemote() { return arcPriorityRemote; }
	public: void setArcPriorityRemote(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// RepliHistC
// typeId=104551413

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// <p>Bit constants for members of RepliHist</p>
/// <p>Copyright: Copyright (c) 2003</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </summary>
class RepliHistC : public BSerializable {
	/// <summary>
	/// DB column: rhrowid
	/// </summary>
	public: const static int64_t mbId = 1LL;
	/// <summary>
	/// DB column: rhtsdate
	/// </summary>
	public: const static int64_t mbTSDate = 2LL;
	/// <summary>
	/// DB column: rhtsdate
	/// </summary>
	protected: int32_t lnTSDate;
	/// <summary>
	/// DB column: rhimex
	/// </summary>
	public: const static int64_t mbImEx = 4LL;
	/// <summary>
	/// DB column: rhsucc
	/// </summary>
	public: const static int64_t mbSucc = 8LL;
	/// <summary>
	/// DB column: rharcguid
	/// </summary>
	public: const static int64_t mbArcGuid = 16LL;
	/// <summary>
	/// DB column: rharcguid
	/// </summary>
	protected: int32_t lnArcGuid;
	/// <summary>
	/// DB column: rharcshort
	/// </summary>
	public: const static int64_t mbArcShort = 32LL;
	/// <summary>
	/// DB column: rharcshort
	/// </summary>
	protected: int32_t lnArcShort;
	/// <summary>
	/// DB column: rharcdesc
	/// </summary>
	public: const static int64_t mbArcDesc = 64LL;
	/// <summary>
	/// DB column: rharcdesc
	/// </summary>
	protected: int32_t lnArcDesc;
	/// <summary>
	/// DB column: rhtsbegin
	/// </summary>
	public: const static int64_t mbTSBegin = 128LL;
	/// <summary>
	/// DB column: rhtsbegin
	/// </summary>
	protected: int32_t lnTSBegin;
	/// <summary>
	/// DB column: rhtsend
	/// </summary>
	public: const static int64_t mbTSEnd = 256LL;
	/// <summary>
	/// DB column: rhtsend
	/// </summary>
	protected: int32_t lnTSEnd;
	/// <summary>
	/// DB column: rhpriolocal
	/// </summary>
	public: const static int64_t mbArcPriorityLocal = 512LL;
	/// <summary>
	/// DB column: rhprioremote
	/// </summary>
	public: const static int64_t mbArcPriorityRemote = 1024LL;
	/// <summary>
	/// All valid member bits.
	/// </summary>
	public: const static int64_t mbAllMembers = 2047LL;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: RepliHistC();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: RepliHistC(int64_t mbId, int64_t mbTSDate, int32_t lnTSDate, int64_t mbImEx, int64_t mbSucc, int64_t mbArcGuid, int32_t lnArcGuid, int64_t mbArcShort, int32_t lnArcShort, int64_t mbArcDesc, int32_t lnArcDesc, int64_t mbTSBegin, int32_t lnTSBegin, int64_t mbTSEnd, int32_t lnTSEnd, int64_t mbArcPriorityLocal, int64_t mbArcPriorityRemote, int64_t mbAllMembers);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getLnTSDate() { return lnTSDate; }
	public: void setLnTSDate(int32_t v);
	public: int32_t getLnArcGuid() { return lnArcGuid; }
	public: void setLnArcGuid(int32_t v);
	public: int32_t getLnArcShort() { return lnArcShort; }
	public: void setLnArcShort(int32_t v);
	public: int32_t getLnArcDesc() { return lnArcDesc; }
	public: void setLnArcDesc(int32_t v);
	public: int32_t getLnTSBegin() { return lnTSBegin; }
	public: void setLnTSBegin(int32_t v);
	public: int32_t getLnTSEnd() { return lnTSEnd; }
	public: void setLnTSEnd(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// ReportC
// typeId=1285453013

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// <p>Bit constants for members of ReportInfo</p>
/// <p>Copyright: Copyright (c) 2003</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </summary>
class ReportC : public BSerializable {
	/// <summary>
	/// DB column: reportid
	/// </summary>
	public: const static int64_t mbId = 1LL;
	/// <summary>
	/// DB column: reportid
	/// </summary>
	protected: int32_t lnId;
	/// <summary>
	/// DB column: actionno
	/// </summary>
	public: const static int64_t mbActionNo = 2LL;
	/// <summary>
	/// DB column: userid
	/// </summary>
	public: const static int64_t mbUserId = 4LL;
	/// <summary>
	/// DB column: acttime
	/// </summary>
	public: const static int64_t mbActTime = 8LL;
	/// <summary>
	/// DB column: docid
	/// </summary>
	public: const static int64_t mbObjId = 16LL;
	/// <summary>
	/// DB column: extra1
	/// </summary>
	public: const static int64_t mbExtra1 = 32LL;
	/// <summary>
	/// DB column: extra2
	/// </summary>
	public: const static int64_t mbExtra2 = 64LL;
	/// <summary>
	/// DB column: sessionno
	/// </summary>
	public: const static int64_t mbSessionNo = 128LL;
	/// <summary>
	/// DB column: addtext
	/// </summary>
	public: const static int64_t mbText = 256LL;
	/// <summary>
	/// DB column: addtext
	/// </summary>
	protected: int32_t lnText;
	/// <summary>
	/// Member bit: Reserved.
	/// </summary>
	/// <remarks>
	/// DB column: extra3
	/// </remarks>
	public: const static int64_t mbExtra3 = 512LL;
	/// <summary>
	/// Column length: Reserved.
	/// </summary>
	/// <remarks>
	/// DB column: extra3
	/// </remarks>
	protected: int32_t lnExtra3;
	/// <summary>
	/// All valid member bits.
	/// </summary>
	public: const static int64_t mbAllMembers = 1023LL;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: ReportC();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: ReportC(int64_t mbId, int32_t lnId, int64_t mbActionNo, int64_t mbUserId, int64_t mbActTime, int64_t mbObjId, int64_t mbExtra1, int64_t mbExtra2, int64_t mbSessionNo, int64_t mbText, int32_t lnText, int64_t mbExtra3, int32_t lnExtra3, int64_t mbAllMembers);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getLnId() { return lnId; }
	public: void setLnId(int32_t v);
	public: int32_t getLnText() { return lnText; }
	public: void setLnText(int32_t v);
	public: int32_t getLnExtra3() { return lnExtra3; }
	public: void setLnExtra3(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// ReportErpCode
// typeId=508806040

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// This class describes an ERP code - a filter code number in the ELO report.
/// </summary>
/// <remarks>
/// <p>Copyright: Copyright (c) 2004</p>
/// <p>Organisation: ELO Digital Office GmbH </p>
/// </remarks>
class ReportErpCode : public ValueClass {
	/// <summary>
	/// ERP code
	/// </summary>
	protected: int32_t id;
	/// <summary>
	/// This code is wirtten in limited report
	/// </summary>
	protected: bool limited;
	/// <summary>
	/// ERP name
	/// </summary>
	protected: ::std::wstring name;
	/// <summary>
	/// This code is written in verbose report
	/// </summary>
	protected: bool verbose;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: ReportErpCode();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: ReportErpCode(int32_t id, bool limited, const ::std::wstring& name, bool verbose);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getId() { return id; }
	public: void setId(int32_t v);
	public: bool getLimited() { return limited; }
	public: void setLimited(bool v);
	public: ::std::wstring getName() { return name; }
	public: void setName(::std::wstring v);
	public: bool getVerbose() { return verbose; }
	public: void setVerbose(bool v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// ReportInfo
// typeId=1280848136

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// This class describes a report/protocol entry for an action carried out in
/// the archive.
/// </summary>
/// <remarks>
/// <p>Copyright: Copyright (c) 2004</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </remarks>
class ReportInfo : public ValueClass {
	/// <summary>
	/// Reserved - internal function.
	/// </summary>
	protected: int32_t actTime;
	/// <summary>
	/// Action number in numeric form.
	/// </summary>
	protected: int32_t actionNo;
	/// <summary>
	/// Reserved - internal,  dependant on actionNo.
	/// </summary>
	protected: int32_t extra1;
	/// <summary>
	/// Reserved - internal,  dependant on actionNo
	/// </summary>
	protected: int32_t extra2;
	/// <summary>
	/// Identifier
	/// </summary>
	protected: ::std::wstring id;
	/// <summary>
	/// Id of the object for which the action is entered in the protocoll.
	/// </summary>
	protected: int32_t objId;
	/// <summary>
	/// Id of the session which carried out the action.
	/// </summary>
	protected: int32_t sessionNo;
	/// <summary>
	/// Reserved - internal,  dependant on actionNo
	/// </summary>
	protected: ::std::wstring text;
	/// <summary>
	/// Id of the user who carried out the action.
	/// </summary>
	protected: int32_t userId;
	/// <summary>
	/// Time of the action in ISO format.
	/// </summary>
	protected: ::std::wstring actTimeISO;
	/// <summary>
	/// ActionNo as name.
	/// </summary>
	protected: ::std::wstring action;
	/// <summary>
	/// Descriptive text or details.
	/// </summary>
	protected: ::std::wstring comment;
	/// <summary>
	/// Name of the user who carried out the action.
	/// </summary>
	protected: ::std::wstring userName;
	/// <summary>
	/// Reserved.
	/// </summary>
	protected: ::std::wstring extra3;
	/// <summary>
	/// Extra information.
	/// </summary>
	/// <remarks>
	/// This member is always null for report entries written by Windows-Client or by ELOix versions older than 9.00.016.
	/// The type of data depends on {@link #actionNo} as shown in the following table:
	/// <table>
	/// <tr><td>ReportInfoC.ACT_LOGIN_IX</td><td>{@link ReportInfoUserProps} object, member userInfo is set to the user logged on.</td></tr>
	/// <tr><td>ReportInfoC.ACT_IX_CREATE_USER</td><td>{@link ReportInfoUserModified} object, member newProps is set to the new user.</td></tr>
	/// <tr><td>ReportInfoC.ACT_IX_DELETE_USER</td><td>{@link ReportInfoUserModified} object, member newProps is set to deleted user.</td></tr>
	/// <tr><td>ReportInfoC.ACT_IX_CHECKIN_USER</td>
	/// <td>{@link ReportInfoUserModified} object, member newProps is set to the modified values.
	/// Member oldProps is set to the values before modification.
	/// </td></tr>
	/// </table>
	/// </remarks>
	protected: PSerializable extraInfo;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: ReportInfo();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: ReportInfo(int32_t actTime, int32_t actionNo, int32_t extra1, int32_t extra2, const ::std::wstring& id, int32_t objId, int32_t sessionNo, const ::std::wstring& text, int32_t userId, const ::std::wstring& actTimeISO, const ::std::wstring& action, const ::std::wstring& comment, const ::std::wstring& userName, const ::std::wstring& extra3, const PSerializable& extraInfo);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getActTime() { return actTime; }
	public: void setActTime(int32_t v);
	public: int32_t getActionNo() { return actionNo; }
	public: void setActionNo(int32_t v);
	public: int32_t getExtra1() { return extra1; }
	public: void setExtra1(int32_t v);
	public: int32_t getExtra2() { return extra2; }
	public: void setExtra2(int32_t v);
	public: ::std::wstring getId() { return id; }
	public: void setId(::std::wstring v);
	public: int32_t getObjId() { return objId; }
	public: void setObjId(int32_t v);
	public: int32_t getSessionNo() { return sessionNo; }
	public: void setSessionNo(int32_t v);
	public: ::std::wstring getText() { return text; }
	public: void setText(::std::wstring v);
	public: int32_t getUserId() { return userId; }
	public: void setUserId(int32_t v);
	public: ::std::wstring getActTimeISO() { return actTimeISO; }
	public: void setActTimeISO(::std::wstring v);
	public: ::std::wstring getAction() { return action; }
	public: void setAction(::std::wstring v);
	public: ::std::wstring getComment() { return comment; }
	public: void setComment(::std::wstring v);
	public: ::std::wstring getUserName() { return userName; }
	public: void setUserName(::std::wstring v);
	public: ::std::wstring getExtra3() { return extra3; }
	public: void setExtra3(::std::wstring v);
	public: PSerializable getExtraInfo() { return extraInfo; }
	public: void setExtraInfo(PSerializable v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// ReportInfoC
// typeId=1071192839

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Report information.
/// </summary>
/// <remarks>
/// <p>IndexServer writes the following report entries</p>
/// <table border="2">
/// <tr>
/// <td>ReportInfo.action</td>
/// <td>ReportInfo.objId</td>
/// <td>ReportInfo.extra1</td>
/// <td>ReportInfo.extra2</td>
/// <td>ReportInfo.comment</td>
/// </tr>
/// <tr>
/// <td>ACT_IX_LOGIN</td>
/// <td>0</td>
/// <td>SSO User ID</td>
/// <td>[EXTRA2_SSO_LOGIN]</td>
/// <td>Computer name</td>
/// </tr>
/// <tr>
/// <td>ACT_IX_LOGOUT</td>
/// <td>0</td>
/// <td>0</td>
/// <td>0</td>
/// <td>&nbsp;</td>
/// </tr>
/// <tr>
/// <td>ACT_IX_LOCK_ARCHIVE</td>
/// <td>0</td>
/// <td>Key ID</td>
/// <td>0</td>
/// <td>Key name</td>
/// </tr>
/// <tr>
/// <td>ACT_IX_CREATE_USER</td>
/// <td>0</td>
/// <td>User ID</td>
/// <td>User Flags</td>
/// <td>User name</td>
/// </tr>
/// <tr>
/// <td>ACT_IX_CHECKIN_USER</td>
/// <td>0</td>
/// <td>User ID</td>
/// <td>User Flags</td>
/// <td>User name</td>
/// </tr>
/// <tr>
/// <td>ACT_IX_DELETE_USER</td>
/// <td>0</td>
/// <td>User ID</td>
/// <td>User Flags</td>
/// <td>User name</td>
/// </tr>
/// <tr>
/// <td>ACT_IX_CREATE_KEY</td>
/// <td>0</td>
/// <td>Key ID</td>
/// <td>0</td>
/// <td>Key name</td>
/// </tr>
/// <tr>
/// <td>ACT_IX_CHECKIN_KEY</td>
/// <td>0</td>
/// <td>Key ID</td>
/// <td>0</td>
/// <td>Key name</td>
/// </tr>
/// <tr>
/// <td>ACT_IX_DELETE_KEY</td>
/// <td>0</td>
/// <td>Key ID</td>
/// <td>0</td>
/// <td>Key name</td>
/// </tr>
/// <tr>
/// <td>ACT_IX_CREATE_SORD</td>
/// <td>Object ID</td>
/// <td>Object type</td>
/// <td>Storage mask ID</td>
/// <td>Sord name</td>
/// </tr>
/// <tr>
/// <td>ACT_IX_CHECKOUT_SORD</td>
/// <td>Object ID</td>
/// <td>0</td>
/// <td>combination of EXTRA2_*</td>
/// <td>Sord name</td>
/// </tr>
/// <tr>
/// <td>ACT_IX_CHECKIN_SORD</td>
/// <td>Object ID</td>
/// <td>0</td>
/// <td>combination of EXTRA2_*</td>
/// <td>Sord name</td>
/// </tr>
/// <tr>
/// <td>ACT_IX_DELETE_SORD</td>
/// <td>Object ID</td>
/// <td>Object type</td>
/// <td>combination of EXTRA2_*</td>
/// <td>Sord name</td>
/// </tr>
/// <tr>
/// <td>ACT_IX_DELETE_REFERENCE</td>
/// <td>Object ID</td>
/// <td>Parent ID</td>
/// <td>combination of EXTRA2_*</td>
/// <td>Sord name</td>
/// </tr>
/// <tr>
/// <td>ACT_IX_COPY_SORD</td>
/// <td>unsupported</td>
/// <td></td>
/// <td></td>
/// <td>&nbsp;</td>
/// </tr>
/// <tr>
/// <td>ACT_IX_REFERENCE_SORD</td>
/// <td>Parent ID</td>
/// <td>Object ID</td>
/// <td></td>
/// <td>Parent name, Object name</td>
/// </tr>
/// <tr>
/// <td>ACT_IX_MOVE_SORD</td>
/// <td>New parent ID</td>
/// <td>Object ID</td>
/// <td>Old parent ID</td>
/// <td>New parent name, old parent name, Sord name</td>
/// </tr>
/// <tr>
/// <td>ACT_IX_LINK_SORD</td>
/// <td>From object ID</td>
/// <td>To object ID</td>
/// <td>
/// </td>
/// <td>From Sord name, To Sord name</td>
/// </tr>
/// <tr>
/// <td>ACT_IX_UNLINK_SORD</td>
/// <td>From object ID</td>
/// <td>To object ID</td>
/// <td>
/// </td>
/// <td>From Sord name, To Sord name</td>
/// </tr>
/// <tr>
/// <td>ACT_IX_CHECKOUT_DOCVERSION</td>
/// <td>Object ID</td>
/// <td>Document version ID</td>
/// <td>combination of EXTRA2_*</td>
/// <td>Objektname, Versionsnummer</td>
/// </tr>
/// <tr>
/// <td>ACT_IX_CHECKIN_DOCVERSION</td>
/// <td>Objekt-ID</td>
/// <td>Doc-ID</td>
/// <td>combination of EXTRA2_*</td>
/// <td>Objektname, Versionsnummer</td>
/// </tr>
/// <tr>
/// <td>ACT_IX_CREATE_DOC_MASK</td>
/// <td>0</td>
/// <td>Mask-ID</td>
/// <td>0</td>
/// <td>Maskname</td>
/// </tr>
/// <tr>
/// <td>ACT_IX_CHECKIN_DOC_MASK</td>
/// <td>0</td>
/// <td>Mask-ID</td>
/// <td>0</td>
/// <td>Maskname</td>
/// </tr>
/// <tr>
/// <td>ACT_IX_DELETE_DOC_MASK</td>
/// <td>0</td>
/// <td>Mask-ID</td>
/// <td>replace with Mask-ID</td>
/// <td>Maskname</td>
/// </tr>
/// <tr>
/// <td>ACT_IX_CHECKIN_REPL_NAME</td>
/// <td>0</td>
/// <td>Repl-ID</td>
/// <td>0</td>
/// <td>ReplSet-Name</td>
/// </tr>
/// <tr>
/// <td>ACT_IX_CHECKIN_REPORT_OPTIONS</td>
/// <td>0</td>
/// <td>0</td>
/// <td>0</td>
/// <td>&nbsp;</td>
/// </tr>
/// <tr>
/// <td>ACT_IX_DELETE_REPORT</td>
/// <td>0</td>
/// <td>endDate</td>
/// <td>0</td>
/// <td>TS-End-Date</td>
/// </tr>
/// <tr>
/// <td>ACT_IX_CHECKIN_COLOR</td>
/// <td>0</td>
/// <td>Color-ID</td>
/// <td>rgb</td>
/// <td>Color-Name</td>
/// </tr>
/// <tr>
/// <td>ACT_IX_CHECKIN_USER_PROFILE</td>
/// <td>0</td>
/// <td>For User-ID</td>
/// <td>0</td>
/// <td>User-Name</td>
/// </tr>
/// <tr>
/// <td>ACT_IX_DELETE_USER_PROFILE</td>
/// <td>0</td>
/// <td>For User-ID</td>
/// <td>0</td>
/// <td>User-Name</td>
/// </tr>
/// <tr>
/// <td>ACT_IX_CREATE_WORKFLOW</td>
/// <td>0</td>
/// <td>Workflow-ID</td>
/// <td>combination of EXTRA2_*</td>
/// <td>Workflow-Name</td>
/// </tr>
/// <tr>
/// <td>ACT_IX_CHECKIN_WORKFLOW</td>
/// <td>0</td>
/// <td>Workflow-ID</td>
/// <td>combination of EXTRA2_*</td>
/// <td>Workflow-Name</td>
/// </tr>
/// <tr>
/// <td>ACT_IX_DELETE_WORKFLOW</td>
/// <td>0</td>
/// <td>Workflow-ID</td>
/// <td>combination of EXTRA2_*</td>
/// <td>Workflow name</td>
/// </tr>
/// <tr>
/// <td>ACT_IX_EDIT_WORKFLOW_NODE</td>
/// <td>Object-ID</td>
/// <td>Workflow-ID</td>
/// <td>Node-ID</td>
/// <td>Node name</td>
/// </tr>
/// <tr>
/// <td>ACT_IX_START_WORKFLOW</td>
/// <td>Object-ID</td>
/// <td>Workflow-ID</td>
/// <td>Template-WF-ID</td>
/// <td>Workflow name</td>
/// </tr>
/// <tr>
/// <td>ACT_IX_START_ADHOC_WORKFLOW</td>
/// <td>Object-ID</td>
/// <td>Workflow-ID</td>
/// <td>0</td>
/// <td>Workflow name</td>
/// </tr>
/// <tr>
/// <td>ACT_IX_TERMINATE_WORKFLOW</td>
/// <td>Object-ID</td>
/// <td>Workflow-ID</td>
/// <td>0</td>
/// <td>Workflow-Name</td>
/// </tr>
/// <tr>
/// <td>ACT_IX_CHECKIN_CONFIG_FILE</td>
/// <td>0</td>
/// <td>0</td>
/// <td>0</td>
/// <td>Config file name</td>
/// </tr>
/// <tr>
/// <td>ACT_IX_DELETE_CONFIG_FILE</td>
/// <td>0</td>
/// <td>0</td>
/// <td>0</td>
/// <td>Config file name</td>
/// </tr>
/// <tr>
/// <td>ACT_IX_CHECKIN_COUNTER</td>
/// <td>0</td>
/// <td>Value</td>
/// <td>0</td>
/// <td>Counter-Name</td>
/// </tr>
/// <tr>
/// <td>ACT_IX_DELETE_COUNTER</td>
/// <td>0</td>
/// <td>0</td>
/// <td>0</td>
/// <td>Counter-Name</td>
/// </tr>
/// <tr>
/// <td>ACT_IX_INCREMENT_COUNTER</td>
/// <td>0</td>
/// <td>Value</td>
/// <td>0</td>
/// <td>Counter name</td>
/// </tr>
/// <tr>
/// <td>ACT_IX_CHECKIN_SORD_TYPE</td>
/// <td>0</td>
/// <td>ID (Sord.type)</td>
/// <td>0</td>
/// <td>Type name</td>
/// </tr>
/// <tr>
/// <td>ACT_IX_DELETE_SORD_TYPE</td>
/// <td>0</td>
/// <td>ID (Sord.type)</td>
/// <td>0</td>
/// <td>Type name</td>
/// </tr>
/// <tr>
/// <td>ACT_IX_CREATE_NOTE</td>
/// <td>Objekt-ID</td>
/// <td>Note-ID (internal)</td>
/// <td>combination of EXTRA2_*</td>
/// <td>Note-Guid</td>
/// </tr>
/// <tr>
/// <td>ACT_IX_CHECKIN_NOTE</td>
/// <td>Objekt-ID</td>
/// <td>Note-ID (internal)</td>
/// <td>combination of EXTRA2_*</td>
/// <td>Note-Guid</td>
/// </tr>
/// <tr>
/// <td>ACT_IX_DELETE_NOTE</td>
/// <td>Objekt-ID</td>
/// <td>Note-ID (internal)</td>
/// <td>combination of EXTRA2_*</td>
/// <td>Note-Guid</td>
/// </tr>
/// <tr>
/// <td>ACT_DM_READDOC</td>
/// <td>Objekt-ID</td>
/// <td>Doc-ID</td>
/// <td>0</td>
/// <td>&nbsp;</td>
/// </tr>
/// </table>
/// 
/// <p>
/// To enable or disable reporting of actions, action codes have to be transformed into
/// ERP codes first. One ERP code can subsume serverel action codes. The ERP codes
/// can be used in checkinReportOptions to manipulate reporting. Furthermore they
/// can be used in findFirstReportInfos, FindReportInfo, to search for reported actions.
/// The following table shows how actions codes are mapped to report options.
/// </p>
/// 
/// <table border="2">
/// <tr><td>Action code, ReportInfoC</td><td>ERP code, ReportOptionsC </td></tr>
/// <tr><td>ACT_CLIENT_ELOSTART           </td><td>ERP_LOGOPENARC     </td></tr>
/// <tr><td>ACT_CLIENT_ELOEND             </td><td>ERP_LOGCLOSEARC    </td></tr>
/// <tr><td>ACT_CLIENT_COMPLAIN           </td><td>ERP_LOGCOMPLAIN    </td></tr>
/// <tr><td>ACT_CLIENT_DELETEDOCS         </td><td>ERP_LOGERADOC      </td></tr>
/// <tr><td>ACT_CLIENT_KEYCHANGED         </td><td>ERP_LOGCHANGEKEY   </td></tr>
/// <tr><td>ACT_CLIENT_USERCHANGED        </td><td>ERP_LOGUSERDATA    </td></tr>
/// <tr><td>ACT_CLIENT_COLORCHANGED       </td><td>ERP_LOGCHANGEKIND  </td></tr>
/// <tr><td>ACT_CLIENT_PATHCHANGED        </td><td>ERP_LOGPATHDATA    </td></tr>
/// <tr><td>ACT_CLIENT_MASKCHANGED        </td><td>ERP_LOGMASKDATA    </td></tr>
/// <tr><td>ACT_CLIENT_PWDCHANGED         </td><td>ERP_LOGCHANGEPWD   </td></tr>
/// <tr><td>ACT_CLIENT_CREATEDOC          </td><td>ERP_LOGCREATEDOC   </td></tr>
/// <tr><td>ACT_CLIENT_EDITDOC            </td><td>ERP_LOGEDITDOC     </td></tr>
/// <tr><td>ACT_CLIENT_CHANGEDOC          </td><td>ERP_LOGEDITDOC     </td></tr>
/// <tr><td>ACT_CLIENT_CHANGEATTACH       </td><td>ERP_LOGEDITDOC     </td></tr>
/// <tr><td>ACT_CLIENT_VIEWDOC            </td><td>ERP_LOGVIEWDOC     </td></tr>
/// <tr><td>ACT_CLIENT_ERASEDOC           </td><td>ERP_LOGERADOC      </td></tr>
/// <tr><td>ACT_CLIENT_MOVEDOC            </td><td>ERP_LOGMOVEDOC     </td></tr>
/// <tr><td>ACT_CLIENT_REFDOC             </td><td>ERP_LOGREFDOC      </td></tr>
/// <tr><td>ACT_CLIENT_CHANGEKEY          </td><td>ERP_LOGCHANGEKEY   </td></tr>
/// <tr><td>ACT_CLIENT_CHANGEKIND         </td><td>ERP_LOGCHANGEKIND  </td></tr>
/// <tr><td>ACT_CLIENT_CONVERT_FORMAT     </td><td>ERP_CONVERT_FORMAT </td></tr>
/// <tr><td>ACT_CLIENT_CHECKOUT           </td><td>ERP_CHECKOUT       </td></tr>
/// <tr><td>ACT_CLIENT_CHECKIN            </td><td>ERP_CHECKIN        </td></tr>
/// <tr><td>ACT_CLIENT_CREATESOR          </td><td>ERP_LOGCREATESOR   </td></tr>
/// <tr><td>ACT_CLIENT_CHANGESOR          </td><td>ERP_LOGEDITDATA    </td></tr>
/// <tr><td>ACT_CLIENT_EDITSOR            </td><td>ERP_LOGEDITDATA    </td></tr>
/// <tr><td>ACT_CLIENT_ERASESOR           </td><td>ERP_LOGERASOR      </td></tr>
/// <tr><td>ACT_CLIENT_MOVESOR            </td><td>ERP_LOGMOVESOR     </td></tr>
/// <tr><td>ACT_CLIENT_REFSOR             </td><td>ERP_LOGREFSOR      </td></tr>
/// <tr><td>ACT_CLIENT_ADDREF             </td><td>ERP_LOGREFDOC      </td></tr>
/// <tr><td>ACT_CLIENT_ERASEREF           </td><td>ERP_LOGERAREF      </td></tr>
/// <tr><td>ACT_CLIENT_MOVEREF            </td><td>ERP_LOGMOVEDOC     </td></tr>
/// <tr><td>ACT_CLIENT_WVNEW              </td><td>ERP_WV             </td></tr>
/// <tr><td>ACT_CLIENT_WVCHANGE           </td><td>ERP_WV             </td></tr>
/// <tr><td>ACT_CLIENT_WVDELETE           </td><td>ERP_WV             </td></tr>
/// <tr><td>ACT_CLIENT_WVSEND             </td><td>ERP_WV             </td></tr>
/// <tr><td>ACT_CLIENT_WVRECEIVE          </td><td>ERP_WV             </td></tr>
/// <tr><td>ACT_CLIENT_WVNEWSEND          </td><td>ERP_WV             </td></tr>
/// <tr><td>ACT_CLIENT_WVCHANGESEND       </td><td>ERP_WV             </td></tr>
/// <tr><td>ACT_CLIENT_POSTFIRST          </td><td>ERP_POSTBOX        </td></tr>
/// <tr><td>ACT_CLIENT_POSTDELETE         </td><td>ERP_POSTBOX        </td></tr>
/// <tr><td>ACT_CLIENT_POSTDOCBUILD       </td><td>ERP_POSTBOX        </td></tr>
/// <tr><td>ACT_CLIENT_POSTEDIT           </td><td>ERP_POSTBOX        </td></tr>
/// <tr><td>ACT_CLIENT_POSTSCHLAGWORT     </td><td>ERP_POSTBOX        </td></tr>
/// <tr><td>ACT_CLIENT_POSTCOPYTO         </td><td>ERP_POSTBOX        </td></tr>
/// <tr><td>ACT_CLIENT_POSTMOVETO         </td><td>ERP_POSTBOX        </td></tr>
/// <tr><td>ACT_CLIENT_POSTMOVE           </td><td>ERP_POSTBOX        </td></tr>
/// <tr><td>ACT_CLIENT_POSTCOLLECT        </td><td>ERP_POSTBOX        </td></tr>
/// <tr><td>ACT_CLIENT_POSTNEWOLE         </td><td>ERP_POSTBOX        </td></tr>
/// <tr><td>ACT_CLIENT_POSTEXPAND         </td><td>ERP_POSTBOX        </td></tr>
/// <tr><td>ACT_CLIENT_POSTIMPORT         </td><td>ERP_POSTBOX        </td></tr>
/// <tr><td>ACT_CLIENT_POSTLAST           </td><td>ERP_POSTBOX        </td></tr>
/// <tr><td>ACT_CLIENT_CREATEFLOWTEMPL    </td><td>ERP_CREATEFLOWTEMPL</td></tr>
/// <tr><td>ACT_CLIENT_EDITFLOWTEMPL      </td><td>ERP_EDITFLOWTEMPL  </td></tr>
/// <tr><td>ACT_CLIENT_DELFLOWTEMPL       </td><td>ERP_DELFLOWTEMPL   </td></tr>
/// <tr><td>ACT_CLIENT_STARTFLOW          </td><td>ERP_STARTFLOW      </td></tr>
/// <tr><td>ACT_CLIENT_RECEIVEFLOW        </td><td>ERP_RECEIVEFLOW    </td></tr>
/// <tr><td>ACT_CLIENT_FORWARDFLOW        </td><td>ERP_FORWARDFLOW    </td></tr>
/// <tr><td>ACT_CLIENT_EDITFLOWACTIVE     </td><td>ERP_EDITFLOWACTIVE </td></tr>
/// <tr><td>ACT_CLIENT_DELFLOWACTIVE      </td><td>ERP_DELFLOWACTIVE  </td></tr>
/// <tr><td>ACT_CLIENT_FLOWTIMELIMIT      </td><td>ERP_FLOWTIMELIMT   </td></tr>
/// <tr><td>ACT_CLIENT_FLOWERRORYESNO     </td><td>ERP_FLOWERRORYESNO </td></tr>
/// <tr><td>ACT_CLIENT_REPORTCHANGED      </td><td>ERP_VERSCHIEDEN    </td></tr>
/// <tr><td>ACT_CLIENT_MASKTEXTTOOLONG    </td><td>ERP_VERSCHIEDEN    </td></tr>
/// <tr><td>ACT_CLIENT_NEWVERT         </td><td>ERP_NEWVERT    </td></tr>
/// <tr><td>ACT_CLIENT_DELVERT         </td><td>ERP_DELVERT    </td></tr>
/// <tr><td>ACT_CLIENT_FREEVERT        </td><td>ERP_FREEVERT   </td></tr>
/// <tr><td>ACT_CLIENT_REMOVEVERT         </td><td>ERP_REMOVEVERT     </td></tr>
/// <tr><td>ACT_CLIENT_SETVERT         </td><td>ERP_SETVERT    </td></tr>
/// <tr><td>ACT_CLIENT_RESETVERT          </td><td>ERP_RESETVERT      </td></tr>
/// <tr><td>ACT_CLIENT_SHOWDOC            </td><td>ERP_SHOWDOC        </td></tr>
/// <tr><td>ACT_CLIENT_SHOWSOR            </td><td>ERP_SHOWSOR        </td></tr>
/// <tr><td>ACT_CLIENT_DELVERSION         </td><td>ERP_DELVERSION     </td></tr>
/// <tr><td>ACT_CLIENT_PICKPOST           </td><td>ERP_PICKPOST       </td></tr>
/// <tr><td>ACT_DM_READDOC                </td><td>ERP_LOGVIEWDOC     </td></tr>
/// <tr><td>ACT_IX_LOGIN                   </td><td>ERP_LOGOPENARC</td></tr>
/// <tr><td>ACT_IX_LOGOUT                  </td><td>ERP_LOGCLOSEARC</td></tr>
/// <tr><td>ACT_IX_LOCK_ARCHIVE            </td><td>ERP_LOGCHANGEKEY</td></tr>
/// <tr><td>ACT_IX_CREATE_USER             </td><td>ERP_LOGUSERDATA</td></tr>
/// <tr><td>ACT_IX_CHECKIN_USER            </td><td>ERP_LOGUSERDATA</td></tr>
/// <tr><td>ACT_IX_DELETE_USER             </td><td>ERP_LOGUSERDATA</td></tr>
/// <tr><td>ACT_IX_CREATE_KEY              </td><td>ERP_LOGCHANGEKEY</td></tr>
/// <tr><td>ACT_IX_CHECKIN_KEY             </td><td>ERP_LOGCHANGEKEY</td></tr>
/// <tr><td>ACT_IX_DELETE_KEY              </td><td>ERP_LOGCHANGEKEY</td></tr>
/// <tr><td>ACT_IX_CREATE_SORD             </td><td>ERP_LOGCREATEDOC</td></tr>
/// <tr><td>ACT_IX_CHECKOUT_SORD           </td><td>ERP_LOGVIEWDOC</td></tr>
/// <tr><td>ACT_IX_CHECKIN_SORD            </td><td>ERP_LOGEDITDOC</td></tr>
/// <tr><td>ACT_IX_DELETE_SORD             </td><td>ERP_LOGERADOC</td></tr>
/// <tr><td>ACT_IX_DELETE_REFERENCE        </td><td>ERP_LOGERAREF</td></tr>
/// <tr><td>ACT_IX_COPY_SORD               </td><td>ERP_LOGCREATEDOC</td></tr>
/// <tr><td>ACT_IX_REFERENCE_SORD          </td><td>ERP_LOGREFDOC</td></tr>
/// <tr><td>ACT_IX_MOVE_SORD               </td><td>ERP_LOGMOVEDOC</td></tr>
/// <tr><td>ACT_IX_LINK_SORD               </td><td>ERP_LOGREFDOC</td></tr>
/// <tr><td>ACT_IX_UNLINK_SORD             </td><td>ERP_LOGREFDOC</td></tr>
/// <tr><td>ACT_IX_CHECKOUT_DOCVERSION     </td><td>ERP_LOGVIEWDOC</td></tr>
/// <tr><td>ACT_IX_CHECKIN_DOCVERSION      </td><td>ERP_CHECKIN</td></tr>
/// <tr><td>ACT_IX_CREATE_DOC_MASK         </td><td>ERP_LOGMASKDATA</td></tr>
/// <tr><td>ACT_IX_CHECKIN_DOC_MASK        </td><td>ERP_LOGMASKDATA</td></tr>
/// <tr><td>ACT_IX_DELETE_DOC_MASK         </td><td>ERP_LOGMASKDATA</td></tr>
/// <tr><td>ACT_IX_CHECKIN_REPL_NAME       </td><td>ERP_LOGKEYDATA</td></tr>
/// <tr><td>ACT_IX_CHECKIN_REPORT_OPTIONS  </td><td>ERP_LOGKEYDATA</td></tr>
/// <tr><td>ACT_IX_DELETE_REPORT           </td><td>ERP_LOGKEYDATA</td></tr>
/// <tr><td>ACT_IX_CHECKIN_COLOR           </td><td>ERP_LOGCOLORDATA</td></tr>
/// <tr><td>ACT_IX_CHECKIN_USER_PROFILE    </td><td>ERP_LOGKEYDATA</td></tr>
/// <tr><td>ACT_IX_DELETE_USER_PROFILE     </td><td>ERP_LOGKEYDATA</td></tr>
/// <tr><td>ACT_IX_CREATE_WORKFLOW         </td><td>ERP_CREATEFLOWTEMPL</td></tr>
/// <tr><td>ACT_IX_CHECKIN_WORKFLOW        </td><td>ERP_EDITFLOWTEMPL</td></tr>
/// <tr><td>ACT_IX_DELETE_WORKFLOW         </td><td>ERP_DELFLOWTEMPL</td></tr>
/// <tr><td>ACT_IX_EDIT_WORKFLOW_NODE      </td><td>ERP_FORWARDFLOW</td></tr>
/// <tr><td>ACT_IX_START_WORKFLOW          </td><td>ERP_STARTFLOW</td></tr>
/// <tr><td>ACT_IX_START_ADHOC_WORKFLOW    </td><td>ERP_STARTFLOW</td></tr>
/// <tr><td>ACT_IX_TERMINATE_WORKFLOW      </td><td>ERP_FORWARDFLOW</td></tr>
/// <tr><td>ACT_IX_TAKE_WORKFLOW_NODE    </td><td>ERP_FORWARDFLOW</td></tr>
/// <tr><td>ACT_IX_CHECKIN_CONFIG_FILE     </td><td>ERP_LOGKEYDATA</td></tr>
/// <tr><td>ACT_IX_DELETE_CONFIG_FILE      </td><td>ERP_LOGKEYDATA</td></tr>
/// <tr><td>ACT_IX_CHECKIN_COUNTER         </td><td>ERP_LOGKEYDATA</td></tr>
/// <tr><td>ACT_IX_DELETE_COUNTER          </td><td>ERP_LOGKEYDATA</td></tr>
/// <tr><td>ACT_IX_INCREMENT_COUNTER       </td><td>ERP_LOGKEYDATA</td></tr>
/// <tr><td>ACT_IX_CHECKIN_SORD_TYPE       </td><td>ERP_LOGKEYDATA</td></tr>
/// <tr><td>ACT_IX_DELETE_SORD_TYPE        </td><td>ERP_LOGKEYDATA</td></tr>
/// <tr><td>ACT_IX_CREATE_NOTE             </td><td>ERP_LOGKEYDATA</td></tr>
/// <tr><td>ACT_IX_CHECKIN_NOTE            </td><td>ERP_LOGEDITDOC</td></tr>
/// <tr><td>ACT_IX_CHECKOUT_NOTE           </td><td>ERP_LOGEDITDOC</td></tr>
/// <tr><td>ACT_IX_DELETE_NOTE             </td><td>ERP_LOGEDITDOC</td></tr>
/// <tr><td>ACT_IX_NEWVERT                   </td><td>ERP_NEWVERT   </td></tr>
/// <tr><td>ACT_IX_DELVERT                   </td><td>ERP_DELVERT   </td></tr>
/// <tr><td>ACT_IX_FREEVERT          </td><td>ERP_FREEVERT    </td></tr>
/// <tr><td>ACT_IX_REMOVEVERT              </td><td>ERP_REMOVEVERT</td></tr>
/// <tr><td>ACT_IX_SETVERT                   </td><td>ERP_SETVERT   </td></tr>
/// <tr><td>ACT_IX_RESETVERT               </td><td>ERP_RESETVERT </td></tr>
/// <tr><td>ACT_DM_READDOC                </td><td>ERP_DM_READDOC </td></tr>
/// </table>
/// </remarks>
class ReportInfoC : public ReportC {
	public: const static int32_t ACT_CLIENT_NONE = 0;
	/// <summary>
	/// Login.
	/// </summary>
	public: const static int32_t ACT_CLIENT_ELOSTART = 1;
	/// <summary>
	/// Logout.
	/// </summary>
	public: const static int32_t ACT_CLIENT_ELOEND = 2;
	/// <summary>
	/// unused
	/// </summary>
	public: const static int32_t ACT_CLIENT_COMPLAIN = 3;
	/// <summary>
	/// unused
	/// </summary>
	public: const static int32_t ACT_CLIENT_DELETEDOCS = 4;
	/// <summary>
	/// Used to report a write access session.
	/// </summary>
	public: const static int32_t ACT_ISWRITESESSION = 5;
	/// <summary>
	/// unused
	/// </summary>
	public: const static int32_t ACT_CLIENT_KEYCHANGED = 10;
	/// <summary>
	/// unused
	/// </summary>
	public: const static int32_t ACT_CLIENT_USERCHANGED = 11;
	/// <summary>
	/// unused
	/// </summary>
	public: const static int32_t ACT_CLIENT_COLORCHANGED = 12;
	/// <summary>
	/// unused
	/// </summary>
	public: const static int32_t ACT_CLIENT_PATHCHANGED = 13;
	/// <summary>
	/// unused
	/// </summary>
	public: const static int32_t ACT_CLIENT_MASKCHANGED = 14;
	/// <summary>
	/// unused
	/// </summary>
	public: const static int32_t ACT_CLIENT_REPORTCHANGED = 15;
	/// <summary>
	/// unused
	/// </summary>
	public: const static int32_t ACT_CLIENT_PWDCHANGED = 16;
	/// <summary>
	/// Used to report search completed
	/// </summary>
	public: const static int32_t ACT_CLIENT_SEARCH = 17;
	/// <summary>
	/// Create a new document entry (for indexing information) in the archive database.
	/// </summary>
	/// <remarks>
	/// ReportInfo.text contains the document name (short description).
	/// </remarks>
	public: const static int32_t ACT_CLIENT_CREATEDOC = 100;
	/// <summary>
	/// unused
	/// </summary>
	public: const static int32_t ACT_CLIENT_CHANGEDOC = 101;
	/// <summary>
	/// Write the indexing information of a document.
	/// </summary>
	public: const static int32_t ACT_CLIENT_EDITDOC = 102;
	/// <summary>
	/// Read the indexing information of a document.
	/// </summary>
	public: const static int32_t ACT_CLIENT_VIEWDOC = 103;
	/// <summary>
	/// Delete/undelete document.
	/// </summary>
	/// <remarks>
	/// <table border="2">
	/// <tr><td>ReportInfo.extra1</td><td>parent ID.</td></tr>
	/// <tr><td>ReportInfo.extra2</td><td>0 if deleted, 1 if undeleted.</td></tr>
	/// <tr><td>ReportInfo.text</td><td>sord name.</td></tr>
	/// </table>
	/// </remarks>
	public: const static int32_t ACT_CLIENT_ERASEDOC = 104;
	/// <summary>
	/// unused
	/// </summary>
	public: const static int32_t ACT_CLIENT_MOVEDOC = 105;
	/// <summary>
	/// unused
	/// </summary>
	public: const static int32_t ACT_CLIENT_REFDOC = 106;
	/// <summary>
	/// unused
	/// </summary>
	public: const static int32_t ACT_CLIENT_CHANGEKEY = 107;
	/// <summary>
	/// unused
	/// </summary>
	public: const static int32_t ACT_CLIENT_CHANGEKIND = 108;
	/// <summary>
	/// unused
	/// </summary>
	public: const static int32_t ACT_CLIENT_CHANGEATTACH = 109;
	/// <summary>
	/// unused
	/// </summary>
	public: const static int32_t ACT_CLIENT_CONVERT_FORMAT = 110;
	/// <summary>
	/// Get document file for editing.
	/// </summary>
	/// <remarks>
	/// This report information is written,
	/// if IXServicePortIF.checkoutDoc is called with lock.
	/// </remarks>
	public: const static int32_t ACT_CLIENT_CHECKOUT = 111;
	/// <summary>
	/// Checkin a new document file.
	/// </summary>
	/// <remarks>
	/// ReportInfo.extra1 ist set to the new document ID
	/// </remarks>
	public: const static int32_t ACT_CLIENT_CHECKIN = 112;
	/// <summary>
	/// Get document file to display (not to edit).
	/// </summary>
	/// <remarks>
	/// This report information is written,
	/// if IXServicePortIF.checkoutDoc is called without lock.
	/// </remarks>
	public: const static int32_t ACT_CLIENT_SHOWDOC = 113;
	public: const static int32_t ACT_CLIENT_DELVERSION = 114;
	/// <summary>
	/// Create new Sord object
	/// </summary>
	public: const static int32_t ACT_CLIENT_CREATESOR = 150;
	/// <summary>
	/// unused
	/// </summary>
	public: const static int32_t ACT_CLIENT_CHANGESOR = 151;
	/// <summary>
	/// Edited new Sord object
	/// </summary>
	public: const static int32_t ACT_CLIENT_EDITSOR = 152;
	/// <summary>
	/// Checkout Sord object without lock
	/// </summary>
	public: const static int32_t ACT_CLIENT_VIEWSOR = 153;
	/// <summary>
	/// Delete/undelete document.
	/// </summary>
	/// <remarks>
	/// <table border="2">
	/// <tr><td>ReportInfo.extra1</td><td>parent ID.</td></tr>
	/// <tr><td>ReportInfo.extra2</td><td>0 if deleted, 1 if undeleted.</td></tr>
	/// <tr><td>ReportInfo.text</td><td>sord name.</td></tr>
	/// </table>
	/// </remarks>
	public: const static int32_t ACT_CLIENT_ERASESOR = 154;
	/// <summary>
	/// unused
	/// </summary>
	public: const static int32_t ACT_CLIENT_MOVESOR = 155;
	/// <summary>
	/// unused
	/// </summary>
	public: const static int32_t ACT_CLIENT_REFSOR = 156;
	/// <summary>
	/// unused
	/// </summary>
	public: const static int32_t ACT_CLIENT_SHOWSOR = 157;
	/// <summary>
	/// unused
	/// </summary>
	public: const static int32_t ACT_CLIENT_ADDREF = 200;
	/// <summary>
	/// Delete/undelete document.
	/// </summary>
	/// <remarks>
	/// <table border="2">
	/// <tr><td>ReportInfo.extra1</td><td>parent ID.</td></tr>
	/// <tr><td>ReportInfo.extra2</td><td>0 if deleted, 1 if undeleted.</td></tr>
	/// </table>
	/// </remarks>
	public: const static int32_t ACT_CLIENT_ERASEREF = 201;
	/// <summary>
	/// unused
	/// </summary>
	public: const static int32_t ACT_CLIENT_MOVEREF = 202;
	/// <summary>
	/// unused
	/// </summary>
	public: const static int32_t ACT_CLIENT_WVFIRST = 220;
	/// <summary>
	/// unused
	/// </summary>
	public: const static int32_t ACT_CLIENT_WVNEW = 220;
	/// <summary>
	/// unused
	/// </summary>
	public: const static int32_t ACT_CLIENT_WVCHANGE = 221;
	/// <summary>
	/// unused
	/// </summary>
	public: const static int32_t ACT_CLIENT_WVDELETE = 222;
	/// <summary>
	/// unused
	/// </summary>
	public: const static int32_t ACT_CLIENT_WVSEND = 223;
	/// <summary>
	/// unused
	/// </summary>
	public: const static int32_t ACT_CLIENT_WVRECEIVE = 224;
	/// <summary>
	/// unused
	/// </summary>
	public: const static int32_t ACT_CLIENT_WVNEWSEND = 225;
	/// <summary>
	/// unused
	/// </summary>
	public: const static int32_t ACT_CLIENT_WVCHANGESEND = 226;
	/// <summary>
	/// unused
	/// </summary>
	public: const static int32_t ACT_CLIENT_WVLAST = 239;
	/// <summary>
	/// unused
	/// </summary>
	public: const static int32_t ACT_CLIENT_POSTFIRST = 240;
	/// <summary>
	/// unused
	/// </summary>
	public: const static int32_t ACT_CLIENT_POSTDELETE = 241;
	/// <summary>
	/// unused
	/// </summary>
	public: const static int32_t ACT_CLIENT_POSTDOCBUILD = 242;
	/// <summary>
	/// unused
	/// </summary>
	public: const static int32_t ACT_CLIENT_POSTEDIT = 243;
	/// <summary>
	/// unused
	/// </summary>
	public: const static int32_t ACT_CLIENT_POSTSCHLAGWORT = 244;
	/// <summary>
	/// unused
	/// </summary>
	public: const static int32_t ACT_CLIENT_POSTCOPYTO = 245;
	/// <summary>
	/// unused
	/// </summary>
	public: const static int32_t ACT_CLIENT_POSTMOVETO = 246;
	/// <summary>
	/// unused
	/// </summary>
	public: const static int32_t ACT_CLIENT_POSTMOVE = 247;
	/// <summary>
	/// unused
	/// </summary>
	public: const static int32_t ACT_CLIENT_POSTCOLLECT = 248;
	/// <summary>
	/// unused
	/// </summary>
	public: const static int32_t ACT_CLIENT_POSTNEWOLE = 249;
	/// <summary>
	/// unused
	/// </summary>
	public: const static int32_t ACT_CLIENT_POSTEXPAND = 250;
	/// <summary>
	/// unused
	/// </summary>
	public: const static int32_t ACT_CLIENT_POSTIMPORT = 251;
	/// <summary>
	/// unused
	/// </summary>
	public: const static int32_t ACT_CLIENT_POSTRECEIVE = 252;
	/// <summary>
	/// unused
	/// </summary>
	public: const static int32_t ACT_CLIENT_POSTLAST = 259;
	/// <summary>
	/// unused
	/// </summary>
	public: const static int32_t ACT_CLIENT_CREATEFLOWTEMPL = 300;
	/// <summary>
	/// unused
	/// </summary>
	public: const static int32_t ACT_CLIENT_EDITFLOWTEMPL = 301;
	/// <summary>
	/// unused
	/// </summary>
	public: const static int32_t ACT_CLIENT_DELFLOWTEMPL = 302;
	/// <summary>
	/// unused
	/// </summary>
	public: const static int32_t ACT_CLIENT_STARTFLOW = 303;
	/// <summary>
	/// unused
	/// </summary>
	public: const static int32_t ACT_CLIENT_RECEIVEFLOW = 304;
	/// <summary>
	/// unused
	/// </summary>
	public: const static int32_t ACT_CLIENT_FORWARDFLOW = 305;
	/// <summary>
	/// unused
	/// </summary>
	public: const static int32_t ACT_CLIENT_EDITFLOWACTIVE = 306;
	/// <summary>
	/// unused
	/// </summary>
	public: const static int32_t ACT_CLIENT_DELFLOWACTIVE = 307;
	/// <summary>
	/// unused
	/// </summary>
	public: const static int32_t ACT_CLIENT_FLOWTIMELIMIT = 308;
	/// <summary>
	/// unused
	/// </summary>
	public: const static int32_t ACT_CLIENT_FLOWERRORYESNO = 309;
	/// <summary>
	/// unused
	/// </summary>
	public: const static int32_t ACT_CLIENT_MASKTEXTTOOLONG = 351;
	/// <summary>
	/// unused
	/// </summary>
	public: const static int32_t ACT_CLIENT_NEWVERT = 370;
	/// <summary>
	/// unused
	/// </summary>
	public: const static int32_t ACT_CLIENT_DELVERT = 371;
	/// <summary>
	/// unused
	/// </summary>
	public: const static int32_t ACT_CLIENT_FREEVERT = 372;
	/// <summary>
	/// unused
	/// </summary>
	public: const static int32_t ACT_CLIENT_REMOVEVERT = 373;
	/// <summary>
	/// unused
	/// </summary>
	public: const static int32_t ACT_CLIENT_SETVERT = 374;
	/// <summary>
	/// unused
	/// </summary>
	public: const static int32_t ACT_CLIENT_RESETVERT = 375;
	/// <summary>
	/// unused
	/// </summary>
	public: const static int32_t ACT_CLIENT_PICKPOST = 376;
	/// <summary>
	/// Delete note.
	/// </summary>
	public: const static int32_t ACT_CLIENT_DELETENOTE = 380;
	/// <summary>
	/// Create note.
	/// </summary>
	public: const static int32_t ACT_CLIENT_CREATENOTE = 381;
	/// <summary>
	/// Overwrite note.
	/// </summary>
	public: const static int32_t ACT_CLIENT_EDITNOTE = 382;
	/// <summary>
	/// Read document file from DM.
	/// </summary>
	public: const static int32_t ACT_DM_READDOC = 2000;
	/// <summary>
	/// IndexServer specific report codes are higher than ACT_IX_FIRST
	/// </summary>
	public: const static int32_t ACT_IX_FIRST = 500;
	public: const static int32_t ACT_IX_LAST = 1000;
	public: const static int32_t ACT_IX_LOGIN = 501;
	public: const static int32_t ACT_IX_LOGOUT = 502;
	/// <summary>
	/// Reporteintrag fÃ¼r Mini-App-Login.
	/// </summary>
	/// <remarks>
	/// RID11587
	/// </remarks>
	public: const static int32_t ACT_IX_MINI_APP_LOGIN = 503;
	public: const static int32_t ACT_IX_LOCK_ARCHIVE = 511;
	public: const static int32_t ACT_IX_CREATE_USER = 520;
	public: const static int32_t ACT_IX_CHECKIN_USER = 521;
	public: const static int32_t ACT_IX_DELETE_USER = 522;
	public: const static int32_t ACT_IX_CREATE_KEY = 530;
	public: const static int32_t ACT_IX_CHECKIN_KEY = 531;
	public: const static int32_t ACT_IX_DELETE_KEY = 532;
	public: const static int32_t ACT_IX_CREATE_SORD = 540;
	public: const static int32_t ACT_IX_CHECKOUT_SORD = 541;
	public: const static int32_t ACT_IX_CHECKIN_SORD = 542;
	public: const static int32_t ACT_IX_DELETE_SORD = 543;
	public: const static int32_t ACT_IX_DELETE_REFERENCE = 544;
	public: const static int32_t ACT_IX_CHANGE_ACL = 545;
	public: const static int32_t ACT_IX_CHANGE_RS = 546;
	public: const static int32_t ACT_IX_CREATE_DOCUMENT = 547;
	public: const static int32_t ACT_IX_CHANGE_DELDATE = 548;
	public: const static int32_t ACT_IX_COPY_SORD = 551;
	public: const static int32_t ACT_IX_REFERENCE_SORD = 552;
	public: const static int32_t ACT_IX_MOVE_SORD = 553;
	public: const static int32_t ACT_IX_LINK_SORD = 555;
	public: const static int32_t ACT_IX_UNLINK_SORD = 556;
	public: const static int32_t ACT_IX_CHECKOUT_DOCVERSION = 561;
	public: const static int32_t ACT_IX_CHECKIN_DOCVERSION = 562;
	public: const static int32_t ACT_IX_CREATE_DOC_MASK = 570;
	public: const static int32_t ACT_IX_CHECKIN_DOC_MASK = 571;
	public: const static int32_t ACT_IX_DELETE_DOC_MASK = 572;
	public: const static int32_t ACT_IX_CHECKIN_REPL_NAME = 581;
	public: const static int32_t ACT_IX_CHECKIN_REPORT_OPTIONS = 591;
	public: const static int32_t ACT_IX_DELETE_REPORT = 592;
	public: const static int32_t ACT_IX_CHECKIN_COLOR = 601;
	public: const static int32_t ACT_IX_CHECKIN_USER_PROFILE = 611;
	public: const static int32_t ACT_IX_DELETE_USER_PROFILE = 612;
	public: const static int32_t ACT_IX_CREATE_WORKFLOW = 620;
	public: const static int32_t ACT_IX_CHECKIN_WORKFLOW = 622;
	public: const static int32_t ACT_IX_DELETE_WORKFLOW = 623;
	public: const static int32_t ACT_IX_EDIT_WORKFLOW_NODE = 624;
	public: const static int32_t ACT_IX_START_WORKFLOW = 625;
	public: const static int32_t ACT_IX_START_ADHOC_WORKFLOW = 626;
	public: const static int32_t ACT_IX_TERMINATE_WORKFLOW = 627;
	public: const static int32_t ACT_IX_TAKE_WORKFLOW_NODE = 628;
	public: const static int32_t ACT_IX_DELEGATE_WORKFLOW = 629;
	public: const static int32_t ACT_IX_CHECKIN_CONFIG_FILE = 651;
	public: const static int32_t ACT_IX_DELETE_CONFIG_FILE = 652;
	public: const static int32_t ACT_IX_CHECKIN_COUNTER = 701;
	public: const static int32_t ACT_IX_DELETE_COUNTER = 702;
	public: const static int32_t ACT_IX_INCREMENT_COUNTER = 703;
	public: const static int32_t ACT_IX_CHECKIN_SORD_TYPE = 711;
	public: const static int32_t ACT_IX_DELETE_SORD_TYPE = 712;
	public: const static int32_t ACT_IX_CREATE_NOTE = 720;
	public: const static int32_t ACT_IX_CHECKIN_NOTE = 721;
	public: const static int32_t ACT_IX_CHECKOUT_NOTE = 722;
	public: const static int32_t ACT_IX_DELETE_NOTE = 723;
	public: const static int32_t ACT_IX_NEWVERT = 724;
	public: const static int32_t ACT_IX_DELVERT = 725;
	public: const static int32_t ACT_IX_FREEVERT = 726;
	public: const static int32_t ACT_IX_REMOVEVERT = 727;
	public: const static int32_t ACT_IX_SETVERT = 728;
	public: const static int32_t ACT_IX_RESETVERT = 729;
	/// <summary>
	/// Custom client specific report codes are higher than ACT_CUSTOM_FIRST
	/// </summary>
	public: const static int32_t ACT_CUSTOM_FIRST = 3000;
	/// <summary>
	/// Custom client specific report codes are lower than ACT_CUSTOM_LAST
	/// </summary>
	public: const static int32_t ACT_CUSTOM_LAST = 4000;
	public: const static int32_t EXTRA2_LOCK = 1;
	public: const static int32_t EXTRA2_FORCE = 2;
	public: const static int32_t EXTRA2_DOCVERSION = 4;
	public: const static int32_t EXTRA2_ATTACHMENT = 8;
	public: const static int32_t EXTRA2_SIGNATURE = 16;
	public: const static int32_t EXTRA2_PREVIEW = 32;
	public: const static int32_t EXTRA2_FINALLY = 64;
	public: const static int32_t EXTRA2_WF_ACTIVE = 128;
	public: const static int32_t EXTRA2_WF_TEMPLATE = 256;
	public: const static int32_t EXTRA2_WF_FINISHED = 512;
	public: const static int32_t EXTRA2_WF_TERMINATE = 1024;
	public: const static int32_t EXTRA2_WF_CANCEL = 2048;
	public: const static int32_t EXTRA2_NOTE_NORMAL = 4096;
	public: const static int32_t EXTRA2_NOTE_PERSONAL = 8192;
	public: const static int32_t EXTRA2_NOTE_STAMP = 16384;
	public: const static int32_t EXTRA2_SSO_LOGIN = 32768;
	public: const static int32_t EXTRA2_ANNOTATION_MARKER = 65536;
	public: const static int32_t EXTRA2_ANNOTATION_NOTE = 131072;
	public: const static int32_t EXTRA2_REPORT_AS_LOGIN = 262144;
	/// <summary>
	/// Extra2 value used when all notes of a Sord are read.
	/// </summary>
	public: const static int32_t EXTRA2_ALL_NOTES_OF_SORD = 225280;
	public: const static int32_t EXTRA2_INDEXSEARCH = 1;
	public: const static int64_t mbAction = 2LL;
	public: const static int64_t mbComment = 2LL;
	public: const static int64_t mbActTimeISO = 8LL;
	public: const static int64_t mbUserName = 4LL;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: ReportInfoC();
	
	public: virtual BTYPEID BSerializable_getTypeId();
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// ReportInfoUserModified
// typeId=1649121955

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Additional report information for modified user.
/// </summary>
class ReportInfoUserModified : public ValueClass {
	/// <summary>
	/// Modified properties.
	/// </summary>
	protected: PReportInfoUserProps newProps;
	/// <summary>
	/// Properties before modification.
	/// </summary>
	/// <remarks>
	/// This member is null for new users and for deleted users.
	/// </remarks>
	protected: PReportInfoUserProps oldProps;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: ReportInfoUserModified();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: ReportInfoUserModified(const PReportInfoUserProps& newProps, const PReportInfoUserProps& oldProps);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: PReportInfoUserProps getNewProps() { return newProps; }
	public: void setNewProps(PReportInfoUserProps v);
	public: PReportInfoUserProps getOldProps() { return oldProps; }
	public: void setOldProps(PReportInfoUserProps v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// ReportInfoUserProps
// typeId=2088129978

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Additional report information for user modifications.
/// </summary>
class ReportInfoUserProps : public ValueClass {
	/// <summary>
	/// UserInfo object.
	/// </summary>
	protected: PUserInfo userInfo;
	/// <summary>
	/// UserInfo object with effective permissions.
	/// </summary>
	protected: PUserInfo userInfoEff;
	/// <summary>
	/// Substitution information.
	/// </summary>
	protected: PVectorSubsInfo subsInfos;
	/// <summary>
	/// Map of user IDs to user names.
	/// </summary>
	/// <remarks>
	/// This map contains all users referred by {@link #userInfo}, {@link #userInfoEff}, and {@link #subsInfos}.
	/// </remarks>
	protected: byps::PMapIntegerString idsToNames;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: ReportInfoUserProps();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: ReportInfoUserProps(const PUserInfo& userInfo, const PUserInfo& userInfoEff, const PVectorSubsInfo& subsInfos, const byps::PMapIntegerString& idsToNames);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: PUserInfo getUserInfo() { return userInfo; }
	public: void setUserInfo(PUserInfo v);
	public: PUserInfo getUserInfoEff() { return userInfoEff; }
	public: void setUserInfoEff(PUserInfo v);
	public: PVectorSubsInfo getSubsInfos() { return subsInfos; }
	public: void setSubsInfos(PVectorSubsInfo v);
	public: byps::PMapIntegerString getIdsToNames() { return idsToNames; }
	public: void setIdsToNames(byps::PMapIntegerString v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// ReportModeC
// typeId=1594659914

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

class ReportModeC : public BSerializable {
	public: const static int64_t bsetNO = 0LL;
	public: const static int64_t bsetLIMITED = 1LL;
	public: const static int64_t bsetVERBOSE = 2LL;
	public: const static int64_t bsetFULL = 3LL;
	/// <summary>
	/// Do not write report.
	/// </summary>
	public: const static PReportModeZ NO;
	/// <summary>
	/// Write limited report.
	/// </summary>
	public: const static PReportModeZ LIMITED;
	/// <summary>
	/// Write verbose report.
	/// </summary>
	public: const static PReportModeZ VERBOSE;
	/// <summary>
	/// Write full report.
	/// </summary>
	public: const static PReportModeZ FULL;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: ReportModeC();
	
	public: virtual BTYPEID BSerializable_getTypeId();
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// ReportModeZ
// typeId=1248158950

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// <p>This class encapsulates the constants of <code>ReportModeC</code></p>
/// 
/// <p>Copyright: Copyright (c) 2004</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </summary>
class ReportModeZ : public ValueClass {
	/// <summary>
	/// Bitset field for constants from ReportModeC class.
	/// </summary>
	protected: int64_t bset;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: ReportModeZ();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: ReportModeZ(int64_t bset);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int64_t getBset() { return bset; }
	public: void setBset(int64_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// ReportOptions
// typeId=1057373949

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// This class contains the codes for the activities/processes that are to be
/// protocolled in a report.
/// </summary>
/// <remarks>
/// <p>Copyright: Copyright (c) 2004</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </remarks>
class ReportOptions : public ValueClass {
	/// <summary>
	/// ERP codes
	/// </summary>
	protected: PArrayReportErpCode erpCodes;
	/// <summary>
	/// A ReportOptionsZ constant
	/// </summary>
	protected: PReportModeZ mode;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: ReportOptions();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: ReportOptions(const PArrayReportErpCode& erpCodes, const PReportModeZ& mode);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: PArrayReportErpCode getErpCodes() { return erpCodes; }
	public: void setErpCodes(PArrayReportErpCode v);
	public: PReportModeZ getMode() { return mode; }
	public: void setMode(PReportModeZ v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// ReportOptionsC
// typeId=2081332891

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Constants for report mode
/// <p>Copyright: Copyright (c) 2004</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// An ERP code is assigned to one or more action codes.
/// </summary>
class ReportOptionsC : public BSerializable {
	public: const static int32_t ERP_LOGFIRSTMESSAGE = 20100;
	public: const static int32_t ERP_LOGOPENARC = 20101;
	public: const static int32_t ERP_LOGCLOSEARC = 20102;
	public: const static int32_t ERP_LOGUSERDATA = 20103;
	public: const static int32_t ERP_LOGCOLORDATA = 20104;
	public: const static int32_t ERP_LOGMASKDATA = 20105;
	public: const static int32_t ERP_LOGPATHDATA = 20106;
	public: const static int32_t ERP_LOGKEYDATA = 20107;
	public: const static int32_t ERP_LOGCREATEDOC = 20108;
	public: const static int32_t ERP_LOGCREATESOR = 20109;
	public: const static int32_t ERP_LOGEDITDATA = 20110;
	public: const static int32_t ERP_LOGEDITDOC = 20111;
	public: const static int32_t ERP_LOGVIEWDOC = 20112;
	public: const static int32_t ERP_LOGERADOC = 20113;
	public: const static int32_t ERP_LOGERASOR = 20114;
	public: const static int32_t ERP_LOGMOVEDOC = 20115;
	public: const static int32_t ERP_LOGREFDOC = 20116;
	public: const static int32_t ERP_LOGMOVESOR = 20117;
	public: const static int32_t ERP_LOGREFSOR = 20118;
	public: const static int32_t ERP_LOGERAREF = 20119;
	public: const static int32_t ERP_LOGCOMPLAIN = 20120;
	public: const static int32_t ERP_LOGCHANGEKIND = 20121;
	public: const static int32_t ERP_LOGCHANGEKEY = 20122;
	public: const static int32_t ERP_LOGCHANGEPWD = 20123;
	public: const static int32_t ERP_LOGATTACHMENT = 20124;
	public: const static int32_t ERP_LOGDELDOCS = 20125;
	public: const static int32_t ERP_CREATEFLOWTEMPL = 20126;
	public: const static int32_t ERP_EDITFLOWTEMPL = 20127;
	public: const static int32_t ERP_DELFLOWTEMPL = 20128;
	public: const static int32_t ERP_STARTFLOW = 20129;
	public: const static int32_t ERP_RECEIVEFLOW = 20130;
	public: const static int32_t ERP_FORWARDFLOW = 20131;
	public: const static int32_t ERP_EDITFLOWACTIVE = 20132;
	public: const static int32_t ERP_DELFLOWACTIVE = 20133;
	public: const static int32_t ERP_FLOWTIMELIMT = 20134;
	public: const static int32_t ERP_FLOWERRORYESNO = 20135;
	public: const static int32_t ERP_CONVERT_FORMAT = 20136;
	public: const static int32_t ERP_WV = 20137;
	public: const static int32_t ERP_POSTBOX = 20138;
	public: const static int32_t ERP_VERSCHIEDEN = 20139;
	public: const static int32_t ERP_NEWVERT = 20140;
	public: const static int32_t ERP_DELVERT = 20141;
	public: const static int32_t ERP_FREEVERT = 20142;
	public: const static int32_t ERP_REMOVEVERT = 20143;
	public: const static int32_t ERP_SETVERT = 20144;
	public: const static int32_t ERP_RESETVERT = 20145;
	public: const static int32_t ERP_CHECKOUT = 20146;
	public: const static int32_t ERP_CHECKIN = 20147;
	public: const static int32_t ERP_SHOWDOC = 20148;
	public: const static int32_t ERP_SHOWSOR = 20149;
	public: const static int32_t ERP_PICKPOST = 20150;
	public: const static int32_t ERP_DELVERSION = 20151;
	public: const static int32_t ERP_SEARCH = 20152;
	public: const static int32_t ERP_WRITESESSION = 20153;
	public: const static int32_t ERP_POSTBARCODE = 20154;
	public: const static int32_t ERP_DM_READDOC = 20155;
	public: const static int32_t ERP_CUSTOM = 20156;
	public: const static int32_t ERP_NOREPDATA = 20170;
	public: const static int32_t ERP_ERROR = 20171;
	public: const static int32_t ERP_LOGLASTMESSAGE = 20157;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: ReportOptionsC();
	
	public: virtual BTYPEID BSerializable_getTypeId();
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// ResolveRightsInfo
// typeId=1631708942

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Parameter Class for
/// {@link IXServicePortIF#resolveRights(ClientInfo, UserInfo, ResolveRightsInfo)}
/// .
/// </summary>
class ResolveRightsInfo : public BSerializable {
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: ResolveRightsInfo();
	
	public: virtual BTYPEID BSerializable_getTypeId();
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// ResolveRightsResult
// typeId=973279163

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Class for the result of the IX-Function
/// {@link IXServicePortIF#resolveRights(ClientInfo, UserInfo, ResolveRightsInfo)}
/// .
/// </summary>
class ResolveRightsResult : public BSerializable {
	/// <summary>
	/// The right the user got by {@link ResolveRightsResult#type}.
	/// </summary>
	/// <remarks>
	/// Values will be
	/// of {@link AccessC}.FLAG_*.
	/// </remarks>
	protected: int32_t right;
	/// <summary>
	/// The right the user got by {@link ResolveRightsResult#type}.
	/// </summary>
	/// <remarks>
	/// Values will be
	/// of {@link AccessC}.FLAG2_*.
	/// </remarks>
	protected: int32_t right2;
	/// <summary>
	/// The kind of way the user got this right.
	/// </summary>
	/// <remarks>
	/// See {@link ResolveRightsResultC}
	/// for valid values.
	/// </remarks>
	protected: int32_t type;
	/// <summary>
	/// Path of members that explains why the user got this right.
	/// </summary>
	/// <remarks>
	/// The first item
	/// in this list is the name of the object directly assigned to the user. The
	/// last item is the name of the object which obtains the right.
	/// </remarks>
	protected: byps::PVectorString members;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: ResolveRightsResult();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: ResolveRightsResult(int32_t right, int32_t right2, int32_t type, const byps::PVectorString& members);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getRight() { return right; }
	public: void setRight(int32_t v);
	public: int32_t getRight2() { return right2; }
	public: void setRight2(int32_t v);
	public: int32_t getType() { return type; }
	public: void setType(int32_t v);
	public: byps::PVectorString getMembers() { return members; }
	public: void setMembers(byps::PVectorString v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// ResolveRightsResultC
// typeId=1322441656

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Constants for {@link ResolveRightsResult}.
/// </summary>
class ResolveRightsResultC : public BSerializable {
	/// <summary>
	/// Indicates that the user got the right directly.
	/// </summary>
	public: const static int32_t DIRECT = 1;
	/// <summary>
	/// Indicates that the user got the right by inheritance of a group.
	/// </summary>
	public: const static int32_t INHERITED = 2;
	/// <summary>
	/// Indicates that the user got the right by a substitution rule.
	/// </summary>
	public: const static int32_t SUBSTITUTION = 4;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: ResolveRightsResultC();
	
	public: virtual BTYPEID BSerializable_getTypeId();
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// RestoreOptions
// typeId=378110234

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// <p>This class contains several options for undeleting archive SORDs by <code>restoreSord</code></p>
/// <p>Copyright: Copyright (c) 2004-2006</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </summary>
class RestoreOptions : public ValueClass {
	/// <summary>
	/// <p><code>minIDate</code> ist the ISO representation of the local date
	/// used to mark the lower limit for restoring.
	/// </summary>
	/// <remarks>
	/// </p>
	/// </remarks>
	protected: ::std::wstring minIDate;
	/// <summary>
	/// <p><code>singleObject=true</code> restricts the operation to the specified
	/// object not traversing sub trees.
	/// </summary>
	/// <remarks>
	/// </p>
	/// </remarks>
	protected: bool singleObject;
	/// <summary>
	/// <p>
	/// Restore only document versions that are deleted after
	/// <code>minDeleteDate</code>.
	/// </summary>
	/// <remarks>
	/// Its String representation is the ISO format
	/// in the client's time zone.
	/// </p>
	/// </remarks>
	protected: ::std::wstring minDeleteDate;
	/// <summary>
	/// <p>
	/// Since references also got a delete date, they can be restored independently
	/// from their main reference.
	/// </summary>
	/// <remarks>
	/// To restore a reference selectively, set parentId
	/// to the references' parentId. Restoring a reference does not affect the
	/// delete status of its main reference.
	/// </p>
	/// <p>Setting parentId implies singleObject=true.</p>
	/// </remarks>
	protected: ::std::wstring parentId;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: RestoreOptions();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: RestoreOptions(const ::std::wstring& minIDate, bool singleObject, const ::std::wstring& minDeleteDate, const ::std::wstring& parentId);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: ::std::wstring getMinIDate() { return minIDate; }
	public: void setMinIDate(::std::wstring v);
	public: bool getSingleObject() { return singleObject; }
	public: void setSingleObject(bool v);
	public: ::std::wstring getMinDeleteDate() { return minDeleteDate; }
	public: void setMinDeleteDate(::std::wstring v);
	public: ::std::wstring getParentId() { return parentId; }
	public: void setParentId(::std::wstring v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// SearchModeC
// typeId=1758444419

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// <p>This class defines options used in <code>FindOptions.searchMode</code>.
/// </summary>
/// <remarks>
/// </p>
/// <p>Copyright: Copyright (c) 2004</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </remarks>
class SearchModeC : public BSerializable {
	public: const static int64_t bsetAND = 0LL;
	public: const static int64_t bsetOR = 1LL;
	public: const static int64_t bsetONE_TERM = 2LL;
	public: const static int64_t bsetEXPRESSION = 3LL;
	/// <summary>
	/// The search terms are concatinated with the boolean AND operator.
	/// </summary>
	public: const static PSearchModeZ AND;
	/// <summary>
	/// The search terms are concatinated with the boolean OR operator.
	/// </summary>
	public: const static PSearchModeZ OR;
	/// <summary>
	/// A blank separated list in <code>FindByIndex.name</code> or <code>FindByIndex.desc</code>
	/// is used as a single term.
	/// </summary>
	public: const static PSearchModeZ ONE_TERM;
	/// <summary>
	/// The value of <code>FindByIndex.name</code> or <code>FindByIndex.desc</code>
	/// contains the operators "AND" (&amp;), "OR" (|), "NOT" (!)
	/// </summary>
	/// <remarks>
	/// for concatination.
	/// </remarks>
	public: const static PSearchModeZ EXPRESSION;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: SearchModeC();
	
	public: virtual BTYPEID BSerializable_getTypeId();
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// SearchModeZ
// typeId=424689505

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// <p>This class encapsulates the constants of <code>SearchModeC</code></p>
/// 
/// <p>Copyright: Copyright (c) 2004</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </summary>
class SearchModeZ : public ValueClass {
	/// <summary>
	/// Bitset field for constants from SearchModeC class.
	/// </summary>
	protected: int64_t bset;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: SearchModeZ();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: SearchModeZ(int64_t bset);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int64_t getBset() { return bset; }
	public: void setBset(int64_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// SearchTermsC
// typeId=334358315

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

class SearchTermsC : public BSerializable {
	public: const static int32_t TERMS = 1;
	public: const static int32_t SYNONYMS = 2;
	public: const static int32_t CORRECTION = 4;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: SearchTermsC();
	
	public: virtual BTYPEID BSerializable_getTypeId();
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// ServerInfo
// typeId=1701204890

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// <p>License key, version and list of other IndexServers</p>
/// <p>Copyright: Copyright (c) 2003</p>
/// <p>Organisation: ELO Digital Office GmbH </p>
/// </summary>
class ServerInfo : public ValueClass {
	/// <summary>
	/// List of other Index Servers.
	/// </summary>
	/// <remarks>
	/// Read only.
	/// </remarks>
	protected: PArrayIndexServerForArchive indexServers;
	/// <summary>
	/// License key for the Index Server.
	/// </summary>
	/// <remarks>
	/// Read only.
	/// </remarks>
	protected: PLicense license;
	/// <summary>
	/// The version of the Index Server.
	/// </summary>
	/// <remarks>
	/// Read only.
	/// </remarks>
	protected: ::std::wstring version;
	/// <summary>
	/// This value defines the server ID which is checked
	/// when a workflow is forwared.
	/// </summary>
	protected: ::std::wstring replProcessOnServerId;
	/// <summary>
	/// Database engine name.
	/// </summary>
	/// <remarks>
	/// E. g. MSSQL, ORACLE, DB2
	/// If connected to DB2, the character set UTF-8 is assumed for
	/// database columns that store Strings. In this case the length members
	/// of the constant classes (e.g. SordC.lnName resp. CONST.SORD.lnName)
	/// contain the column widths in bytes rather than characters. Use
	/// the IXConnection.truncate function to truncate a String value to
	/// fit the corresponding database column.
	/// </remarks>
	protected: ::std::wstring databaseEngine;
	/// <summary>
	/// Indexserver name.
	/// </summary>
	/// <remarks>
	/// This is the name configured in config.xml or web.xml as "ixid".
	/// </remarks>
	protected: ::std::wstring instanceName;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: ServerInfo();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: ServerInfo(const PArrayIndexServerForArchive& indexServers, const PLicense& license, const ::std::wstring& version, const ::std::wstring& replProcessOnServerId, const ::std::wstring& databaseEngine, const ::std::wstring& instanceName);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: PArrayIndexServerForArchive getIndexServers() { return indexServers; }
	public: void setIndexServers(PArrayIndexServerForArchive v);
	public: PLicense getLicense() { return license; }
	public: void setLicense(PLicense v);
	public: ::std::wstring getVersion() { return version; }
	public: void setVersion(::std::wstring v);
	public: ::std::wstring getReplProcessOnServerId() { return replProcessOnServerId; }
	public: void setReplProcessOnServerId(::std::wstring v);
	public: ::std::wstring getDatabaseEngine() { return databaseEngine; }
	public: void setDatabaseEngine(::std::wstring v);
	public: ::std::wstring getInstanceName() { return instanceName; }
	public: void setInstanceName(::std::wstring v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// ServerInfoDM
// typeId=1425760760

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// This class contains infomation about the filing paths of the document manager (DM).
/// </summary>
class ServerInfoDM : public ValueClass {
	/// <summary>
	/// IDs of the paths to be used for filing docments.
	/// </summary>
	/// <remarks>
	/// The first path ID is the ID of the default
	/// filing path. This array can contain up to 4 elements.
	/// </remarks>
	protected: PArrayInt basisStoreIds;
	/// <summary>
	/// reserved.
	/// </summary>
	protected: PArrayInt backupStoreIds;
	/// <summary>
	/// ID of restore path.
	/// </summary>
	protected: int32_t restoreStoreId;
	/// <summary>
	/// Mode to be used to fill the filing paths.
	/// </summary>
	/// <remarks>
	/// This value is a bitset of the
	/// ServerInfoDMC.STOREMODE_* constants.
	/// </remarks>
	protected: int32_t storeMode;
	/// <summary>
	/// DM proxy mode.
	/// </summary>
	/// <remarks>
	/// Read-only.
	/// <table>
	/// <tr>
	/// <td>-1</td>
	/// <td>Proxy mode is not active</td>
	/// </tr>
	/// <tr>
	/// <td>0</td>
	/// <td>Main instance</td>
	/// </tr>
	/// <tr>
	/// <td>&gt;0</td>
	/// <td>Branch instance</td>
	/// </tr>
	/// </table>
	/// </remarks>
	protected: int32_t proxyMode;
	/// <summary>
	/// DM is enabled for blackening of document parts.
	/// </summary>
	protected: bool blackeningEnabled;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: ServerInfoDM();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: ServerInfoDM(const PArrayInt& basisStoreIds, const PArrayInt& backupStoreIds, int32_t restoreStoreId, int32_t storeMode, int32_t proxyMode, bool blackeningEnabled);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: PArrayInt getBasisStoreIds() { return basisStoreIds; }
	public: void setBasisStoreIds(PArrayInt v);
	public: PArrayInt getBackupStoreIds() { return backupStoreIds; }
	public: void setBackupStoreIds(PArrayInt v);
	public: int32_t getRestoreStoreId() { return restoreStoreId; }
	public: void setRestoreStoreId(int32_t v);
	public: int32_t getStoreMode() { return storeMode; }
	public: void setStoreMode(int32_t v);
	public: int32_t getProxyMode() { return proxyMode; }
	public: void setProxyMode(int32_t v);
	public: bool getBlackeningEnabled() { return blackeningEnabled; }
	public: void setBlackeningEnabled(bool v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// ServerInfoDMC
// typeId=287365821

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Constants used by the members of the class ServerInfoDM.
/// </summary>
class ServerInfoDMC : public BSerializable {
	/// <summary>
	/// This bitmask selects the lower two bits of the ServerInfoDM.storeMode.
	/// </summary>
	/// <remarks>
	/// This bits are equal to one of the STOREMODE_BASEPATH_* constants.
	/// </remarks>
	public: const static int32_t STOREMODE_BASEPATH_MASK = 3;
	/// <summary>
	/// Fill up base paths subsequently.
	/// </summary>
	public: const static int32_t STOREMODE_BASEPATH_FILL_UP = 1;
	/// <summary>
	/// Fill base paths by round robin algorithm.
	/// </summary>
	public: const static int32_t STOREMODE_BASEPATH_ROUNDROBIN = 0;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: ServerInfoDMC();
	
	public: virtual BTYPEID BSerializable_getTypeId();
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// ServerState
// typeId=1076606418

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Internal class.
/// </summary>
class ServerState : public ValueClass {
	/// <summary>
	/// DB column: actionid
	/// </summary>
	protected: int32_t actionId;
	/// <summary>
	/// DB column: subkey
	/// </summary>
	protected: int32_t subKey;
	/// <summary>
	/// DB column: action
	/// </summary>
	protected: ::std::wstring action;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: ServerState();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: ServerState(int32_t actionId, int32_t subKey, const ::std::wstring& action);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getActionId() { return actionId; }
	public: void setActionId(int32_t v);
	public: int32_t getSubKey() { return subKey; }
	public: void setSubKey(int32_t v);
	public: ::std::wstring getAction() { return action; }
	public: void setAction(::std::wstring v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// ServerStateC
// typeId=1862501863

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// <p>Bit constants for members of ServerState</p>
/// <p>Copyright: Copyright (c) 2003</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </summary>
class ServerStateC : public BSerializable {
	/// <summary>
	/// DB column: actionid
	/// </summary>
	public: const static int64_t mbActionId = 1LL;
	/// <summary>
	/// DB column: subkey
	/// </summary>
	public: const static int64_t mbSubKey = 2LL;
	/// <summary>
	/// DB column: action
	/// </summary>
	public: const static int64_t mbAction = 4LL;
	/// <summary>
	/// DB column: action
	/// </summary>
	protected: int32_t lnAction;
	/// <summary>
	/// All valid member bits.
	/// </summary>
	public: const static int64_t mbAllMembers = 7LL;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: ServerStateC();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: ServerStateC(int64_t mbActionId, int64_t mbSubKey, int64_t mbAction, int32_t lnAction, int64_t mbAllMembers);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getLnAction() { return lnAction; }
	public: void setLnAction(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// SessionInfo
// typeId=866689803

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// <p>Provides details of the current session with the Index Server</p>
/// <p>Copyright: Copyright (c) 2003</p>
/// <p>Organisation: ELO Digital Office GmbH </p>
/// </summary>
class SessionInfo : public ValueClass {
	/// <summary>
	/// The client computer connected with the Index Server.
	/// </summary>
	protected: ::std::wstring clientComputer;
	/// <summary>
	/// The id of the user used for the connection.
	/// </summary>
	protected: int32_t userId;
	/// <summary>
	/// The length of time the connection is valid for.
	/// </summary>
	protected: int32_t validSeconds;
	/// <summary>
	/// The ticket of this session within the Index Server.
	/// </summary>
	protected: ::std::wstring ticket;
	/// <summary>
	/// The name of the user used for the connection.
	/// </summary>
	protected: ::std::wstring userName;
	/// <summary>
	/// The name of the user who initialized the runAs connection
	/// </summary>
	protected: ::std::wstring loginName;
	/// <summary>
	/// The time stamp of the session best before date.
	/// </summary>
	protected: ::std::wstring bestBefore;
	/// <summary>
	/// The name of the client's application connected with the Index Server.
	/// </summary>
	protected: ::std::wstring appName;
	/// <summary>
	/// The version of the client's application connected with the Index Server.
	/// </summary>
	protected: ::std::wstring appVersion;
	/// <summary>
	/// The type of the client's application connected with the Index Server.
	/// </summary>
	protected: ::std::wstring appType;
	/// <summary>
	/// Session is constrained to this account
	/// </summary>
	protected: ::std::wstring runAs;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: SessionInfo();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: SessionInfo(const ::std::wstring& clientComputer, int32_t userId, int32_t validSeconds, const ::std::wstring& ticket, const ::std::wstring& userName, const ::std::wstring& loginName, const ::std::wstring& bestBefore, const ::std::wstring& appName, const ::std::wstring& appVersion, const ::std::wstring& appType, const ::std::wstring& runAs);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: ::std::wstring getClientComputer() { return clientComputer; }
	public: void setClientComputer(::std::wstring v);
	public: int32_t getUserId() { return userId; }
	public: void setUserId(int32_t v);
	public: int32_t getValidSeconds() { return validSeconds; }
	public: void setValidSeconds(int32_t v);
	public: ::std::wstring getTicket() { return ticket; }
	public: void setTicket(::std::wstring v);
	public: ::std::wstring getUserName() { return userName; }
	public: void setUserName(::std::wstring v);
	public: ::std::wstring getLoginName() { return loginName; }
	public: void setLoginName(::std::wstring v);
	public: ::std::wstring getBestBefore() { return bestBefore; }
	public: void setBestBefore(::std::wstring v);
	public: ::std::wstring getAppName() { return appName; }
	public: void setAppName(::std::wstring v);
	public: ::std::wstring getAppVersion() { return appVersion; }
	public: void setAppVersion(::std::wstring v);
	public: ::std::wstring getAppType() { return appType; }
	public: void setAppType(::std::wstring v);
	public: ::std::wstring getRunAs() { return runAs; }
	public: void setRunAs(::std::wstring v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// SessionInfoParams
// typeId=2013576169

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

class SessionInfoParams : public ValueClass {
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: SessionInfoParams();
	
	public: virtual BTYPEID BSerializable_getTypeId();
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// SessionOptions
// typeId=1197100286

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Objects of this class hold an array of options that are used to manipulate the
/// current IndexServer session.
/// </summary>
class SessionOptions : public ValueClass {
	/// <summary>
	/// Array containing options used for the Index Server session.
	/// </summary>
	protected: PArrayKeyValue options;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: SessionOptions();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: SessionOptions(const PArrayKeyValue& options);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: PArrayKeyValue getOptions() { return options; }
	public: void setOptions(PArrayKeyValue v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// SessionOptionsC
// typeId=2000345779

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Constants of SessionOptions.
/// </summary>
class SessionOptionsC : public BSerializable {
	/// <summary>
	/// Client application name.
	/// </summary>
	/// <remarks>
	/// Optional.
	/// </remarks>
	public: const static ::std::wstring CLIENT_APP_NAME;
	/// <summary>
	/// Client application version.
	/// </summary>
	/// <remarks>
	/// Optional.
	/// </remarks>
	public: const static ::std::wstring CLIENT_APP_VERSION;
	/// <summary>
	/// Client application type.
	/// </summary>
	/// <remarks>
	/// Mandatory.
	/// The appropriate value for partner applications is TYPE_PARTNER_APPLICATION
	/// unless a special type is arranged.
	/// </remarks>
	public: const static ::std::wstring CLIENT_APP_TYPE;
	/// <summary>
	/// This option value has to be used for option CLIENT_APP_TYPE if a
	/// partner application connects to IX.
	/// </summary>
	public: const static ::std::wstring TYPE_PARTNER_APPLICATION;
	/// <summary>
	/// Reserved.
	/// </summary>
	/// <remarks>
	/// This value is reserved for ELO applications. Unauthorized usage
	/// violates the ELO licensing terms.
	/// </remarks>
	public: const static ::std::wstring APP_TYPE_MINI_CLIENT;
	/// <summary>
	/// This character is used in the SQL statement, if the search criterias contain
	/// one of the SQL wildcard characters: &quot;%&quot;, &quot;_&quot;.
	/// </summary>
	/// <remarks>
	/// It defaults to &quot;Â¶&quot; which is a reserved character in ELO and a
	/// valid escape character for the most SQL servers and configurations.
	/// Unless a search kritera contains &quot;Â¶&quot; or the SQL server does not
	/// allow the use of this character (e. g. ORACLE, UTF-8) the value has to be
	/// changed.
	/// Hint: IndexServer-API uses &quot;*&quot; as the only valid wildcard.
	/// The escape character must not be used in the search criterias.
	/// </remarks>
	public: const static ::std::wstring DB_ESCAPE_CHAR;
	/// <summary>
	/// This characters are used as wildcards in search terms.
	/// </summary>
	/// <remarks>
	/// The first wildcard is used for zero or more characters.
	/// The second wildcard is used for exactly one character.
	/// By default (if this member is null or empty),
	/// only the first wildcard is defined: *
	/// </remarks>
	public: const static ::std::wstring DB_WILDCARDS;
	/// <summary>
	/// This option specifies which application is addressed in URLs to upload
	/// and download documents.
	/// </summary>
	/// <remarks>
	/// If direct access is true, the URLs address the
	/// DM directly. Otherwise the documents are routed though the IX.
	/// </remarks>
	public: const static ::std::wstring DIRECT_DM_ACCESS;
	/// <summary>
	/// Set this option to encrypt documents on checkin.
	/// </summary>
	/// <remarks>
	/// A secure connection (HTTPS)
	/// is required to use this option.
	/// </remarks>
	public: const static ::std::wstring ENCRYPT_DOCUMENTS;
	/// <summary>
	/// Set this option to decrypt documents on checkout.
	/// </summary>
	/// <remarks>
	/// A secure connection (HTTPS)
	/// is required to use this option.
	/// </remarks>
	public: const static ::std::wstring DECRYPT_DOCUMENTS;
	/// <summary>
	/// Translate keywording forms names, index names, index values and keyword lists
	/// into resp. from the language given in <code>ClientInfo.language</code>.
	/// </summary>
	public: const static ::std::wstring TRANSLATE_TERMS;
	/// <summary>
	/// Format ISO date values with delimiter characters defined in ISO 8601.
	/// </summary>
	public: const static ::std::wstring ISO_DATE_WITH_DELIMS;
	/// <summary>
	/// If this option is set to "true", the IndexServer starts the workflow
	/// defined in DocMask.flowId and DocMask.flowId2 when an associated document
	/// is created or checked in.
	/// </summary>
	public: const static ::std::wstring START_DOCMASK_WORKFLOWS;
	/// <summary>
	/// Function getSessionFromTicket: session must be known by this IndexServer instance.
	/// </summary>
	/// <remarks>
	/// An exception is thrown, if the session is not known by this IndexServer instance.
	/// The ticket lifetime is extended.
	/// </remarks>
	public: const static int32_t SESSION_FROM_IX = 0;
	/// <summary>
	/// Function getSessionFromTicket: any active session known by the AccessManager can be requested.
	/// </summary>
	/// <remarks>
	/// The session is not inserted into the session management of this IndexServer instance.
	/// Thus the session cannot be used to make IndexServer function calls.
	/// The ticket lifetime is not extended.
	/// </remarks>
	public: const static int32_t SESSION_FROM_AM = 1;
	/// <summary>
	/// Function getSessionFromTicket: used in combination with SESSION_FROM_AM.
	/// </summary>
	/// <remarks>
	/// Add the session into the internal session management.
	/// </remarks>
	public: const static int32_t SESSION_ADD = 2;
	/// <summary>
	/// Function getSessionFromTicket: any active session can be requested and is inserted
	/// into the session management of this IndexServer instance.
	/// </summary>
	/// <remarks>
	/// If the session is not known by this IndexServer instance, it is assumed to be a
	/// Windows CLIENT session (relevant to license model).
	/// The ticket lifetime is extended.
	/// This value is the same as SESSION_FROM_AM | SESSION_ADD.
	/// </remarks>
	public: const static int32_t SESSION_FROM_AM_ADD = 3;
	/// <summary>
	/// Define the first part of the URLs generated from Indexserver.
	/// </summary>
	/// <remarks>
	/// See configuration option ixUrlBase on the Indexserver option page.
	/// </remarks>
	public: const static ::std::wstring IX_URL_BASE;
	/// <summary>
	/// Define the first part of the document URLs generated from Indexserver.
	/// </summary>
	/// <remarks>
	/// See configuration option documentUrlBase on the Indexserver option page.
	/// </remarks>
	public: const static ::std::wstring DOC_URL_BASE;
	/// <summary>
	/// Define the download URL type.
	/// </summary>
	/// <remarks>
	/// IX can generate several types of URLs to download documents.
	/// Possible values are the constants DOWNLOAD_URL_TYPE_*.
	/// The default value is DOWNLOAD_URL_TYPE_TEMPORARY.
	/// </remarks>
	public: const static ::std::wstring DOWNLOAD_URL_TYPE;
	/// <summary>
	/// Generate URLs that expire after a given time.
	/// </summary>
	/// <remarks>
	/// The lifetime can be specified with the option "documentUrlLifetimeSeconds".
	/// By default, all URLs are created with a constrained lifetime.
	/// </remarks>
	public: const static ::std::wstring DOWNLOAD_URL_TYPE_TEMPORARY;
	/// <summary>
	/// Generate URLs that do not expire.
	/// </summary>
	/// <remarks>
	/// IX generates URLs that can be used without time limitation.
	/// The URL includes a strongly encrypted ID of the document or attachment version.
	/// AES is used to encrypt the URL parameters. The AES key is read from the IX option AESEncryptionKey.
	/// 
	/// <br/>
	/// <b>ATTENTION: If the key AESEncryptionKey is changed, all URLs generated before become invalid!</b>
	/// 
	/// <br/>
	/// <b>ATTENTION: No access checking is performed, when the document is downloaded from the URL!
	/// Everyone who knows the URL and has access to ELOix can download the document.
	/// This option cannot not be used for documents with blackening. No URL is generated for those documents.</b>
	/// 
	/// <br/>
	/// Only main administrators can use this option. The document is accessed by the IX account.
	/// Authentication is not required or performed.
	/// </remarks>
	public: const static ::std::wstring DOWNLOAD_URL_TYPE_PERSISTENT;
	/// <summary>
	/// Generate public download URLs for the actual working version, that expire after a given time.
	/// </summary>
	/// <remarks>
	/// Only a given number of downloads is allowed.
	/// IX generates URLs that can be used by non ELO users.
	/// The URL includes a strongly encrypted ID of the document or attachment version.
	/// AES is used to encrypt the URL parameters. The AES key is read from the IX option AESEncryptionKey.
	/// 
	/// <br/>
	/// <b>ATTENTION: If the key AESEncryptionKey is changed, all URLs generated before become invalid!</b>
	/// 
	/// <br/>
	/// <b>ATTENTION: No access checking is performed, when the document is downloaded from the URL!
	/// Everyone who knows the URL and has access to ELOix can download the document.
	/// This option cannot not be used for documents with blackening. No URL is generated for those documents.</b>
	/// 
	/// <br/>
	/// Authentication is not required or performed.
	/// </remarks>
	public: const static ::std::wstring DOWNLOAD_URL_TYPE_PUBLIC;
	/// <summary>
	/// Generate public download URLs for the document version, that expire after a given time..
	/// </summary>
	/// <remarks>
	/// Only a given number of downloads is allowed.
	/// IX generates URLs that can be used by non ELO users.
	/// The URL includes a strongly encrypted ID of the document or attachment version.
	/// AES is used to encrypt the URL parameters. The AES key is read from the IX option AESEncryptionKey.
	/// 
	/// <br/>
	/// <b>ATTENTION: If the key AESEncryptionKey is changed, all URLs generated before become invalid!</b>
	/// 
	/// <br/>
	/// <b>ATTENTION: No access checking is performed, when the document is downloaded from the URL!
	/// Everyone who knows the URL and has access to ELOix can download the document.
	/// This option cannot not be used for documents with blackening. No URL is generated for those documents.</b>
	/// 
	/// <br/>
	/// Authentication is not required or performed.
	/// </remarks>
	public: const static ::std::wstring DOWNLOAD_URL_TYPE_PUBLIC_VERSION;
	/// <summary>
	/// Define the allowed number of public downloads.
	/// </summary>
	public: const static ::std::wstring PUBLIC_DOWNLOAD_COUNT;
	/// <summary>
	/// Define the expired time of public downloads.
	/// </summary>
	public: const static ::std::wstring PUBLIC_DOWNLOAD_EXPIREDTIME;
	/// <summary>
	/// Apply all blackenings on documents regardless of their ACL.
	/// </summary>
	/// <remarks>
	/// ELOtr sets this option as "true" to receive documents with all blackenings.
	/// This ensures that blackened parts cannot be retrieved by a fulltext search.
	/// TTS003793
	/// </remarks>
	public: const static ::std::wstring APPLY_ALL_BLACKENINGS;
	/// <summary>
	/// If set, this option disables the protection of change information.
	/// </summary>
	/// <remarks>
	/// <p>
	/// Disabling the writing of changes information causes the IndexServer to not
	/// update the *tstamp* database columns. Then, the client has to ensure that
	/// the time stamps of objects are set correctly. Setting this option without
	/// reason causes the loss of traceability of objects in the archive! Only the
	/// replication module should use this option.
	/// </p>
	/// <p>
	/// The replication searches the database for changes since the last
	/// replication run. The gathered changes will be transported to other sites
	/// and imported into the database there. Such an import must not trigger the
	/// writing of change informations as further this would trigger the export of
	/// these changes again, claiming the changes would have been made at the site
	/// importing the changes.
	/// </p>
	/// </remarks>
	public: const static ::std::wstring DISABLE_CHANGE_INFO_PROTECTION;
	/// <summary>
	/// This session option declares that the IXConnection handles server events declared in {@link IXServerEvents}.
	/// </summary>
	public: const static ::std::wstring HANDLE_IX_SERVER_EVENTS;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: SessionOptionsC();
	
	public: virtual BTYPEID BSerializable_getTypeId();
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// Sord
// typeId=1576327931

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// <p>Indexing information of an archive entry.
/// </summary>
/// <remarks>
/// </p>
/// <p>Copyright: Copyright (c) 2004</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </remarks>
class Sord : public ValueClass {
	/// <summary>
	/// Version numer of the current work version.
	/// </summary>
	protected: ::std::wstring SReg;
	/// <summary>
	/// Timestamp of the last change.
	/// </summary>
	/// <remarks>
	/// The format is JJJJ.MM.DD.hh.mm.ss
	/// </remarks>
	protected: ::std::wstring TStamp;
	/// <summary>
	/// Access control language in coded form.
	/// </summary>
	/// <remarks>
	/// The checkInSord method must set either
	/// acl or aclItems. aclItems has priority.
	/// </remarks>
	protected: ::std::wstring acl;
	/// <summary>
	/// Id of the current attachment version.
	/// </summary>
	/// <remarks>
	/// Read-only.
	/// </remarks>
	protected: int32_t att;
	/// <summary>
	/// Estimated sum of the sub-entries in a directory.
	/// </summary>
	/// <remarks>
	/// This does not take
	/// account of any access rights assigned to the entries.
	/// This property should only be used to determine whether the directory has
	/// additional entries.
	/// Read-only.
	/// </remarks>
	protected: int32_t childCount;
	/// <summary>
	/// Read-only.
	/// </summary>
	/// <remarks>
	/// Id of the current document version.
	/// </remarks>
	protected: int32_t doc;
	/// <summary>
	/// GUID of the current document version.
	/// </summary>
	protected: ::std::wstring guid;
	/// <summary>
	/// Number of document versions.
	/// </summary>
	protected: int32_t histCount;
	/// <summary>
	/// Id of the current document version.
	/// </summary>
	protected: int32_t id;
	/// <summary>
	/// RESERVED
	/// </summary>
	protected: int32_t info;
	/// <summary>
	/// RESERVED
	/// </summary>
	protected: int32_t key;
	/// <summary>
	/// Colour
	/// </summary>
	protected: int32_t kind;
	/// <summary>
	/// This is the id of the user who has a lock on the object.
	/// </summary>
	/// <remarks>
	/// To know whether
	/// the Sord or the Document is locked, see lockIdSord or lockIdDoc
	/// respectively. The object is locked using checkoutSord with the LOCK.YES,
	/// LOCK.SORD or LOCK.DOC parameter. Read-only.
	/// </remarks>
	protected: int32_t lockId;
	/// <summary>
	/// The id of the filing mask used to archive the sord.
	/// </summary>
	/// <remarks>
	/// Read-only.
	/// </remarks>
	protected: int32_t mask;
	/// <summary>
	/// The short description/name for the object.
	/// </summary>
	protected: ::std::wstring name;
	/// <summary>
	/// The id of the owner of the object.
	/// </summary>
	/// <remarks>
	/// Read-only.
	/// </remarks>
	protected: int32_t ownerId;
	/// <summary>
	/// Id of the parent object(archive heirachy) of the sord object.
	/// </summary>
	/// <remarks>
	/// Read-only
	/// </remarks>
	protected: int32_t parentId;
	/// <summary>
	/// Filing path for the document manager.
	/// </summary>
	/// <remarks>
	/// Only valid for documents. Read-only.
	/// <p>
	/// If this Sord object is obtained by a call to checkoutSord or checkoutDoc
	/// with a database lock (e.g. LockC.IF_FREE), this member contains the storage
	/// path specified in the associated keywording form (DocMask.DPath). If the keywording
	/// form does not define a path, the default storage path is returned
	/// (ServerInfoDM.basisStoreIds[0]). Hence, the current value of the
	/// database column objekte.objpath is not used as default
	/// for new versions anymore.
	/// </p>
	/// <p>
	/// If this Sord object is obtained by a call without a lock, e.g. from findFirstSords,
	/// this value should not be used anymore. The storage path of the work version
	/// should be used instead, which can be found in Sord.docVersion.pathId.
	/// </p>
	/// </remarks>
	protected: int32_t path;
	/// <summary>
	/// The type of sord object.
	/// </summary>
	/// <remarks>
	/// Folder objects: 0 &lt; type &lt; LBT_DOCUMENT
	/// Document objects: LBT_DOCUMENT &lt;= type &lt; LBT_DOCUMENT_MAX
	/// </remarks>
	protected: int32_t type;
	/// <summary>
	/// RESERVED
	/// </summary>
	protected: int32_t vtRep;
	/// <summary>
	/// ISO encoded internal (archive defined) date.
	/// </summary>
	protected: ::std::wstring IDateIso;
	/// <summary>
	/// ISO encoded external (user defined) date.
	/// </summary>
	protected: ::std::wstring XDateIso;
	/// <summary>
	/// The current users access rights for this Sord.
	/// </summary>
	/// <remarks>
	/// Returns a combination of AccessC.LUR_ constants.
	/// Read-only. Is returned when SordC.mbAcl is set in checkoutSord.
	/// </remarks>
	protected: int32_t access;
	/// <summary>
	/// This is the access control list as an array of <code>AclItem</code> objects.
	/// </summary>
	protected: PArrayAclItem aclItems;
	/// <summary>
	/// ISO encoded expiry date.
	/// </summary>
	/// <remarks>
	/// Only users having right AccessC.FLAG_EDITDUEDATE
	/// are allowed to set the expiry date. Once the expiry date is set, it cannot
	/// be set to a date before the original expiry date.
	/// </remarks>
	protected: ::std::wstring delDateIso;
	/// <summary>
	/// Indicates whether the sord has been deleted or not.
	/// </summary>
	protected: bool deleted;
	/// <summary>
	/// The (visible) memo text.
	/// </summary>
	/// <remarks>
	/// If the value starts with a "!" this member can define a dynamic folder.
	/// This is a folder which contents are filled by an arbitrary SQL statement.
	/// </remarks>
	protected: ::std::wstring desc;
	/// <summary>
	/// Object encapsulates flags.
	/// </summary>
	protected: PSordDetails details;
	/// <summary>
	/// Version information of current document work version.
	/// </summary>
	/// <remarks>
	/// Read-only.
	/// </remarks>
	protected: PDocVersion docVersion;
	/// <summary>
	/// Hidden text that must not be displayed to the user.
	/// </summary>
	protected: ::std::wstring hiddenText;
	/// <summary>
	/// Links pointing from other archive entries to this.
	/// </summary>
	/// <remarks>
	/// Read-only.
	/// </remarks>
	protected: PArraySordLink linksComeIn;
	/// <summary>
	/// Links starting from <code>this</code> to other archive entries.
	/// </summary>
	/// <remarks>
	/// Read-only.
	/// </remarks>
	protected: PArraySordLink linksGoOut;
	/// <summary>
	/// The name of the user who has locked the object.
	/// </summary>
	/// <remarks>
	/// Read-only.
	/// </remarks>
	protected: ::std::wstring lockName;
	/// <summary>
	/// Index values during serialization
	/// </summary>
	protected: PArrayObjKey objKeys;
	/// <summary>
	/// Name of the owner (read-only).
	/// </summary>
	protected: ::std::wstring ownerName;
	/// <summary>
	/// GUIDs of archive entries that contain a reference to <code>this</code>.
	/// </summary>
	/// <remarks>
	/// The first element of
	/// the array is the GUID of the main parent, where <code>this</code> is physically placed.
	/// Read-only.
	/// </remarks>
	protected: PArrayString parentIds;
	/// <summary>
	/// Archive paths to this Sord.
	/// </summary>
	/// <remarks>
	/// The first path, refPaths[0], contains the path to the original Sord.
	/// The other paths contain references to this Sord. The paths do not include an
	/// entry for the archive and for this Sord.
	/// Since 10.18.021, TTS005149: If the user does not have read access to at least one element in a reference path, this path is
	/// excluded from the list. An exception applies to the original path. If the user does not have
	/// read access to at least one element in the original path, the ArcPath object at refPaths[0] is
	/// empty: refPaths[0].path.length == 0, refPaths[0].pathAsString = "Â¶".
	/// In contrast to refPaths, the array {@link #parentIds} is not checked for read access.
	/// </remarks>
	protected: PArrayArcPath refPaths;
	/// <summary>
	/// Replication set names.
	/// </summary>
	/// <remarks>
	/// The replication set information of an object is binary encoded in the
	/// database. The Class <code>ReplNameMap</code> provides functions to convert from the binary
	/// format into a list of replication set names and vice versa.
	/// Both replNames and replSet contain the information in which replications
	/// set the object is contain in. replNames has priority when checking the object in.
	/// </remarks>
	protected: PArrayReplSetName replNames;
	/// <summary>
	/// Replication sets.
	/// </summary>
	/// <remarks>
	/// Binary encoded information.
	/// Both replNames and replSet contain the information determining in which replications
	/// sets the object is contain in. replNames has priority when checking the object in.
	/// </remarks>
	protected: PReplSet replSet;
	/// <summary>
	/// Name of keywording form.
	/// </summary>
	/// <remarks>
	/// This value is translated into the language given by {@link ClientInfo#language}.
	/// It cannot be used as a parameter in Indexserver API functions. Use {@link Sord#getMask()} to specify the Keywording form in API functions.
	/// Read-only.
	/// </remarks>
	protected: ::std::wstring maskName;
	/// <summary>
	/// Work version of the attachment.
	/// </summary>
	protected: PDocVersion attVersion;
	/// <summary>
	/// The Sord is deleted at this date.
	/// </summary>
	/// <remarks>
	/// ClientInfo determines the Timezone.
	/// <p>Is undefined if isDeleted() returns false.</p>
	/// </remarks>
	protected: ::std::wstring deleteDateIso;
	/// <summary>
	/// This is the id of the user who has a lock on the object (not the document).
	/// </summary>
	/// <remarks>
	/// The object is locked using checkoutSord with the LOCK.SORD parameter.
	/// Read-only.
	/// </remarks>
	protected: int32_t lockIdSord;
	/// <summary>
	/// This is the id of the user who has a lock on the document (not the object).
	/// </summary>
	/// <remarks>
	/// The object is locked using checkoutSord with the LOCK.DOC parameter.
	/// Read-only.
	/// </remarks>
	protected: int32_t lockIdDoc;
	/// <summary>
	/// The name of the user who has locked the object.
	/// </summary>
	/// <remarks>
	/// Read-only.
	/// </remarks>
	protected: ::std::wstring lockNameSord;
	/// <summary>
	/// The name of the user who has locked the document.
	/// </summary>
	/// <remarks>
	/// Read-only.
	/// </remarks>
	protected: ::std::wstring lockNameDoc;
	/// <summary>
	/// Timestamp of this object's last export by the replication.
	/// </summary>
	protected: ::std::wstring TStampSync;
	/// <summary>
	/// Timestamp of the last ACL change.
	/// </summary>
	/// <remarks>
	/// The format is JJJJ.MM.DD.hh.mm.ss
	/// </remarks>
	protected: ::std::wstring TStampAcl;
	/// <summary>
	/// Timestamp of this object's ACLs last export by the replication.
	/// </summary>
	protected: ::std::wstring TStampAclSync;
	/// <summary>
	/// The Sord is deleted at this user.
	/// </summary>
	/// <remarks>
	/// <p>Is undefined if isDeleted() returns false.</p>
	/// </remarks>
	protected: int32_t deleteUser;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: Sord();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: Sord(const ::std::wstring& SReg, const ::std::wstring& TStamp, const ::std::wstring& acl, int32_t att, int32_t childCount, int32_t doc, const ::std::wstring& guid, int32_t histCount, int32_t id, int32_t info, int32_t key, int32_t kind, int32_t lockId, int32_t mask, const ::std::wstring& name, int32_t ownerId, int32_t parentId, int32_t path, int32_t type, int32_t vtRep, const ::std::wstring& IDateIso, const ::std::wstring& XDateIso, int32_t access, const PArrayAclItem& aclItems, const ::std::wstring& delDateIso, bool deleted, const ::std::wstring& desc, const PSordDetails& details, const PDocVersion& docVersion, const ::std::wstring& hiddenText, const PArraySordLink& linksComeIn, const PArraySordLink& linksGoOut, const ::std::wstring& lockName, const PArrayObjKey& objKeys, const ::std::wstring& ownerName, const PArrayString& parentIds, const PArrayArcPath& refPaths, const PArrayReplSetName& replNames, const PReplSet& replSet, const ::std::wstring& maskName, const PDocVersion& attVersion, const ::std::wstring& deleteDateIso, int32_t lockIdSord, int32_t lockIdDoc, const ::std::wstring& lockNameSord, const ::std::wstring& lockNameDoc, const ::std::wstring& TStampSync, const ::std::wstring& TStampAcl, const ::std::wstring& TStampAclSync, int32_t deleteUser);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: ::std::wstring getSReg() { return SReg; }
	public: void setSReg(::std::wstring v);
	public: ::std::wstring getTStamp() { return TStamp; }
	public: void setTStamp(::std::wstring v);
	public: ::std::wstring getAcl() { return acl; }
	public: void setAcl(::std::wstring v);
	public: int32_t getAtt() { return att; }
	public: void setAtt(int32_t v);
	public: int32_t getChildCount() { return childCount; }
	public: void setChildCount(int32_t v);
	public: int32_t getDoc() { return doc; }
	public: void setDoc(int32_t v);
	public: ::std::wstring getGuid() { return guid; }
	public: void setGuid(::std::wstring v);
	public: int32_t getHistCount() { return histCount; }
	public: void setHistCount(int32_t v);
	public: int32_t getId() { return id; }
	public: void setId(int32_t v);
	public: int32_t getInfo() { return info; }
	public: void setInfo(int32_t v);
	public: int32_t getKey() { return key; }
	public: void setKey(int32_t v);
	public: int32_t getKind() { return kind; }
	public: void setKind(int32_t v);
	public: int32_t getLockId() { return lockId; }
	public: void setLockId(int32_t v);
	public: int32_t getMask() { return mask; }
	public: void setMask(int32_t v);
	public: ::std::wstring getName() { return name; }
	public: void setName(::std::wstring v);
	public: int32_t getOwnerId() { return ownerId; }
	public: void setOwnerId(int32_t v);
	public: int32_t getParentId() { return parentId; }
	public: void setParentId(int32_t v);
	public: int32_t getPath() { return path; }
	public: void setPath(int32_t v);
	public: int32_t getType() { return type; }
	public: void setType(int32_t v);
	public: int32_t getVtRep() { return vtRep; }
	public: void setVtRep(int32_t v);
	public: ::std::wstring getIDateIso() { return IDateIso; }
	public: void setIDateIso(::std::wstring v);
	public: ::std::wstring getXDateIso() { return XDateIso; }
	public: void setXDateIso(::std::wstring v);
	public: int32_t getAccess() { return access; }
	public: void setAccess(int32_t v);
	public: PArrayAclItem getAclItems() { return aclItems; }
	public: void setAclItems(PArrayAclItem v);
	public: ::std::wstring getDelDateIso() { return delDateIso; }
	public: void setDelDateIso(::std::wstring v);
	public: bool getDeleted() { return deleted; }
	public: void setDeleted(bool v);
	public: ::std::wstring getDesc() { return desc; }
	public: void setDesc(::std::wstring v);
	public: PSordDetails getDetails() { return details; }
	public: void setDetails(PSordDetails v);
	public: PDocVersion getDocVersion() { return docVersion; }
	public: void setDocVersion(PDocVersion v);
	public: ::std::wstring getHiddenText() { return hiddenText; }
	public: void setHiddenText(::std::wstring v);
	public: PArraySordLink getLinksComeIn() { return linksComeIn; }
	public: void setLinksComeIn(PArraySordLink v);
	public: PArraySordLink getLinksGoOut() { return linksGoOut; }
	public: void setLinksGoOut(PArraySordLink v);
	public: ::std::wstring getLockName() { return lockName; }
	public: void setLockName(::std::wstring v);
	public: PArrayObjKey getObjKeys() { return objKeys; }
	public: void setObjKeys(PArrayObjKey v);
	public: ::std::wstring getOwnerName() { return ownerName; }
	public: void setOwnerName(::std::wstring v);
	public: PArrayString getParentIds() { return parentIds; }
	public: void setParentIds(PArrayString v);
	public: PArrayArcPath getRefPaths() { return refPaths; }
	public: void setRefPaths(PArrayArcPath v);
	public: PArrayReplSetName getReplNames() { return replNames; }
	public: void setReplNames(PArrayReplSetName v);
	public: PReplSet getReplSet() { return replSet; }
	public: void setReplSet(PReplSet v);
	public: ::std::wstring getMaskName() { return maskName; }
	public: void setMaskName(::std::wstring v);
	public: PDocVersion getAttVersion() { return attVersion; }
	public: void setAttVersion(PDocVersion v);
	public: ::std::wstring getDeleteDateIso() { return deleteDateIso; }
	public: void setDeleteDateIso(::std::wstring v);
	public: int32_t getLockIdSord() { return lockIdSord; }
	public: void setLockIdSord(int32_t v);
	public: int32_t getLockIdDoc() { return lockIdDoc; }
	public: void setLockIdDoc(int32_t v);
	public: ::std::wstring getLockNameSord() { return lockNameSord; }
	public: void setLockNameSord(::std::wstring v);
	public: ::std::wstring getLockNameDoc() { return lockNameDoc; }
	public: void setLockNameDoc(::std::wstring v);
	public: ::std::wstring getTStampSync() { return TStampSync; }
	public: void setTStampSync(::std::wstring v);
	public: ::std::wstring getTStampAcl() { return TStampAcl; }
	public: void setTStampAcl(::std::wstring v);
	public: ::std::wstring getTStampAclSync() { return TStampAclSync; }
	public: void setTStampAclSync(::std::wstring v);
	public: int32_t getDeleteUser() { return deleteUser; }
	public: void setDeleteUser(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// SordC
// typeId=1553100003

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// <p>Constants for indexing information.
/// </summary>
/// <remarks>
/// Each member of this class with prefix
/// "mb" has a corresponding member in class <code>Sord</code></p>
/// </remarks>
class SordC : public ObjDataC {
	/// <summary>
	/// ACL in a human readable format.
	/// </summary>
	public: const static int64_t mbAclItems = 1099511627776LL;
	/// <summary>
	/// Replication set.
	/// </summary>
	public: const static int64_t mbReplSet = 2199023255552LL;
	/// <summary>
	/// Replication set names.
	/// </summary>
	public: const static int64_t mbReplNames = 4398046511104LL;
	/// <summary>
	/// Index lines.
	/// </summary>
	public: const static int64_t mbObjKeys = 8796093022208LL;
	/// <summary>
	/// Version information of the current document work version.
	/// </summary>
	public: const static int64_t mbDocVersionMembers = 17592186044416LL;
	/// <summary>
	/// Return the content of a "small" document in <code>DocVersion.fileData</code>.
	/// </summary>
	/// <remarks>
	/// Reading small documents is up to 3 times faster this way.
	/// The IX configuration defines the maximum size of a
	/// "small" document (e. g. less than 100KB).
	/// </remarks>
	public: const static int64_t mbSmallDocumentContent = 35184372088832LL;
	/// <summary>
	/// Detects whether there is a preview for a given document availiable.
	/// </summary>
	public: const static int64_t mbPreview = 70368744177664LL;
	/// <summary>
	/// Set this option to return the physical path of the document in the DocVersion object.
	/// </summary>
	/// <remarks>
	/// This Option requires always a request to Document Manager.
	/// </remarks>
	public: const static int64_t mbPhysPath = 70368744177664LL;
	/// <summary>
	/// GUIDs of parents that reference <code>this</code>
	/// </summary>
	public: const static int64_t mbParentIds = 140737488355328LL;
	/// <summary>
	/// GUIDs of linked archive entries.
	/// </summary>
	public: const static int64_t mbLinks = 281474976710656LL;
	public: const static int64_t mbRefPaths = 562949953421312LL;
	/// <summary>
	/// Member bit for Sord.attVersion
	/// </summary>
	public: const static int64_t mbAttVersionMembers = 1125899906842624LL;
	/// <summary>
	/// Document file content is supplied in {@link FileData#stream}.
	/// </summary>
	public: const static int64_t mbContentStream = 2251799813685248LL;
	public: const static int64_t mbIDateIso = 128LL;
	public: const static int64_t mbXDateIso = 256LL;
	public: const static int64_t mbDelDateIso = 8388608LL;
	public: const static int64_t mbDeleted = 524288LL;
	public: const static int64_t mbDetails = 16LL;
	public: const static int64_t mbDocVersion = 17592186044416LL;
	public: const static int64_t mbHiddenText = 2097152LL;
	public: const static int64_t mbLinksComeIn = 281474976710656LL;
	public: const static int64_t mbLinksGoOut = 281474976710656LL;
	public: const static int64_t mbOwnerName = 131072LL;
	/// <summary>
	/// Description and Hidden Text
	/// </summary>
	public: const static int64_t mbDesc = 2097152LL;
	/// <summary>
	/// This members are read-only and ignored in checkinSord
	/// </summary>
	public: const static int64_t mbReadOnlyMembers = 985175307845632LL;
	/// <summary>
	/// This members are write-only and were not read in checkoutSord, checkoutDoc, findFirstSords.
	/// </summary>
	/// <remarks>
	/// mbSDesc, mbSName
	/// </remarks>
	public: const static int64_t mbWriteOnlyMembers = 1610612736LL;
	/// <summary>
	/// Length of description + hidden text
	/// </summary>
	protected: int32_t lnDesc;
	/// <summary>
	/// All members - without mbSmallDocumentContent
	/// </summary>
	public: const static int64_t mbAllMembers = 2145422063697919LL;
	/// <summary>
	/// Includes:
	/// ObjDataC.mbAllMembers with mbAclItems, mbObjKeys
	/// </summary>
	public: const static int64_t mbLeanMembers = 10168869847039LL;
	/// <summary>
	/// Includes:
	/// ObjDataC.mbAllMembers with mbObjKeys
	/// </summary>
	public: const static int64_t mbReplMembers = 9070970929151LL;
	/// <summary>
	/// Includes:
	/// mbLeanMembers without mbObjKeys
	/// </summary>
	public: const static int64_t mbMinMembers = 1372776824831LL;
	/// <summary>
	/// <code>Sord</code> objects with type greater or equal than
	/// <code>LBT_DOCUMENT</code> and less or equal than
	/// <code>LBT_DOCUMENT_MAX</code> are documents.
	/// </summary>
	public: const static int32_t LBT_DOCUMENT = 254;
	/// <summary>
	/// <code>Sord</code> objects with type greater or equal than
	/// <code>LBT_DOCUMENT</code> and less or equal than
	/// <code>LBT_DOCUMENT_MAX</code> are documents.
	/// </summary>
	public: const static int32_t LBT_DOCUMENT_MAX = 310;
	/// <summary>
	/// There is one <code>Sord</code> object inside the archive database with ID 1.
	/// </summary>
	/// <remarks>
	/// It contains some archive configuration and has this type:
	/// </remarks>
	public: const static int32_t LBT_ARCHIVE = 9999;
	/// <summary>
	/// Sord type of user folder.
	/// </summary>
	/// <remarks>
	/// User folders are stored under folder Administration/Users and
	/// this value is used as {@link Sord#type}.
	/// </remarks>
	public: const static int32_t TYPE_USER_FOLDER = 23;
	/// <summary>
	/// Implementation detail: This flag is added to the object ID in the table
	/// "dochistory" to differentiate between documents and attachments.
	/// </summary>
	public: const static int32_t ATTACHMENT_FLAG_IN_DOCHISTORY = 1073741824;
	/// <summary>
	/// All members
	/// without
	/// mbSmallDocumentContent
	/// mbPreview
	/// </summary>
	public: const static PSordZ mbAll;
	/// <summary>
	/// Lean members
	/// </summary>
	public: const static PSordZ mbLean;
	/// <summary>
	/// All members
	/// without
	/// mbSmallDocumentContent
	/// mbPreview
	/// mbDocVersionMembers
	/// mbRefPaths
	/// mbAttVersionMembers
	/// </summary>
	public: const static PSordZ mbAllIndex;
	/// <summary>
	/// Minimum members.
	/// </summary>
	public: const static PSordZ mbMin;
	/// <summary>
	/// Includes only <code>Sord.id</code>
	/// </summary>
	public: const static PSordZ mbOnlyId;
	/// <summary>
	/// Includes only <code>Sord.guid</code>
	/// </summary>
	public: const static PSordZ mbOnlyGuid;
	/// <summary>
	/// Do not store/read any members.
	/// </summary>
	/// <remarks>
	/// Evaluate the lock flag only.
	/// </remarks>
	public: const static PSordZ mbOnlyLock;
	/// <summary>
	/// Same as mbOnlyLock
	/// </summary>
	public: const static PSordZ mbOnlyUnlock;
	/// <summary>
	/// Includes:
	/// mbMinMembers,
	/// mbDocVersionMembers,
	/// mbPreview
	/// </summary>
	public: const static PSordZ mbMinDocVersion;
	/// <summary>
	/// Includes:
	/// mbAllMembers,
	/// mbSmallDocumentContent
	/// without
	/// mbPreview
	/// </summary>
	public: const static PSordZ mbCheckout;
	/// <summary>
	/// Includes:
	/// mbAllMembers,
	/// mbSmallDocumentContent,
	/// mbPreview
	/// </summary>
	public: const static PSordZ mbCheckoutPreview;
	/// <summary>
	/// The objdesc column in the database is splitted into a visible and an
	/// invisible part.
	/// </summary>
	/// <remarks>
	/// This constant is the delimiter between them.
	/// </remarks>
	public: const static ::std::wstring DESC_DELIM;
	/// <summary>
	/// GUID of folder "Replication Base"
	/// </summary>
	protected: ::std::wstring GUID_REPLICATION_BASE;
	/// <summary>
	/// GUID of folder "Scripting Base"
	/// </summary>
	protected: ::std::wstring GUID_SCRIPTING_BASE;
	/// <summary>
	/// GUID of folder "IndexServer Scripting Base"
	/// </summary>
	protected: ::std::wstring GUID_IX_SCRIPTING_BASE;
	/// <summary>
	/// GUID of folder "Administration".
	/// </summary>
	/// <remarks>
	/// This folder contains "Replication Base", "Scripting Base" etc.
	/// </remarks>
	protected: ::std::wstring GUID_ADMINISTRATION_BASE;
	/// <summary>
	/// Archive folder /Administration/COLD Background Images
	/// </summary>
	protected: ::std::wstring GUID_COLD_BACKGROUND_IMAGES;
	/// <summary>
	/// Archive folder /Administration/ELOscripts, VB scripts for Windows Client.
	/// </summary>
	protected: ::std::wstring GUID_WIN_SCRIPTING_BASE;
	/// <summary>
	/// Archive folder that contains the icons for the workflow nodes.
	/// </summary>
	protected: ::std::wstring GUID_WORKFLOW_ICONS_BASE;
	/// <summary>
	/// Object-GUID of icon file for begin node.
	/// </summary>
	protected: ::std::wstring GUID_WFNODE_ICON_BEGINNODE;
	/// <summary>
	/// Object-GUID of icon file for person node.
	/// </summary>
	protected: ::std::wstring GUID_WFNODE_ICON_PERSONNODE;
	/// <summary>
	/// Object-GUID of icon file for decision node.
	/// </summary>
	protected: ::std::wstring GUID_WFNODE_ICON_IFNODE;
	/// <summary>
	/// Object-GUID of icon file for collect node.
	/// </summary>
	protected: ::std::wstring GUID_WFNODE_ICON_COLLECTNODE;
	/// <summary>
	/// reserved
	/// </summary>
	protected: ::std::wstring GUID_WFNODE_ICON_TERMINATE;
	/// <summary>
	/// Object-GUID of icon file for cycle node.
	/// </summary>
	protected: ::std::wstring GUID_WFNODE_ICON_CYCLE_BEGIN;
	/// <summary>
	/// Object-GUID of icon file for cycle node.
	/// </summary>
	protected: ::std::wstring GUID_WFNODE_ICON_CYCLE_END;
	/// <summary>
	/// Object-GUID of icon file for server node.
	/// </summary>
	protected: ::std::wstring GUID_WFNODE_ICON_SET_SERVER_ID;
	/// <summary>
	/// Object-GUID of icon file for split node.
	/// </summary>
	protected: ::std::wstring GUID_WFNODE_ICON_SPLITNODE;
	/// <summary>
	/// Object-GUID of users folder.
	/// </summary>
	protected: ::std::wstring GUID_USERS_FOLDER;
	/// <summary>
	/// Object-GUID of ELO Textreader folder.
	/// </summary>
	protected: ::std::wstring GUID_TEXTREADER_FOLDER;
	/// <summary>
	/// Object-GUID of ELO Textreader not converted documents folder.
	/// </summary>
	protected: ::std::wstring GUID_TRNOTCONV_FOLDER;
	/// <summary>
	/// GUID of folder "/Administration/ELO-Apps".
	/// </summary>
	protected: ::std::wstring GUID_APPS_FOLDER;
	/// <summary>
	/// Index value ELOINDEX of sub-folder "data" of a users folder.
	/// </summary>
	/// <remarks>
	/// The "data" sub-folder of a user folder can be read as follows:
	/// <code>String objId = "OKEY:ELOINDEX=" + ELOINDEX_USER_FOLDER_DATA + user-guid</code>
	/// <code>EditInfo ed = conn.ix().checkoutSord(objId, ...)</code>
	/// </remarks>
	protected: ::std::wstring ELOINDEX_USER_FOLDER_DATA;
	/// <summary>
	/// Index value ELOINDEX of sub-folder "data/elo.profile" of a users folder.
	/// </summary>
	protected: ::std::wstring ELOINDEX_USER_FOLDER_DATA_PROFILE;
	/// <summary>
	/// Index value ELOINDEX of sub-folder "private" of a users folder.
	/// </summary>
	protected: ::std::wstring ELOINDEX_USER_FOLDER_PRIVATE;
	/// <summary>
	/// Index value ELOINDEX of sub-folder "inbox" of a users folder.
	/// </summary>
	protected: ::std::wstring ELOINDEX_USER_FOLDER_INBOX;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: SordC();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: SordC(int64_t mbAclItems, int64_t mbReplSet, int64_t mbReplNames, int64_t mbObjKeys, int64_t mbDocVersionMembers, int64_t mbSmallDocumentContent, int64_t mbPreview, int64_t mbPhysPath, int64_t mbParentIds, int64_t mbLinks, int64_t mbRefPaths, int64_t mbAttVersionMembers, int64_t mbContentStream, int64_t mbIDateIso, int64_t mbXDateIso, int64_t mbDelDateIso, int64_t mbDeleted, int64_t mbDetails, int64_t mbDocVersion, int64_t mbHiddenText, int64_t mbLinksComeIn, int64_t mbLinksGoOut, int64_t mbOwnerName, int64_t mbDesc, int64_t mbReadOnlyMembers, int64_t mbWriteOnlyMembers, int32_t lnDesc, int64_t mbAllMembers, int64_t mbLeanMembers, int64_t mbReplMembers, int64_t mbMinMembers, int32_t LBT_DOCUMENT, int32_t LBT_DOCUMENT_MAX, int32_t LBT_ARCHIVE, int32_t TYPE_USER_FOLDER, int32_t ATTACHMENT_FLAG_IN_DOCHISTORY, const PSordZ& mbAll, const PSordZ& mbLean, const PSordZ& mbAllIndex, const PSordZ& mbMin, const PSordZ& mbOnlyId, const PSordZ& mbOnlyGuid, const PSordZ& mbOnlyLock, const PSordZ& mbOnlyUnlock, const PSordZ& mbMinDocVersion, const PSordZ& mbCheckout, const PSordZ& mbCheckoutPreview, const ::std::wstring& DESC_DELIM, const ::std::wstring& GUID_REPLICATION_BASE, const ::std::wstring& GUID_SCRIPTING_BASE, const ::std::wstring& GUID_IX_SCRIPTING_BASE, const ::std::wstring& GUID_ADMINISTRATION_BASE, const ::std::wstring& GUID_COLD_BACKGROUND_IMAGES, const ::std::wstring& GUID_WIN_SCRIPTING_BASE, const ::std::wstring& GUID_WORKFLOW_ICONS_BASE, const ::std::wstring& GUID_WFNODE_ICON_BEGINNODE, const ::std::wstring& GUID_WFNODE_ICON_PERSONNODE, const ::std::wstring& GUID_WFNODE_ICON_IFNODE, const ::std::wstring& GUID_WFNODE_ICON_COLLECTNODE, const ::std::wstring& GUID_WFNODE_ICON_TERMINATE, const ::std::wstring& GUID_WFNODE_ICON_CYCLE_BEGIN, const ::std::wstring& GUID_WFNODE_ICON_CYCLE_END, const ::std::wstring& GUID_WFNODE_ICON_SET_SERVER_ID, const ::std::wstring& GUID_WFNODE_ICON_SPLITNODE, const ::std::wstring& GUID_USERS_FOLDER, const ::std::wstring& GUID_TEXTREADER_FOLDER, const ::std::wstring& GUID_TRNOTCONV_FOLDER, const ::std::wstring& GUID_APPS_FOLDER, const ::std::wstring& ELOINDEX_USER_FOLDER_DATA, const ::std::wstring& ELOINDEX_USER_FOLDER_DATA_PROFILE, const ::std::wstring& ELOINDEX_USER_FOLDER_PRIVATE, const ::std::wstring& ELOINDEX_USER_FOLDER_INBOX);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getLnDesc() { return lnDesc; }
	public: void setLnDesc(int32_t v);
	public: ::std::wstring getGUID_REPLICATION_BASE() { return GUID_REPLICATION_BASE; }
	public: void setGUID_REPLICATION_BASE(::std::wstring v);
	public: ::std::wstring getGUID_SCRIPTING_BASE() { return GUID_SCRIPTING_BASE; }
	public: void setGUID_SCRIPTING_BASE(::std::wstring v);
	public: ::std::wstring getGUID_IX_SCRIPTING_BASE() { return GUID_IX_SCRIPTING_BASE; }
	public: void setGUID_IX_SCRIPTING_BASE(::std::wstring v);
	public: ::std::wstring getGUID_ADMINISTRATION_BASE() { return GUID_ADMINISTRATION_BASE; }
	public: void setGUID_ADMINISTRATION_BASE(::std::wstring v);
	public: ::std::wstring getGUID_COLD_BACKGROUND_IMAGES() { return GUID_COLD_BACKGROUND_IMAGES; }
	public: void setGUID_COLD_BACKGROUND_IMAGES(::std::wstring v);
	public: ::std::wstring getGUID_WIN_SCRIPTING_BASE() { return GUID_WIN_SCRIPTING_BASE; }
	public: void setGUID_WIN_SCRIPTING_BASE(::std::wstring v);
	public: ::std::wstring getGUID_WORKFLOW_ICONS_BASE() { return GUID_WORKFLOW_ICONS_BASE; }
	public: void setGUID_WORKFLOW_ICONS_BASE(::std::wstring v);
	public: ::std::wstring getGUID_WFNODE_ICON_BEGINNODE() { return GUID_WFNODE_ICON_BEGINNODE; }
	public: void setGUID_WFNODE_ICON_BEGINNODE(::std::wstring v);
	public: ::std::wstring getGUID_WFNODE_ICON_PERSONNODE() { return GUID_WFNODE_ICON_PERSONNODE; }
	public: void setGUID_WFNODE_ICON_PERSONNODE(::std::wstring v);
	public: ::std::wstring getGUID_WFNODE_ICON_IFNODE() { return GUID_WFNODE_ICON_IFNODE; }
	public: void setGUID_WFNODE_ICON_IFNODE(::std::wstring v);
	public: ::std::wstring getGUID_WFNODE_ICON_COLLECTNODE() { return GUID_WFNODE_ICON_COLLECTNODE; }
	public: void setGUID_WFNODE_ICON_COLLECTNODE(::std::wstring v);
	public: ::std::wstring getGUID_WFNODE_ICON_TERMINATE() { return GUID_WFNODE_ICON_TERMINATE; }
	public: void setGUID_WFNODE_ICON_TERMINATE(::std::wstring v);
	public: ::std::wstring getGUID_WFNODE_ICON_CYCLE_BEGIN() { return GUID_WFNODE_ICON_CYCLE_BEGIN; }
	public: void setGUID_WFNODE_ICON_CYCLE_BEGIN(::std::wstring v);
	public: ::std::wstring getGUID_WFNODE_ICON_CYCLE_END() { return GUID_WFNODE_ICON_CYCLE_END; }
	public: void setGUID_WFNODE_ICON_CYCLE_END(::std::wstring v);
	public: ::std::wstring getGUID_WFNODE_ICON_SET_SERVER_ID() { return GUID_WFNODE_ICON_SET_SERVER_ID; }
	public: void setGUID_WFNODE_ICON_SET_SERVER_ID(::std::wstring v);
	public: ::std::wstring getGUID_WFNODE_ICON_SPLITNODE() { return GUID_WFNODE_ICON_SPLITNODE; }
	public: void setGUID_WFNODE_ICON_SPLITNODE(::std::wstring v);
	public: ::std::wstring getGUID_USERS_FOLDER() { return GUID_USERS_FOLDER; }
	public: void setGUID_USERS_FOLDER(::std::wstring v);
	public: ::std::wstring getGUID_TEXTREADER_FOLDER() { return GUID_TEXTREADER_FOLDER; }
	public: void setGUID_TEXTREADER_FOLDER(::std::wstring v);
	public: ::std::wstring getGUID_TRNOTCONV_FOLDER() { return GUID_TRNOTCONV_FOLDER; }
	public: void setGUID_TRNOTCONV_FOLDER(::std::wstring v);
	public: ::std::wstring getGUID_APPS_FOLDER() { return GUID_APPS_FOLDER; }
	public: void setGUID_APPS_FOLDER(::std::wstring v);
	public: ::std::wstring getELOINDEX_USER_FOLDER_DATA() { return ELOINDEX_USER_FOLDER_DATA; }
	public: void setELOINDEX_USER_FOLDER_DATA(::std::wstring v);
	public: ::std::wstring getELOINDEX_USER_FOLDER_DATA_PROFILE() { return ELOINDEX_USER_FOLDER_DATA_PROFILE; }
	public: void setELOINDEX_USER_FOLDER_DATA_PROFILE(::std::wstring v);
	public: ::std::wstring getELOINDEX_USER_FOLDER_PRIVATE() { return ELOINDEX_USER_FOLDER_PRIVATE; }
	public: void setELOINDEX_USER_FOLDER_PRIVATE(::std::wstring v);
	public: ::std::wstring getELOINDEX_USER_FOLDER_INBOX() { return ELOINDEX_USER_FOLDER_INBOX; }
	public: void setELOINDEX_USER_FOLDER_INBOX(::std::wstring v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// SordDetails
// typeId=1713693326

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Objects of this class are data elements and control the values assigned to
/// certain boolean properties(yes/no attributes).
/// </summary>
/// <remarks>
/// <p>Copyright: Copyright (c) 2004</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </remarks>
class SordDetails : public ValueClass {
	/// <summary>
	/// Archiving mode.
	/// </summary>
	/// <remarks>
	/// The possible values are:
	/// <table border="2">
	/// <tr><td>version controlled</td><td>ArchivingModeC.VERSION</td></tr>
	/// <tr><td>read-only</td><td>ArchivingModeC.READONLY</td></tr>
	/// <tr><td>read/write</td><td>ArchivingModeC.READWRITE</td></tr>
	/// </table>
	/// This value is only valid for document objects.
	/// </remarks>
	protected: int32_t archivingMode;
	/// <summary>
	/// Encryption set number.
	/// </summary>
	protected: int32_t encryptionSet;
	/// <summary>
	/// Document is or should be containted in the fultext database.
	/// </summary>
	protected: bool fulltext;
	/// <summary>
	/// Sort order of child entries.
	/// </summary>
	/// <remarks>
	/// This value is only valid for folder objects.
	/// </remarks>
	protected: int32_t sortOrder;
	/// <summary>
	/// True, if replication is enabled for this archive.
	/// </summary>
	protected: bool arcReplEnabled;
	/// <summary>
	/// Document is indexed in the fultext database.
	/// </summary>
	protected: bool fulltextDone;
	/// <summary>
	/// True, if this object is a root folder for replication.
	/// </summary>
	protected: bool replRoot;
	/// <summary>
	/// True, if this object has links to other Sords.
	/// </summary>
	/// <remarks>
	/// This member is read-only and is ignored in checkinSord and checkinDocEnd.
	/// </remarks>
	protected: bool linked;
	/// <summary>
	/// True, if a document or attachment version has been deleted.
	/// </summary>
	protected: bool incomplete;
	/// <summary>
	/// Documents using this mask may be used as release notes
	/// </summary>
	protected: bool limitedReleaseDocument;
	/// <summary>
	/// True, if this object has permanent links to other Sords.
	/// </summary>
	/// <remarks>
	/// This member is read-only and is ignored in checkinSord and checkinDocEnd.
	/// </remarks>
	protected: bool linkedPermanent;
	/// <summary>
	/// Folders can be marked as a document container by this flag.
	/// </summary>
	/// <remarks>
	/// If true,
	/// clients are advised to preview the first document in this folder on
	/// selection.
	/// </remarks>
	protected: bool documentContainer;
	/// <summary>
	/// If <tt>true</tt> translate the sord's short description into or from the user language.
	/// </summary>
	protected: bool translateSordName;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: SordDetails();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: SordDetails(int32_t archivingMode, int32_t encryptionSet, bool fulltext, int32_t sortOrder, bool arcReplEnabled, bool fulltextDone, bool replRoot, bool linked, bool incomplete, bool limitedReleaseDocument, bool linkedPermanent, bool documentContainer, bool translateSordName);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getArchivingMode() { return archivingMode; }
	public: void setArchivingMode(int32_t v);
	public: int32_t getEncryptionSet() { return encryptionSet; }
	public: void setEncryptionSet(int32_t v);
	public: bool getFulltext() { return fulltext; }
	public: void setFulltext(bool v);
	public: int32_t getSortOrder() { return sortOrder; }
	public: void setSortOrder(int32_t v);
	public: bool getArcReplEnabled() { return arcReplEnabled; }
	public: void setArcReplEnabled(bool v);
	public: bool getFulltextDone() { return fulltextDone; }
	public: void setFulltextDone(bool v);
	public: bool getReplRoot() { return replRoot; }
	public: void setReplRoot(bool v);
	public: bool getLinked() { return linked; }
	public: void setLinked(bool v);
	public: bool getIncomplete() { return incomplete; }
	public: void setIncomplete(bool v);
	public: bool getLimitedReleaseDocument() { return limitedReleaseDocument; }
	public: void setLimitedReleaseDocument(bool v);
	public: bool getLinkedPermanent() { return linkedPermanent; }
	public: void setLinkedPermanent(bool v);
	public: bool getDocumentContainer() { return documentContainer; }
	public: void setDocumentContainer(bool v);
	public: bool getTranslateSordName() { return translateSordName; }
	public: void setTranslateSordName(bool v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// SordHist
// typeId=2121567102

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Version history for the keywording from an object.
/// </summary>
/// <remarks>
/// A version history is
/// created for a sord object when the keywording is
/// changed for the first time (a newly created sord has no version history).
/// Once created only one SordHist object exist for the sord object and is
/// assigned to the sord object via the Sord.guid = SordHist.objGuid relationship.
/// The keywording properties that were altered in the change process are saved in
/// an array of SordHistKey objects.
/// 
/// <p>Copyright: Copyright (c) 2004</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </remarks>
class SordHist : public ValueClass {
	/// <summary>
	/// GUID of the SordHist object.
	/// </summary>
	protected: ::std::wstring histGuid;
	/// <summary>
	/// Identifies the application with which changes were made to the keywording.
	/// </summary>
	protected: int32_t histSource;
	/// <summary>
	/// GUID of the sord object.
	/// </summary>
	protected: ::std::wstring objGuid;
	/// <summary>
	/// Timestamp of the change in the timezone of the client.
	/// </summary>
	/// <remarks>
	/// The format is JJJJ.MM.DD.hh.mm.ss
	/// </remarks>
	protected: ::std::wstring timeStampLocal;
	/// <summary>
	/// Timestamp of the change in the timezone of the client, in UTC form.
	/// </summary>
	/// <remarks>
	/// The format is JJJJ.MM.DD.hh.mm.ss
	/// </remarks>
	protected: ::std::wstring timeStampUTC;
	/// <summary>
	/// The name of the user who carried out the changes.
	/// </summary>
	protected: ::std::wstring userName;
	/// <summary>
	/// The user who carried out the changes.
	/// </summary>
	protected: int32_t userNo;
	/// <summary>
	/// The name of the computer from which the change was carried out.
	/// </summary>
	/// <remarks>
	/// This is the parameter
	/// clientComputer which is provided by the ix.login function.
	/// </remarks>
	protected: ::std::wstring workStation;
	/// <summary>
	/// An array of the keywording changes.
	/// </summary>
	protected: PArraySordHistKey histKeys;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: SordHist();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: SordHist(const ::std::wstring& histGuid, int32_t histSource, const ::std::wstring& objGuid, const ::std::wstring& timeStampLocal, const ::std::wstring& timeStampUTC, const ::std::wstring& userName, int32_t userNo, const ::std::wstring& workStation, const PArraySordHistKey& histKeys);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: ::std::wstring getHistGuid() { return histGuid; }
	public: void setHistGuid(::std::wstring v);
	public: int32_t getHistSource() { return histSource; }
	public: void setHistSource(int32_t v);
	public: ::std::wstring getObjGuid() { return objGuid; }
	public: void setObjGuid(::std::wstring v);
	public: ::std::wstring getTimeStampLocal() { return timeStampLocal; }
	public: void setTimeStampLocal(::std::wstring v);
	public: ::std::wstring getTimeStampUTC() { return timeStampUTC; }
	public: void setTimeStampUTC(::std::wstring v);
	public: ::std::wstring getUserName() { return userName; }
	public: void setUserName(::std::wstring v);
	public: int32_t getUserNo() { return userNo; }
	public: void setUserNo(int32_t v);
	public: ::std::wstring getWorkStation() { return workStation; }
	public: void setWorkStation(::std::wstring v);
	public: PArraySordHistKey getHistKeys() { return histKeys; }
	public: void setHistKeys(PArraySordHistKey v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// SordHistC
// typeId=520610723

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Constanst for class SordHist.
/// </summary>
class SordHistC : public ObjHistC {
	/// <summary>
	/// History entry created by unknown program.
	/// </summary>
	public: const static int32_t SRC_NONE = 0;
	/// <summary>
	/// History entry created by ELO Windows Client.
	/// </summary>
	public: const static int32_t SRC_CLIENT = 1;
	/// <summary>
	/// History entry created by ELO Automation Interface.
	/// </summary>
	public: const static int32_t SRC_OLE = 2;
	/// <summary>
	/// History entry created by ELO Internet Gateway.
	/// </summary>
	public: const static int32_t SRC_IGW = 3;
	/// <summary>
	/// History entry created by ELO XML Importer
	/// </summary>
	public: const static int32_t SRC_XML = 4;
	/// <summary>
	/// History entry created by ELO SAPALINK.
	/// </summary>
	public: const static int32_t SRC_SAP = 5;
	/// <summary>
	/// History entry created by ELO IndexServer.
	/// </summary>
	public: const static int32_t SRC_IX = 6;
	/// <summary>
	/// History entry created by ELO Replication.
	/// </summary>
	public: const static int32_t SRC_REPL = 7;
	/// <summary>
	/// History entry created by ELO Archive Synchronisation.
	/// </summary>
	public: const static int32_t SRC_SYNC = 8;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: SordHistC();
	
	public: virtual BTYPEID BSerializable_getTypeId();
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// SordHistKey
// typeId=251810638

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// This class provides the version information for a keywording attribute
/// that has been modified.
/// </summary>
/// <remarks>
/// <p>Copyright: Copyright (c) 2004</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </remarks>
class SordHistKey : public ValueClass {
	/// <summary>
	/// GUID of the assigned SordHist object.
	/// </summary>
	protected: ::std::wstring histGuid;
	/// <summary>
	/// Value of dat of the attribute.
	/// </summary>
	protected: ::std::wstring keyData;
	/// <summary>
	/// Name of the attribute.
	/// </summary>
	protected: ::std::wstring keyName;
	/// <summary>
	/// ID of the attribute.
	/// </summary>
	protected: int32_t keyNo;
	/// <summary>
	/// Index of the attribute within an array of attributes.
	/// </summary>
	protected: int32_t keyIndex;
	/// <summary>
	/// External ID of the attribute, serves as an identifier for keyNames.
	/// </summary>
	protected: int32_t keyId;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: SordHistKey();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: SordHistKey(const ::std::wstring& histGuid, const ::std::wstring& keyData, const ::std::wstring& keyName, int32_t keyNo, int32_t keyIndex, int32_t keyId);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: ::std::wstring getHistGuid() { return histGuid; }
	public: void setHistGuid(::std::wstring v);
	public: ::std::wstring getKeyData() { return keyData; }
	public: void setKeyData(::std::wstring v);
	public: ::std::wstring getKeyName() { return keyName; }
	public: void setKeyName(::std::wstring v);
	public: int32_t getKeyNo() { return keyNo; }
	public: void setKeyNo(int32_t v);
	public: int32_t getKeyIndex() { return keyIndex; }
	public: void setKeyIndex(int32_t v);
	public: int32_t getKeyId() { return keyId; }
	public: void setKeyId(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// SordHistKeyC
// typeId=762601968

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

class SordHistKeyC : public ObjHistKeyC {
	/// <summary>
	/// Entry IDs greater or equal of this value are used for Sord.name, Sord.xDate etc.
	/// </summary>
	public: const static int32_t ID_RESERVED_MIN = 200;
	/// <summary>
	/// Entry ID for Sord.name.
	/// </summary>
	public: const static int32_t ID_SORD_NAME = 200;
	/// <summary>
	/// Entry name for Sord.name.
	/// </summary>
	public: const static ::std::wstring NAME_SORD_NAME;
	/// <summary>
	/// Entry ID for Sord.xDate.
	/// </summary>
	public: const static int32_t ID_SORD_XDATE = 201;
	/// <summary>
	/// Entry name for Sord.xDate.
	/// </summary>
	public: const static ::std::wstring NAME_SORD_XDATE;
	/// <summary>
	/// Entry ID for Sord.desc.
	/// </summary>
	public: const static int32_t ID_SORD_DESC = 202;
	/// <summary>
	/// Entry name for Sord.desc.
	/// </summary>
	public: const static ::std::wstring NAME_SORD_DESC;
	/// <summary>
	/// Entry ID for Sord.mask.
	/// </summary>
	public: const static int32_t ID_DOCMASK_NAME = 203;
	/// <summary>
	/// Entry mame for Sord.name.
	/// </summary>
	public: const static ::std::wstring NAME_DOCMASK_NAME;
	/// <summary>
	/// Entry ID for Sord.acl
	/// </summary>
	public: const static int32_t ID_SORD_ACL = 204;
	/// <summary>
	/// Entry ID for Sord.acl
	/// </summary>
	public: const static ::std::wstring NAME_SORD_ACL;
	/// <summary>
	/// Entry ID for Sord.delDate.
	/// </summary>
	public: const static int32_t ID_SORD_DELDATE = 205;
	/// <summary>
	/// Entry name for Sord.delDate.
	/// </summary>
	public: const static ::std::wstring NAME_SORD_DELDATE;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: SordHistKeyC();
	
	public: virtual BTYPEID BSerializable_getTypeId();
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// SordLink
// typeId=200815802

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// This class represents a link to an archive entry.
/// </summary>
/// <remarks>
/// <p>Copyright: Copyright (c) 2004</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </remarks>
class SordLink : public ValueClass {
	/// <summary>
	/// Numerical ID of referenced Sord.
	/// </summary>
	protected: ::std::wstring id;
	/// <summary>
	/// Link ID.
	/// </summary>
	protected: ::std::wstring linkId;
	/// <summary>
	/// True, if this SordLink is permanent.
	/// </summary>
	/// <remarks>
	/// Permanent links between Sords cannot
	/// be deleted.
	/// </remarks>
	protected: bool permanent;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: SordLink();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: SordLink(const ::std::wstring& id, const ::std::wstring& linkId, bool permanent);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: ::std::wstring getId() { return id; }
	public: void setId(::std::wstring v);
	public: ::std::wstring getLinkId() { return linkId; }
	public: void setLinkId(::std::wstring v);
	public: bool getPermanent() { return permanent; }
	public: void setPermanent(bool v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// SordLinkC
// typeId=1347988541

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Constants-class for the table links.
/// </summary>
class SordLinkC : public ObjLinkC {
	public: const static int64_t FLAG_PERMANENT = 1LL;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: SordLinkC();
	
	public: virtual BTYPEID BSerializable_getTypeId();
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// SordPath
// typeId=544862901

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

class SordPath : public BSerializable {
	protected: PVectorSord sords;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: SordPath();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: SordPath(const PVectorSord& sords);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: PVectorSord getSords() { return sords; }
	public: void setSords(PVectorSord v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// SordPaths
// typeId=1835331414

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

class SordPaths : public BSerializable {
	protected: PVectorSordPath sordPaths;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: SordPaths();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: SordPaths(const PVectorSordPath& sordPaths);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: PVectorSordPath getSordPaths() { return sordPaths; }
	public: void setSordPaths(PVectorSordPath v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// SordType
// typeId=2065094749

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Each file structure element is assigned a SordType.
/// </summary>
/// <remarks>
/// This SordType has three
/// icons , which are used in the different view in the client: a standard icon,
/// a disabled icon (empty folders or references) and a workflow icon.<br>
/// The icons are available in BMP, ICO and JPEG format.
/// 
/// <p>Copyright: Copyright (c) 2004</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// 
/// see@ SordTypeC SordTypeC
/// </remarks>
class SordType : public ValueClass {
	/// <summary>
	/// File data of disabled icon.
	/// </summary>
	protected: PFileData disabledIcon;
	/// <summary>
	/// For document types, this array lists the associated file extensions.
	/// </summary>
	protected: PArrayString extensions;
	/// <summary>
	/// File data of normal icon.
	/// </summary>
	protected: PFileData icon;
	/// <summary>
	/// Sord type ID.
	/// </summary>
	protected: int32_t id;
	/// <summary>
	/// Type name.
	/// </summary>
	protected: ::std::wstring name;
	/// <summary>
	/// File data of workflow icon.
	/// </summary>
	protected: PFileData workflowIcon;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: SordType();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: SordType(const PFileData& disabledIcon, const PArrayString& extensions, const PFileData& icon, int32_t id, const ::std::wstring& name, const PFileData& workflowIcon);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: PFileData getDisabledIcon() { return disabledIcon; }
	public: void setDisabledIcon(PFileData v);
	public: PArrayString getExtensions() { return extensions; }
	public: void setExtensions(PArrayString v);
	public: PFileData getIcon() { return icon; }
	public: void setIcon(PFileData v);
	public: int32_t getId() { return id; }
	public: void setId(int32_t v);
	public: ::std::wstring getName() { return name; }
	public: void setName(::std::wstring v);
	public: PFileData getWorkflowIcon() { return workflowIcon; }
	public: void setWorkflowIcon(PFileData v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// SordTypeC
// typeId=635922924

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Constants for folder or document types.
/// </summary>
class SordTypeC : public BSerializable {
	/// <summary>
	/// Maximum number of folder types (=253).
	/// </summary>
	public: const static int32_t MAX_FOLDER_TYPES = 253;
	/// <summary>
	/// Maximum number of document types (=56).
	/// </summary>
	public: const static int32_t MAX_DOCUMENT_TYPES = 56;
	/// <summary>
	/// ID, name, extension.
	/// </summary>
	public: const static int64_t mbIdNameExt = 1LL;
	/// <summary>
	/// Return icon file data in <code>checkoutSordType</code>.
	/// </summary>
	public: const static int64_t mbIconMember = 2LL;
	/// <summary>
	/// Return file data of workflow icon in <code>checkoutSordType</code>.
	/// </summary>
	public: const static int64_t mbWorkflowIconMember = 4LL;
	/// <summary>
	/// Return file data of disabled icon in <code>checkoutSordType</code>.
	/// </summary>
	public: const static int64_t mbDisabledIconMember = 8LL;
	public: const static int64_t mbJPG = 16LL;
	public: const static int64_t mbBMP = 32LL;
	public: const static int64_t mbICO = 64LL;
	public: const static int64_t mbPNG = 128LL;
	/// <summary>
	/// Return only ID, name, extension - no icon data.
	/// </summary>
	public: const static PSordTypeZ mbNoIcons;
	/// <summary>
	/// Return icon file data in <code>checkoutSordType</code>.
	/// </summary>
	public: const static PSordTypeZ mbIconJPG;
	public: const static PSordTypeZ mbIconBMP;
	public: const static PSordTypeZ mbIconICO;
	public: const static PSordTypeZ mbIconPNG;
	/// <summary>
	/// Return file data of normal icon and disabled icon in <code>checkoutSordType</code>.
	/// </summary>
	public: const static PSordTypeZ mbIconsJPG;
	public: const static PSordTypeZ mbIconsBMP;
	public: const static PSordTypeZ mbIconsICO;
	public: const static PSordTypeZ mbIconsPNG;
	/// <summary>
	/// Return file data of normal, workflow and disabled icon in <code>checkoutSordType</code>.
	/// </summary>
	public: const static PSordTypeZ mbAllJPG;
	public: const static PSordTypeZ mbAllBMP;
	public: const static PSordTypeZ mbAllICO;
	public: const static PSordTypeZ mbAllPNG;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: SordTypeC();
	
	public: virtual BTYPEID BSerializable_getTypeId();
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// SordTypeZ
// typeId=314474107

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// <p>This class encapsulates the constants of <code>SordTypeC</code></p>
/// 
/// <p>Copyright: Copyright (c) 2004</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </summary>
class SordTypeZ : public ValueClass {
	/// <summary>
	/// Bitset field for constants from SordTypeC class.
	/// </summary>
	protected: int64_t bset;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: SordTypeZ();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: SordTypeZ(int64_t bset);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int64_t getBset() { return bset; }
	public: void setBset(int64_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// SordZ
// typeId=1441094282

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// <p>This class encapsulates the constants of <code>SordC</code></p>
/// 
/// <p>Copyright: Copyright (c) 2004</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </summary>
class SordZ : public ValueClass {
	/// <summary>
	/// Bitset field for constants from SordC class.
	/// </summary>
	protected: int64_t bset;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: SordZ();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: SordZ(int64_t bset);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int64_t getBset() { return bset; }
	public: void setBset(int64_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// SortOrderC
// typeId=1551556842

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// This class contains constants for sorting of archive entries and search results.
/// </summary>
class SortOrderC : public BSerializable {
	/// <summary>
	/// Subitems are sorted manually.
	/// </summary>
	public: const static int32_t MANUAL = 1000;
	/// <summary>
	/// Subitems are sorted by name.
	/// </summary>
	public: const static int32_t ALPHA = 1001;
	/// <summary>
	/// Subitems are sorted by external date.
	/// </summary>
	public: const static int32_t XDATE = 1002;
	/// <summary>
	/// Subitems are sorted by internal date.
	/// </summary>
	public: const static int32_t IDATE = 1003;
	/// <summary>
	/// Subitems are sorted by external date descending.
	/// </summary>
	public: const static int32_t IXDATE = 1004;
	/// <summary>
	/// Subitems are sorted by internal date descending.
	/// </summary>
	public: const static int32_t IIDATE = 1005;
	/// <summary>
	/// Subitems are sorted by name descending.
	/// </summary>
	public: const static int32_t IALPHA = 1006;
	public: const static int32_t DEFAULT = 1001;
	public: const static int32_t NONE = 1999;
	/// <summary>
	/// Used for the ascending ordering of threads by username.
	/// </summary>
	/// <remarks>
	/// This value can be used for {@link FindBackgroundThreadOptions#sortOrder}.
	/// </remarks>
	public: const static int32_t USERNAME = 1001;
	/// <summary>
	/// Used for the descending ordering of threads by username.
	/// </summary>
	/// <remarks>
	/// This value can be used for {@link FindBackgroundThreadOptions#sortOrder}.
	/// </remarks>
	public: const static int32_t IUSERNAME = 1006;
	private: int32_t dummy; // transient
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: SortOrderC();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: SortOrderC(int32_t MANUAL, int32_t ALPHA, int32_t XDATE, int32_t IDATE, int32_t IXDATE, int32_t IIDATE, int32_t IALPHA, int32_t DEFAULT, int32_t NONE, int32_t USERNAME, int32_t IUSERNAME, int32_t dummy);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getDummy() { return dummy; }
	public: void setDummy(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// StartAdHocWorkflowInfo
// typeId=1587514612

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// This class contains several options that are used to start the AdHocWorkflow
/// </summary>
class StartAdHocWorkflowInfo : public BSerializable {
	/// <summary>
	/// If true, the workflow comes back to the user who started it.
	/// </summary>
	protected: bool forValidation;
	/// <summary>
	/// If true, the workflow routes the object from user to user.
	/// </summary>
	/// <remarks>
	/// The workflow
	/// finishes when the last user has edited their node. If
	/// <code>serialFlow</code> is false, the workflow routes the object to all
	/// users. The first user who edits their node terminates the workflow.
	/// </remarks>
	protected: bool serialFlow;
	/// <summary>
	/// If the workflow is canceled, this user receives a message,
	/// <code>cancelMessage</code>.
	/// </summary>
	protected: ::std::wstring cancelUserId;
	/// <summary>
	/// The message that is send to the user specified with
	/// <code>cancelUserId</code>, if the workflow is canceled.
	/// </summary>
	protected: ::std::wstring cancelMessage;
	/// <summary>
	/// If the workflow is finished, this user receives a message,
	/// <code>finishedMessage</code>.
	/// </summary>
	protected: ::std::wstring finishedUserId;
	/// <summary>
	/// The message that is send to the user specified with
	/// <code>finishedUserId</code>, if the workflow is finished.
	/// </summary>
	protected: ::std::wstring finishedMessage;
	/// <summary>
	/// This script is executed, when the workflow is finished.
	/// </summary>
	protected: ::std::wstring finishedScript;
	/// <summary>
	/// Start node name.
	/// </summary>
	protected: ::std::wstring nodeName;
	/// <summary>
	/// This message is send to the user who started the workflow if the workflow is repeated.
	/// </summary>
	protected: ::std::wstring workflowRepeatMessage;
	/// <summary>
	/// This message is send to the user who started the workflow if the workflow is canceled.
	/// </summary>
	protected: ::std::wstring breakWorkflowMessage;
	/// <summary>
	/// The list of the person nodes to be deactivated when the workflow is canceled.
	/// </summary>
	/// <remarks>
	/// This option is only used for "parallel for validation" workflow. Otherwise this option is ignored.
	/// </remarks>
	protected: PArrayString userIdsToDeactivate;
	/// <summary>
	/// If true, all person nodes are deactivated when the workflow is canceled.
	/// </summary>
	/// <remarks>
	/// This option is only used for "parallel for validation" workflow. Otherwise this option is ignored.
	/// </remarks>
	protected: bool deactivateNodes;
	/// <summary>
	/// This message is shown if the workflow is accepted by a person.
	/// </summary>
	protected: ::std::wstring acceptMessage;
	/// <summary>
	/// This message is shown if the a person was informed about the workflow.
	/// </summary>
	protected: ::std::wstring noticeMessage;
	/// <summary>
	/// This message is shown if the workflow is rejected.
	/// </summary>
	protected: ::std::wstring actionRejectMessage;
	/// <summary>
	/// This message is shown if the workflow is successfully processed.
	/// </summary>
	protected: ::std::wstring successMessage;
	/// <summary>
	/// Time-limit for the entire workflow.
	/// </summary>
	protected: PWFTimeLimit timeLimit;
	/// <summary>
	/// Additional definitions for time limits.
	/// </summary>
	protected: PArrayWFTimeLimit timeLimitEscalations;
	/// <summary>
	/// Control flags for the node, a combination of WFNode.C.FLAG_* constants.
	/// </summary>
	protected: int32_t flags;
	/// <summary>
	/// The information of all nodes in the workflow.
	/// </summary>
	protected: PVectorValueClass nodeInfos;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: StartAdHocWorkflowInfo();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: StartAdHocWorkflowInfo(bool forValidation, bool serialFlow, const ::std::wstring& cancelUserId, const ::std::wstring& cancelMessage, const ::std::wstring& finishedUserId, const ::std::wstring& finishedMessage, const ::std::wstring& finishedScript, const ::std::wstring& nodeName, const ::std::wstring& workflowRepeatMessage, const ::std::wstring& breakWorkflowMessage, const PArrayString& userIdsToDeactivate, bool deactivateNodes, const ::std::wstring& acceptMessage, const ::std::wstring& noticeMessage, const ::std::wstring& actionRejectMessage, const ::std::wstring& successMessage, const PWFTimeLimit& timeLimit, const PArrayWFTimeLimit& timeLimitEscalations, int32_t flags, const PVectorValueClass& nodeInfos);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: bool getForValidation() { return forValidation; }
	public: void setForValidation(bool v);
	public: bool getSerialFlow() { return serialFlow; }
	public: void setSerialFlow(bool v);
	public: ::std::wstring getCancelUserId() { return cancelUserId; }
	public: void setCancelUserId(::std::wstring v);
	public: ::std::wstring getCancelMessage() { return cancelMessage; }
	public: void setCancelMessage(::std::wstring v);
	public: ::std::wstring getFinishedUserId() { return finishedUserId; }
	public: void setFinishedUserId(::std::wstring v);
	public: ::std::wstring getFinishedMessage() { return finishedMessage; }
	public: void setFinishedMessage(::std::wstring v);
	public: ::std::wstring getFinishedScript() { return finishedScript; }
	public: void setFinishedScript(::std::wstring v);
	public: ::std::wstring getNodeName() { return nodeName; }
	public: void setNodeName(::std::wstring v);
	public: ::std::wstring getWorkflowRepeatMessage() { return workflowRepeatMessage; }
	public: void setWorkflowRepeatMessage(::std::wstring v);
	public: ::std::wstring getBreakWorkflowMessage() { return breakWorkflowMessage; }
	public: void setBreakWorkflowMessage(::std::wstring v);
	public: PArrayString getUserIdsToDeactivate() { return userIdsToDeactivate; }
	public: void setUserIdsToDeactivate(PArrayString v);
	public: bool getDeactivateNodes() { return deactivateNodes; }
	public: void setDeactivateNodes(bool v);
	public: ::std::wstring getAcceptMessage() { return acceptMessage; }
	public: void setAcceptMessage(::std::wstring v);
	public: ::std::wstring getNoticeMessage() { return noticeMessage; }
	public: void setNoticeMessage(::std::wstring v);
	public: ::std::wstring getActionRejectMessage() { return actionRejectMessage; }
	public: void setActionRejectMessage(::std::wstring v);
	public: ::std::wstring getSuccessMessage() { return successMessage; }
	public: void setSuccessMessage(::std::wstring v);
	public: PWFTimeLimit getTimeLimit() { return timeLimit; }
	public: void setTimeLimit(PWFTimeLimit v);
	public: PArrayWFTimeLimit getTimeLimitEscalations() { return timeLimitEscalations; }
	public: void setTimeLimitEscalations(PArrayWFTimeLimit v);
	public: int32_t getFlags() { return flags; }
	public: void setFlags(int32_t v);
	public: PVectorValueClass getNodeInfos() { return nodeInfos; }
	public: void setNodeInfos(PVectorValueClass v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// StoreInfo
// typeId=964052256

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// <p>This class represents a storage path.
/// </summary>
/// <remarks>
/// </p>
/// <p>Copyright: Copyright (c) 2004</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </remarks>
class StoreInfo : public ValueClass {
	/// <summary>
	/// Create date (UTC).
	/// </summary>
	protected: ::std::wstring createDateISO;
	/// <summary>
	/// Physical directory where the documents of this path are stored.
	/// </summary>
	/// <remarks>
	/// Length of the field in database: 255byte.
	/// </remarks>
	protected: ::std::wstring dir;
	/// <summary>
	/// Bitset of options.
	/// </summary>
	protected: int32_t flags;
	/// <summary>
	/// Path ID
	/// Set this value to -1 in order to create a new storage path.
	/// </summary>
	protected: int32_t id;
	/// <summary>
	/// Path name.
	/// </summary>
	/// <remarks>
	/// Length of the field in database: 16byte.
	/// </remarks>
	protected: ::std::wstring name;
	/// <summary>
	/// Granularity of subdirectories in the physical directory.
	/// </summary>
	protected: int32_t scatter;
	/// <summary>
	/// standard path?
	/// </summary>
	/// <remarks>
	/// read-only
	/// </remarks>
	protected: bool stdPath;
	/// <summary>
	/// Update date (UTC).
	/// </summary>
	protected: ::std::wstring updateDateISO;
	/// <summary>
	/// Physical directory where previews stored.
	/// </summary>
	/// <remarks>
	/// Length of the field in database: 255byte.
	/// </remarks>
	protected: ::std::wstring previewDir;
	/// <summary>
	/// Physical directory where fulltext content is stored.
	/// </summary>
	/// <remarks>
	/// Length of the field in database: 255byte.
	/// </remarks>
	protected: ::std::wstring fulltextDir;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: StoreInfo();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: StoreInfo(const ::std::wstring& createDateISO, const ::std::wstring& dir, int32_t flags, int32_t id, const ::std::wstring& name, int32_t scatter, bool stdPath, const ::std::wstring& updateDateISO, const ::std::wstring& previewDir, const ::std::wstring& fulltextDir);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: ::std::wstring getCreateDateISO() { return createDateISO; }
	public: void setCreateDateISO(::std::wstring v);
	public: ::std::wstring getDir() { return dir; }
	public: void setDir(::std::wstring v);
	public: int32_t getFlags() { return flags; }
	public: void setFlags(int32_t v);
	public: int32_t getId() { return id; }
	public: void setId(int32_t v);
	public: ::std::wstring getName() { return name; }
	public: void setName(::std::wstring v);
	public: int32_t getScatter() { return scatter; }
	public: void setScatter(int32_t v);
	public: bool getStdPath() { return stdPath; }
	public: void setStdPath(bool v);
	public: ::std::wstring getUpdateDateISO() { return updateDateISO; }
	public: void setUpdateDateISO(::std::wstring v);
	public: ::std::wstring getPreviewDir() { return previewDir; }
	public: void setPreviewDir(::std::wstring v);
	public: ::std::wstring getFulltextDir() { return fulltextDir; }
	public: void setFulltextDir(::std::wstring v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// StoreInfoC
// typeId=979653235

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Definition of a document path.
/// </summary>
/// <remarks>
/// <p>Copyright: Copyright (c) 2004</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </remarks>
class StoreInfoC : public BSerializable {
	/// <summary>
	/// No sub directories.
	/// </summary>
	public: const static int32_t SP_FLAT = 0;
	/// <summary>
	/// 64k documents per sub directory
	/// </summary>
	public: const static int32_t SP_64K = 1;
	/// <summary>
	/// 16k documents per sub directory
	/// </summary>
	public: const static int32_t SP_16 = 2;
	/// <summary>
	/// 4k documents per sub directory
	/// </summary>
	public: const static int32_t SP_4K = 3;
	/// <summary>
	/// 1k documents per sub directory
	/// </summary>
	public: const static int32_t SP_1K = 4;
	/// <summary>
	/// 256 folders with 256 documents
	/// </summary>
	public: const static int32_t SP_FULL = 6;
	/// <summary>
	/// Store using MD5 hash.
	/// </summary>
	public: const static int32_t SP_MD5_HASH = 8;
	/// <summary>
	/// Store on CENTERA device.
	/// </summary>
	public: const static int32_t SP_CENTERA = 9;
	/// <summary>
	/// Store on TSM device.
	/// </summary>
	public: const static int32_t SP_TSM = 10;
	/// <summary>
	/// External storage definition.
	/// </summary>
	/// <remarks>
	/// A physical (relative) path is specified for each document.
	/// </remarks>
	public: const static int32_t SP_REL_FILE_PATH = 11;
	/// <summary>
	/// Store in KGS Activator.
	/// </summary>
	public: const static int32_t SP_ACTIVATOR = 12;
	/// <summary>
	/// Only ELO 5.0: path has been changed.
	/// </summary>
	public: const static int32_t FLAG_ELO5_PATH_CHANGED = 1;
	/// <summary>
	/// Only ELO 5.0: path is protected.
	/// </summary>
	public: const static int32_t FLAG_ELO5_PATH_PROTECTED = 2;
	/// <summary>
	/// Only ELO 5.0: no NT security.
	/// </summary>
	public: const static int32_t FLAG_ELO5_NO_NT_SECURITY = 8;
	/// <summary>
	/// Backup path.
	/// </summary>
	public: const static int32_t FLAG_BACKUP = 4;
	/// <summary>
	/// Path is read-only.
	/// </summary>
	public: const static int32_t FLAG_READONLY = 16;
	/// <summary>
	/// Used with FLAG_BACKUP, document files are not restored in a normal path.
	/// </summary>
	public: const static int32_t FLAG_NO_RESTORE = 32;
	/// <summary>
	/// Path can only be written once.
	/// </summary>
	/// <remarks>
	/// DM does not use temporary files.
	/// </remarks>
	public: const static int32_t FLAG_WORM = 64;
	/// <summary>
	/// Reserved path name.
	/// </summary>
	/// <remarks>
	/// Documents stored within DMPATH_ELOSYS will not be purged.
	/// </remarks>
	public: const static ::std::wstring DMPATH_ELOSYS;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: StoreInfoC();
	
	public: virtual BTYPEID BSerializable_getTypeId();
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// SubsInfo
// typeId=1910142939

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// This class contains information about a user that is beeing deputized
/// by another user.
/// </summary>
class SubsInfo : public ValueClass {
	/// <summary>
	/// The deputy relationship is applied if this member is true.
	/// </summary>
	/// <remarks>
	/// If false,
	/// the deputy does not currently act as the user but may activate the
	/// relationship by themself.
	/// </remarks>
	protected: bool active;
	/// <summary>
	/// The deputy inherits the rights of the user if this member is true.
	/// </summary>
	protected: bool inheritRights;
	/// <summary>
	/// Deputy: the user that deputizes <code>userId</code>.
	/// </summary>
	protected: int32_t subsId;
	/// <summary>
	/// Deputy name.
	/// </summary>
	/// <remarks>
	/// If this member is set <code>subsId</code> is ignored.
	/// </remarks>
	protected: ::std::wstring subsName;
	/// <summary>
	/// The user that is being deputized by <code>subsId</code>
	/// </summary>
	protected: int32_t userId;
	/// <summary>
	/// User name.
	/// </summary>
	/// <remarks>
	/// If this member is set <code>userId</code> is ignored.
	/// </remarks>
	protected: ::std::wstring userName;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: SubsInfo();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: SubsInfo(bool active, bool inheritRights, int32_t subsId, const ::std::wstring& subsName, int32_t userId, const ::std::wstring& userName);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: bool getActive() { return active; }
	public: void setActive(bool v);
	public: bool getInheritRights() { return inheritRights; }
	public: void setInheritRights(bool v);
	public: int32_t getSubsId() { return subsId; }
	public: void setSubsId(int32_t v);
	public: ::std::wstring getSubsName() { return subsName; }
	public: void setSubsName(::std::wstring v);
	public: int32_t getUserId() { return userId; }
	public: void setUserId(int32_t v);
	public: ::std::wstring getUserName() { return userName; }
	public: void setUserName(::std::wstring v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// Subscription
// typeId=323351719

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// This class describes a subscription.
/// </summary>
/// <remarks>
/// A user can subscribe for changes to an object.
/// Currently, the only supported object type is a document feed.
/// If the feed receives new comments, notification information
/// is inserted into the database for the user.
/// By calling FeedService.findFirstActions and setting FindActionsInfo.findNotifications=true,
/// the user can search for her notifications.
/// </remarks>
class Subscription : public ValueClass {
	/// <summary>
	/// GUID of user who registered the subscription.
	/// </summary>
	protected: ::std::wstring userGuid;
	/// <summary>
	/// GUID of Object to be watched.
	/// </summary>
	/// <remarks>
	/// Currently, this can only be a feed guid.
	/// </remarks>
	protected: ::std::wstring watchGuid;
	/// <summary>
	/// Create date of the subscription.
	/// </summary>
	protected: ::std::wstring createDateIso;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: Subscription();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: Subscription(const ::std::wstring& userGuid, const ::std::wstring& watchGuid, const ::std::wstring& createDateIso);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: ::std::wstring getUserGuid() { return userGuid; }
	public: void setUserGuid(::std::wstring v);
	public: ::std::wstring getWatchGuid() { return watchGuid; }
	public: void setWatchGuid(::std::wstring v);
	public: ::std::wstring getCreateDateIso() { return createDateIso; }
	public: void setCreateDateIso(::std::wstring v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// SubscriptionDataC
// typeId=1152087606

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// <p>Bit constants for members of Subscription</p>
/// <p>Copyright: Copyright (c) 2003</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </summary>
class SubscriptionDataC : public BSerializable {
	/// <summary>
	/// Member bit: GUID of user who registered the subscription.
	/// </summary>
	/// <remarks>
	/// DB column: userguid
	/// </remarks>
	public: const static int64_t mbUserGuid = 1LL;
	/// <summary>
	/// Column length: GUID of user who registered the subscription.
	/// </summary>
	/// <remarks>
	/// DB column: userguid
	/// </remarks>
	protected: int32_t lnUserGuid;
	/// <summary>
	/// Member bit: GUID of Object to be watched.
	/// </summary>
	/// <remarks>
	/// DB column: watchguid
	/// </remarks>
	public: const static int64_t mbWatchGuid = 2LL;
	/// <summary>
	/// Column length: GUID of Object to be watched.
	/// </summary>
	/// <remarks>
	/// DB column: watchguid
	/// </remarks>
	protected: int32_t lnWatchGuid;
	/// <summary>
	/// Member bit: Create date of the subscription.
	/// </summary>
	/// <remarks>
	/// DB column: createdateiso
	/// </remarks>
	public: const static int64_t mbCreateDateIso = 4LL;
	/// <summary>
	/// Column length: Create date of the subscription.
	/// </summary>
	/// <remarks>
	/// DB column: createdateiso
	/// </remarks>
	protected: int32_t lnCreateDateIso;
	/// <summary>
	/// All valid member bits.
	/// </summary>
	public: const static int64_t mbAllMembers = 7LL;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: SubscriptionDataC();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: SubscriptionDataC(int64_t mbUserGuid, int32_t lnUserGuid, int64_t mbWatchGuid, int32_t lnWatchGuid, int64_t mbCreateDateIso, int32_t lnCreateDateIso, int64_t mbAllMembers);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getLnUserGuid() { return lnUserGuid; }
	public: void setLnUserGuid(int32_t v);
	public: int32_t getLnWatchGuid() { return lnWatchGuid; }
	public: void setLnWatchGuid(int32_t v);
	public: int32_t getLnCreateDateIso() { return lnCreateDateIso; }
	public: void setLnCreateDateIso(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// SubscriptionC
// typeId=1994646365

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

class SubscriptionC : public SubscriptionDataC {
	public: const static PSubscriptionZ mbAll;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: SubscriptionC();
	
	public: virtual BTYPEID BSerializable_getTypeId();
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// SubscriptionZ
// typeId=1493215896

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

class SubscriptionZ : public BSerializable {
	/// <summary>
	/// Bitset field for constants from the SubscriptionC class.
	/// </summary>
	protected: int64_t bset;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: SubscriptionZ();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: SubscriptionZ(int64_t bset);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int64_t getBset() { return bset; }
	public: void setBset(int64_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// Thesaurus
// typeId=1664944753

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Internal class.
/// </summary>
class Thesaurus : public ValueClass {
	/// <summary>
	/// DB column: groupid
	/// </summary>
	protected: int32_t groupId;
	/// <summary>
	/// DB column: prio
	/// </summary>
	protected: int32_t prio;
	/// <summary>
	/// DB column: data
	/// </summary>
	protected: ::std::wstring data;
	/// <summary>
	/// DB column: compare
	/// </summary>
	protected: ::std::wstring compare;
	/// <summary>
	/// DB column: listid
	/// </summary>
	protected: int32_t listId;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: Thesaurus();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: Thesaurus(int32_t groupId, int32_t prio, const ::std::wstring& data, const ::std::wstring& compare, int32_t listId);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getGroupId() { return groupId; }
	public: void setGroupId(int32_t v);
	public: int32_t getPrio() { return prio; }
	public: void setPrio(int32_t v);
	public: ::std::wstring getData() { return data; }
	public: void setData(::std::wstring v);
	public: ::std::wstring getCompare() { return compare; }
	public: void setCompare(::std::wstring v);
	public: int32_t getListId() { return listId; }
	public: void setListId(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// ThesaurusC
// typeId=670698541

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// <p>Bit constants for members of Thesaurus</p>
/// <p>Copyright: Copyright (c) 2003</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </summary>
class ThesaurusC : public BSerializable {
	/// <summary>
	/// DB column: groupid
	/// </summary>
	public: const static int64_t mbGroupId = 1LL;
	/// <summary>
	/// DB column: prio
	/// </summary>
	public: const static int64_t mbPrio = 2LL;
	/// <summary>
	/// DB column: data
	/// </summary>
	public: const static int64_t mbData = 4LL;
	/// <summary>
	/// DB column: data
	/// </summary>
	protected: int32_t lnData;
	/// <summary>
	/// DB column: compare
	/// </summary>
	public: const static int64_t mbCompare = 8LL;
	/// <summary>
	/// DB column: compare
	/// </summary>
	protected: int32_t lnCompare;
	/// <summary>
	/// DB column: listid
	/// </summary>
	public: const static int64_t mbListId = 16LL;
	/// <summary>
	/// All valid member bits.
	/// </summary>
	public: const static int64_t mbAllMembers = 31LL;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: ThesaurusC();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: ThesaurusC(int64_t mbGroupId, int64_t mbPrio, int64_t mbData, int32_t lnData, int64_t mbCompare, int32_t lnCompare, int64_t mbListId, int64_t mbAllMembers);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getLnData() { return lnData; }
	public: void setLnData(int32_t v);
	public: int32_t getLnCompare() { return lnCompare; }
	public: void setLnCompare(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// TranslateTerm
// typeId=356302605

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Objects of this class represent one term in different languages.
/// </summary>
class TranslateTerm : public ValueClass {
	/// <summary>
	/// GUID
	/// </summary>
	protected: ::std::wstring guid;
	/// <summary>
	/// True, if this entry is logically deleted.
	/// </summary>
	protected: bool deleted;
	/// <summary>
	/// Last modified.
	/// </summary>
	/// <remarks>
	/// ISO date with seaparator "." measured in UTC.
	/// </remarks>
	protected: ::std::wstring tStamp;
	/// <summary>
	/// Term in its languages.
	/// </summary>
	/// <remarks>
	/// The Term <code>termLangs[i]</code> is in Language <code>langs[i]</code>.
	/// If a translation does not exist, the corresponding <code>termLangs[.]</code> is an empty string.
	/// </remarks>
	protected: PArrayString termLangs;
	/// <summary>
	/// The languages of the term in <code>termLangs</code>.
	/// </summary>
	/// <remarks>
	/// In an array of TranslateTerm objects returned in FindResult or
	/// returned by checkoutTranslateTerm, all objects share the same
	/// array <code>langs</code>.
	/// </remarks>
	protected: PArrayString langs;
	/// <summary>
	/// Timestamp of this object's last export by the replication.
	/// </summary>
	protected: ::std::wstring tStampSync;
	/// <summary>
	/// Read-only member.
	/// </summary>
	/// <remarks>
	/// The IX sets this member when a client searches for
	/// translation keys from property files.
	/// </remarks>
	protected: ::std::wstring translationKey;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: TranslateTerm();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: TranslateTerm(const ::std::wstring& guid, bool deleted, const ::std::wstring& tStamp, const PArrayString& termLangs, const PArrayString& langs, const ::std::wstring& tStampSync, const ::std::wstring& translationKey);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: ::std::wstring getGuid() { return guid; }
	public: void setGuid(::std::wstring v);
	public: bool getDeleted() { return deleted; }
	public: void setDeleted(bool v);
	public: ::std::wstring getTStamp() { return tStamp; }
	public: void setTStamp(::std::wstring v);
	public: PArrayString getTermLangs() { return termLangs; }
	public: void setTermLangs(PArrayString v);
	public: PArrayString getLangs() { return langs; }
	public: void setLangs(PArrayString v);
	public: ::std::wstring getTStampSync() { return tStampSync; }
	public: void setTStampSync(::std::wstring v);
	public: ::std::wstring getTranslationKey() { return translationKey; }
	public: void setTranslationKey(::std::wstring v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// TranslateTermC
// typeId=1212336284

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Constants for class TranslateTerm.
/// </summary>
class TranslateTermC : public BSerializable {
	/// <summary>
	/// Use this value in parameter <code>termIds[.]
	/// </summary>
	/// <remarks>
	/// </code> to
	/// retrieve the system languages.
	/// </remarks>
	public: const static ::std::wstring GUID_SYSTEM_LANGUAGES;
	/// <summary>
	/// Use this value as parameter <code>termIds</code> to
	/// retrieve the system languages.
	/// </summary>
	public: const static PArrayString TASKIDS_FOR_SYSTEM_LANGUAGES;
	/// <summary>
	/// Maximum term length;
	/// </summary>
	protected: int32_t lnTermLang;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: TranslateTermC();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: TranslateTermC(const ::std::wstring& GUID_SYSTEM_LANGUAGES, const PArrayString& TASKIDS_FOR_SYSTEM_LANGUAGES, int32_t lnTermLang);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getLnTermLang() { return lnTermLang; }
	public: void setLnTermLang(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// TranslateTermData
// typeId=486835904

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

class TranslateTermData : public ValueClass {
	/// <summary>
	/// GUID
	/// </summary>
	protected: ::std::wstring guid;
	/// <summary>
	/// Timestamp.
	/// </summary>
	/// <remarks>
	/// Last mofified time, ISO date with dots measured in UTC
	/// The format is JJJJ.MM.DD.hh.mm.ss
	/// </remarks>
	protected: ::std::wstring TStamp;
	/// <summary>
	/// Status.
	/// </summary>
	/// <remarks>
	/// The object is not deleted, if <code>status</code> is -1.
	/// </remarks>
	protected: int32_t status;
	/// <summary>
	/// Language 1.
	/// </summary>
	/// <remarks>
	/// System language.
	/// </remarks>
	protected: ::std::wstring lang1;
	/// <summary>
	/// Language 2
	/// </summary>
	protected: ::std::wstring lang2;
	/// <summary>
	/// Language 3
	/// </summary>
	protected: ::std::wstring lang3;
	/// <summary>
	/// Language 4
	/// </summary>
	protected: ::std::wstring lang4;
	/// <summary>
	/// Language 5
	/// </summary>
	protected: ::std::wstring lang5;
	/// <summary>
	/// Language 6
	/// </summary>
	protected: ::std::wstring lang6;
	/// <summary>
	/// Language 7
	/// </summary>
	protected: ::std::wstring lang7;
	/// <summary>
	/// Language 8
	/// </summary>
	protected: ::std::wstring lang8;
	/// <summary>
	/// Language 9
	/// </summary>
	protected: ::std::wstring lang9;
	/// <summary>
	/// Timestamp.
	/// </summary>
	/// <remarks>
	/// Timestamp of this object's last export by the replication.
	/// The format is JJJJ.MM.DD.hh.mm.ss
	/// </remarks>
	protected: ::std::wstring TStampSync;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: TranslateTermData();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: TranslateTermData(const ::std::wstring& guid, const ::std::wstring& TStamp, int32_t status, const ::std::wstring& lang1, const ::std::wstring& lang2, const ::std::wstring& lang3, const ::std::wstring& lang4, const ::std::wstring& lang5, const ::std::wstring& lang6, const ::std::wstring& lang7, const ::std::wstring& lang8, const ::std::wstring& lang9, const ::std::wstring& TStampSync);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: ::std::wstring getGuid() { return guid; }
	public: void setGuid(::std::wstring v);
	public: ::std::wstring getTStamp() { return TStamp; }
	public: void setTStamp(::std::wstring v);
	public: int32_t getStatus() { return status; }
	public: void setStatus(int32_t v);
	public: ::std::wstring getLang1() { return lang1; }
	public: void setLang1(::std::wstring v);
	public: ::std::wstring getLang2() { return lang2; }
	public: void setLang2(::std::wstring v);
	public: ::std::wstring getLang3() { return lang3; }
	public: void setLang3(::std::wstring v);
	public: ::std::wstring getLang4() { return lang4; }
	public: void setLang4(::std::wstring v);
	public: ::std::wstring getLang5() { return lang5; }
	public: void setLang5(::std::wstring v);
	public: ::std::wstring getLang6() { return lang6; }
	public: void setLang6(::std::wstring v);
	public: ::std::wstring getLang7() { return lang7; }
	public: void setLang7(::std::wstring v);
	public: ::std::wstring getLang8() { return lang8; }
	public: void setLang8(::std::wstring v);
	public: ::std::wstring getLang9() { return lang9; }
	public: void setLang9(::std::wstring v);
	public: ::std::wstring getTStampSync() { return TStampSync; }
	public: void setTStampSync(::std::wstring v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// TranslateTermDataC
// typeId=1699470707

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// <p>Bit constants for members of TranslateTermData</p>
/// <p>Copyright: Copyright (c) 2003</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </summary>
class TranslateTermDataC : public BSerializable {
	/// <summary>
	/// Member bit: GUID
	/// DB column: guid
	/// </summary>
	public: const static int64_t mbGuid = 1LL;
	/// <summary>
	/// Column length: GUID
	/// DB column: guid
	/// </summary>
	protected: int32_t lnGuid;
	/// <summary>
	/// Member bit: Timestamp.
	/// </summary>
	/// <remarks>
	/// DB column: tstamp
	/// </remarks>
	public: const static int64_t mbTStamp = 2LL;
	/// <summary>
	/// Column length: Timestamp.
	/// </summary>
	/// <remarks>
	/// DB column: tstamp
	/// </remarks>
	protected: int32_t lnTStamp;
	/// <summary>
	/// Member bit: Status.
	/// </summary>
	/// <remarks>
	/// DB column: status
	/// </remarks>
	public: const static int64_t mbStatus = 4LL;
	/// <summary>
	/// Member bit: Language 1.
	/// </summary>
	/// <remarks>
	/// System language.
	/// DB column: lang1
	/// </remarks>
	public: const static int64_t mbLang1 = 8LL;
	/// <summary>
	/// Column length: Language 1.
	/// </summary>
	/// <remarks>
	/// System language.
	/// DB column: lang1
	/// </remarks>
	protected: int32_t lnLang1;
	/// <summary>
	/// Member bit: Language 2
	/// DB column: lang2
	/// </summary>
	public: const static int64_t mbLang2 = 16LL;
	/// <summary>
	/// Column length: Language 2
	/// DB column: lang2
	/// </summary>
	protected: int32_t lnLang2;
	/// <summary>
	/// Member bit: Language 3
	/// DB column: lang3
	/// </summary>
	public: const static int64_t mbLang3 = 32LL;
	/// <summary>
	/// Column length: Language 3
	/// DB column: lang3
	/// </summary>
	protected: int32_t lnLang3;
	/// <summary>
	/// Member bit: Language 4
	/// DB column: lang4
	/// </summary>
	public: const static int64_t mbLang4 = 64LL;
	/// <summary>
	/// Column length: Language 4
	/// DB column: lang4
	/// </summary>
	protected: int32_t lnLang4;
	/// <summary>
	/// Member bit: Language 5
	/// DB column: lang5
	/// </summary>
	public: const static int64_t mbLang5 = 128LL;
	/// <summary>
	/// Column length: Language 5
	/// DB column: lang5
	/// </summary>
	protected: int32_t lnLang5;
	/// <summary>
	/// Member bit: Language 6
	/// DB column: lang6
	/// </summary>
	public: const static int64_t mbLang6 = 256LL;
	/// <summary>
	/// Column length: Language 6
	/// DB column: lang6
	/// </summary>
	protected: int32_t lnLang6;
	/// <summary>
	/// Member bit: Language 7
	/// DB column: lang7
	/// </summary>
	public: const static int64_t mbLang7 = 512LL;
	/// <summary>
	/// Column length: Language 7
	/// DB column: lang7
	/// </summary>
	protected: int32_t lnLang7;
	/// <summary>
	/// Member bit: Language 8
	/// DB column: lang8
	/// </summary>
	public: const static int64_t mbLang8 = 1024LL;
	/// <summary>
	/// Column length: Language 8
	/// DB column: lang8
	/// </summary>
	protected: int32_t lnLang8;
	/// <summary>
	/// Member bit: Language 9
	/// DB column: lang9
	/// </summary>
	public: const static int64_t mbLang9 = 2048LL;
	/// <summary>
	/// Column length: Language 9
	/// DB column: lang9
	/// </summary>
	protected: int32_t lnLang9;
	/// <summary>
	/// Member bit: Timestamp.
	/// </summary>
	/// <remarks>
	/// DB column: tstampsync
	/// </remarks>
	public: const static int64_t mbTStampSync = 4096LL;
	/// <summary>
	/// Column length: Timestamp.
	/// </summary>
	/// <remarks>
	/// DB column: tstampsync
	/// </remarks>
	protected: int32_t lnTStampSync;
	/// <summary>
	/// All valid member bits.
	/// </summary>
	public: const static int64_t mbAllMembers = 8191LL;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: TranslateTermDataC();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: TranslateTermDataC(int64_t mbGuid, int32_t lnGuid, int64_t mbTStamp, int32_t lnTStamp, int64_t mbStatus, int64_t mbLang1, int32_t lnLang1, int64_t mbLang2, int32_t lnLang2, int64_t mbLang3, int32_t lnLang3, int64_t mbLang4, int32_t lnLang4, int64_t mbLang5, int32_t lnLang5, int64_t mbLang6, int32_t lnLang6, int64_t mbLang7, int32_t lnLang7, int64_t mbLang8, int32_t lnLang8, int64_t mbLang9, int32_t lnLang9, int64_t mbTStampSync, int32_t lnTStampSync, int64_t mbAllMembers);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getLnGuid() { return lnGuid; }
	public: void setLnGuid(int32_t v);
	public: int32_t getLnTStamp() { return lnTStamp; }
	public: void setLnTStamp(int32_t v);
	public: int32_t getLnLang1() { return lnLang1; }
	public: void setLnLang1(int32_t v);
	public: int32_t getLnLang2() { return lnLang2; }
	public: void setLnLang2(int32_t v);
	public: int32_t getLnLang3() { return lnLang3; }
	public: void setLnLang3(int32_t v);
	public: int32_t getLnLang4() { return lnLang4; }
	public: void setLnLang4(int32_t v);
	public: int32_t getLnLang5() { return lnLang5; }
	public: void setLnLang5(int32_t v);
	public: int32_t getLnLang6() { return lnLang6; }
	public: void setLnLang6(int32_t v);
	public: int32_t getLnLang7() { return lnLang7; }
	public: void setLnLang7(int32_t v);
	public: int32_t getLnLang8() { return lnLang8; }
	public: void setLnLang8(int32_t v);
	public: int32_t getLnLang9() { return lnLang9; }
	public: void setLnLang9(int32_t v);
	public: int32_t getLnTStampSync() { return lnTStampSync; }
	public: void setLnTStampSync(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// UrlParams
// typeId=2007960901

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// This class describes additional params for an upload or download URL.
/// </summary>
class UrlParams : public ValueClass {
	/// <summary>
	/// Download only length bytes from the resource.
	/// </summary>
	/// <remarks>
	/// Set this value to 0, if all bytes should be read.
	/// </remarks>
	protected: int64_t length;
	/// <summary>
	/// Download bytes beginning from this offset.
	/// </summary>
	protected: int64_t offset;
	/// <summary>
	/// Highlight this terms.
	/// </summary>
	/// <remarks>
	/// This value is only valid for fulltext URLs.
	/// Many terms have to be separated by space character.
	/// Each term is enclosed in the HTML tags &lt;b&gt; term &lt;/b&gt;
	/// </remarks>
	protected: ::std::wstring highlightTerms;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: UrlParams();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: UrlParams(int64_t length, int64_t offset, const ::std::wstring& highlightTerms);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int64_t getLength() { return length; }
	public: void setLength(int64_t v);
	public: int64_t getOffset() { return offset; }
	public: void setOffset(int64_t v);
	public: ::std::wstring getHighlightTerms() { return highlightTerms; }
	public: void setHighlightTerms(::std::wstring v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// UserInfo
// typeId=1485735592

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// <p>Data class containing the user information data for the user logged in to
/// the Index server.
/// </summary>
/// <remarks>
/// User information includes ID, name, rights, parent, etc.</p>
/// <p>Copyright: Copyright (c) 2004</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </remarks>
class UserInfo : public ValueClass {
	/// <summary>
	/// User description.
	/// </summary>
	protected: ::std::wstring desc;
	/// <summary>
	/// User rights.
	/// </summary>
	/// <remarks>
	/// Possible values are combinations of <code>AccessC.FLAG_*</code> constants.
	/// </remarks>
	protected: int32_t flags;
	/// <summary>
	/// The groups the user is a member of.
	/// </summary>
	/// <remarks>
	/// For Substitues, this list contains the IDs of the substituted users too.
	/// </remarks>
	protected: PArrayInt groupList;
	/// <summary>
	/// User identifier
	/// </summary>
	protected: int32_t id;
	/// <summary>
	/// User keys.
	/// </summary>
	/// <remarks>
	/// Array of key access rights. Each item is a combination of the
	/// access constants <code>AccessC.LUR_*</code>. The key ID corresponds to the
	/// index of the key access item in the key array. A user owns a key, if at least
	/// one access constant is included in the key item.
	/// Keys do not distinguish between <code>LUR_WRTE</code> and <code>LUR_LIST</code>:
	/// <code>LUR_WRITE</code> implies <code>LUR_LIST</code> and v.v.
	/// </remarks>
	protected: PArrayInt keylist;
	/// <summary>
	/// User name
	/// </summary>
	protected: ::std::wstring name;
	/// <summary>
	/// User ID of the users parent (users adminstrator).
	/// </summary>
	protected: int32_t parent;
	/// <summary>
	/// User password
	/// </summary>
	protected: ::std::wstring pwd;
	/// <summary>
	/// The currently active tickets for the user
	/// </summary>
	protected: PArraySessionInfo sessions;
	/// <summary>
	/// User type.
	/// </summary>
	/// <remarks>
	/// <code>TYPE_USER</code> for user, <code>TYPE_GROUP</code> for group.
	/// </remarks>
	protected: int32_t type;
	/// <summary>
	/// Reserved (Additional user properties).
	/// </summary>
	/// <remarks>
	/// Index this array with constants named PROP_* in class UserInfoC.
	/// </remarks>
	protected: PArrayString userProps;
	/// <summary>
	/// Reserved (LDAP user properties).
	/// </summary>
	/// <remarks>
	/// Keys of this map named LDAP_PROP_* in class UserInfoC.
	/// 
	/// Mandatory properties
	/// - For user: objectGUID, distinguishedName, displayName, sAMAccountName und UserPrincipalName
	/// - For group:  objectGUID, distinguishedName, name und sAMAccountName
	/// </remarks>
	protected: byps::PMapStringString ldapProperties;
	/// <summary>
	/// GUID
	/// </summary>
	protected: ::std::wstring guid;
	/// <summary>
	/// Timestamp
	/// The format is JJJJ.MM.DD.hh.mm.ss
	/// </summary>
	protected: ::std::wstring tStamp;
	/// <summary>
	/// Last login timestamp (in timezone UTC).
	/// </summary>
	/// <remarks>
	/// This value is read-only and undefined for groups.
	/// Only the date part is valid.
	/// </remarks>
	protected: ::std::wstring lastLoginIso;
	/// <summary>
	/// ID of the users superior.
	/// </summary>
	/// <remarks>
	/// If the user does not have a superior, this value is equal to <code>id</code>.
	/// </remarks>
	protected: int32_t superiorId;
	/// <summary>
	/// Second bitset of user rights.
	/// </summary>
	protected: int32_t flags2;
	/// <summary>
	/// Organisation unit IDs.
	/// </summary>
	/// <remarks>
	/// A user or group can be assigned to at most one organization unit.
	/// But due to its group membership a user or group can actually belong to a list of organization units.
	/// When writing this UserInfo object, only the first organization unit in the array is taken into account.
	/// In order to remove the relationship, set an empty array.
	/// </remarks>
	protected: PArrayInt orgUnitIds;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: UserInfo();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: UserInfo(const ::std::wstring& desc, int32_t flags, const PArrayInt& groupList, int32_t id, const PArrayInt& keylist, const ::std::wstring& name, int32_t parent, const ::std::wstring& pwd, const PArraySessionInfo& sessions, int32_t type, const PArrayString& userProps, const byps::PMapStringString& ldapProperties, const ::std::wstring& guid, const ::std::wstring& tStamp, const ::std::wstring& lastLoginIso, int32_t superiorId, int32_t flags2, const PArrayInt& orgUnitIds);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: ::std::wstring getDesc() { return desc; }
	public: void setDesc(::std::wstring v);
	public: int32_t getFlags() { return flags; }
	public: void setFlags(int32_t v);
	public: PArrayInt getGroupList() { return groupList; }
	public: void setGroupList(PArrayInt v);
	public: int32_t getId() { return id; }
	public: void setId(int32_t v);
	public: PArrayInt getKeylist() { return keylist; }
	public: void setKeylist(PArrayInt v);
	public: ::std::wstring getName() { return name; }
	public: void setName(::std::wstring v);
	public: int32_t getParent() { return parent; }
	public: void setParent(int32_t v);
	public: ::std::wstring getPwd() { return pwd; }
	public: void setPwd(::std::wstring v);
	public: PArraySessionInfo getSessions() { return sessions; }
	public: void setSessions(PArraySessionInfo v);
	public: int32_t getType() { return type; }
	public: void setType(int32_t v);
	public: PArrayString getUserProps() { return userProps; }
	public: void setUserProps(PArrayString v);
	public: byps::PMapStringString getLdapProperties() { return ldapProperties; }
	public: void setLdapProperties(byps::PMapStringString v);
	public: ::std::wstring getGuid() { return guid; }
	public: void setGuid(::std::wstring v);
	public: ::std::wstring getTStamp() { return tStamp; }
	public: void setTStamp(::std::wstring v);
	public: ::std::wstring getLastLoginIso() { return lastLoginIso; }
	public: void setLastLoginIso(::std::wstring v);
	public: int32_t getSuperiorId() { return superiorId; }
	public: void setSuperiorId(int32_t v);
	public: int32_t getFlags2() { return flags2; }
	public: void setFlags2(int32_t v);
	public: PArrayInt getOrgUnitIds() { return orgUnitIds; }
	public: void setOrgUnitIds(PArrayInt v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// UserInfoC
// typeId=703234555

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// <p>Constants related to user information.
/// </summary>
/// <remarks>
/// </p>
/// <p>Copyright: Copyright (c) 2004</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </remarks>
class UserInfoC : public BSerializable {
	/// <summary>
	/// Maximum number of user properties.
	/// </summary>
	public: const static int32_t MAX_USERPROP = 8;
	/// <summary>
	/// Maximum number of keys.
	/// </summary>
	public: const static int32_t MAX_KEY = 254;
	/// <summary>
	/// Maximale number of users and groups.
	/// </summary>
	public: const static int32_t MAX_USERS = 16384;
	/// <summary>
	/// Maximum number of groups per user.
	/// </summary>
	public: const static int32_t MAX_GROUPS = 16384;
	/// <summary>
	/// Maximum number of persistent groups per user.
	/// </summary>
	public: const static int32_t MAX_PERSISTENT_GROUPS = 16384;
	/// <summary>
	/// Type value for an user.
	/// </summary>
	public: const static int32_t TYPE_USER = 1;
	/// <summary>
	/// Type value for a group.
	/// </summary>
	public: const static int32_t TYPE_GROUP = 0;
	/// <summary>
	/// Type value for the current user
	/// </summary>
	public: const static int32_t TYPE_USERID_OWNER = -2;
	public: const static int32_t MAX_NAME = 64;
	public: const static int32_t PROP_NAME_OS = 0;
	public: const static int32_t PROP_NAME_EMAIL = 1;
	/// <summary>
	/// This user property is used to trigger actions in the client application.
	/// </summary>
	/// <remarks>
	/// The value of the property is found at UserInfo.userProps[UserInfoC.PROP_ACTION].
	/// If the value contains the String PROP_ACTION_SHOW_PASSWORD_DIALOG, the user should change the password.
	/// If the value contains the String PROP_ACTION_FORCE_CHANGE_PASSWORD, the user must change the password.
	/// If the value contains the String PROP_ACTION_END_PASSWORD_DATE, the password expires at the ISO date
	/// defined by the next 10 characters. E.g. "EX20120405" means that the password expires at April 5, 2012.
	/// </remarks>
	public: const static int32_t PROP_ACTION = 3;
	/// <summary>
	/// The user should change the password.
	/// </summary>
	public: const static ::std::wstring PROP_ACTION_USER_SHOULD_CHANGE_PASSWORD;
	/// <summary>
	/// The user must change the password.
	/// </summary>
	public: const static ::std::wstring PROP_ACTION_USER_MUST_CHANGE_PASSWORD;
	/// <summary>
	/// The password expires.
	/// </summary>
	public: const static ::std::wstring PROP_ACTION_END_PASSWORD_DATE;
	/// <summary>
	/// User property GUID.
	/// </summary>
	public: const static int32_t PROP_GUID = 4;
	/// <summary>
	/// Maximum user name length
	/// </summary>
	protected: int32_t lnName;
	/// <summary>
	/// Maximum user password length
	/// </summary>
	protected: int32_t lnPwd;
	/// <summary>
	/// Maximum user desc length
	/// </summary>
	protected: int32_t lnDesc;
	/// <summary>
	/// Maximum user property length
	/// </summary>
	protected: int32_t lnUserProp;
	/// <summary>
	/// Maximum length of LDAP property key.
	/// </summary>
	protected: int32_t lnLdapPropKey;
	/// <summary>
	/// Maximum length of LDAP property value.
	/// </summary>
	protected: int32_t lnLdapPropValue;
	/// <summary>
	/// Every user is in the group "Everyone".
	/// </summary>
	/// <remarks>
	/// This is
	/// the internal ID for this group.
	/// </remarks>
	public: const static int32_t ID_EVERYONE_GROUP = 9999;
	/// <summary>
	/// User ID of main administrator.
	/// </summary>
	public: const static int32_t ID_ADMINISTRATOR = 0;
	/// <summary>
	/// GUID of group "Everybody"
	/// </summary>
	protected: ::std::wstring GUID_EVERYONE_GROUP;
	/// <summary>
	/// GUID of main administrator
	/// </summary>
	protected: ::std::wstring GUID_ADMINISTRATOR;
	/// <summary>
	/// This value can be set for UserInfo.pwd to
	/// </summary>
	public: const static ::std::wstring PWD_VALUE_IGNORE;
	/// <summary>
	/// Common name
	/// </summary>
	public: const static ::std::wstring LDAP_PROP_CN;
	/// <summary>
	/// Distinguished name
	/// </summary>
	public: const static ::std::wstring LDAP_PROP_DISTINGUISHED_NAME;
	/// <summary>
	/// Display name
	/// </summary>
	public: const static ::std::wstring LDAP_PROP_DISPLAY_NAME;
	/// <summary>
	/// Name
	/// </summary>
	public: const static ::std::wstring LDAP_PROP_NAME;
	/// <summary>
	/// Proxy addresses
	/// </summary>
	public: const static ::std::wstring LDAP_PROP_PROXY_ADDRESSES;
	/// <summary>
	/// Flags that control the behavior of the user account
	/// </summary>
	public: const static ::std::wstring LDAP_PROP_USER_ACCOUNT_CONTROL;
	/// <summary>
	/// NT account name
	/// </summary>
	public: const static ::std::wstring LDAP_PROP_SAM_ACCOUNT_NAME;
	/// <summary>
	/// Contains information about every account type object
	/// </summary>
	public: const static ::std::wstring LDAP_PROP_SAM_ACCOUNT_TYPE;
	/// <summary>
	/// User principal name
	/// </summary>
	public: const static ::std::wstring LDAP_PROP_USER_PRINCIPAL_NAME;
	/// <summary>
	/// Object category
	/// </summary>
	public: const static ::std::wstring LDAP_PROP_OBJECT_CATEGORY;
	/// <summary>
	/// Mail nick name
	/// </summary>
	public: const static ::std::wstring LDAP_PROP_MAIL_NICK_NAME;
	/// <summary>
	/// The unique identifier for an object
	/// </summary>
	public: const static ::std::wstring LDAP_PROP_OBJECT_GUID;
	/// <summary>
	/// A binary value that specifies the security identifier (SID) of the user.
	/// </summary>
	public: const static ::std::wstring LDAP_PROP_OBJECT_SID;
	/// <summary>
	/// Mailbox globally unique identifier
	/// </summary>
	public: const static ::std::wstring LDAP_PROP_MS_EXCHANGE_MAILBOX_GUID;
	/// <summary>
	/// Group type
	/// </summary>
	public: const static ::std::wstring LDAP_PROP_GROUP_TYPE;
	/// <summary>
	/// Full Qualified Domain Name
	/// </summary>
	public: const static ::std::wstring LDAP_PROP_FQDN;
	/// <summary>
	/// Online
	/// </summary>
	public: const static ::std::wstring LDAP_PROP_ONLINE;
	/// <summary>
	/// Object class
	/// </summary>
	public: const static ::std::wstring LDAP_PROP_OBJECT_CLASS;
	/// <summary>
	/// Member of
	/// </summary>
	public: const static ::std::wstring LDAP_PROP_MEMBER_OF;
	/// <summary>
	/// LegacyExchangeDN
	/// </summary>
	public: const static ::std::wstring LDAP_PROP_LEGACY_EXCHANGE_DN;
	/// <summary>
	/// Mail
	/// </summary>
	public: const static ::std::wstring LDAP_PROP_MAIL;
	/// <summary>
	/// msExchHideFromAddressLists
	/// </summary>
	public: const static ::std::wstring LDAP_PROP_EXCH_HIDE_FROM_ADDRESS_LISTS;
	/// <summary>
	/// msExchRecipientTypeDetails
	/// </summary>
	public: const static ::std::wstring LDAP_PROP_EXCH_RECIPIENT_TYPE_DETAILS;
	/// <summary>
	/// msExchRecipientDisplayType
	/// </summary>
	public: const static ::std::wstring LDAP_PROP_EXCH_RECIPIENT_DISPLAY_TYPE;
	/// <summary>
	/// msExchDelegateListLink
	/// </summary>
	public: const static ::std::wstring LDAP_PROP_EXCH_DELEGATE_LIST_LINK;
	/// <summary>
	/// msExchPublicFolderMailbox
	/// </summary>
	public: const static ::std::wstring LDAP_PROP_EXCH_PUBFOLDER_MAILBOX;
	/// <summary>
	/// adminDisplayName
	/// </summary>
	public: const static ::std::wstring LDAP_PROP_ADMIN_DISPLAY_NAME;
	/// <summary>
	/// msExchMessageJournalRecipient
	/// </summary>
	public: const static ::std::wstring LDAP_PROP_EXCH_JOURNAL_RCPT;
	/// <summary>
	/// msExchOwningServer
	/// </summary>
	public: const static ::std::wstring LDAP_PROP_EXCH_OWNING_SERVER;
	/// <summary>
	/// PrimarySmtpAddress
	/// </summary>
	public: const static ::std::wstring LDAP_PROP_ONLINE_MAIL;
	/// <summary>
	/// RecipientTypeDetails
	/// </summary>
	public: const static ::std::wstring LDAP_PROP_ONLINE_RECIPIENT_TYPE_DETAILS;
	/// <summary>
	/// Guid
	/// </summary>
	public: const static ::std::wstring LDAP_PROP_ONLINE_GUID;
	/// <summary>
	/// IsMailboxEnabled
	/// </summary>
	public: const static ::std::wstring LDAP_PROP_ONLINE_MAILBOX_ENABLED;
	/// <summary>
	/// Common name.
	/// </summary>
	/// <remarks>
	/// Key to access the map UserInfo.ldapProperties
	/// </remarks>
	public: const static ::std::wstring LDAP_KEY_CN;
	/// <summary>
	/// Distinguished name.
	/// </summary>
	/// <remarks>
	/// Key to access the map UserInfo.ldapProperties
	/// </remarks>
	public: const static ::std::wstring LDAP_KEY_DISTINGUISHED_NAME;
	/// <summary>
	/// Display name.
	/// </summary>
	/// <remarks>
	/// Key to access the map UserInfo.ldapProperties
	/// </remarks>
	public: const static ::std::wstring LDAP_KEY_DISPLAY_NAME;
	/// <summary>
	/// Name.
	/// </summary>
	/// <remarks>
	/// Key to access the map UserInfo.ldapProperties.
	/// </remarks>
	public: const static ::std::wstring LDAP_KEY_NAME;
	/// <summary>
	/// Proxy addresses.
	/// </summary>
	/// <remarks>
	/// Key to access the map UserInfo.ldapProperties
	/// </remarks>
	public: const static ::std::wstring LDAP_KEY_PROXY_ADDRESSES;
	/// <summary>
	/// Flags that control the behavior of the user account.
	/// </summary>
	/// <remarks>
	/// Key to access the map UserInfo.ldapProperties
	/// </remarks>
	public: const static ::std::wstring LDAP_KEY_USER_ACCOUNT_CONTROL;
	/// <summary>
	/// NT account name.
	/// </summary>
	/// <remarks>
	/// Key to access the map UserInfo.ldapProperties
	/// </remarks>
	public: const static ::std::wstring LDAP_KEY_SAM_ACCOUNT_NAME;
	/// <summary>
	/// Contains information about every account type object.
	/// </summary>
	/// <remarks>
	/// Key to access the map UserInfo.ldapProperties
	/// </remarks>
	public: const static ::std::wstring LDAP_KEY_SAM_ACCOUNT_TYPE;
	/// <summary>
	/// User principal name.
	/// </summary>
	/// <remarks>
	/// Key to access the map UserInfo.ldapProperties
	/// </remarks>
	public: const static ::std::wstring LDAP_KEY_USER_PRINCIPAL_NAME;
	/// <summary>
	/// Object category.
	/// </summary>
	/// <remarks>
	/// Key to access the map UserInfo.ldapProperties
	/// </remarks>
	public: const static ::std::wstring LDAP_KEY_OBJECT_CATEGORY;
	/// <summary>
	/// Mail nick name.
	/// </summary>
	/// <remarks>
	/// Key to access the map UserInfo.ldapProperties
	/// </remarks>
	public: const static ::std::wstring LDAP_KEY_MAIL_NICK_NAME;
	/// <summary>
	/// The unique identifier for an object.
	/// </summary>
	/// <remarks>
	/// Key to access the map UserInfo.ldapProperties
	/// </remarks>
	public: const static ::std::wstring LDAP_KEY_OBJECT_GUID;
	/// <summary>
	/// A binary value that specifies the security identifier (SID) of the user.
	/// </summary>
	/// <remarks>
	/// Key to access the map UserInfo.ldapProperties
	/// </remarks>
	public: const static ::std::wstring LDAP_KEY_OBJECT_SID;
	/// <summary>
	/// Mailbox globally unique identifier.
	/// </summary>
	/// <remarks>
	/// Key to access the map UserInfo.ldapProperties
	/// </remarks>
	public: const static ::std::wstring LDAP_KEY_MS_EXCHANGE_MAILBOX_GUID;
	/// <summary>
	/// Group type.
	/// </summary>
	/// <remarks>
	/// Key to access the map UserInfo.ldapProperties
	/// </remarks>
	public: const static ::std::wstring LDAP_KEY_GROUP_TYPE;
	/// <summary>
	/// Full Qualified Domain Name.
	/// </summary>
	/// <remarks>
	/// Key to access the map UserInfo.ldapProperties
	/// </remarks>
	public: const static ::std::wstring LDAP_KEY_FQDN;
	/// <summary>
	/// Online.
	/// </summary>
	/// <remarks>
	/// Key to access the map UserInfo.ldapProperties
	/// </remarks>
	public: const static ::std::wstring LDAP_KEY_ONLINE;
	/// <summary>
	/// Object class.
	/// </summary>
	/// <remarks>
	/// Key to access the map UserInfo.ldapProperties
	/// </remarks>
	public: const static ::std::wstring LDAP_KEY_OBJECT_CLASS;
	/// <summary>
	/// Member of.
	/// </summary>
	/// <remarks>
	/// Key to access the map UserInfo.ldapProperties
	/// </remarks>
	public: const static ::std::wstring LDAP_KEY_MEMBER_OF;
	/// <summary>
	/// LegacyExchangeDN.
	/// </summary>
	/// <remarks>
	/// Key to access the map UserInfo.ldapProperties
	/// </remarks>
	public: const static ::std::wstring LDAP_KEY_LEGACY_EXCHANGE_DN;
	/// <summary>
	/// Mail.
	/// </summary>
	/// <remarks>
	/// Key to access the map UserInfo.ldapProperties
	/// </remarks>
	public: const static ::std::wstring LDAP_KEY_MAIL;
	/// <summary>
	/// msExchHideFromAddressLists.
	/// </summary>
	/// <remarks>
	/// Key to access the map UserInfo.ldapProperties
	/// </remarks>
	public: const static ::std::wstring LDAP_KEY_EXCH_HIDE_FROM_ADDRESS_LISTS;
	/// <summary>
	/// msExchRecipientTypeDetails.
	/// </summary>
	/// <remarks>
	/// Key to access the map UserInfo.ldapProperties
	/// </remarks>
	public: const static ::std::wstring LDAP_KEY_EXCH_RECIPIENT_TYPE_DETAILS;
	/// <summary>
	/// msExchRecipientDisplayType.
	/// </summary>
	/// <remarks>
	/// Key to access the map UserInfo.ldapProperties
	/// </remarks>
	public: const static ::std::wstring LDAP_KEY_EXCH_RECIPIENT_DISPLAY_TYPE;
	/// <summary>
	/// msExchDelegateListLink.
	/// </summary>
	/// <remarks>
	/// Key to access the map UserInfo.ldapProperties
	/// </remarks>
	public: const static ::std::wstring LDAP_KEY_EXCH_DELEGATE_LIST_LINK;
	/// <summary>
	/// msExchPublicFolderMailbox.
	/// </summary>
	/// <remarks>
	/// Key to access the map UserInfo.ldapProperties
	/// </remarks>
	public: const static ::std::wstring LDAP_KEY_EXCH_PUBFOLDER_MAILBOX;
	/// <summary>
	/// adminDisplayName.
	/// </summary>
	/// <remarks>
	/// Key to access the map UserInfo.ldapProperties
	/// </remarks>
	public: const static ::std::wstring LDAP_KEY_ADMIN_DISPLAY_NAME;
	/// <summary>
	/// msExchMessageJournalRecipient.
	/// </summary>
	/// <remarks>
	/// Key to access the map UserInfo.ldapProperties
	/// </remarks>
	public: const static ::std::wstring LDAP_KEY_EXCH_JOURNAL_RCPT;
	/// <summary>
	/// msExchOwningServer.
	/// </summary>
	/// <remarks>
	/// Key to access the map UserInfo.ldapProperties
	/// </remarks>
	public: const static ::std::wstring LDAP_KEY_EXCH_OWNING_SERVER;
	/// <summary>
	/// PrimarySmtpAddress.
	/// </summary>
	/// <remarks>
	/// Key to access the map UserInfo.ldapProperties
	/// </remarks>
	public: const static ::std::wstring LDAP_KEY_ONLINE_MAIL;
	/// <summary>
	/// RecipientTypeDetails.
	/// </summary>
	/// <remarks>
	/// Key to access the map UserInfo.ldapProperties
	/// </remarks>
	public: const static ::std::wstring LDAP_KEY_ONLINE_RECIPIENT_TYPE_DETAILS;
	/// <summary>
	/// Guid.
	/// </summary>
	/// <remarks>
	/// Key to access the map UserInfo.ldapProperties
	/// </remarks>
	public: const static ::std::wstring LDAP_KEY_ONLINE_GUID;
	/// <summary>
	/// IsMailboxEnabled.
	/// </summary>
	/// <remarks>
	/// Key to access the map UserInfo.ldapProperties
	/// </remarks>
	public: const static ::std::wstring LDAP_KEY_ONLINE_MAILBOX_ENABLED;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: UserInfoC();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: UserInfoC(int32_t MAX_USERPROP, int32_t MAX_KEY, int32_t MAX_USERS, int32_t MAX_GROUPS, int32_t MAX_PERSISTENT_GROUPS, int32_t TYPE_USER, int32_t TYPE_GROUP, int32_t TYPE_USERID_OWNER, int32_t MAX_NAME, int32_t PROP_NAME_OS, int32_t PROP_NAME_EMAIL, int32_t PROP_ACTION, const ::std::wstring& PROP_ACTION_USER_SHOULD_CHANGE_PASSWORD, const ::std::wstring& PROP_ACTION_USER_MUST_CHANGE_PASSWORD, const ::std::wstring& PROP_ACTION_END_PASSWORD_DATE, int32_t PROP_GUID, int32_t lnName, int32_t lnPwd, int32_t lnDesc, int32_t lnUserProp, int32_t lnLdapPropKey, int32_t lnLdapPropValue, int32_t ID_EVERYONE_GROUP, int32_t ID_ADMINISTRATOR, const ::std::wstring& GUID_EVERYONE_GROUP, const ::std::wstring& GUID_ADMINISTRATOR, const ::std::wstring& PWD_VALUE_IGNORE, const ::std::wstring& LDAP_PROP_CN, const ::std::wstring& LDAP_PROP_DISTINGUISHED_NAME, const ::std::wstring& LDAP_PROP_DISPLAY_NAME, const ::std::wstring& LDAP_PROP_NAME, const ::std::wstring& LDAP_PROP_PROXY_ADDRESSES, const ::std::wstring& LDAP_PROP_USER_ACCOUNT_CONTROL, const ::std::wstring& LDAP_PROP_SAM_ACCOUNT_NAME, const ::std::wstring& LDAP_PROP_SAM_ACCOUNT_TYPE, const ::std::wstring& LDAP_PROP_USER_PRINCIPAL_NAME, const ::std::wstring& LDAP_PROP_OBJECT_CATEGORY, const ::std::wstring& LDAP_PROP_MAIL_NICK_NAME, const ::std::wstring& LDAP_PROP_OBJECT_GUID, const ::std::wstring& LDAP_PROP_OBJECT_SID, const ::std::wstring& LDAP_PROP_MS_EXCHANGE_MAILBOX_GUID, const ::std::wstring& LDAP_PROP_GROUP_TYPE, const ::std::wstring& LDAP_PROP_FQDN, const ::std::wstring& LDAP_PROP_ONLINE, const ::std::wstring& LDAP_PROP_OBJECT_CLASS, const ::std::wstring& LDAP_PROP_MEMBER_OF, const ::std::wstring& LDAP_PROP_LEGACY_EXCHANGE_DN, const ::std::wstring& LDAP_PROP_MAIL, const ::std::wstring& LDAP_PROP_EXCH_HIDE_FROM_ADDRESS_LISTS, const ::std::wstring& LDAP_PROP_EXCH_RECIPIENT_TYPE_DETAILS, const ::std::wstring& LDAP_PROP_EXCH_RECIPIENT_DISPLAY_TYPE, const ::std::wstring& LDAP_PROP_EXCH_DELEGATE_LIST_LINK, const ::std::wstring& LDAP_PROP_EXCH_PUBFOLDER_MAILBOX, const ::std::wstring& LDAP_PROP_ADMIN_DISPLAY_NAME, const ::std::wstring& LDAP_PROP_EXCH_JOURNAL_RCPT, const ::std::wstring& LDAP_PROP_EXCH_OWNING_SERVER, const ::std::wstring& LDAP_PROP_ONLINE_MAIL, const ::std::wstring& LDAP_PROP_ONLINE_RECIPIENT_TYPE_DETAILS, const ::std::wstring& LDAP_PROP_ONLINE_GUID, const ::std::wstring& LDAP_PROP_ONLINE_MAILBOX_ENABLED, const ::std::wstring& LDAP_KEY_CN, const ::std::wstring& LDAP_KEY_DISTINGUISHED_NAME, const ::std::wstring& LDAP_KEY_DISPLAY_NAME, const ::std::wstring& LDAP_KEY_NAME, const ::std::wstring& LDAP_KEY_PROXY_ADDRESSES, const ::std::wstring& LDAP_KEY_USER_ACCOUNT_CONTROL, const ::std::wstring& LDAP_KEY_SAM_ACCOUNT_NAME, const ::std::wstring& LDAP_KEY_SAM_ACCOUNT_TYPE, const ::std::wstring& LDAP_KEY_USER_PRINCIPAL_NAME, const ::std::wstring& LDAP_KEY_OBJECT_CATEGORY, const ::std::wstring& LDAP_KEY_MAIL_NICK_NAME, const ::std::wstring& LDAP_KEY_OBJECT_GUID, const ::std::wstring& LDAP_KEY_OBJECT_SID, const ::std::wstring& LDAP_KEY_MS_EXCHANGE_MAILBOX_GUID, const ::std::wstring& LDAP_KEY_GROUP_TYPE, const ::std::wstring& LDAP_KEY_FQDN, const ::std::wstring& LDAP_KEY_ONLINE, const ::std::wstring& LDAP_KEY_OBJECT_CLASS, const ::std::wstring& LDAP_KEY_MEMBER_OF, const ::std::wstring& LDAP_KEY_LEGACY_EXCHANGE_DN, const ::std::wstring& LDAP_KEY_MAIL, const ::std::wstring& LDAP_KEY_EXCH_HIDE_FROM_ADDRESS_LISTS, const ::std::wstring& LDAP_KEY_EXCH_RECIPIENT_TYPE_DETAILS, const ::std::wstring& LDAP_KEY_EXCH_RECIPIENT_DISPLAY_TYPE, const ::std::wstring& LDAP_KEY_EXCH_DELEGATE_LIST_LINK, const ::std::wstring& LDAP_KEY_EXCH_PUBFOLDER_MAILBOX, const ::std::wstring& LDAP_KEY_ADMIN_DISPLAY_NAME, const ::std::wstring& LDAP_KEY_EXCH_JOURNAL_RCPT, const ::std::wstring& LDAP_KEY_EXCH_OWNING_SERVER, const ::std::wstring& LDAP_KEY_ONLINE_MAIL, const ::std::wstring& LDAP_KEY_ONLINE_RECIPIENT_TYPE_DETAILS, const ::std::wstring& LDAP_KEY_ONLINE_GUID, const ::std::wstring& LDAP_KEY_ONLINE_MAILBOX_ENABLED);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getLnName() { return lnName; }
	public: void setLnName(int32_t v);
	public: int32_t getLnPwd() { return lnPwd; }
	public: void setLnPwd(int32_t v);
	public: int32_t getLnDesc() { return lnDesc; }
	public: void setLnDesc(int32_t v);
	public: int32_t getLnUserProp() { return lnUserProp; }
	public: void setLnUserProp(int32_t v);
	public: int32_t getLnLdapPropKey() { return lnLdapPropKey; }
	public: void setLnLdapPropKey(int32_t v);
	public: int32_t getLnLdapPropValue() { return lnLdapPropValue; }
	public: void setLnLdapPropValue(int32_t v);
	public: ::std::wstring getGUID_EVERYONE_GROUP() { return GUID_EVERYONE_GROUP; }
	public: void setGUID_EVERYONE_GROUP(::std::wstring v);
	public: ::std::wstring getGUID_ADMINISTRATOR() { return GUID_ADMINISTRATOR; }
	public: void setGUID_ADMINISTRATOR(::std::wstring v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// UserName
// typeId=123879203

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// <p>Contains user name, ID and type (group or user).
/// </summary>
/// <remarks>
/// </p>
/// <p>Copyright: Copyright (c) 2004</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </remarks>
class UserName : public ValueClass {
	/// <summary>
	/// User ID
	/// </summary>
	protected: int32_t id;
	/// <summary>
	/// User name.
	/// </summary>
	protected: ::std::wstring name;
	/// <summary>
	/// User type.
	/// </summary>
	protected: int32_t type;
	/// <summary>
	/// User rights.
	/// </summary>
	/// <remarks>
	/// To detect a suspended user, test bit AccessC.FLAG_NOLOGIN.
	/// </remarks>
	protected: int32_t flags;
	/// <summary>
	/// User rights, second set.
	/// </summary>
	/// <remarks>
	/// This member is a bit set of AccessC.FLAGS2_* constants.
	/// </remarks>
	protected: int32_t flags2;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: UserName();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: UserName(int32_t id, const ::std::wstring& name, int32_t type, int32_t flags, int32_t flags2);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getId() { return id; }
	public: void setId(int32_t v);
	public: ::std::wstring getName() { return name; }
	public: void setName(::std::wstring v);
	public: int32_t getType() { return type; }
	public: void setType(int32_t v);
	public: int32_t getFlags() { return flags; }
	public: void setFlags(int32_t v);
	public: int32_t getFlags2() { return flags2; }
	public: void setFlags2(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// UserNodeInfo
// typeId=2059835971

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// This class contains the information of a user node using to create a
/// AdHocWorkflow.
/// </summary>
/// <remarks>
/// This class is used by the method
/// IXServicePortIF.startAdHocWorkFlow2.
/// </remarks>
class UserNodeInfo : public ValueClass {
	protected: ::std::wstring nodeName;
	protected: ::std::wstring userId;
	/// <summary>
	/// Additional definitions for time limits.
	/// </summary>
	/// <remarks>
	/// This member is only valid for person nodes.
	/// </remarks>
	protected: PArrayWFTimeLimit timeLimitEscalations;
	/// <summary>
	/// The time-limit to process the node.
	/// </summary>
	/// <remarks>
	/// This member is only valid for person nodes.
	/// </remarks>
	protected: int32_t timeLimit;
	/// <summary>
	/// After this date the node exceeds the time-limit for processing.
	/// </summary>
	/// <remarks>
	/// This member is only valid for person nodes.
	/// </remarks>
	protected: ::std::wstring timeLimitIso;
	/// <summary>
	/// Control flags for the node, a combination of WFNode.C.FLAG_* constants.
	/// </summary>
	protected: int32_t flags;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: UserNodeInfo();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: UserNodeInfo(const ::std::wstring& nodeName, const ::std::wstring& userId, const PArrayWFTimeLimit& timeLimitEscalations, int32_t timeLimit, const ::std::wstring& timeLimitIso, int32_t flags);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: ::std::wstring getNodeName() { return nodeName; }
	public: void setNodeName(::std::wstring v);
	public: ::std::wstring getUserId() { return userId; }
	public: void setUserId(::std::wstring v);
	public: PArrayWFTimeLimit getTimeLimitEscalations() { return timeLimitEscalations; }
	public: void setTimeLimitEscalations(PArrayWFTimeLimit v);
	public: int32_t getTimeLimit() { return timeLimit; }
	public: void setTimeLimit(int32_t v);
	public: ::std::wstring getTimeLimitIso() { return timeLimitIso; }
	public: void setTimeLimitIso(::std::wstring v);
	public: int32_t getFlags() { return flags; }
	public: void setFlags(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// UserProfile
// typeId=1401065069

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// User profile options
/// <p>Copyright: Copyright (c) 2004</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </summary>
class UserProfile : public ValueClass {
	/// <summary>
	/// Options as name-value-pairs.
	/// </summary>
	/// <remarks>
	/// This array contains the sum of default options, group options and user options.
	/// </remarks>
	protected: PArrayKeyValue options;
	/// <summary>
	/// The user name or UserProfileC.USERID_ALL, if the options for all users are represented by this object.
	/// </summary>
	/// <remarks>
	/// The values null or empty are equal to UserProfileC.USERID_ALL.
	/// </remarks>
	protected: ::std::wstring userId;
	/// <summary>
	/// Do not read values of option groups.
	/// </summary>
	/// <remarks>
	/// Only valid for checkoutUserProfile.
	/// </remarks>
	protected: bool excludeGroupValues;
	/// <summary>
	/// Do not read values for all users.
	/// </summary>
	/// <remarks>
	/// Only valid for checkoutUserProfile.
	/// </remarks>
	protected: bool excludeDefaultValues;
	/// <summary>
	/// Options as name-value-pairs.
	/// </summary>
	/// <remarks>
	/// This array contains the options defined for the given user.
	/// Read-only.
	/// </remarks>
	protected: PArrayKeyValue userOptions;
	/// <summary>
	/// Options as name-value-pairs.
	/// </summary>
	/// <remarks>
	/// This array contains the options defined for the users option group.
	/// Read-only.
	/// </remarks>
	protected: PArrayKeyValue groupOptions;
	/// <summary>
	/// Options as name-value-pairs.
	/// </summary>
	/// <remarks>
	/// This array contains the default options valid for all users.
	/// Read-only.
	/// </remarks>
	protected: PArrayKeyValue defaultOptions;
	/// <summary>
	/// The users option group ID.
	/// </summary>
	/// <remarks>
	/// This value is -1, if the user is not member of an option group.
	/// Read-only.
	/// </remarks>
	protected: int32_t groupId;
	/// <summary>
	/// Include all group and default options.
	/// </summary>
	/// <remarks>
	/// Set this member as true, if all group and default options shall be returned.
	/// If the value is false, only those options are returned that are not particularly defined for the user.
	/// </remarks>
	protected: bool includeAllGroupAndDefaultOptions;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: UserProfile();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: UserProfile(const PArrayKeyValue& options, const ::std::wstring& userId, bool excludeGroupValues, bool excludeDefaultValues, const PArrayKeyValue& userOptions, const PArrayKeyValue& groupOptions, const PArrayKeyValue& defaultOptions, int32_t groupId, bool includeAllGroupAndDefaultOptions);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: PArrayKeyValue getOptions() { return options; }
	public: void setOptions(PArrayKeyValue v);
	public: ::std::wstring getUserId() { return userId; }
	public: void setUserId(::std::wstring v);
	public: bool getExcludeGroupValues() { return excludeGroupValues; }
	public: void setExcludeGroupValues(bool v);
	public: bool getExcludeDefaultValues() { return excludeDefaultValues; }
	public: void setExcludeDefaultValues(bool v);
	public: PArrayKeyValue getUserOptions() { return userOptions; }
	public: void setUserOptions(PArrayKeyValue v);
	public: PArrayKeyValue getGroupOptions() { return groupOptions; }
	public: void setGroupOptions(PArrayKeyValue v);
	public: PArrayKeyValue getDefaultOptions() { return defaultOptions; }
	public: void setDefaultOptions(PArrayKeyValue v);
	public: int32_t getGroupId() { return groupId; }
	public: void setGroupId(int32_t v);
	public: bool getIncludeAllGroupAndDefaultOptions() { return includeAllGroupAndDefaultOptions; }
	public: void setIncludeAllGroupAndDefaultOptions(bool v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// UserProfileC
// typeId=1968434410

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// The constants in this class exist due to compatibility requirements with
/// older Index Server versions, which gave back formatted data (Sord.xDataDispl).
/// </summary>
/// <remarks>
/// <p>Copyright: Copyright (c) 2004</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </remarks>
class UserProfileC : public BSerializable {
	public: const static ::std::wstring DATE_FORMAT;
	public: const static ::std::wstring SORD_DATE_FORMAT;
	public: const static ::std::wstring SORD_IDATE_FORMAT;
	public: const static ::std::wstring SORD_XDATE_FORMAT;
	public: const static ::std::wstring SORD_DELDATE_FORMAT;
	public: const static ::std::wstring DOC_VERSION_DATE_FORMAT;
	public: const static ::std::wstring DOC_VERSION_CREATE_FORMAT;
	public: const static ::std::wstring DOC_VERSION_ACCESS_FORMAT;
	public: const static ::std::wstring DOC_VERSION_UPDATE_FORMAT;
	/// <summary>
	/// Read/write user profile options for all users.
	/// </summary>
	public: const static ::std::wstring USERID_ALL;
	/// <summary>
	/// Extended access control for documents or folders used in workflows.
	/// </summary>
	/// <remarks>
	/// <p>
	/// There are two concepts of extending access control for folders and documents routed though a workflow.
	/// The rules are only applied if (a) the current user has an active workflow task for the folder or document and
	/// (b) the right AccessC.FLAG2_EXTEND_WORKFLOW_RIGHTS is assigned to the current user.
	/// </p><p>
	/// 1. Overlay additional access rights over the objects ACL: the lower 8 bits of the keys value
	/// specify a combination of AccessC.LUR_* constants that are added to the ACL access rights when access checking is performed.
	/// The objects ACL is not modified, this rule only changes the internal program logic.
	/// </p><p>
	/// 2. Permanently add additional access to the ACL: the higher 8 bits of the keys value
	/// specify a combination of AccessC.LUR_* constants for a new ACL entry to be added for the current user.
	/// The ACL is only extended, if checkoutSord or checkoutDoc detects less access for the current user.
	/// </remarks>
	public: const static ::std::wstring KEY_EXTEND_DOCUMENT_ACCESS_IN_WORKFLOW;
	/// <summary>
	/// Password rules.
	/// </summary>
	/// <remarks>
	/// The password rules are stored as a comma separated list of 5 Integers, e.g. "7,1,1,0,0".
	/// 1. Minimum password length
	/// 2. Is != 0, if password must contain at least one letter.
	/// 3. Is != 0, if password must contain at least one special character (not letter and not digit).
	/// 4. Is != 0, if password must contain at least one lower case and one upper case letter.
	/// 5. Is != 0, if password must contain at least one digit.
	/// </remarks>
	public: const static ::std::wstring KEY_PASSWORD_RULES;
	/// <summary>
	/// The password has to be changed after this number of days.
	/// </summary>
	/// <remarks>
	/// The value corresponds to UserInfo.userProps[UserInfoC.PROP_ACTION].
	/// </remarks>
	public: const static ::std::wstring KEY_PASSWORD_VALID_DAYS;
	/// <summary>
	/// Give the archive's language (set by a new installation since Server Setup 9.00.004).
	/// </summary>
	public: const static ::std::wstring KEY_ARCHIVE_LANGUAGE;
	/// <summary>
	/// Automatically subscribe Feed if the User creates a new Document
	/// </summary>
	public: const static ::std::wstring KEY_FEED_SUBSCRIBE_MYDOC;
	/// <summary>
	/// Automatically subscribe Feed if the User creates a new Folder
	/// </summary>
	public: const static ::std::wstring KEY_FEED_SUBSCRIBE_MYFOLDER;
	/// <summary>
	/// Automatically subscribe Feed if the User creates a new Version of a Document
	/// </summary>
	public: const static ::std::wstring KEY_FEED_SUBSCRIBE_NEWVERSION;
	/// <summary>
	/// Automatically subscribe Feed if the User adds a comment to a Feed
	/// </summary>
	public: const static ::std::wstring KEY_FEED_SUBSCRIBE_NEWCOMMENT;
	/// <summary>
	/// Prefix for fulltext search options.
	/// </summary>
	public: const static ::std::wstring KEY_PREFIX_FULLTEXT_SEARCH_OPTIONS;
	/// <summary>
	/// Maximum length of key
	/// </summary>
	protected: int32_t lnKey;
	/// <summary>
	/// Maximum length of value
	/// </summary>
	protected: int32_t lnValue;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: UserProfileC();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: UserProfileC(const ::std::wstring& DATE_FORMAT, const ::std::wstring& SORD_DATE_FORMAT, const ::std::wstring& SORD_IDATE_FORMAT, const ::std::wstring& SORD_XDATE_FORMAT, const ::std::wstring& SORD_DELDATE_FORMAT, const ::std::wstring& DOC_VERSION_DATE_FORMAT, const ::std::wstring& DOC_VERSION_CREATE_FORMAT, const ::std::wstring& DOC_VERSION_ACCESS_FORMAT, const ::std::wstring& DOC_VERSION_UPDATE_FORMAT, const ::std::wstring& USERID_ALL, const ::std::wstring& KEY_EXTEND_DOCUMENT_ACCESS_IN_WORKFLOW, const ::std::wstring& KEY_PASSWORD_RULES, const ::std::wstring& KEY_PASSWORD_VALID_DAYS, const ::std::wstring& KEY_ARCHIVE_LANGUAGE, const ::std::wstring& KEY_FEED_SUBSCRIBE_MYDOC, const ::std::wstring& KEY_FEED_SUBSCRIBE_MYFOLDER, const ::std::wstring& KEY_FEED_SUBSCRIBE_NEWVERSION, const ::std::wstring& KEY_FEED_SUBSCRIBE_NEWCOMMENT, const ::std::wstring& KEY_PREFIX_FULLTEXT_SEARCH_OPTIONS, int32_t lnKey, int32_t lnValue);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getLnKey() { return lnKey; }
	public: void setLnKey(int32_t v);
	public: int32_t getLnValue() { return lnValue; }
	public: void setLnValue(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// UserProfileData
// typeId=2015395180

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Internal class.
/// </summary>
class UserProfileData : public ValueClass {
	/// <summary>
	/// User ID.
	/// </summary>
	/// <remarks>
	/// DB column: userid
	/// </remarks>
	protected: int32_t user;
	/// <summary>
	/// Option key.
	/// </summary>
	/// <remarks>
	/// DB column: optkey
	/// </remarks>
	protected: ::std::wstring key;
	/// <summary>
	/// Option value.
	/// </summary>
	/// <remarks>
	/// DB column: optvalue
	/// </remarks>
	protected: ::std::wstring value;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: UserProfileData();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: UserProfileData(int32_t user, const ::std::wstring& key, const ::std::wstring& value);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getUser() { return user; }
	public: void setUser(int32_t v);
	public: ::std::wstring getKey() { return key; }
	public: void setKey(::std::wstring v);
	public: ::std::wstring getValue() { return value; }
	public: void setValue(::std::wstring v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// UserProfileDataC
// typeId=466121473

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// <p>Bit constants for members of UserProfileData</p>
/// <p>Copyright: Copyright (c) 2003</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </summary>
class UserProfileDataC : public BSerializable {
	/// <summary>
	/// DB column: userid
	/// </summary>
	public: const static int64_t mbUser = 1LL;
	/// <summary>
	/// DB column: optkey
	/// </summary>
	public: const static int64_t mbKey = 2LL;
	/// <summary>
	/// DB column: optkey
	/// </summary>
	protected: int32_t lnKey;
	/// <summary>
	/// DB column: optvalue
	/// </summary>
	public: const static int64_t mbValue = 4LL;
	/// <summary>
	/// DB column: optvalue
	/// </summary>
	protected: int32_t lnValue;
	/// <summary>
	/// All valid member bits.
	/// </summary>
	public: const static int64_t mbAllMembers = 7LL;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: UserProfileDataC();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: UserProfileDataC(int64_t mbUser, int64_t mbKey, int32_t lnKey, int64_t mbValue, int32_t lnValue, int64_t mbAllMembers);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getLnKey() { return lnKey; }
	public: void setLnKey(int32_t v);
	public: int32_t getLnValue() { return lnValue; }
	public: void setLnValue(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// UserTask
// typeId=1484696239

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Describes the tasks assigned to a user.
/// </summary>
/// <remarks>
/// ix.findFirstTasks returns the tasks for a user in the form of UserTask objects.
/// Either activity, reminder or workflow is set depending upon whether the task
/// is an activity, reminder or workflow task.
/// 
/// <p>Copyright: Copyright (c) 2004</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </remarks>
class UserTask : public ValueClass {
	/// <summary>
	/// Task is an activity.
	/// </summary>
	protected: PActivity activity;
	/// <summary>
	/// Task is a reminder item.
	/// </summary>
	protected: PReminder reminder;
	/// <summary>
	/// Task is a workflow task.
	/// </summary>
	protected: PWFCollectNode wfNode;
	/// <summary>
	/// Associated Sord object.
	/// </summary>
	/// <remarks>
	/// This member is set, if {@link IXServicePortIF#findFirstTasks(ClientInfo, FindTasksInfo, int)} is called with
	/// {@link FindTasksInfo#sordZ} != null.
	/// This member contains the associatied Sord object to the task. Its valid members are defined by the element
	/// selector given in {@link FindTasksInfo#sordZ}.
	/// </remarks>
	protected: PSord sord;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: UserTask();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: UserTask(const PActivity& activity, const PReminder& reminder, const PWFCollectNode& wfNode, const PSord& sord);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: PActivity getActivity() { return activity; }
	public: void setActivity(PActivity v);
	public: PReminder getReminder() { return reminder; }
	public: void setReminder(PReminder v);
	public: PWFCollectNode getWfNode() { return wfNode; }
	public: void setWfNode(PWFCollectNode v);
	public: PSord getSord() { return sord; }
	public: void setSord(PSord v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// UserTaskPriorityC
// typeId=260320342

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

class UserTaskPriorityC : public BSerializable {
	/// <summary>
	/// Minimum value = highest priority of reminder and activity
	/// </summary>
	public: const static int32_t MIN = 0;
	/// <summary>
	/// Maximum value = lowest priority of reminder and activity
	/// </summary>
	public: const static int32_t MAX = 2;
	/// <summary>
	/// Highest priority.
	/// </summary>
	public: const static int32_t HIGHEST = 0;
	/// <summary>
	/// Lowest priority.
	/// </summary>
	public: const static int32_t LOWEST = 2;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: UserTaskPriorityC();
	
	public: virtual BTYPEID BSerializable_getTypeId();
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// UserTaskSortOrderC
// typeId=854117900

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

class UserTaskSortOrderC : public BSerializable {
	public: const static int64_t bsetPRIORITY_DATE_NAME = 0LL;
	public: const static int64_t bsetDATE_PRIORITY_NAME = 1LL;
	public: const static int64_t bsetNAME_PRIORITY_DATE = 2LL;
	public: const static int64_t bsetFLAG_SORT_ORDER_INV = 4611686018427387904LL;
	public: const static int64_t bsetPRIORITY_DATE_NAME_INV = 4611686018427387904LL;
	public: const static int64_t bsetDATE_PRIORITY_NAME_INV = 4611686018427387905LL;
	public: const static int64_t bsetNAME_PRIORITY_DATE_INV = 4611686018427387906LL;
	/// <summary>
	/// Order collected tasks by priority, date and NAME.
	/// </summary>
	public: const static PUserTaskSortOrderZ PRIORITY_DATE_NAME;
	/// <summary>
	/// Order collected tasks by date, priority and NAME.
	/// </summary>
	public: const static PUserTaskSortOrderZ DATE_PRIORITY_NAME;
	/// <summary>
	/// Order collected tasks by NAME, priority, date.
	/// </summary>
	public: const static PUserTaskSortOrderZ NAME_PRIORITY_DATE;
	/// <summary>
	/// Inverse order collected tasks by priority, date and NAME.
	/// </summary>
	public: const static PUserTaskSortOrderZ PRIORITY_DATE_NAME_INV;
	/// <summary>
	/// Inverse order collected tasks by date, priority and NAME.
	/// </summary>
	public: const static PUserTaskSortOrderZ DATE_PRIORITY_NAME_INV;
	/// <summary>
	/// Inverse order collected tasks by NAME, priority, date.
	/// </summary>
	public: const static PUserTaskSortOrderZ NAME_PRIORITY_DATE_INV;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: UserTaskSortOrderC();
	
	public: virtual BTYPEID BSerializable_getTypeId();
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// UserTaskSortOrderZ
// typeId=1199296467

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// This class encapsulates the constants of the UserTaskSortOrderC class.
/// </summary>
/// <remarks>
/// <p>Copyright: Copyright (c) 2004</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </remarks>
class UserTaskSortOrderZ : public ValueClass {
	/// <summary>
	/// Bitset field for constants from the UserTaskSortOrderC class.
	/// </summary>
	protected: int64_t bset;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: UserTaskSortOrderZ();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: UserTaskSortOrderZ(int64_t bset);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int64_t getBset() { return bset; }
	public: void setBset(int64_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// ValuesOfObjKey
// typeId=1153931872

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Objects of this class contain the returned data from IXServicePortIF.getDistinctValuesOfObjKey.
/// </summary>
class ValuesOfObjKey : public BSerializable {
	/// <summary>
	/// ObjKey values.
	/// </summary>
	protected: PArrayString values;
	/// <summary>
	/// For each entry values[i] the corresponding usageCount[i]
	/// tells how often the value is used.
	/// </summary>
	protected: PArrayInt usageCounts;
	/// <summary>
	/// The sum of all usageCounts.
	/// </summary>
	protected: int32_t totalCount;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: ValuesOfObjKey();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: ValuesOfObjKey(const PArrayString& values, const PArrayInt& usageCounts, int32_t totalCount);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: PArrayString getValues() { return values; }
	public: void setValues(PArrayString v);
	public: PArrayInt getUsageCounts() { return usageCounts; }
	public: void setUsageCounts(PArrayInt v);
	public: int32_t getTotalCount() { return totalCount; }
	public: void setTotalCount(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// ValuesOfObjKeyOptions
// typeId=958310068

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

class ValuesOfObjKeyOptions : public ValueClass {
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: ValuesOfObjKeyOptions();
	
	public: virtual BTYPEID BSerializable_getTypeId();
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// VtDoc
// typeId=1935852595

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Internal class.
/// </summary>
class VtDoc : public ValueClass {
	/// <summary>
	/// DB column: objid
	/// </summary>
	protected: int32_t objId;
	/// <summary>
	/// DB column: objdoc
	/// </summary>
	protected: int32_t docId;
	/// <summary>
	/// DB column: vtcode
	/// </summary>
	protected: int32_t code;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: VtDoc();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: VtDoc(int32_t objId, int32_t docId, int32_t code);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getObjId() { return objId; }
	public: void setObjId(int32_t v);
	public: int32_t getDocId() { return docId; }
	public: void setDocId(int32_t v);
	public: int32_t getCode() { return code; }
	public: void setCode(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// VtDocC
// typeId=1585149555

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// <p>Bit constants for members of VtDoc</p>
/// <p>Copyright: Copyright (c) 2003</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </summary>
class VtDocC : public BSerializable {
	/// <summary>
	/// DB column: objid
	/// </summary>
	public: const static int64_t mbObjId = 1LL;
	/// <summary>
	/// DB column: objdoc
	/// </summary>
	public: const static int64_t mbDocId = 2LL;
	/// <summary>
	/// DB column: vtcode
	/// </summary>
	public: const static int64_t mbCode = 4LL;
	/// <summary>
	/// All valid member bits.
	/// </summary>
	public: const static int64_t mbAllMembers = 7LL;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: VtDocC();
	
	public: virtual BTYPEID BSerializable_getTypeId();
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// WFCollectNode
// typeId=1492908819

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// <p>Data used to display a workflow node int the task view.
/// </summary>
/// <remarks>
/// </p>
/// <p>This class bundles the data which is required for displaying a workflow
/// node. The class is used by <code>findFirstTasks</code> </p>
/// </remarks>
class WFCollectNode : public ValueClass {
	/// <summary>
	/// Date the node was activated
	/// </summary>
	protected: ::std::wstring activateDateIso;
	/// <summary>
	/// Is the node active or not?
	/// </summary>
	protected: bool active;
	/// <summary>
	/// Workflow id
	/// </summary>
	protected: int32_t flowId;
	/// <summary>
	/// Workflow name
	/// </summary>
	protected: ::std::wstring flowName;
	/// <summary>
	/// Date the node was set to <i>In Use</i>
	/// </summary>
	protected: ::std::wstring inUseDateIso;
	/// <summary>
	/// Node identifier
	/// </summary>
	protected: int32_t nodeId;
	/// <summary>
	/// Description/processing instructions for the workflow node
	/// </summary>
	protected: ::std::wstring nodeName;
	/// <summary>
	/// Object GUID of the object for which the workflow is started.
	/// </summary>
	/// <remarks>
	/// This member is not set, if workflow caching is enabled.
	/// </remarks>
	protected: ::std::wstring objGuid;
	/// <summary>
	/// Object id of the object for which the workflow is started.
	/// </summary>
	protected: int32_t objId;
	/// <summary>
	/// Object type of the object for which the workflow is started
	/// </summary>
	/// <remarks>
	/// .
	/// (1 for cabinet, 2 for folder, etc.)
	/// </remarks>
	protected: int32_t objType;
	/// <summary>
	/// Node priority
	/// </summary>
	protected: int32_t prio;
	/// <summary>
	/// Date the node was completed/terminated
	/// </summary>
	protected: ::std::wstring terminateDateIso;
	/// <summary>
	/// User number of the user for whom the workflow node is intended.
	/// </summary>
	protected: int32_t userId;
	/// <summary>
	/// User name of the user for whom the workflow node is intended.
	/// </summary>
	protected: ::std::wstring userName;
	/// <summary>
	/// True, if the node exceeds the time limit.
	/// </summary>
	protected: bool overTimeLimit;
	/// <summary>
	/// Date the workfow was completed
	/// </summary>
	protected: ::std::wstring completionDateIso;
	/// <summary>
	/// The workflow node is deferred until this date.
	/// </summary>
	/// <remarks>
	/// Not valid for template workflows.
	/// Only valid for person nodes.
	/// ELO date format.
	/// </remarks>
	protected: ::std::wstring userDelayDateIso;
	/// <summary>
	/// Workflow status.
	/// </summary>
	/// <remarks>
	/// This member is only valid when this object is returned by the
	/// findFirstTasks or findNextTasks functions.
	/// </remarks>
	protected: ::std::wstring flowStatus;
	/// <summary>
	/// Node must be completed until this date.
	/// </summary>
	/// <remarks>
	/// This member is only valid when this object is returned by the
	/// findFirstTasks or findNextTasks functions.
	/// </remarks>
	protected: ::std::wstring timeLimitIso;
	/// <summary>
	/// Additional definitions for time limits.
	/// </summary>
	protected: PArrayWFTimeLimit timeLimitEscalations;
	/// <summary>
	/// Workflow owner ID.
	/// </summary>
	/// <remarks>
	/// This member is only valid when this object is returned by the
	/// findFirstTasks or findNextTasks functions.
	/// </remarks>
	protected: int32_t workflowOwnerId;
	/// <summary>
	/// Workflow owner name.
	/// </summary>
	/// <remarks>
	/// This member is only valid when this object is returned by the
	/// findFirstTasks or findNextTasks functions.
	/// </remarks>
	protected: ::std::wstring workflowOwnerName;
	/// <summary>
	/// ID of the user that was assigned to the node when the workflow started.
	/// </summary>
	protected: int32_t designDepartmentId;
	/// <summary>
	/// Name of the user that was assigned to the node when the workflow started.
	/// </summary>
	protected: ::std::wstring designDepartmentName;
	/// <summary>
	/// Node description.
	/// </summary>
	protected: ::std::wstring nodeComment;
	/// <summary>
	/// Sord name.
	/// </summary>
	protected: ::std::wstring objName;
	/// <summary>
	/// Time limit in minutes.
	/// </summary>
	protected: int32_t timeLimit;
	/// <summary>
	/// The ID of the user that should be informed,
	/// if the time-limit is exceeded.
	/// </summary>
	/// <remarks>
	/// The IndexServer does not send any notification to the
	/// user. The client application is responsible for doing this.
	/// </remarks>
	protected: int32_t timeLimitUserId;
	/// <summary>
	/// User name for timeLimitUserId;
	/// When writing a workflow with checkinWorkFlow, this value has preceedence
	/// before timeLimitUserId.
	/// </summary>
	/// <remarks>
	/// Set timeLimitUserName to an empty string, if
	/// timeLimitUserId should be used.
	/// </remarks>
	protected: ::std::wstring timeLimitUserName;
	/// <summary>
	/// Time limits and time limit escalation of the entire workflow.
	/// </summary>
	/// <remarks>
	/// This array holds 3 time limit states of the entire workflow.
	/// The first item is filled from WFDiagram.overTimeLimit, WFDiagram.timeLimit,
	/// WFDiagram.timeLimitIso, WFDiagram.timeLimitUserId and WFDiagram.timeLimitUserName.
	/// The second and third items are set to the two items in WFDiagram.timeLimitEscaltions.
	/// </remarks>
	protected: PArrayWFTimeLimit timeLimitsWorkflow;
	/// <summary>
	/// Workflow start date.
	/// </summary>
	protected: ::std::wstring activateDateWorkflowIso;
	/// <summary>
	/// Same as {@link WFNode#formSpec}.
	/// </summary>
	protected: ::std::wstring formSpec;
	/// <summary>
	/// Indicates whether the workflow is an escalation.
	/// </summary>
	protected: bool overTimeLimitAny;
	/// <summary>
	/// Indicates whether this workflow is hidden.
	/// </summary>
	protected: bool hidden;
	/// <summary>
	/// Translation-keyword for nodeName.
	/// </summary>
	protected: ::std::wstring nodeNameTranslationKey;
	/// <summary>
	/// Translation-keyword for nodeComment.
	/// </summary>
	protected: ::std::wstring nodeCommentTranslationKey;
	/// <summary>
	/// Translation-keyword for workflow name.
	/// </summary>
	protected: ::std::wstring flowNameTranslationKey;
	/// <summary>
	/// Display name by forwarding
	/// </summary>
	protected: ::std::wstring label;
	/// <summary>
	/// Node properties
	/// </summary>
	protected: ::std::wstring properties;
	/// <summary>
	/// ID of the parent workflow.
	/// </summary>
	protected: int32_t parentFlowId;
	/// <summary>
	/// Translation-keyword for {@link WFCollectNode#label}.
	/// </summary>
	protected: ::std::wstring labelTranslationKey;
	/// <summary>
	/// The call node id of the main workflow, which call this sub workflow.
	/// </summary>
	protected: int32_t callNodeId;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: WFCollectNode();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: WFCollectNode(const ::std::wstring& activateDateIso, bool active, int32_t flowId, const ::std::wstring& flowName, const ::std::wstring& inUseDateIso, int32_t nodeId, const ::std::wstring& nodeName, const ::std::wstring& objGuid, int32_t objId, int32_t objType, int32_t prio, const ::std::wstring& terminateDateIso, int32_t userId, const ::std::wstring& userName, bool overTimeLimit, const ::std::wstring& completionDateIso, const ::std::wstring& userDelayDateIso, const ::std::wstring& flowStatus, const ::std::wstring& timeLimitIso, const PArrayWFTimeLimit& timeLimitEscalations, int32_t workflowOwnerId, const ::std::wstring& workflowOwnerName, int32_t designDepartmentId, const ::std::wstring& designDepartmentName, const ::std::wstring& nodeComment, const ::std::wstring& objName, int32_t timeLimit, int32_t timeLimitUserId, const ::std::wstring& timeLimitUserName, const PArrayWFTimeLimit& timeLimitsWorkflow, const ::std::wstring& activateDateWorkflowIso, const ::std::wstring& formSpec, bool overTimeLimitAny, bool hidden, const ::std::wstring& nodeNameTranslationKey, const ::std::wstring& nodeCommentTranslationKey, const ::std::wstring& flowNameTranslationKey, const ::std::wstring& label, const ::std::wstring& properties, int32_t parentFlowId, const ::std::wstring& labelTranslationKey, int32_t callNodeId);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: ::std::wstring getActivateDateIso() { return activateDateIso; }
	public: void setActivateDateIso(::std::wstring v);
	public: bool getActive() { return active; }
	public: void setActive(bool v);
	public: int32_t getFlowId() { return flowId; }
	public: void setFlowId(int32_t v);
	public: ::std::wstring getFlowName() { return flowName; }
	public: void setFlowName(::std::wstring v);
	public: ::std::wstring getInUseDateIso() { return inUseDateIso; }
	public: void setInUseDateIso(::std::wstring v);
	public: int32_t getNodeId() { return nodeId; }
	public: void setNodeId(int32_t v);
	public: ::std::wstring getNodeName() { return nodeName; }
	public: void setNodeName(::std::wstring v);
	public: ::std::wstring getObjGuid() { return objGuid; }
	public: void setObjGuid(::std::wstring v);
	public: int32_t getObjId() { return objId; }
	public: void setObjId(int32_t v);
	public: int32_t getObjType() { return objType; }
	public: void setObjType(int32_t v);
	public: int32_t getPrio() { return prio; }
	public: void setPrio(int32_t v);
	public: ::std::wstring getTerminateDateIso() { return terminateDateIso; }
	public: void setTerminateDateIso(::std::wstring v);
	public: int32_t getUserId() { return userId; }
	public: void setUserId(int32_t v);
	public: ::std::wstring getUserName() { return userName; }
	public: void setUserName(::std::wstring v);
	public: bool getOverTimeLimit() { return overTimeLimit; }
	public: void setOverTimeLimit(bool v);
	public: ::std::wstring getCompletionDateIso() { return completionDateIso; }
	public: void setCompletionDateIso(::std::wstring v);
	public: ::std::wstring getUserDelayDateIso() { return userDelayDateIso; }
	public: void setUserDelayDateIso(::std::wstring v);
	public: ::std::wstring getFlowStatus() { return flowStatus; }
	public: void setFlowStatus(::std::wstring v);
	public: ::std::wstring getTimeLimitIso() { return timeLimitIso; }
	public: void setTimeLimitIso(::std::wstring v);
	public: PArrayWFTimeLimit getTimeLimitEscalations() { return timeLimitEscalations; }
	public: void setTimeLimitEscalations(PArrayWFTimeLimit v);
	public: int32_t getWorkflowOwnerId() { return workflowOwnerId; }
	public: void setWorkflowOwnerId(int32_t v);
	public: ::std::wstring getWorkflowOwnerName() { return workflowOwnerName; }
	public: void setWorkflowOwnerName(::std::wstring v);
	public: int32_t getDesignDepartmentId() { return designDepartmentId; }
	public: void setDesignDepartmentId(int32_t v);
	public: ::std::wstring getDesignDepartmentName() { return designDepartmentName; }
	public: void setDesignDepartmentName(::std::wstring v);
	public: ::std::wstring getNodeComment() { return nodeComment; }
	public: void setNodeComment(::std::wstring v);
	public: ::std::wstring getObjName() { return objName; }
	public: void setObjName(::std::wstring v);
	public: int32_t getTimeLimit() { return timeLimit; }
	public: void setTimeLimit(int32_t v);
	public: int32_t getTimeLimitUserId() { return timeLimitUserId; }
	public: void setTimeLimitUserId(int32_t v);
	public: ::std::wstring getTimeLimitUserName() { return timeLimitUserName; }
	public: void setTimeLimitUserName(::std::wstring v);
	public: PArrayWFTimeLimit getTimeLimitsWorkflow() { return timeLimitsWorkflow; }
	public: void setTimeLimitsWorkflow(PArrayWFTimeLimit v);
	public: ::std::wstring getActivateDateWorkflowIso() { return activateDateWorkflowIso; }
	public: void setActivateDateWorkflowIso(::std::wstring v);
	public: ::std::wstring getFormSpec() { return formSpec; }
	public: void setFormSpec(::std::wstring v);
	public: bool getOverTimeLimitAny() { return overTimeLimitAny; }
	public: void setOverTimeLimitAny(bool v);
	public: bool getHidden() { return hidden; }
	public: void setHidden(bool v);
	public: ::std::wstring getNodeNameTranslationKey() { return nodeNameTranslationKey; }
	public: void setNodeNameTranslationKey(::std::wstring v);
	public: ::std::wstring getNodeCommentTranslationKey() { return nodeCommentTranslationKey; }
	public: void setNodeCommentTranslationKey(::std::wstring v);
	public: ::std::wstring getFlowNameTranslationKey() { return flowNameTranslationKey; }
	public: void setFlowNameTranslationKey(::std::wstring v);
	public: ::std::wstring getLabel() { return label; }
	public: void setLabel(::std::wstring v);
	public: ::std::wstring getProperties() { return properties; }
	public: void setProperties(::std::wstring v);
	public: int32_t getParentFlowId() { return parentFlowId; }
	public: void setParentFlowId(int32_t v);
	public: ::std::wstring getLabelTranslationKey() { return labelTranslationKey; }
	public: void setLabelTranslationKey(::std::wstring v);
	public: int32_t getCallNodeId() { return callNodeId; }
	public: void setCallNodeId(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// WFDelegateNodeInfo
// typeId=20892334

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// This class is used as a parameter in the function {@link IXServicePortIF#delegateWorkFlowNode(ClientInfo, WFDelegateNodeInfo, LockZ)}.
/// </summary>
class WFDelegateNodeInfo : public BSerializable {
	/// <summary>
	/// Workflow ID, GUID or name
	/// </summary>
	protected: ::std::wstring flowId;
	/// <summary>
	/// Node ID
	/// </summary>
	protected: int32_t nodeId;
	/// <summary>
	/// Name or ID of user or group to whom the workflow is delegated.
	/// </summary>
	protected: ::std::wstring delegateToUserId;
	/// <summary>
	/// Names or IDs of users or groups to whom the workflow is delegated.
	/// </summary>
	/// <remarks>
	/// The delegation nodes are organized serial or parallel as defined by member {@link #delegateParallel}.
	/// </remarks>
	protected: byps::PVectorString delegateToUserIds;
	/// <summary>
	/// Delegate parallel or serial to the list of users.
	/// </summary>
	/// <remarks>
	/// if {@link #delegateToUserIds} is not null or empty, this member describes how the
	/// nodes created for delegation are connected.
	/// <p>Set this member as true, if all delegation nodes
	/// should be activated directly. The delegation returns, if at least one of the users forwards
	/// her/his node.
	/// </p>
	/// <p>
	/// Set this member as false, if the delegation nodes should be lined up one after another.
	/// The delegation returns, if all users have forwarded their nodes.
	/// </p>
	/// Ignored, if {@link #delegateToUserIds} is null or empty.
	/// </remarks>
	protected: bool delegateParallel;
	/// <summary>
	/// Name of the new node
	/// </summary>
	protected: ::std::wstring delegateNodeName;
	/// <summary>
	/// Description of the new node
	/// </summary>
	protected: ::std::wstring delegateNodeComment;
	/// <summary>
	/// Name of the back node.
	/// </summary>
	protected: ::std::wstring backNodeName;
	/// <summary>
	/// Description of the back node.
	/// </summary>
	protected: ::std::wstring backNodeComment;
	/// <summary>
	/// Horizontal distance between the active node and the delegation node.
	/// </summary>
	/// <remarks>
	/// Recommended value is 240.
	/// </remarks>
	protected: int32_t delegateNodeMoveX;
	/// <summary>
	/// Vertical distance between the active node and the delegation node.
	/// </summary>
	/// <remarks>
	/// Recommended value is 0.
	/// </remarks>
	protected: int32_t delegateNodeMoveY;
	/// <summary>
	/// Horizontal distance between the active node and the back node.
	/// </summary>
	/// <remarks>
	/// Recommended value is 0.
	/// </remarks>
	protected: int32_t backNodeMoveX;
	/// <summary>
	/// Vertical distance between the active node and the back node.
	/// </summary>
	/// <remarks>
	/// Recommended value is 80.
	/// </remarks>
	protected: int32_t backNodeMoveY;
	/// <summary>
	/// This selector defines which members of the node specified by nodeId are copied
	/// to the delegated node.
	/// </summary>
	/// <remarks>
	/// If this value is null, all node members are copied except the following:
	/// WFNodeC.mbId|
	/// WFNodeC.mbDelayDate|WFNodeC.mbDelayDateIso|
	/// WFNodeC.mbEnterDate|WFNodeC.mbEnterDateIso|
	/// WFNodeC.mbExitDate|WFNodeC.mbExitDateIso|
	/// WFNodeC.mbInUseDate|WFNodeC.mbInUseDateIso|
	/// WFNodeC.mbUserDelayDate|WFNodeC.mbUserDelayDateIso|
	/// WFNodeC.mbIsNext
	/// overwrite the members copied due copyMembersToDelegateNodeZ.
	/// The member WFNode.formSpec is always copied from the current node and need not to be included in copyMembersToDelegateNodeZ.
	/// </remarks>
	protected: PWFNodeZ copyMembersToDelegateNodeZ;
	/// <summary>
	/// This selector defines which members of the current node are copied
	/// to the node that leads back to the current user.
	/// </summary>
	/// <remarks>
	/// If this value is null, the following members are copied by default:
	/// <code>WFNodeC.mbFlags|WFNodeC.mbMoveCyclePosX|WFNodeC.mbObjKeyNames|WFNodeC.mbScriptNames|WFNodeC.mbTag|WFNodeC.mbTimeLimit|WFNodeC.mbTimeLimitEscalations</code>.
	/// The members given or evaluated by backNodeName, backNodeComment, backNodeMoveX and backNodeMoveY overwrite the members copied due copyMembersToBackNodeZ.
	/// The following members are always copied from the current node:
	/// WFNode.userId, WFNode.userName, WFNode.designDepartment, WFNode.department2, WFNode.formSpec and need not to be included in copyMembersToBackNodeZ.
	/// </remarks>
	protected: PWFNodeZ copyMembersToBackNodeZ;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: WFDelegateNodeInfo();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: WFDelegateNodeInfo(const ::std::wstring& flowId, int32_t nodeId, const ::std::wstring& delegateToUserId, const byps::PVectorString& delegateToUserIds, bool delegateParallel, const ::std::wstring& delegateNodeName, const ::std::wstring& delegateNodeComment, const ::std::wstring& backNodeName, const ::std::wstring& backNodeComment, int32_t delegateNodeMoveX, int32_t delegateNodeMoveY, int32_t backNodeMoveX, int32_t backNodeMoveY, const PWFNodeZ& copyMembersToDelegateNodeZ, const PWFNodeZ& copyMembersToBackNodeZ);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: ::std::wstring getFlowId() { return flowId; }
	public: void setFlowId(::std::wstring v);
	public: int32_t getNodeId() { return nodeId; }
	public: void setNodeId(int32_t v);
	public: ::std::wstring getDelegateToUserId() { return delegateToUserId; }
	public: void setDelegateToUserId(::std::wstring v);
	public: byps::PVectorString getDelegateToUserIds() { return delegateToUserIds; }
	public: void setDelegateToUserIds(byps::PVectorString v);
	public: bool getDelegateParallel() { return delegateParallel; }
	public: void setDelegateParallel(bool v);
	public: ::std::wstring getDelegateNodeName() { return delegateNodeName; }
	public: void setDelegateNodeName(::std::wstring v);
	public: ::std::wstring getDelegateNodeComment() { return delegateNodeComment; }
	public: void setDelegateNodeComment(::std::wstring v);
	public: ::std::wstring getBackNodeName() { return backNodeName; }
	public: void setBackNodeName(::std::wstring v);
	public: ::std::wstring getBackNodeComment() { return backNodeComment; }
	public: void setBackNodeComment(::std::wstring v);
	public: int32_t getDelegateNodeMoveX() { return delegateNodeMoveX; }
	public: void setDelegateNodeMoveX(int32_t v);
	public: int32_t getDelegateNodeMoveY() { return delegateNodeMoveY; }
	public: void setDelegateNodeMoveY(int32_t v);
	public: int32_t getBackNodeMoveX() { return backNodeMoveX; }
	public: void setBackNodeMoveX(int32_t v);
	public: int32_t getBackNodeMoveY() { return backNodeMoveY; }
	public: void setBackNodeMoveY(int32_t v);
	public: PWFNodeZ getCopyMembersToDelegateNodeZ() { return copyMembersToDelegateNodeZ; }
	public: void setCopyMembersToDelegateNodeZ(PWFNodeZ v);
	public: PWFNodeZ getCopyMembersToBackNodeZ() { return copyMembersToBackNodeZ; }
	public: void setCopyMembersToBackNodeZ(PWFNodeZ v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// WFDiagram
// typeId=1663767661

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// This class represents an active or finished workflow or a workflow template
/// </summary>
class WFDiagram : public ValueClass {
	/// <summary>
	/// Access control list in the internal format.
	/// </summary>
	/// <remarks>
	/// It defines who is able to edit
	/// the workflow. This member is only valid for workflow templates.
	/// </remarks>
	protected: ::std::wstring acl;
	/// <summary>
	/// Access control list in a more convenient format than member acl.
	/// </summary>
	/// <remarks>
	/// It defines
	/// who is able to edit the workflow. This member is only valid for workflow
	/// templates.
	/// </remarks>
	protected: PArrayAclItem aclItems;
	/// <summary>
	/// Date of completion in ISO format.
	/// </summary>
	protected: ::std::wstring completionDateIso;
	/// <summary>
	/// Flag that indicates whether the workflow template is deleted.
	/// </summary>
	/// <remarks>
	/// Only valid
	/// for template workflows.
	/// </remarks>
	protected: bool deleted;
	/// <summary>
	/// Workflow ID.
	/// </summary>
	protected: int32_t id;
	/// <summary>
	/// The ID of the user who has currently locked the workflow.
	/// </summary>
	protected: int32_t lockId;
	/// <summary>
	/// The name of the user who has currently locked the workflow.
	/// </summary>
	protected: ::std::wstring lockName;
	/// <summary>
	/// Node matrix.
	/// </summary>
	protected: PWFNodeMatrix matrix;
	/// <summary>
	/// Workflow name.
	/// </summary>
	protected: ::std::wstring name;
	/// <summary>
	/// Array of nodes.
	/// </summary>
	protected: PArrayWFNode nodes;
	/// <summary>
	/// ID or GUID of the associated folder or document object. checkoutWorkFlow
	/// will always return the numeric object ID in this field. checkinWorkFlow is
	/// able to receive a GUID too.
	/// </summary>
	protected: ::std::wstring objId;
	/// <summary>
	/// Sord type of the associated folder or document.
	/// </summary>
	protected: int32_t objType;
	/// <summary>
	/// ID of the user who has started the workflow.
	/// </summary>
	protected: int32_t ownerId;
	/// <summary>
	/// Name of the user who has started the workflow.
	/// </summary>
	protected: ::std::wstring ownerName;
	/// <summary>
	/// Workflow priortiy: 0...high, 1...medium, 2...low.
	/// </summary>
	protected: int32_t prio;
	/// <summary>
	/// Date of start in ISO format.
	/// </summary>
	protected: ::std::wstring startDateIso;
	/// <summary>
	/// The workflow was started based on this workflow template.
	/// </summary>
	/// <remarks>
	/// This member is
	/// only valid for active and finished workflows.
	/// </remarks>
	protected: int32_t templateId;
	/// <summary>
	/// The workflow was started based on the workflow template with this name.
	/// </summary>
	/// <remarks>
	/// This member is only valid for active and finished workflows.
	/// </remarks>
	protected: ::std::wstring templateName;
	/// <summary>
	/// Time-limit for the entire workflow in minutes.
	/// </summary>
	protected: int32_t timeLimit;
	/// <summary>
	/// The entire workflow should be finished by this date.
	/// </summary>
	/// <remarks>
	/// Otherwise the
	/// time-limit is exceeded. This member is only valid for active and finished
	/// workflows. Read-only.
	/// </remarks>
	protected: ::std::wstring timeLimitIso;
	/// <summary>
	/// The ID of the user that should be informed,if the time-limit for the
	/// workflow is exceeded.
	/// </summary>
	/// <remarks>
	/// The IndexServer does not send any notification to the
	/// user. The client application is responsible for doing this.
	/// </remarks>
	protected: int32_t timeLimitUserId;
	/// <summary>
	/// The name of the user that should be informed, if the time-limit is
	/// exceeded.
	/// </summary>
	/// <remarks>
	/// When writing a workflow with checkinWorkFlow, this value has
	/// preceedence before timeLimitUserId. Set timeLimitUserName to an empty
	/// string, if timeLimitUserId should be used.
	/// </remarks>
	protected: ::std::wstring timeLimitUserName;
	/// <summary>
	/// Typeof template: template, active or finished.
	/// </summary>
	protected: PWFTypeZ type;
	/// <summary>
	/// True, if the workflow exceeds the time limit.
	/// </summary>
	/// <remarks>
	/// Read-only.
	/// </remarks>
	protected: bool overTimeLimit;
	/// <summary>
	/// Flags of the begin node.
	/// </summary>
	/// <remarks>
	/// This value is a combination of the node flags
	/// suitable to begin nodes, e. g. WFNodeC.FLAG_WORKINGDAYS. To ensure
	/// compatibility with older client programs, the WFNode.flags of the start
	/// node are or-ed with the WFDiagram.flags.
	/// </remarks>
	protected: int32_t flags;
	/// <summary>
	/// Access rights to the object for the current user.
	/// </summary>
	/// <remarks>
	/// A combination of LUR_*
	/// constants. Read-only.
	/// </remarks>
	protected: int32_t access;
	/// <summary>
	/// Only templates: version information.
	/// </summary>
	protected: PWFVersion version;
	/// <summary>
	/// GUID
	/// </summary>
	protected: ::std::wstring guid;
	/// <summary>
	/// TStamp
	/// </summary>
	protected: ::std::wstring tStamp;
	/// <summary>
	/// If not empty, the workflow can only be continued on this server (resp.
	/// </summary>
	/// <remarks>
	/// replication branch). The current server ID can be read by getServerInfo().
	/// This member is only valid for ACTIVE or FINISHED workflows.
	/// </remarks>
	protected: ::std::wstring processOnServerId;
	/// <summary>
	/// Additional definitions for time limits.
	/// </summary>
	protected: PArrayWFTimeLimit timeLimitEscalations;
	/// <summary>
	/// Sord name.
	/// </summary>
	/// <remarks>
	/// Readonly.
	/// </remarks>
	protected: ::std::wstring objName;
	/// <summary>
	/// Timestamp of this object's last export by the replication.
	/// </summary>
	protected: ::std::wstring TStampSync;
	/// <summary>
	/// Translation-keyword for {@link WFDiagram#name}.
	/// </summary>
	protected: ::std::wstring nameTranslationKey;
	/// <summary>
	/// Indicates whether this workflow is hidden.
	/// </summary>
	protected: bool hidden;
	/// <summary>
	/// ID of the parent workflow.
	/// </summary>
	protected: int32_t parentFlowId;
	/// <summary>
	/// The call node id of the main workflow, which call this sub workflow.
	/// </summary>
	protected: int32_t callNodeId;
	/// <summary>
	/// Sub workflows.
	/// </summary>
	protected: PMapIntegerWFDiagram subWorkflows;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: WFDiagram();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: WFDiagram(const ::std::wstring& acl, const PArrayAclItem& aclItems, const ::std::wstring& completionDateIso, bool deleted, int32_t id, int32_t lockId, const ::std::wstring& lockName, const PWFNodeMatrix& matrix, const ::std::wstring& name, const PArrayWFNode& nodes, const ::std::wstring& objId, int32_t objType, int32_t ownerId, const ::std::wstring& ownerName, int32_t prio, const ::std::wstring& startDateIso, int32_t templateId, const ::std::wstring& templateName, int32_t timeLimit, const ::std::wstring& timeLimitIso, int32_t timeLimitUserId, const ::std::wstring& timeLimitUserName, const PWFTypeZ& type, bool overTimeLimit, int32_t flags, int32_t access, const PWFVersion& version, const ::std::wstring& guid, const ::std::wstring& tStamp, const ::std::wstring& processOnServerId, const PArrayWFTimeLimit& timeLimitEscalations, const ::std::wstring& objName, const ::std::wstring& TStampSync, const ::std::wstring& nameTranslationKey, bool hidden, int32_t parentFlowId, int32_t callNodeId, const PMapIntegerWFDiagram& subWorkflows);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: ::std::wstring getAcl() { return acl; }
	public: void setAcl(::std::wstring v);
	public: PArrayAclItem getAclItems() { return aclItems; }
	public: void setAclItems(PArrayAclItem v);
	public: ::std::wstring getCompletionDateIso() { return completionDateIso; }
	public: void setCompletionDateIso(::std::wstring v);
	public: bool getDeleted() { return deleted; }
	public: void setDeleted(bool v);
	public: int32_t getId() { return id; }
	public: void setId(int32_t v);
	public: int32_t getLockId() { return lockId; }
	public: void setLockId(int32_t v);
	public: ::std::wstring getLockName() { return lockName; }
	public: void setLockName(::std::wstring v);
	public: PWFNodeMatrix getMatrix() { return matrix; }
	public: void setMatrix(PWFNodeMatrix v);
	public: ::std::wstring getName() { return name; }
	public: void setName(::std::wstring v);
	public: PArrayWFNode getNodes() { return nodes; }
	public: void setNodes(PArrayWFNode v);
	public: ::std::wstring getObjId() { return objId; }
	public: void setObjId(::std::wstring v);
	public: int32_t getObjType() { return objType; }
	public: void setObjType(int32_t v);
	public: int32_t getOwnerId() { return ownerId; }
	public: void setOwnerId(int32_t v);
	public: ::std::wstring getOwnerName() { return ownerName; }
	public: void setOwnerName(::std::wstring v);
	public: int32_t getPrio() { return prio; }
	public: void setPrio(int32_t v);
	public: ::std::wstring getStartDateIso() { return startDateIso; }
	public: void setStartDateIso(::std::wstring v);
	public: int32_t getTemplateId() { return templateId; }
	public: void setTemplateId(int32_t v);
	public: ::std::wstring getTemplateName() { return templateName; }
	public: void setTemplateName(::std::wstring v);
	public: int32_t getTimeLimit() { return timeLimit; }
	public: void setTimeLimit(int32_t v);
	public: ::std::wstring getTimeLimitIso() { return timeLimitIso; }
	public: void setTimeLimitIso(::std::wstring v);
	public: int32_t getTimeLimitUserId() { return timeLimitUserId; }
	public: void setTimeLimitUserId(int32_t v);
	public: ::std::wstring getTimeLimitUserName() { return timeLimitUserName; }
	public: void setTimeLimitUserName(::std::wstring v);
	public: PWFTypeZ getType() { return type; }
	public: void setType(PWFTypeZ v);
	public: bool getOverTimeLimit() { return overTimeLimit; }
	public: void setOverTimeLimit(bool v);
	public: int32_t getFlags() { return flags; }
	public: void setFlags(int32_t v);
	public: int32_t getAccess() { return access; }
	public: void setAccess(int32_t v);
	public: PWFVersion getVersion() { return version; }
	public: void setVersion(PWFVersion v);
	public: ::std::wstring getGuid() { return guid; }
	public: void setGuid(::std::wstring v);
	public: ::std::wstring getTStamp() { return tStamp; }
	public: void setTStamp(::std::wstring v);
	public: ::std::wstring getProcessOnServerId() { return processOnServerId; }
	public: void setProcessOnServerId(::std::wstring v);
	public: PArrayWFTimeLimit getTimeLimitEscalations() { return timeLimitEscalations; }
	public: void setTimeLimitEscalations(PArrayWFTimeLimit v);
	public: ::std::wstring getObjName() { return objName; }
	public: void setObjName(::std::wstring v);
	public: ::std::wstring getTStampSync() { return TStampSync; }
	public: void setTStampSync(::std::wstring v);
	public: ::std::wstring getNameTranslationKey() { return nameTranslationKey; }
	public: void setNameTranslationKey(::std::wstring v);
	public: bool getHidden() { return hidden; }
	public: void setHidden(bool v);
	public: int32_t getParentFlowId() { return parentFlowId; }
	public: void setParentFlowId(int32_t v);
	public: int32_t getCallNodeId() { return callNodeId; }
	public: void setCallNodeId(int32_t v);
	public: PMapIntegerWFDiagram getSubWorkflows() { return subWorkflows; }
	public: void setSubWorkflows(PMapIntegerWFDiagram v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// WFDiagramC
// typeId=1231341428

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// <p>Constants for workflows.
/// </summary>
/// <remarks>
/// </p>
/// </remarks>
class WFDiagramC : public BSerializable {
	/// <summary>
	/// Maximum number of subnodes.
	/// </summary>
	public: const static int32_t MAX_SUBNODES = 20;
	/// <summary>
	/// ID
	/// </summary>
	public: const static int64_t mbId = 1LL;
	/// <summary>
	/// Name
	/// </summary>
	public: const static int64_t mbName = 2LL;
	/// <summary>
	/// Maximum length of workflow name.
	/// </summary>
	protected: int32_t lnName;
	/// <summary>
	/// Object ID
	/// </summary>
	public: const static int64_t mbObjId = 4LL;
	/// <summary>
	/// Object type.
	/// </summary>
	public: const static int64_t mbObjType = 8LL;
	/// <summary>
	/// Completed at this date.
	/// </summary>
	public: const static int64_t mbCompletionDate = 16LL;
	/// <summary>
	/// Nodes.
	/// </summary>
	public: const static int64_t mbNodes = 32LL;
	/// <summary>
	/// Node matrix.
	/// </summary>
	public: const static int64_t mbMatrix = 64LL;
	/// <summary>
	/// Member bit: Alert user.
	/// </summary>
	public: const static int64_t mbTimeLimitUserId = 128LL;
	/// <summary>
	/// Member bit: Time-limit.
	/// </summary>
	public: const static int64_t mbTimeLimit = 256LL;
	/// <summary>
	/// Member bit: StartDate.
	/// </summary>
	public: const static int64_t mbStartDate = 512LL;
	/// <summary>
	/// Member bit: acl and aclItems.
	/// </summary>
	public: const static int64_t mbAcl = 1024LL;
	/// <summary>
	/// Member bit: ownerId and ownerName
	/// </summary>
	public: const static int64_t mbOwnerId = 2048LL;
	/// <summary>
	/// Member bit: lockId and lockName
	/// </summary>
	public: const static int64_t mbLockId = 4096LL;
	/// <summary>
	/// Member bit: prio
	/// </summary>
	public: const static int64_t mbPrio = 8192LL;
	/// <summary>
	/// Member bit: deleted
	/// </summary>
	public: const static int64_t mbDeleted = 16384LL;
	/// <summary>
	/// Member bit: templateId
	/// </summary>
	public: const static int64_t mbTemplateId = 32768LL;
	/// <summary>
	/// Member bit: flags
	/// </summary>
	public: const static int64_t mbFlags = 65536LL;
	/// <summary>
	/// Member bit: access
	/// </summary>
	public: const static int64_t mbAccess = 131072LL;
	/// <summary>
	/// Member bit: access
	/// </summary>
	public: const static int64_t mbVersion = 262144LL;
	/// <summary>
	/// Member bit: Guid
	/// </summary>
	public: const static int64_t mbGuid = 524288LL;
	/// <summary>
	/// Maximum length of workflow GUID.
	/// </summary>
	protected: int32_t lnGuid;
	/// <summary>
	/// Member bit: TStamp
	/// </summary>
	public: const static int64_t mbTStamp = 1048576LL;
	/// <summary>
	/// Maximum length of workflow TStamp.
	/// </summary>
	protected: int32_t lnTStamp;
	/// <summary>
	/// Member bit: processOnServerId
	/// </summary>
	public: const static int64_t mbProcessOnServerId = 2097152LL;
	/// <summary>
	/// Maximum length of processOnServerId.
	/// </summary>
	protected: int32_t lnProcessOnServerId;
	/// <summary>
	/// Member bit: timeLimitEscalation
	/// </summary>
	public: const static int64_t mbTimeLimitEscalations = 4194304LL;
	/// <summary>
	/// Member bit: objName
	/// </summary>
	public: const static int64_t mbObjName = 8388608LL;
	/// <summary>
	/// Nodes required for worfklow overview in ELO Java Client.
	/// </summary>
	/// <remarks>
	/// Includes begin node, active nodes, exceeded nodes.
	/// </remarks>
	public: const static int64_t mbNodesOverview = 16777216LL;
	/// <summary>
	/// Member bit: TStampSync
	/// </summary>
	public: const static int64_t mbTStampSync = 33554432LL;
	/// <summary>
	/// Maximum length of the name's translation key.
	/// </summary>
	protected: int32_t lnNameTranslationKey;
	/// <summary>
	/// Member bit: nameTranslationKey
	/// </summary>
	public: const static int64_t mbNameTranslationKey = 33554432LL;
	/// <summary>
	/// Member bit: {@link WFDiagram#subWorkflows}.
	/// </summary>
	public: const static int64_t mbSubWorkflows = 67108864LL;
	/// <summary>
	/// Member bit: {@link WFDiagram#callNodeId}.
	/// </summary>
	public: const static int64_t mbCallNodeId = 134217728LL;
	/// <summary>
	/// Prefix of all scripts selectable as finish scripts for adhoc workflows
	/// </summary>
	public: const static ::std::wstring ADHOC_WF_FINISH_SCRIPT_PREFIX;
	/// <summary>
	/// All elements.
	/// </summary>
	public: const static int64_t mbAllMembers = 268435455LL;
	public: const static int64_t mbLeanMembers = 268435359LL;
	public: const static PWFDiagramZ mbLean;
	public: const static PWFDiagramZ mbAll;
	public: const static PWFDiagramZ mbOnlyLock;
	public: const static int64_t mbAclItems = 1024LL;
	public: const static int64_t mbCompletionDateIso = 16LL;
	public: const static int64_t mbOwnerName = 2048LL;
	public: const static int64_t mbStartDateIso = 512LL;
	public: const static int64_t mbTemplateName = 32768LL;
	public: const static int64_t mbTimeLimitIso = 256LL;
	public: const static int64_t mbTimeLimitUserName = 128LL;
	public: const static int64_t mbType = 1LL;
	/// <summary>
	/// Compare this value to WFDiagram.templateId to check whether the workflow
	/// was started as an adhoc workflow.
	/// </summary>
	/// <remarks>
	/// This member is for convenience. You can
	/// also check the flag FLAG_ROOT_ADHOC of the root node.
	/// </remarks>
	public: const static int32_t TEMPLATE_ID_ADHOC = -2;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: WFDiagramC();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: WFDiagramC(int32_t MAX_SUBNODES, int64_t mbId, int64_t mbName, int32_t lnName, int64_t mbObjId, int64_t mbObjType, int64_t mbCompletionDate, int64_t mbNodes, int64_t mbMatrix, int64_t mbTimeLimitUserId, int64_t mbTimeLimit, int64_t mbStartDate, int64_t mbAcl, int64_t mbOwnerId, int64_t mbLockId, int64_t mbPrio, int64_t mbDeleted, int64_t mbTemplateId, int64_t mbFlags, int64_t mbAccess, int64_t mbVersion, int64_t mbGuid, int32_t lnGuid, int64_t mbTStamp, int32_t lnTStamp, int64_t mbProcessOnServerId, int32_t lnProcessOnServerId, int64_t mbTimeLimitEscalations, int64_t mbObjName, int64_t mbNodesOverview, int64_t mbTStampSync, int32_t lnNameTranslationKey, int64_t mbNameTranslationKey, int64_t mbSubWorkflows, int64_t mbCallNodeId, const ::std::wstring& ADHOC_WF_FINISH_SCRIPT_PREFIX, int64_t mbAllMembers, int64_t mbLeanMembers, const PWFDiagramZ& mbLean, const PWFDiagramZ& mbAll, const PWFDiagramZ& mbOnlyLock, int64_t mbAclItems, int64_t mbCompletionDateIso, int64_t mbOwnerName, int64_t mbStartDateIso, int64_t mbTemplateName, int64_t mbTimeLimitIso, int64_t mbTimeLimitUserName, int64_t mbType, int32_t TEMPLATE_ID_ADHOC);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getLnName() { return lnName; }
	public: void setLnName(int32_t v);
	public: int32_t getLnGuid() { return lnGuid; }
	public: void setLnGuid(int32_t v);
	public: int32_t getLnTStamp() { return lnTStamp; }
	public: void setLnTStamp(int32_t v);
	public: int32_t getLnProcessOnServerId() { return lnProcessOnServerId; }
	public: void setLnProcessOnServerId(int32_t v);
	public: int32_t getLnNameTranslationKey() { return lnNameTranslationKey; }
	public: void setLnNameTranslationKey(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// WFDiagramZ
// typeId=1717407429

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// This class encapsulates the constants of the WFDiagramC class.
/// </summary>
/// <remarks>
/// <p>Copyright: Copyright (c) 2004</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </remarks>
class WFDiagramZ : public ValueClass {
	/// <summary>
	/// Bitset field for constants from the WFDiagramC class.
	/// </summary>
	protected: int64_t bset;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: WFDiagramZ();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: WFDiagramZ(int64_t bset);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int64_t getBset() { return bset; }
	public: void setBset(int64_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// WFEditNode
// typeId=1822579866

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Data required for processing a workflow person node.
/// </summary>
class WFEditNode : public ValueClass {
	/// <summary>
	/// Workflow identifier
	/// </summary>
	protected: int32_t flowId;
	/// <summary>
	/// The node to be processed
	/// </summary>
	protected: PWFNode node;
	/// <summary>
	/// Node identifier
	/// </summary>
	protected: int32_t nodeId;
	/// <summary>
	/// Choice of following nodes.
	/// </summary>
	/// <remarks>
	/// Array of ELOWorkFlowNode objects.
	/// </remarks>
	protected: PArrayWFNode succNodes;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: WFEditNode();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: WFEditNode(int32_t flowId, const PWFNode& node, int32_t nodeId, const PArrayWFNode& succNodes);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getFlowId() { return flowId; }
	public: void setFlowId(int32_t v);
	public: PWFNode getNode() { return node; }
	public: void setNode(PWFNode v);
	public: int32_t getNodeId() { return nodeId; }
	public: void setNodeId(int32_t v);
	public: PArrayWFNode getSuccNodes() { return succNodes; }
	public: void setSuccNodes(PArrayWFNode v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// WFNode
// typeId=2015686193

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// <p>Objects of this class represent a workflow node.
/// </summary>
/// <remarks>
/// </p>
/// 
/// <p>Copyright: Copyright (c) 2004</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </remarks>
class WFNode : public ValueClass {
	/// <summary>
	/// Can this node be activated?
	/// </summary>
	/// <remarks>
	/// A script can set this value to prevent the activation of the node.
	/// This member is valid for all node types.
	/// </remarks>
	protected: bool allowActivate;
	/// <summary>
	/// Comment text for the node.
	/// </summary>
	/// <remarks>
	/// This member is valid for all node types.
	/// </remarks>
	protected: ::std::wstring comment;
	/// <summary>
	/// An active person node (Activate is set) might be displayed to the user
	/// delayed by this number of days.
	/// </summary>
	/// <remarks>
	/// Only valid for person nodes.
	/// </remarks>
	protected: int32_t delayDays;
	/// <summary>
	/// A group ID to constrain access to the node.
	/// </summary>
	/// <remarks>
	/// Only members of this group
	/// are allowed to see and process the node.
	/// Only valid for person nodes.
	/// </remarks>
	protected: int32_t department2;
	/// <summary>
	/// A group ID or user ID that was originally assigned in the designer.
	/// </summary>
	/// <remarks>
	/// Only valid for person nodes.
	/// </remarks>
	protected: int32_t designDepartment;
	/// <summary>
	/// The node was activated on this date.
	/// </summary>
	/// <remarks>
	/// This member is valid for all node types.
	/// </remarks>
	protected: ::std::wstring enterDateIso;
	/// <summary>
	/// The node was exited/completed on this date.
	/// </summary>
	/// <remarks>
	/// This member is valid for all node types.
	/// </remarks>
	protected: ::std::wstring exitDateIso;
	/// <summary>
	/// Control flags for the node, a combination of WFNodeC.FLAG_* constants.
	/// </summary>
	/// <remarks>
	/// For start nodes (TYPE_BEGINNODE), the flags should be specified in
	/// WFDiagram.flags. To ensure compatibility with older client programs,
	/// the WFNode.flags of the start node are or-ed with the WFDiagram.flags.
	/// This member is valid for all node types.
	/// </remarks>
	protected: int32_t flags;
	/// <summary>
	/// Node ID.
	/// </summary>
	/// <remarks>
	/// This member is valid for all node types.
	/// </remarks>
	protected: int32_t id;
	/// <summary>
	/// The date when the node was last used(activated or completed).
	/// </summary>
	/// <remarks>
	/// This member is valid for all node types.
	/// </remarks>
	protected: ::std::wstring inUseDateIso;
	/// <summary>
	/// The activation state of the node.
	/// </summary>
	/// <remarks>
	/// This member is valid for all node types.
	/// </remarks>
	protected: int32_t isNext;
	/// <summary>
	/// If a cycle is re-entered, the nodes in the cycle are duplicated.
	/// </summary>
	/// <remarks>
	/// The copied
	/// nodes will be placed in the designer moved by this value to the right. If
	/// this value is 0, the nodes are moved 60 points right and 20 points up.
	/// This member is valid for all node types.
	/// </remarks>
	protected: int32_t moveCyclePosX;
	/// <summary>
	/// The node description (work instruction).
	/// </summary>
	/// <remarks>
	/// This member is valid for all node types.
	/// </remarks>
	protected: ::std::wstring name;
	/// <summary>
	/// The number of predecessor nodes that must be processed to forward this
	/// collector node.
	/// </summary>
	/// <remarks>
	/// A value of -1 means that all predecessor nodes must be processed. If set to
	/// 0, the collect node switches when it is activated regardless of the state of
	/// the predecessor nodes.
	/// This member is only valid for collect nodes.
	/// </remarks>
	protected: int32_t nbOfDonesToExit;
	/// <summary>
	/// The script name that is executed when the node is activated.
	/// </summary>
	/// <remarks>
	/// This member is valid for all node types.
	/// </remarks>
	protected: ::std::wstring onEnter;
	/// <summary>
	/// The script name that is executed when the node is exited/completed.
	/// </summary>
	/// <remarks>
	/// This member is valid for all node types.
	/// </remarks>
	protected: ::std::wstring onExit;
	/// <summary>
	/// The X position in the designer view.
	/// </summary>
	/// <remarks>
	/// This member is valid for all node types.
	/// </remarks>
	protected: int32_t posX;
	/// <summary>
	/// The Y position in the designer view.
	/// </summary>
	/// <remarks>
	/// This member is valid for all node types.
	/// </remarks>
	protected: int32_t posY;
	/// <summary>
	/// reserved.
	/// </summary>
	/// <remarks>
	/// DB column: wf_tag
	/// </remarks>
	protected: int32_t tag;
	/// <summary>
	/// The time-limit to process the node.
	/// </summary>
	/// <remarks>
	/// Measured in minutes.
	/// This member is only valid for person nodes.
	/// </remarks>
	protected: int32_t timeLimit;
	/// <summary>
	/// After this date the node exceeds the time-limit for processing.
	/// </summary>
	/// <remarks>
	/// This member is only valid for person nodes.
	/// Read-only.
	/// </remarks>
	protected: ::std::wstring timeLimitIso;
	/// <summary>
	/// The node type.
	/// </summary>
	/// <remarks>
	/// This member is set to one of the TYPE_* constants in WFNodeC.
	/// </remarks>
	protected: int32_t type;
	/// <summary>
	/// This user has to edit the node.
	/// </summary>
	/// <remarks>
	/// This member is only valid for person nodes.
	/// </remarks>
	protected: int32_t userId;
	/// <summary>
	/// The name of the user that has the ID <code>userId</code>
	/// This member is only valid for person nodes.
	/// </summary>
	protected: ::std::wstring userName;
	/// <summary>
	/// The ID of the user who has forwarded the node.
	/// </summary>
	/// <remarks>
	/// Not valid for template workflows.
	/// This member is only valid for person nodes.
	/// </remarks>
	protected: ::std::wstring userTerminate;
	/// <summary>
	/// IF node: test condition, numeric values must be formatted according to the servers locale.
	/// </summary>
	/// <remarks>
	/// split node: sets the workflow status to this value,
	/// begin node: contains workflow status
	/// cycle node: condition that evaluates true to leave the cycle
	/// </remarks>
	protected: ::std::wstring yesNoCondition;
	/// <summary>
	/// The node is displayed to the user at this date.
	/// </summary>
	/// <remarks>
	/// This date is computed by
	/// enterDateIso + delayDays.
	/// This member is only valid for person nodes.
	/// Read-only.
	/// </remarks>
	protected: ::std::wstring delayDateIso;
	/// <summary>
	/// True, if the node exceeds the time limit.
	/// </summary>
	/// <remarks>
	/// This member is only valid for person nodes in active or finished workflows.
	/// Read-only.
	/// </remarks>
	protected: bool overTimeLimit;
	/// <summary>
	/// The workflow node is deferred until this date.
	/// </summary>
	/// <remarks>
	/// This member is only valid for person nodes in active or finished workflows.
	/// ISO date format.
	/// </remarks>
	protected: ::std::wstring userDelayDateIso;
	/// <summary>
	/// Server ID (resp. replication branch).
	/// </summary>
	/// <remarks>
	/// If the node is activated, the server ID is set to this value.
	/// This member is only valid for nodes of type WFNodeC.TYPE_SET_SERVER_ID.
	/// </remarks>
	protected: ::std::wstring processOnServerId;
	/// <summary>
	/// Additional definitions for time limits.
	/// </summary>
	/// <remarks>
	/// This member is only valid for person nodes.
	/// </remarks>
	protected: PArrayWFTimeLimit timeLimitEscalations;
	/// <summary>
	/// Group names of index values (DocMaskLine.key resp.
	/// </summary>
	/// <remarks>
	/// ObjKey.name)
	/// for which an edit box is to be displayed when forwarding a person node.
	/// This member is only valid for person nodes.
	/// </remarks>
	protected: PArrayString objKeyNames;
	/// <summary>
	/// Script names used as action scripts in buttons
	/// when forwarding a person node.
	/// </summary>
	/// <remarks>
	/// Script files for the Windows CLIENT have to be named
	/// as ELOWF_ + scriptNames[.].
	/// This member is only valid for person nodes.
	/// </remarks>
	protected: PArrayString scriptNames;
	/// <summary>
	/// Object-GUID of an icon file that is displayed in the designer.
	/// </summary>
	protected: ::std::wstring iconId;
	/// <summary>
	/// Multipurpose field.
	/// </summary>
	/// <remarks>
	/// <p>
	/// If the node is a collect node (type={@link WFNodeC#TYPE_COLLECTNODE}),
	/// formSpec contains a comma separated list of node IDs. This nodes are
	/// deactivated when the collect node forwards the workflow. In addition to
	/// a list of IDs, the value of {@link WFNodeC#DEACTIVATE_ALL_PREDS} causes
	/// to deactivate all predecessor nodes.
	/// </p>
	/// <p>
	/// In case of a person node ({@link WFNodeC#TYPE_PERSONNODE}),
	/// formSpec can contain proprietary encoded information about a workflow form.
	/// </p>
	/// </remarks>
	protected: ::std::wstring formSpec;
	/// <summary>
	/// Translation-keyword for {@link WFNode#name}.
	/// </summary>
	protected: ::std::wstring nameTranslationKey;
	/// <summary>
	/// Translation-keyword for {@link WFNode#comment}.
	/// </summary>
	protected: ::std::wstring commentTranslationKey;
	/// <summary>
	/// Display name by forwarding.
	/// </summary>
	protected: ::std::wstring label;
	/// <summary>
	/// Node properties.
	/// </summary>
	/// <remarks>
	/// Maximum byte size of this string in UTF-8 encoding is constrained to {@link FileDataC#MAX_BLOB_LENGTH}.
	/// </remarks>
	protected: ::std::wstring properties;
	/// <summary>
	/// Grouping of nodes for function takeWorkFlowNode.
	/// </summary>
	/// <remarks>
	/// A non-zero value binds nodes with the same value to a group of nodes that is evaluated in {@link IXServicePortIF#takeWorkFlowNode(ClientInfo, int, int, String, int, LockZ)}.
	/// The function takeWorkFlowNodes takes - in addition to the given node - all nodes with the same group assignment specified by this member.
	/// This member is only used as a marker and is not interpreted as a group or user ID.
	/// </remarks>
	protected: int32_t departmentGroup;
	/// <summary>
	/// Id of the active sub-workflow.
	/// </summary>
	/// <remarks>
	/// Only valid for TYPE_CALL_SUB_WORKFLOW.
	/// </remarks>
	protected: int32_t subFlowId;
	/// <summary>
	/// Return value of an end node.
	/// </summary>
	/// <remarks>
	/// Only valid for TYPE_END.
	/// </remarks>
	protected: int32_t retVal;
	/// <summary>
	/// Return value of a sub-workflow.
	/// </summary>
	/// <remarks>
	/// The value defines the name of the successor node of the call-node {@link WFNodeC#TYPE_CALL_SUB_WORKFLOW}
	/// that will be activated when the sub-workflow returns.
	/// If the sub-workflow returns a node name that does not exist in the main workflow, a new person node is inserted
	/// between the call-node and its successors. This new node is named as the return value and is assigned to
	/// the workflow owner.
	/// </remarks>
	protected: ::std::wstring returnValue;
	/// <summary>
	/// Translation-keyword for {@link WFNode#label}.
	/// </summary>
	protected: ::std::wstring labelTranslationKey;
	/// <summary>
	/// ID, GUID or name of the sub-workflow template.
	/// </summary>
	protected: int32_t subTemplateId;
	/// <summary>
	/// Node priortiy: 0...high, 1...medium, 2...low.
	/// </summary>
	/// <remarks>
	/// Only valid for person nodes, type=={@link WFNodeC#TYPE_PERSONNODE}.
	/// The user assigned to the person node can change this value by conn.ix().forwardWorkflowNode():
	/// <pre>
	/// <code>
	/// WFEditNode editNode = conn.ix().beginForwardWorkflowNode(flowId, nodeId, null, LockC.NO);
	/// WFNode activeNode = editNode.getNode();
	/// activeNode.setPrio(activeNode.getPrio()-1); // One level higher.
	/// ForwardWorkflowNodeInfo fwdInfo = new ForwardWorkflowNodeInfo();
	/// fwdInfo.setNode(activeNode);
	/// conn.ix().forwardWorkflowNode(wfActive.getId(), activeNode.getId(), fwdInfo, LockC.NO);
	/// 
	/// </code>
	/// </pre>
	/// </remarks>
	protected: int32_t prio;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: WFNode();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: WFNode(bool allowActivate, const ::std::wstring& comment, int32_t delayDays, int32_t department2, int32_t designDepartment, const ::std::wstring& enterDateIso, const ::std::wstring& exitDateIso, int32_t flags, int32_t id, const ::std::wstring& inUseDateIso, int32_t isNext, int32_t moveCyclePosX, const ::std::wstring& name, int32_t nbOfDonesToExit, const ::std::wstring& onEnter, const ::std::wstring& onExit, int32_t posX, int32_t posY, int32_t tag, int32_t timeLimit, const ::std::wstring& timeLimitIso, int32_t type, int32_t userId, const ::std::wstring& userName, const ::std::wstring& userTerminate, const ::std::wstring& yesNoCondition, const ::std::wstring& delayDateIso, bool overTimeLimit, const ::std::wstring& userDelayDateIso, const ::std::wstring& processOnServerId, const PArrayWFTimeLimit& timeLimitEscalations, const PArrayString& objKeyNames, const PArrayString& scriptNames, const ::std::wstring& iconId, const ::std::wstring& formSpec, const ::std::wstring& nameTranslationKey, const ::std::wstring& commentTranslationKey, const ::std::wstring& label, const ::std::wstring& properties, int32_t departmentGroup, int32_t subFlowId, int32_t retVal, const ::std::wstring& returnValue, const ::std::wstring& labelTranslationKey, int32_t subTemplateId, int32_t prio);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: bool getAllowActivate() { return allowActivate; }
	public: void setAllowActivate(bool v);
	public: ::std::wstring getComment() { return comment; }
	public: void setComment(::std::wstring v);
	public: int32_t getDelayDays() { return delayDays; }
	public: void setDelayDays(int32_t v);
	public: int32_t getDepartment2() { return department2; }
	public: void setDepartment2(int32_t v);
	public: int32_t getDesignDepartment() { return designDepartment; }
	public: void setDesignDepartment(int32_t v);
	public: ::std::wstring getEnterDateIso() { return enterDateIso; }
	public: void setEnterDateIso(::std::wstring v);
	public: ::std::wstring getExitDateIso() { return exitDateIso; }
	public: void setExitDateIso(::std::wstring v);
	public: int32_t getFlags() { return flags; }
	public: void setFlags(int32_t v);
	public: int32_t getId() { return id; }
	public: void setId(int32_t v);
	public: ::std::wstring getInUseDateIso() { return inUseDateIso; }
	public: void setInUseDateIso(::std::wstring v);
	public: int32_t getIsNext() { return isNext; }
	public: void setIsNext(int32_t v);
	public: int32_t getMoveCyclePosX() { return moveCyclePosX; }
	public: void setMoveCyclePosX(int32_t v);
	public: ::std::wstring getName() { return name; }
	public: void setName(::std::wstring v);
	public: int32_t getNbOfDonesToExit() { return nbOfDonesToExit; }
	public: void setNbOfDonesToExit(int32_t v);
	public: ::std::wstring getOnEnter() { return onEnter; }
	public: void setOnEnter(::std::wstring v);
	public: ::std::wstring getOnExit() { return onExit; }
	public: void setOnExit(::std::wstring v);
	public: int32_t getPosX() { return posX; }
	public: void setPosX(int32_t v);
	public: int32_t getPosY() { return posY; }
	public: void setPosY(int32_t v);
	public: int32_t getTag() { return tag; }
	public: void setTag(int32_t v);
	public: int32_t getTimeLimit() { return timeLimit; }
	public: void setTimeLimit(int32_t v);
	public: ::std::wstring getTimeLimitIso() { return timeLimitIso; }
	public: void setTimeLimitIso(::std::wstring v);
	public: int32_t getType() { return type; }
	public: void setType(int32_t v);
	public: int32_t getUserId() { return userId; }
	public: void setUserId(int32_t v);
	public: ::std::wstring getUserName() { return userName; }
	public: void setUserName(::std::wstring v);
	public: ::std::wstring getUserTerminate() { return userTerminate; }
	public: void setUserTerminate(::std::wstring v);
	public: ::std::wstring getYesNoCondition() { return yesNoCondition; }
	public: void setYesNoCondition(::std::wstring v);
	public: ::std::wstring getDelayDateIso() { return delayDateIso; }
	public: void setDelayDateIso(::std::wstring v);
	public: bool getOverTimeLimit() { return overTimeLimit; }
	public: void setOverTimeLimit(bool v);
	public: ::std::wstring getUserDelayDateIso() { return userDelayDateIso; }
	public: void setUserDelayDateIso(::std::wstring v);
	public: ::std::wstring getProcessOnServerId() { return processOnServerId; }
	public: void setProcessOnServerId(::std::wstring v);
	public: PArrayWFTimeLimit getTimeLimitEscalations() { return timeLimitEscalations; }
	public: void setTimeLimitEscalations(PArrayWFTimeLimit v);
	public: PArrayString getObjKeyNames() { return objKeyNames; }
	public: void setObjKeyNames(PArrayString v);
	public: PArrayString getScriptNames() { return scriptNames; }
	public: void setScriptNames(PArrayString v);
	public: ::std::wstring getIconId() { return iconId; }
	public: void setIconId(::std::wstring v);
	public: ::std::wstring getFormSpec() { return formSpec; }
	public: void setFormSpec(::std::wstring v);
	public: ::std::wstring getNameTranslationKey() { return nameTranslationKey; }
	public: void setNameTranslationKey(::std::wstring v);
	public: ::std::wstring getCommentTranslationKey() { return commentTranslationKey; }
	public: void setCommentTranslationKey(::std::wstring v);
	public: ::std::wstring getLabel() { return label; }
	public: void setLabel(::std::wstring v);
	public: ::std::wstring getProperties() { return properties; }
	public: void setProperties(::std::wstring v);
	public: int32_t getDepartmentGroup() { return departmentGroup; }
	public: void setDepartmentGroup(int32_t v);
	public: int32_t getSubFlowId() { return subFlowId; }
	public: void setSubFlowId(int32_t v);
	public: int32_t getRetVal() { return retVal; }
	public: void setRetVal(int32_t v);
	public: ::std::wstring getReturnValue() { return returnValue; }
	public: void setReturnValue(::std::wstring v);
	public: ::std::wstring getLabelTranslationKey() { return labelTranslationKey; }
	public: void setLabelTranslationKey(::std::wstring v);
	public: int32_t getSubTemplateId() { return subTemplateId; }
	public: void setSubTemplateId(int32_t v);
	public: int32_t getPrio() { return prio; }
	public: void setPrio(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// WFNodeAssoc
// typeId=1042649178

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// <p>Represents a bridge (connection) in a workflow diagram</p>
/// <p>Copyright: Copyright (c) 2004</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </summary>
class WFNodeAssoc : public ValueClass {
	/// <summary>
	/// Indicates whether the bridge has been passed through/over (used).
	/// </summary>
	/// <remarks>
	/// For a condition node, this member is true for both paths (TRUE and FALSE) if either has been passed.
	/// Thus it cannot be used in a client application to find out, which path the workflow has taken.
	/// </remarks>
	protected: bool done;
	/// <summary>
	/// Start node (starting location)
	/// </summary>
	protected: int32_t nodeFrom;
	/// <summary>
	/// Destination (end) node
	/// </summary>
	protected: int32_t nodeTo;
	/// <summary>
	/// Type of bridge (connection).
	/// </summary>
	/// <remarks>
	/// {@link WFNodeMatrixC#ALWAYS}, {@link WFNodeMatrixC#IF_TRUE}, {@link WFNodeMatrixC#IF_FALSE}.
	/// </remarks>
	protected: int32_t type;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: WFNodeAssoc();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: WFNodeAssoc(bool done, int32_t nodeFrom, int32_t nodeTo, int32_t type);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: bool getDone() { return done; }
	public: void setDone(bool v);
	public: int32_t getNodeFrom() { return nodeFrom; }
	public: void setNodeFrom(int32_t v);
	public: int32_t getNodeTo() { return nodeTo; }
	public: void setNodeTo(int32_t v);
	public: int32_t getType() { return type; }
	public: void setType(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// WFNodeC
// typeId=1514069164

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// <p>Constants for <code>WorkFlowNode</code>.
/// </summary>
/// <remarks>
/// </p>
/// </remarks>
class WFNodeC : public BSerializable {
	/// <summary>
	/// Member bit: Node ID
	/// </summary>
	public: const static int64_t mbId = 1LL;
	/// <summary>
	/// Member bit: Type
	/// </summary>
	public: const static int64_t mbType = 2LL;
	/// <summary>
	/// Member bit: Activated at this date.
	/// </summary>
	public: const static int64_t mbEnterDate = 4LL;
	/// <summary>
	/// Member bit: Leaved at this date.
	/// </summary>
	public: const static int64_t mbExitDate = 8LL;
	/// <summary>
	/// Member bit: In use at this date.
	/// </summary>
	public: const static int64_t mbInUseDate = 16LL;
	/// <summary>
	/// Member bit: Name
	/// </summary>
	public: const static int64_t mbName = 32LL;
	/// <summary>
	/// Maximum length of node name.
	/// </summary>
	protected: int32_t lnName;
	/// <summary>
	/// Member bit: User ID
	/// </summary>
	public: const static int64_t mbUserId = 64LL;
	/// <summary>
	/// Member bit: number of predecessor nodes that must be processed to forward this node.
	/// </summary>
	public: const static int64_t mbNbOfDonesToExit = 128LL;
	/// <summary>
	/// Member bit: (to be defined)
	/// </summary>
	public: const static int64_t mbTimeLimit = 512LL;
	/// <summary>
	/// Member bit: Node comment.
	/// </summary>
	public: const static int64_t mbComment = 1024LL;
	/// <summary>
	/// Maximum length of comment.
	/// </summary>
	protected: int32_t lnComment;
	/// <summary>
	/// Member bit: x position in designer view.
	/// </summary>
	public: const static int64_t mbPosX = 4096LL;
	/// <summary>
	/// Member bit: y position in designer view.
	/// </summary>
	public: const static int64_t mbPosY = 8192LL;
	/// <summary>
	/// Member bit: locked from user.
	/// </summary>
	public: const static int64_t mbLockId = 16384LL;
	/// <summary>
	/// Member bit: script to execute when node is activated.
	/// </summary>
	public: const static int64_t mbOnEnter = 32768LL;
	protected: int32_t lnOnEnter;
	/// <summary>
	/// Member bit: script to execute when node is leaved.
	/// </summary>
	public: const static int64_t mbOnExit = 65536LL;
	protected: int32_t lnOnExit;
	/// <summary>
	/// Member bit: control flags.
	/// </summary>
	public: const static int64_t mbFlags = 131072LL;
	/// <summary>
	/// Member bit: (to be defined)
	/// </summary>
	public: const static int64_t mbIsNext = 262144LL;
	/// <summary>
	/// Member bit: yes/no condition
	/// </summary>
	public: const static int64_t mbYesNoCondition = 524288LL;
	protected: int32_t lnYesNoCondition;
	/// <summary>
	/// Member bit: condition, is only internally used
	/// </summary>
	public: const static int64_t mbCondition = 1048576LL;
	protected: int32_t lnCondition;
	/// <summary>
	/// Member bit: Condition result.
	/// </summary>
	public: const static int64_t mbResult = 2097152LL;
	/// <summary>
	/// Member bit: The ID of the user who has forwarded the node.
	/// </summary>
	/// <remarks>
	/// Not valid for template workflows.
	/// Only valid for person nodes.
	/// DB column: wf_userterminate
	/// </remarks>
	public: const static int64_t mbUserTerminate = 4194304LL;
	/// <summary>
	/// Member bit: reserved.
	/// </summary>
	/// <remarks>
	/// DB column: wf_tag
	/// </remarks>
	public: const static int64_t mbTag = 8388608LL;
	/// <summary>
	/// Member bit: A group ID or user ID that was originally assigned in the designer.
	/// </summary>
	/// <remarks>
	/// DB column: wf_designdepartment
	/// </remarks>
	public: const static int64_t mbDesignDepartment = 16777216LL;
	/// <summary>
	/// Member bit: If a cycle is re-entered, the nodes in the cycle are duplicated.
	/// </summary>
	/// <remarks>
	/// The copied
	/// nodes will be placed in the designer moved by this value to the right. If
	/// this value is 0, the nodes are moved 60 points right and 20 points up.
	/// DB column: wf_dx
	/// </remarks>
	public: const static int64_t mbMoveCyclePosX = 33554432LL;
	/// <summary>
	/// Member bit: A group ID to constrain access to the node.
	/// </summary>
	/// <remarks>
	/// Only members of this group
	/// are allowed to see and process the node.
	/// Only valid for person nodes.
	/// DB column: wf_department2
	/// </remarks>
	public: const static int64_t mbDepartment2 = 67108864LL;
	/// <summary>
	/// Member bit: An active person node (Activate is set) might be displayed to the user
	/// delayed by this number of days.
	/// </summary>
	/// <remarks>
	/// Only valid for person nodes.
	/// DB column: wf_deldays
	/// </remarks>
	public: const static int64_t mbDelayDays = 134217728LL;
	/// <summary>
	/// Member bit: DelayDaye.
	/// </summary>
	/// <remarks>
	/// Not valid for template workflows.
	/// Only valid for person nodes.
	/// DB column: wf_duedate
	/// </remarks>
	public: const static int64_t mbDelayDate = 268435456LL;
	/// <summary>
	/// Member bit: UserDelayDate.
	/// </summary>
	/// <remarks>
	/// Not valid for template workflows.
	/// Only valid for person nodes.
	/// DB column: wf_duedate
	/// </remarks>
	public: const static int64_t mbUserDelayDate = 536870912LL;
	/// <summary>
	/// Member bit: processOnServerId;
	/// </summary>
	public: const static int64_t mbProcessOnServerId = 1073741824LL;
	/// <summary>
	/// Maximum length of processOnServerId.
	/// </summary>
	protected: int32_t lnProcessOnServerId;
	/// <summary>
	/// Member bit: timeLimitEscalation
	/// </summary>
	public: const static int64_t mbTimeLimitEscalations = 2147483648LL;
	/// <summary>
	/// Member bit: objKeyNames
	/// </summary>
	public: const static int64_t mbObjKeyNames = 4294967296LL;
	/// <summary>
	/// Member bit: scriptNames
	/// </summary>
	public: const static int64_t mbScriptNames = 8589934592LL;
	/// <summary>
	/// Member bit: Icon GUID.
	/// </summary>
	public: const static int64_t mbIconId = 17179869184LL;
	/// <summary>
	/// Member bit: FormSpec.
	/// </summary>
	public: const static int64_t mbFormSpec = 34359738368LL;
	/// <summary>
	/// Maximum length of form spec.
	/// </summary>
	protected: int32_t lnFormSpec;
	/// <summary>
	/// Member bit: NameTranslationKey
	/// </summary>
	public: const static int64_t mbNameTranslationKey = 68719476736LL;
	/// <summary>
	/// Maximum length of the name's translation key.
	/// </summary>
	protected: int32_t lnNameTranslationKey;
	/// <summary>
	/// Member bit: CommentTranslationKey
	/// </summary>
	public: const static int64_t mbCommentTranslationKey = 137438953472LL;
	/// <summary>
	/// Maximum length of the comment's translation key.
	/// </summary>
	protected: int32_t lnCommentTranslationKey;
	/// <summary>
	/// Member bit: label
	/// </summary>
	public: const static int64_t mbLabel = 274877906944LL;
	/// <summary>
	/// Maximum length of the label.
	/// </summary>
	protected: int32_t lnLabel;
	/// <summary>
	/// Maximum length of the labelTranslationKey.
	/// </summary>
	protected: int32_t lnLabelTranslationKey;
	/// <summary>
	/// Member bit: properties
	/// </summary>
	public: const static int64_t mbProperties = 549755813888LL;
	/// <summary>
	/// Maximum length of the properties.
	/// </summary>
	protected: int32_t lnProperties;
	/// <summary>
	/// Member bit: departmentGroup
	/// </summary>
	public: const static int64_t mbDepartmentGroup = 1099511627776LL;
	/// <summary>
	/// Member bit: subFlowId
	/// </summary>
	public: const static int64_t mbSubFlowId = 2199023255552LL;
	/// <summary>
	/// Member bit: retVal
	/// </summary>
	public: const static int64_t mbRetVal = 4398046511104LL;
	/// <summary>
	/// reserved.
	/// </summary>
	public: const static int64_t mbSubTemplateName = 8796093022208LL;
	/// <summary>
	/// Member bit: subTemplateId
	/// </summary>
	public: const static int64_t mbSubTemplateId = 8796093022208LL;
	/// <summary>
	/// Member bit: labelTranslationKey
	/// </summary>
	public: const static int64_t mbLabelTranslationKey = 17592186044416LL;
	/// <summary>
	/// Member bit: returnValue
	/// </summary>
	public: const static int64_t mbReturnValue = 35184372088832LL;
	/// <summary>
	/// Member bit: returnValue
	/// </summary>
	public: const static int64_t mbPrio = 70368744177664LL;
	public: const static int64_t mbEnterDateIso = 4LL;
	public: const static int64_t mbExitDateIso = 8LL;
	public: const static int64_t mbInUseDateIso = 16LL;
	public: const static int64_t mbTimeLimitIso = 512LL;
	public: const static int64_t mbUserName = 64LL;
	public: const static int64_t mbDelayDateIso = 268435456LL;
	public: const static int64_t mbUserDelayDateIso = 536870912LL;
	/// <summary>
	/// All members.
	/// </summary>
	public: const static int64_t mbAllMembers = 140737488355327LL;
	/// <summary>
	/// All members.
	/// </summary>
	public: const static PWFNodeZ mbAll;
	/// <summary>
	/// Node flag: Only one user can receive this node.
	/// </summary>
	public: const static int32_t FLAG_ONE_SUCCESSOR = 1;
	/// <summary>
	/// Node flag: The start node of an Adhoc workflow has this flag.
	/// </summary>
	public: const static int32_t FLAG_ROOT_ADHOC = 1;
	/// <summary>
	/// Node flag: Not released.
	/// </summary>
	/// <remarks>
	/// A personal node of an Adhoc workflow has this flag
	/// set, if the user has not released the node.
	/// The IndexServer does not use this flag anywhere.
	/// </remarks>
	public: const static int32_t FLAG_NOT_VALID = 2;
	/// <summary>
	/// Node flag: End of workflow.
	/// </summary>
	/// <remarks>
	/// This flag is set to the end node of an Adhoc workflow.
	/// The IndexServer does not need this flag but maybe the ELO Windows Client.
	/// </remarks>
	public: const static int32_t FLAG_TERMINATE_USER = 4;
	/// <summary>
	/// Node flag: Reset the ExitDate of the following nodes, if this node is activated.
	/// </summary>
	public: const static int32_t FLAG_RESET_CHILDREN = 8;
	/// <summary>
	/// Node flag: This flag denotes, whether a cycle node (TYPE_CYCLE) is the
	/// end of a cycle.
	/// </summary>
	public: const static int32_t FLAG_CYCLE_END = 16;
	/// <summary>
	/// Node flag: This is a copied start node of a cylce.
	/// </summary>
	/// <remarks>
	/// Do not use this flag in
	/// workflow templates. The workflow engine will mark copied cycle.
	/// nodes with this flag.
	/// </remarks>
	public: const static int32_t FLAG_CYCLE_X = 32;
	/// <summary>
	/// Node flag: This flag indicates that all nodes in the cycle should be copied
	/// when entering the begin cycle node.
	/// </summary>
	/// <remarks>
	/// This flag is only used for the begin
	/// cycle node.
	/// </remarks>
	public: const static int32_t FLAG_COPY_CHILDREN = 5;
	/// <summary>
	/// Node flag: This flag indicates that weekend days should be skipped when
	/// evaluating time limits.
	/// </summary>
	public: const static int32_t FLAG_WORKINGDAYS = 128;
	/// <summary>
	/// Node flag: Reset all person nodes.
	/// </summary>
	/// <remarks>
	/// This flag is only used for parallel for
	/// validation workflow.
	/// </remarks>
	public: const static int32_t FLAG_RESETADHOCNODE = 512;
	/// <summary>
	/// Node flag: Hide this workflow from default searches and listings.
	/// </summary>
	public: const static int32_t FLAG_HIDDEN = 1024;
	/// <summary>
	/// Node flag: This flag indicates whether the sub workflow can be started manually.
	/// </summary>
	/// <remarks>
	/// The sub workflow of. This flag is used for sub workflows.
	/// </remarks>
	public: const static int32_t FLAG_DO_NOT_START_MANUALLY = 2048;
	/// <summary>
	/// Node flag: This flag indicates whether the person node was delegated.
	/// </summary>
	/// <remarks>
	/// This flag
	/// is only used for the person node.
	/// </remarks>
	public: const static int32_t FLAG_DELEGATED = 4096;
	/// <summary>
	/// Node type: undefined or deleted
	/// </summary>
	public: const static int32_t TYPE_NOTHING = 0;
	/// <summary>
	/// Node type: Start of workflow.
	/// </summary>
	public: const static int32_t TYPE_BEGINNODE = 1;
	/// <summary>
	/// Node type: Personal node.
	/// </summary>
	/// <remarks>
	/// A user must edit the node to continue the workflow.
	/// </remarks>
	public: const static int32_t TYPE_PERSONNODE = 2;
	/// <summary>
	/// Node type: Distribute to many following nodes.
	/// </summary>
	public: const static int32_t TYPE_SPLITNODE = 3;
	/// <summary>
	/// Node type: Decision node.
	/// </summary>
	public: const static int32_t TYPE_IFNODE = 4;
	/// <summary>
	/// Node type: Collects many workflow paths.
	/// </summary>
	public: const static int32_t TYPE_COLLECTNODE = 5;
	/// <summary>
	/// Node type: End of workflow.
	/// </summary>
	public: const static int32_t TYPE_ENDNODE = 6;
	/// <summary>
	/// Node type: Cycle
	/// Cycle nodes are contained in pairs in a workflow.
	/// </summary>
	/// <remarks>
	/// One cycle node denotes the
	/// beginning of a cycle and an associated cycle node marks the end. Both cycle
	/// nodes must have the same name (WFNode.name). The begin node must be flagged
	/// with FLAG_CYCLE_END.
	/// </remarks>
	public: const static int32_t TYPE_CYCLE = 7;
	/// <summary>
	/// Note type: Set the server ID where the WF can be continued.
	/// </summary>
	/// <remarks>
	/// This node is used in replicated workflows.
	/// </remarks>
	public: const static int32_t TYPE_SET_SERVER_ID = 8;
	/// <summary>
	/// Note type: Call sub workflow.
	/// </summary>
	public: const static int32_t TYPE_CALL_SUB_WORKFLOW = 9;
	/// <summary>
	/// Set WFNode.userId to this value, if a workflow node should belong to the
	/// owner of the associated Sord object.
	/// </summary>
	public: const static int32_t USERID_OWNER = -2;
	/// <summary>
	/// This value can be used in Node.department2 to make clear,
	/// that Node.department2 has to be ignored.
	/// </summary>
	public: const static int32_t USERID_IGNORE = -3;
	/// <summary>
	/// This ID is a placeholder for the superior of the
	/// workflow owner.
	/// </summary>
	public: const static int32_t USERID_SUPERIOR = -4;
	/// <summary>
	/// Indicates that all predecessor of the collect node should be terminated.
	/// </summary>
	public: const static ::std::wstring DEACTIVATE_ALL_PREDS;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: WFNodeC();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: WFNodeC(int64_t mbId, int64_t mbType, int64_t mbEnterDate, int64_t mbExitDate, int64_t mbInUseDate, int64_t mbName, int32_t lnName, int64_t mbUserId, int64_t mbNbOfDonesToExit, int64_t mbTimeLimit, int64_t mbComment, int32_t lnComment, int64_t mbPosX, int64_t mbPosY, int64_t mbLockId, int64_t mbOnEnter, int32_t lnOnEnter, int64_t mbOnExit, int32_t lnOnExit, int64_t mbFlags, int64_t mbIsNext, int64_t mbYesNoCondition, int32_t lnYesNoCondition, int64_t mbCondition, int32_t lnCondition, int64_t mbResult, int64_t mbUserTerminate, int64_t mbTag, int64_t mbDesignDepartment, int64_t mbMoveCyclePosX, int64_t mbDepartment2, int64_t mbDelayDays, int64_t mbDelayDate, int64_t mbUserDelayDate, int64_t mbProcessOnServerId, int32_t lnProcessOnServerId, int64_t mbTimeLimitEscalations, int64_t mbObjKeyNames, int64_t mbScriptNames, int64_t mbIconId, int64_t mbFormSpec, int32_t lnFormSpec, int64_t mbNameTranslationKey, int32_t lnNameTranslationKey, int64_t mbCommentTranslationKey, int32_t lnCommentTranslationKey, int64_t mbLabel, int32_t lnLabel, int32_t lnLabelTranslationKey, int64_t mbProperties, int32_t lnProperties, int64_t mbDepartmentGroup, int64_t mbSubFlowId, int64_t mbRetVal, int64_t mbSubTemplateName, int64_t mbSubTemplateId, int64_t mbLabelTranslationKey, int64_t mbReturnValue, int64_t mbPrio, int64_t mbEnterDateIso, int64_t mbExitDateIso, int64_t mbInUseDateIso, int64_t mbTimeLimitIso, int64_t mbUserName, int64_t mbDelayDateIso, int64_t mbUserDelayDateIso, int64_t mbAllMembers, const PWFNodeZ& mbAll, int32_t FLAG_ONE_SUCCESSOR, int32_t FLAG_ROOT_ADHOC, int32_t FLAG_NOT_VALID, int32_t FLAG_TERMINATE_USER, int32_t FLAG_RESET_CHILDREN, int32_t FLAG_CYCLE_END, int32_t FLAG_CYCLE_X, int32_t FLAG_COPY_CHILDREN, int32_t FLAG_WORKINGDAYS, int32_t FLAG_RESETADHOCNODE, int32_t FLAG_HIDDEN, int32_t FLAG_DO_NOT_START_MANUALLY, int32_t FLAG_DELEGATED, int32_t TYPE_NOTHING, int32_t TYPE_BEGINNODE, int32_t TYPE_PERSONNODE, int32_t TYPE_SPLITNODE, int32_t TYPE_IFNODE, int32_t TYPE_COLLECTNODE, int32_t TYPE_ENDNODE, int32_t TYPE_CYCLE, int32_t TYPE_SET_SERVER_ID, int32_t TYPE_CALL_SUB_WORKFLOW, int32_t USERID_OWNER, int32_t USERID_IGNORE, int32_t USERID_SUPERIOR, const ::std::wstring& DEACTIVATE_ALL_PREDS);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getLnName() { return lnName; }
	public: void setLnName(int32_t v);
	public: int32_t getLnComment() { return lnComment; }
	public: void setLnComment(int32_t v);
	public: int32_t getLnOnEnter() { return lnOnEnter; }
	public: void setLnOnEnter(int32_t v);
	public: int32_t getLnOnExit() { return lnOnExit; }
	public: void setLnOnExit(int32_t v);
	public: int32_t getLnYesNoCondition() { return lnYesNoCondition; }
	public: void setLnYesNoCondition(int32_t v);
	public: int32_t getLnCondition() { return lnCondition; }
	public: void setLnCondition(int32_t v);
	public: int32_t getLnProcessOnServerId() { return lnProcessOnServerId; }
	public: void setLnProcessOnServerId(int32_t v);
	public: int32_t getLnFormSpec() { return lnFormSpec; }
	public: void setLnFormSpec(int32_t v);
	public: int32_t getLnNameTranslationKey() { return lnNameTranslationKey; }
	public: void setLnNameTranslationKey(int32_t v);
	public: int32_t getLnCommentTranslationKey() { return lnCommentTranslationKey; }
	public: void setLnCommentTranslationKey(int32_t v);
	public: int32_t getLnLabel() { return lnLabel; }
	public: void setLnLabel(int32_t v);
	public: int32_t getLnLabelTranslationKey() { return lnLabelTranslationKey; }
	public: void setLnLabelTranslationKey(int32_t v);
	public: int32_t getLnProperties() { return lnProperties; }
	public: void setLnProperties(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// WFNodeHistory
// typeId=784568809

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Version history for a workflow node.
/// </summary>
/// <remarks>
/// A version history is created while
/// leaving a workflow node.
/// 
/// <p>
/// Copyright: Copyright (c) 2015
/// </p>
/// <p>
/// Organisation: ELO Digital Office GmbH
/// </p>
/// </remarks>
class WFNodeHistory : public ValueClass {
	/// <summary>
	/// GUID of the WorkflowHist object.
	/// </summary>
	/// <remarks>
	/// DB column: wfhistguid
	/// </remarks>
	protected: ::std::wstring histGuid;
	/// <summary>
	/// GUID of the workflow.
	/// </summary>
	/// <remarks>
	/// DB column: wfguid
	/// </remarks>
	protected: ::std::wstring flowGuid;
	/// <summary>
	/// Node ID.
	/// </summary>
	/// <remarks>
	/// DB column: wf_nodeid
	/// </remarks>
	protected: int32_t nodeId;
	/// <summary>
	/// ID of user who has to process the node.
	/// </summary>
	/// <remarks>
	/// Might be a group ID too. Only valid
	/// for person nodes. DB column: wf_userid
	/// </remarks>
	protected: int32_t userId;
	/// <summary>
	/// Name of user who has to process the node.
	/// </summary>
	/// <remarks>
	/// Might be a group name too. Only valid
	/// for person nodes. DB column: wf_username
	/// </remarks>
	protected: ::std::wstring userName;
	/// <summary>
	/// The node was activated on this date.
	/// </summary>
	/// <remarks>
	/// This member is valid for all node types.
	/// </remarks>
	protected: ::std::wstring enterDateIso;
	/// <summary>
	/// The node was exited/completed on this date.
	/// </summary>
	/// <remarks>
	/// This member is valid for all node types.
	/// </remarks>
	protected: ::std::wstring exitDateIso;
	/// <summary>
	/// Successor node(s) succ_0 ...
	/// </summary>
	/// <remarks>
	/// Succ 19 DB column: wf_succ_0
	/// </remarks>
	protected: int32_t succ_0;
	/// <summary>
	/// DB column: wf_succ_1
	/// </summary>
	protected: int32_t succ_1;
	/// <summary>
	/// DB column: wf_succ_2
	/// </summary>
	protected: int32_t succ_2;
	/// <summary>
	/// DB column: wf_succ_3
	/// </summary>
	protected: int32_t succ_3;
	/// <summary>
	/// DB column: wf_succ_4
	/// </summary>
	protected: int32_t succ_4;
	/// <summary>
	/// DB column: wf_succ_5
	/// </summary>
	protected: int32_t succ_5;
	/// <summary>
	/// DB column: wf_succ_6
	/// </summary>
	protected: int32_t succ_6;
	/// <summary>
	/// DB column: wf_succ_7
	/// </summary>
	protected: int32_t succ_7;
	/// <summary>
	/// DB column: wf_succ_8
	/// </summary>
	protected: int32_t succ_8;
	/// <summary>
	/// DB column: wf_succ_9
	/// </summary>
	protected: int32_t succ_9;
	/// <summary>
	/// DB column: wf_succ_10
	/// </summary>
	protected: int32_t succ_10;
	/// <summary>
	/// DB column: wf_succ_11
	/// </summary>
	protected: int32_t succ_11;
	/// <summary>
	/// DB column: wf_succ_12
	/// </summary>
	protected: int32_t succ_12;
	/// <summary>
	/// DB column: wf_succ_13
	/// </summary>
	protected: int32_t succ_13;
	/// <summary>
	/// DB column: wf_succ_14
	/// </summary>
	protected: int32_t succ_14;
	/// <summary>
	/// DB column: wf_succ_15
	/// </summary>
	protected: int32_t succ_15;
	/// <summary>
	/// DB column: wf_succ_16
	/// </summary>
	protected: int32_t succ_16;
	/// <summary>
	/// DB column: wf_succ_17
	/// </summary>
	protected: int32_t succ_17;
	/// <summary>
	/// DB column: wf_succ_18
	/// </summary>
	protected: int32_t succ_18;
	/// <summary>
	/// DB column: wf_succ_19
	/// </summary>
	protected: int32_t succ_19;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: WFNodeHistory();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: WFNodeHistory(const ::std::wstring& histGuid, const ::std::wstring& flowGuid, int32_t nodeId, int32_t userId, const ::std::wstring& userName, const ::std::wstring& enterDateIso, const ::std::wstring& exitDateIso, int32_t succ_0, int32_t succ_1, int32_t succ_2, int32_t succ_3, int32_t succ_4, int32_t succ_5, int32_t succ_6, int32_t succ_7, int32_t succ_8, int32_t succ_9, int32_t succ_10, int32_t succ_11, int32_t succ_12, int32_t succ_13, int32_t succ_14, int32_t succ_15, int32_t succ_16, int32_t succ_17, int32_t succ_18, int32_t succ_19);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: ::std::wstring getHistGuid() { return histGuid; }
	public: void setHistGuid(::std::wstring v);
	public: ::std::wstring getFlowGuid() { return flowGuid; }
	public: void setFlowGuid(::std::wstring v);
	public: int32_t getNodeId() { return nodeId; }
	public: void setNodeId(int32_t v);
	public: int32_t getUserId() { return userId; }
	public: void setUserId(int32_t v);
	public: ::std::wstring getUserName() { return userName; }
	public: void setUserName(::std::wstring v);
	public: ::std::wstring getEnterDateIso() { return enterDateIso; }
	public: void setEnterDateIso(::std::wstring v);
	public: ::std::wstring getExitDateIso() { return exitDateIso; }
	public: void setExitDateIso(::std::wstring v);
	public: int32_t getSucc_0() { return succ_0; }
	public: void setSucc_0(int32_t v);
	public: int32_t getSucc_1() { return succ_1; }
	public: void setSucc_1(int32_t v);
	public: int32_t getSucc_2() { return succ_2; }
	public: void setSucc_2(int32_t v);
	public: int32_t getSucc_3() { return succ_3; }
	public: void setSucc_3(int32_t v);
	public: int32_t getSucc_4() { return succ_4; }
	public: void setSucc_4(int32_t v);
	public: int32_t getSucc_5() { return succ_5; }
	public: void setSucc_5(int32_t v);
	public: int32_t getSucc_6() { return succ_6; }
	public: void setSucc_6(int32_t v);
	public: int32_t getSucc_7() { return succ_7; }
	public: void setSucc_7(int32_t v);
	public: int32_t getSucc_8() { return succ_8; }
	public: void setSucc_8(int32_t v);
	public: int32_t getSucc_9() { return succ_9; }
	public: void setSucc_9(int32_t v);
	public: int32_t getSucc_10() { return succ_10; }
	public: void setSucc_10(int32_t v);
	public: int32_t getSucc_11() { return succ_11; }
	public: void setSucc_11(int32_t v);
	public: int32_t getSucc_12() { return succ_12; }
	public: void setSucc_12(int32_t v);
	public: int32_t getSucc_13() { return succ_13; }
	public: void setSucc_13(int32_t v);
	public: int32_t getSucc_14() { return succ_14; }
	public: void setSucc_14(int32_t v);
	public: int32_t getSucc_15() { return succ_15; }
	public: void setSucc_15(int32_t v);
	public: int32_t getSucc_16() { return succ_16; }
	public: void setSucc_16(int32_t v);
	public: int32_t getSucc_17() { return succ_17; }
	public: void setSucc_17(int32_t v);
	public: int32_t getSucc_18() { return succ_18; }
	public: void setSucc_18(int32_t v);
	public: int32_t getSucc_19() { return succ_19; }
	public: void setSucc_19(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// WFNodeHistoryC
// typeId=1457412372

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// <p>Bit constants for members of WFNodeHistory</p>
/// <p>Copyright: Copyright (c) 2003</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </summary>
class WFNodeHistoryC : public BSerializable {
	/// <summary>
	/// DB column: wfhistguid
	/// </summary>
	public: const static int64_t mbHistGuid = 1LL;
	/// <summary>
	/// DB column: wfhistguid
	/// </summary>
	protected: int32_t lnHistGuid;
	/// <summary>
	/// DB column: wfguid
	/// </summary>
	public: const static int64_t mbFlowGuid = 2LL;
	/// <summary>
	/// DB column: wfguid
	/// </summary>
	protected: int32_t lnFlowGuid;
	/// <summary>
	/// DB column: wf_nodeid
	/// </summary>
	public: const static int64_t mbNodeId = 4LL;
	/// <summary>
	/// DB column: wf_activate
	/// </summary>
	public: const static int64_t mbActivate = 8LL;
	/// <summary>
	/// DB column: wf_terminate
	/// </summary>
	public: const static int64_t mbTerminate = 16LL;
	/// <summary>
	/// DB column: wf_user
	/// </summary>
	public: const static int64_t mbUserId = 32LL;
	/// <summary>
	/// DB column: wf_username
	/// </summary>
	public: const static int64_t mbUserName = 64LL;
	/// <summary>
	/// DB column: wf_username
	/// </summary>
	protected: int32_t lnUserName;
	/// <summary>
	/// DB column: wf_succ_0
	/// </summary>
	public: const static int64_t mbSucc_0 = 128LL;
	/// <summary>
	/// DB column: wf_succ_1
	/// </summary>
	public: const static int64_t mbSucc_1 = 256LL;
	/// <summary>
	/// DB column: wf_succ_2
	/// </summary>
	public: const static int64_t mbSucc_2 = 512LL;
	/// <summary>
	/// DB column: wf_succ_3
	/// </summary>
	public: const static int64_t mbSucc_3 = 1024LL;
	/// <summary>
	/// DB column: wf_succ_4
	/// </summary>
	public: const static int64_t mbSucc_4 = 2048LL;
	/// <summary>
	/// DB column: wf_succ_5
	/// </summary>
	public: const static int64_t mbSucc_5 = 4096LL;
	/// <summary>
	/// DB column: wf_succ_6
	/// </summary>
	public: const static int64_t mbSucc_6 = 8192LL;
	/// <summary>
	/// DB column: wf_succ_7
	/// </summary>
	public: const static int64_t mbSucc_7 = 16384LL;
	/// <summary>
	/// DB column: wf_succ_8
	/// </summary>
	public: const static int64_t mbSucc_8 = 32768LL;
	/// <summary>
	/// DB column: wf_succ_9
	/// </summary>
	public: const static int64_t mbSucc_9 = 65536LL;
	/// <summary>
	/// DB column: wf_succ_10
	/// </summary>
	public: const static int64_t mbSucc_10 = 131072LL;
	/// <summary>
	/// DB column: wf_succ_11
	/// </summary>
	public: const static int64_t mbSucc_11 = 262144LL;
	/// <summary>
	/// DB column: wf_succ_12
	/// </summary>
	public: const static int64_t mbSucc_12 = 524288LL;
	/// <summary>
	/// DB column: wf_succ_13
	/// </summary>
	public: const static int64_t mbSucc_13 = 1048576LL;
	/// <summary>
	/// DB column: wf_succ_14
	/// </summary>
	public: const static int64_t mbSucc_14 = 2097152LL;
	/// <summary>
	/// DB column: wf_succ_15
	/// </summary>
	public: const static int64_t mbSucc_15 = 4194304LL;
	/// <summary>
	/// DB column: wf_succ_16
	/// </summary>
	public: const static int64_t mbSucc_16 = 8388608LL;
	/// <summary>
	/// DB column: wf_succ_17
	/// </summary>
	public: const static int64_t mbSucc_17 = 16777216LL;
	/// <summary>
	/// DB column: wf_succ_18
	/// </summary>
	public: const static int64_t mbSucc_18 = 33554432LL;
	/// <summary>
	/// DB column: wf_succ_19
	/// </summary>
	public: const static int64_t mbSucc_19 = 67108864LL;
	/// <summary>
	/// All valid member bits.
	/// </summary>
	public: const static int64_t mbAllMembers = 134217727LL;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: WFNodeHistoryC();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: WFNodeHistoryC(int64_t mbHistGuid, int32_t lnHistGuid, int64_t mbFlowGuid, int32_t lnFlowGuid, int64_t mbNodeId, int64_t mbActivate, int64_t mbTerminate, int64_t mbUserId, int64_t mbUserName, int32_t lnUserName, int64_t mbSucc_0, int64_t mbSucc_1, int64_t mbSucc_2, int64_t mbSucc_3, int64_t mbSucc_4, int64_t mbSucc_5, int64_t mbSucc_6, int64_t mbSucc_7, int64_t mbSucc_8, int64_t mbSucc_9, int64_t mbSucc_10, int64_t mbSucc_11, int64_t mbSucc_12, int64_t mbSucc_13, int64_t mbSucc_14, int64_t mbSucc_15, int64_t mbSucc_16, int64_t mbSucc_17, int64_t mbSucc_18, int64_t mbSucc_19, int64_t mbAllMembers);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getLnHistGuid() { return lnHistGuid; }
	public: void setLnHistGuid(int32_t v);
	public: int32_t getLnFlowGuid() { return lnFlowGuid; }
	public: void setLnFlowGuid(int32_t v);
	public: int32_t getLnUserName() { return lnUserName; }
	public: void setLnUserName(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// WFNodeMatrix
// typeId=425879495

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// <p>Stores the relationship between workflow nodes </p>
/// <p>Administers the bridges(connections) in a workflow diagram.
/// </summary>
/// <remarks>
/// These are
/// objects of type WorkFlowNodeAssoc.</p>
/// <p>Copyright: Copyright (c) 2004</p>
/// <p>Organisation: ELO Digital Office </p>
/// </remarks>
class WFNodeMatrix : public ValueClass {
	/// <summary>
	/// Array of the edges.
	/// </summary>
	/// <remarks>
	/// Since 9.00.030, IX stores the order of the items in the database. When reading a workflow, the saved element order is restored.
	/// </remarks>
	protected: PArrayWFNodeAssoc assocs;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: WFNodeMatrix();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: WFNodeMatrix(const PArrayWFNodeAssoc& assocs);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: PArrayWFNodeAssoc getAssocs() { return assocs; }
	public: void setAssocs(PArrayWFNodeAssoc v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// WFNodeMatrixC
// typeId=171864975

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// These constants describe the type of connection between two nodes.
/// </summary>
/// <remarks>
/// <p>Copyright: Copyright (c) 2004</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </remarks>
class WFNodeMatrixC : public BSerializable {
	/// <summary>
	/// Connection type for non-decision nodes.
	/// </summary>
	/// <remarks>
	/// The connection will always be
	/// utilised to reach the next node. No conditions have to be fulfilled.
	/// </remarks>
	public: const static int32_t ALWAYS = -3;
	/// <summary>
	/// This connection is the FALSE connection following a decision node.
	/// </summary>
	/// <remarks>
	/// This
	/// connection will be utilised when the IF requirement is not fulfilled.
	/// </remarks>
	public: const static int32_t IF_FALSE = -2;
	/// <summary>
	/// This connection is the TRUE connection following a decision node.
	/// </summary>
	/// <remarks>
	/// This
	/// connection will be utilised when the IF requirement is fulfilled.
	/// </remarks>
	public: const static int32_t IF_TRUE = -1;
	/// <summary>
	/// This connection is only for the case of overtime.
	/// </summary>
	public: const static int32_t IF_OVERTIME = 1;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: WFNodeMatrixC();
	
	public: virtual BTYPEID BSerializable_getTypeId();
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// WFNodeZ
// typeId=226200225

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// This class encapsulates the constants of the WFNodeC class.
/// </summary>
/// <remarks>
/// <p>Copyright: Copyright (c) 2011</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </remarks>
class WFNodeZ : public ValueClass {
	/// <summary>
	/// Bitset field for constants from the WFNodeC class.
	/// </summary>
	protected: int64_t bset;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: WFNodeZ();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: WFNodeZ(int64_t bset);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int64_t getBset() { return bset; }
	public: void setBset(int64_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// WFTakeNodeC
// typeId=1164251184

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Constant class for controlling the taking over(passing to another user) of a workflow object.
/// </summary>
/// <remarks>
/// <p>Copyright: Copyright (c) 2004</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </remarks>
class WFTakeNodeC : public BSerializable {
	/// <summary>
	/// Standard action.
	/// </summary>
	/// <remarks>
	/// Neither WFNode.department2 nor WFNode.inUseDateIso are returned.
	/// </remarks>
	public: const static int32_t DEFAULT = 0;
	/// <summary>
	/// WFNode.department2 is set when the node is taken over by another user.
	/// </summary>
	public: const static int32_t RESET_DEPARTMENT2 = 2;
	/// <summary>
	/// WFNode.inUseDateIso is set when the node is taken over by another user.
	/// </summary>
	public: const static int32_t RESET_IN_USE_DATE = 1;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: WFTakeNodeC();
	
	public: virtual BTYPEID BSerializable_getTypeId();
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// WFTimeLimit
// typeId=633363356

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// This class describes a time limit for a workflow or for a person node of a workflow.
/// </summary>
class WFTimeLimit : public ValueClass {
	/// <summary>
	/// Time-limit in minutes.
	/// </summary>
	protected: int32_t timeLimit;
	/// <summary>
	/// The ID of the user that should be informed,
	/// if the time-limit is exceeded.
	/// </summary>
	/// <remarks>
	/// The IndexServer does not send any notification to the
	/// user. The client application is responsible for doing this.
	/// </remarks>
	protected: int32_t userId;
	/// <summary>
	/// User name for timeLimitUserId;
	/// When writing a workflow with checkinWorkFlow, this value has preceedence
	/// before timeLimitUserId.
	/// </summary>
	/// <remarks>
	/// Set timeLimitUserName to an empty string, if
	/// timeLimitUserId should be used.
	/// </remarks>
	protected: ::std::wstring userName;
	/// <summary>
	/// After this date the node exceeds the time-limit for processing.
	/// </summary>
	/// <remarks>
	/// Read-only.
	/// </remarks>
	protected: ::std::wstring timeLimitIso;
	/// <summary>
	/// True, if the workflow exceeds the time limit.
	/// </summary>
	/// <remarks>
	/// Read-only.
	/// </remarks>
	protected: bool overTimeLimit;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: WFTimeLimit();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: WFTimeLimit(int32_t timeLimit, int32_t userId, const ::std::wstring& userName, const ::std::wstring& timeLimitIso, bool overTimeLimit);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getTimeLimit() { return timeLimit; }
	public: void setTimeLimit(int32_t v);
	public: int32_t getUserId() { return userId; }
	public: void setUserId(int32_t v);
	public: ::std::wstring getUserName() { return userName; }
	public: void setUserName(::std::wstring v);
	public: ::std::wstring getTimeLimitIso() { return timeLimitIso; }
	public: void setTimeLimitIso(::std::wstring v);
	public: bool getOverTimeLimit() { return overTimeLimit; }
	public: void setOverTimeLimit(bool v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// WFTypeC
// typeId=1842783874

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Constants class for WFType.
/// </summary>
/// <remarks>
/// This class describes the workflow type/status.
/// <p>Copyright: Copyright (c) 2004</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </remarks>
class WFTypeC : public BSerializable {
	public: const static int64_t bsetACTIVE = 0LL;
	public: const static int64_t bsetFINISHED = 1LL;
	public: const static int64_t bsetTEMPLATE = 2LL;
	/// <summary>
	/// The workflow is active.
	/// </summary>
	public: const static PWFTypeZ ACTIVE;
	/// <summary>
	/// The workflow is finished (completed).
	/// </summary>
	public: const static PWFTypeZ FINISHED;
	/// <summary>
	/// The workflow is a template workflow.
	/// </summary>
	public: const static PWFTypeZ TEMPLATE;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: WFTypeC();
	
	public: virtual BTYPEID BSerializable_getTypeId();
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// WFTypeZ
// typeId=927083544

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// This class encapsulates the constants of the WFTypeC class.
/// </summary>
/// <remarks>
/// <p>Copyright: Copyright (c) 2004</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </remarks>
class WFTypeZ : public ValueClass {
	/// <summary>
	/// Bitset field for constants from the WFTypeC class.
	/// </summary>
	protected: int64_t bset;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: WFTypeZ();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: WFTypeZ(int64_t bset);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int64_t getBset() { return bset; }
	public: void setBset(int64_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// WFVersion
// typeId=914434915

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Version information for a workflow template.
/// </summary>
class WFVersion : public ValueClass {
	/// <summary>
	/// Version ID.
	/// </summary>
	/// <remarks>
	/// Set this member -1, to check in a new workflow template version.
	/// A value of 0 indicates the current working version.
	/// </remarks>
	protected: int32_t id;
	/// <summary>
	/// Version comment.
	/// </summary>
	protected: ::std::wstring comment;
	/// <summary>
	/// ID of the user who created the version.
	/// </summary>
	protected: int32_t userId;
	/// <summary>
	/// Name of the user who created the version.
	/// </summary>
	protected: ::std::wstring userName;
	/// <summary>
	/// Version number.
	/// </summary>
	protected: ::std::wstring version;
	/// <summary>
	/// Create date in ISO format.
	/// </summary>
	protected: ::std::wstring createDateIso;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: WFVersion();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: WFVersion(int32_t id, const ::std::wstring& comment, int32_t userId, const ::std::wstring& userName, const ::std::wstring& version, const ::std::wstring& createDateIso);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getId() { return id; }
	public: void setId(int32_t v);
	public: ::std::wstring getComment() { return comment; }
	public: void setComment(::std::wstring v);
	public: int32_t getUserId() { return userId; }
	public: void setUserId(int32_t v);
	public: ::std::wstring getUserName() { return userName; }
	public: void setUserName(::std::wstring v);
	public: ::std::wstring getVersion() { return version; }
	public: void setVersion(::std::wstring v);
	public: ::std::wstring getCreateDateIso() { return createDateIso; }
	public: void setCreateDateIso(::std::wstring v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// WFVersionC
// typeId=1378592156

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Constants for WFVersion
/// </summary>
class WFVersionC : public BSerializable {
	/// <summary>
	/// Length of WFVersion.comment.
	/// </summary>
	protected: int32_t lnComment;
	/// <summary>
	/// Length of WFVersion.version.
	/// </summary>
	protected: int32_t lnVersion;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: WFVersionC();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: WFVersionC(int32_t lnComment, int32_t lnVersion);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getLnComment() { return lnComment; }
	public: void setLnComment(int32_t v);
	public: int32_t getLnVersion() { return lnVersion; }
	public: void setLnVersion(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// WorkFlowActiveDoc
// typeId=1807635378

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Internal class.
/// </summary>
class WorkFlowActiveDoc : public ValueClass {
	/// <summary>
	/// Workflow ID.
	/// </summary>
	/// <remarks>
	/// DB column: wf_flowid
	/// </remarks>
	protected: int32_t flowId;
	/// <summary>
	/// Node ID.
	/// </summary>
	/// <remarks>
	/// DB column: wf_nodeid
	/// </remarks>
	protected: int32_t nodeId;
	/// <summary>
	/// Workflow name.
	/// </summary>
	/// <remarks>
	/// DB column: wf_flow_name
	/// </remarks>
	protected: ::std::wstring flowName;
	/// <summary>
	/// Node name (work instruction).
	/// </summary>
	/// <remarks>
	/// DB column: wf_name
	/// </remarks>
	protected: ::std::wstring name;
	/// <summary>
	/// Node type (begin node, split node, etc.).
	/// </summary>
	/// <remarks>
	/// DB column: wf_node_type
	/// </remarks>
	protected: int32_t nodeType;
	/// <summary>
	/// This value depends on the node type and is not processed anymore by IndexServer.
	/// </summary>
	/// <remarks>
	/// It is written for compability with workflows of older CLIENT versions.
	/// DB column: wf_succ_type
	/// </remarks>
	protected: int32_t succType;
	/// <summary>
	/// ID of user who has to process the node.
	/// </summary>
	/// <remarks>
	/// Might
	/// be a group ID too. Only valid for person nodes.
	/// DB column: wf_department
	/// </remarks>
	protected: int32_t department;
	/// <summary>
	/// ID of user who should be informed, if a time-limit exceeds.
	/// </summary>
	/// <remarks>
	/// It might be
	/// the time-limit for the entire workflow or for a signle person node.
	/// DB column: wf_alert_to
	/// </remarks>
	protected: int32_t alertTo;
	/// <summary>
	/// Time-limt for the entire workflow in minutes.
	/// </summary>
	/// <remarks>
	/// This value is only valid for
	/// the begin node.
	/// DB column: wf_alert_from_begin
	/// </remarks>
	protected: int32_t alertFromBegin;
	/// <summary>
	/// Time-limit for a single node.
	/// </summary>
	/// <remarks>
	/// This value is only valid for person nodes.
	/// DB column: wf_alert_wait
	/// </remarks>
	protected: int32_t alertWait;
	/// <summary>
	/// IF-Nodes: test condition,
	/// person nodes: index values or scripts,
	/// split nodes: workflow status.
	/// </summary>
	/// <remarks>
	/// DB column: wf_yesnocondition
	/// </remarks>
	protected: ::std::wstring yNCondition;
	/// <summary>
	/// Contains the ACL of the workflow.
	/// </summary>
	/// <remarks>
	/// Only valid for begin nodes.
	/// DB column: wf_condition
	/// </remarks>
	protected: ::std::wstring condition;
	/// <summary>
	/// Comment, only valid for person nodes.
	/// </summary>
	/// <remarks>
	/// DB column: wf_comment
	/// </remarks>
	protected: ::std::wstring comment;
	/// <summary>
	/// Successor node(s) succ_0 ...
	/// </summary>
	/// <remarks>
	/// Succ 19
	/// DB column: wf_succ_0
	/// This mebers are moved into WorkFlowNodeMatrix.
	/// They are still here due to compatibiltiy with older stream versions.
	/// </remarks>
	protected: int32_t succ_0;
	/// <summary>
	/// DB column: wf_succ_1
	/// </summary>
	protected: int32_t succ_1;
	/// <summary>
	/// DB column: wf_succ_2
	/// </summary>
	protected: int32_t succ_2;
	/// <summary>
	/// DB column: wf_succ_3
	/// </summary>
	protected: int32_t succ_3;
	/// <summary>
	/// DB column: wf_succ_4
	/// </summary>
	protected: int32_t succ_4;
	/// <summary>
	/// DB column: wf_succ_5
	/// </summary>
	protected: int32_t succ_5;
	/// <summary>
	/// DB column: wf_succ_6
	/// </summary>
	protected: int32_t succ_6;
	/// <summary>
	/// DB column: wf_succ_7
	/// </summary>
	protected: int32_t succ_7;
	/// <summary>
	/// DB column: wf_succ_8
	/// </summary>
	protected: int32_t succ_8;
	/// <summary>
	/// DB column: wf_succ_9
	/// </summary>
	protected: int32_t succ_9;
	/// <summary>
	/// DB column: wf_succ_10
	/// </summary>
	protected: int32_t succ_10;
	/// <summary>
	/// DB column: wf_succ_11
	/// </summary>
	protected: int32_t succ_11;
	/// <summary>
	/// DB column: wf_succ_12
	/// </summary>
	protected: int32_t succ_12;
	/// <summary>
	/// DB column: wf_succ_13
	/// </summary>
	protected: int32_t succ_13;
	/// <summary>
	/// DB column: wf_succ_14
	/// </summary>
	protected: int32_t succ_14;
	/// <summary>
	/// DB column: wf_succ_15
	/// </summary>
	protected: int32_t succ_15;
	/// <summary>
	/// DB column: wf_succ_16
	/// </summary>
	protected: int32_t succ_16;
	/// <summary>
	/// DB column: wf_succ_17
	/// </summary>
	protected: int32_t succ_17;
	/// <summary>
	/// DB column: wf_succ_18
	/// </summary>
	protected: int32_t succ_18;
	/// <summary>
	/// DB column: wf_succ_19
	/// </summary>
	protected: int32_t succ_19;
	/// <summary>
	/// If node is locked, it contains 1 otherwise 0
	/// DB column: wf_locked
	/// </summary>
	protected: int32_t locked;
	/// <summary>
	/// Node X position in designer view.
	/// </summary>
	/// <remarks>
	/// DB column: pos_x
	/// </remarks>
	protected: int32_t posX;
	/// <summary>
	/// Node Y position in designer view.
	/// </summary>
	/// <remarks>
	/// DB column: pos_y
	/// </remarks>
	protected: int32_t posY;
	/// <summary>
	/// Name of script to be executed, if the node is activated (entered).
	/// </summary>
	/// <remarks>
	/// DB column: wf_ev_on_activate
	/// </remarks>
	protected: ::std::wstring onActivate;
	/// <summary>
	/// Name of script to be executed, if the node is leaved (exited).
	/// </summary>
	/// <remarks>
	/// DB column: wf_ev_on_terminate
	/// </remarks>
	protected: ::std::wstring onTerminate;
	/// <summary>
	/// Node flags.
	/// </summary>
	/// <remarks>
	/// DB column: wf_nodeflags
	/// </remarks>
	protected: int32_t nodeFlags;
	/// <summary>
	/// Associated object ID.
	/// </summary>
	/// <remarks>
	/// Only valid for non-template workflows.
	/// DB column: wf_eloobjid
	/// </remarks>
	protected: int32_t eloObjId;
	/// <summary>
	/// User ID of the owner of the lock.
	/// </summary>
	/// <remarks>
	/// DB column: wf_locked_owner
	/// </remarks>
	protected: int32_t lockId;
	/// <summary>
	/// Contains 1, if this node is active.
	/// </summary>
	/// <remarks>
	/// DB column: wf_is_next
	/// </remarks>
	protected: int32_t isNext;
	/// <summary>
	/// ELO-date when the node was entered.
	/// </summary>
	/// <remarks>
	/// DB column: wf_activate
	/// </remarks>
	protected: int32_t activate;
	/// <summary>
	/// ELO-date when the node was exited.
	/// </summary>
	/// <remarks>
	/// DB column: wf_terminate
	/// </remarks>
	protected: int32_t terminate;
	/// <summary>
	/// ELO-date when the node was visited the last time.
	/// </summary>
	/// <remarks>
	/// DB column: wf_in_use_date
	/// </remarks>
	protected: int32_t inUseDate;
	/// <summary>
	/// ELO-date when the workflow was finished.
	/// </summary>
	/// <remarks>
	/// All nodes contain the same value.
	/// DB column: wf_completion_date
	/// </remarks>
	protected: int32_t completionDate;
	/// <summary>
	/// Workflow template ID.
	/// </summary>
	/// <remarks>
	/// Not valid for template workflows. For active and
	/// finished workflows this member specifies the template ID that was used
	/// to start the workflow. If the workflow is started as an adhoc workflow,
	/// this member is 0 and flags contains the bit FLAG_ROOT_ADHOC.
	/// DB column: wf_template
	/// </remarks>
	protected: int32_t templateId;
	/// <summary>
	/// The ID of the user who has forwarded the node.
	/// </summary>
	/// <remarks>
	/// Not valid for template workflows.
	/// Only valid for person nodes.
	/// DB column: wf_userterminate
	/// </remarks>
	protected: ::std::wstring userTerminate;
	/// <summary>
	/// reserved.
	/// </summary>
	/// <remarks>
	/// DB column: wf_tag
	/// </remarks>
	protected: int32_t tag;
	/// <summary>
	/// A group ID or user ID that was originally assigned in the designer.
	/// </summary>
	/// <remarks>
	/// DB column: wf_designdepartment
	/// </remarks>
	protected: int32_t designDepartment;
	/// <summary>
	/// If a cycle is re-entered, the nodes in the cycle are duplicated.
	/// </summary>
	/// <remarks>
	/// The copied
	/// nodes will be placed in the designer moved by this value to the right. If
	/// this value is 0, the nodes are moved 60 points right and 20 points up.
	/// DB column: wf_dx
	/// </remarks>
	protected: int32_t moveCyclePosX;
	/// <summary>
	/// A group ID to constrain access to the node.
	/// </summary>
	/// <remarks>
	/// Only members of this group
	/// are allowed to see and process the node.
	/// Only valid for person nodes.
	/// DB column: wf_department2
	/// </remarks>
	protected: int32_t department2;
	/// <summary>
	/// An active person node (Activate is set) might be displayed to the user
	/// delayed by this number of days.
	/// </summary>
	/// <remarks>
	/// Only valid for person nodes.
	/// DB column: wf_delaydays
	/// </remarks>
	protected: int32_t delayDays;
	/// <summary>
	/// Activate + DelayDays.
	/// </summary>
	/// <remarks>
	/// Not valid for template workflows.
	/// Only valid for person nodes.
	/// DB column: wf_duedate
	/// </remarks>
	protected: int32_t delayDate;
	/// <summary>
	/// Flag that indicates whether the workflow template is deleted.
	/// </summary>
	/// <remarks>
	/// If the value is not 0, the workflow template is deleted.
	/// Only valid for template workflows.
	/// DB column: wf_deleted
	/// </remarks>
	protected: int32_t deleted;
	/// <summary>
	/// Workflow priority: 0...high, 1...medium, 2...low.
	/// </summary>
	/// <remarks>
	/// DB column: wf_prio
	/// </remarks>
	protected: int32_t prio;
	/// <summary>
	/// The workflow node is deferred until this date.
	/// </summary>
	/// <remarks>
	/// ELO date format.
	/// DB column: wf_user_delaydate
	/// </remarks>
	protected: int32_t userDelayDate;
	/// <summary>
	/// Version ID.
	/// </summary>
	protected: int32_t versionId;
	/// <summary>
	/// Version comment.
	/// </summary>
	protected: ::std::wstring versionName;
	/// <summary>
	/// ID of user who should be informed,
	/// if the time-limit alertWait2 exceeds.
	/// </summary>
	protected: int32_t alertTo2;
	/// <summary>
	/// Second Time-limit for a person node or begin node.
	/// </summary>
	protected: int32_t alertWait2;
	/// <summary>
	/// ID of user who should be informed,
	/// if the time-limit alertWait2 exceeds.
	/// </summary>
	protected: int32_t alertTo3;
	/// <summary>
	/// Third Time-limit for a person node or begin node.
	/// </summary>
	protected: int32_t alertWait3;
	/// <summary>
	/// Next server name.
	/// </summary>
	/// <remarks>
	/// This value is used in replication environments
	/// and defines the ID of the next server (resp. replication branch)
	/// where the workflow continues processing.
	/// </remarks>
	protected: ::std::wstring nextServerId;
	/// <summary>
	/// Version number.
	/// </summary>
	protected: ::std::wstring versionTag;
	/// <summary>
	/// ID of the user who created the workflow version.
	/// </summary>
	protected: int32_t versionUserId;
	/// <summary>
	/// ID of the user who created the workflow version.
	/// </summary>
	protected: int32_t versionCreateDate;
	/// <summary>
	/// Object-GUID of an icon file that is displayed in the designer.
	/// </summary>
	protected: ::std::wstring iconId;
	/// <summary>
	/// User defined data to be stored in the database.
	/// </summary>
	protected: ::std::wstring formSpec;
	/// <summary>
	/// Translation-keyword for {@link WFDiagram#name}.
	/// </summary>
	protected: ::std::wstring flowNameTranslationKey;
	/// <summary>
	/// Translation-keyword for {@link WFNode#name}.
	/// </summary>
	protected: ::std::wstring nameTranslationKey;
	/// <summary>
	/// Translation-keyword for {@link WFNode#comment}.
	/// </summary>
	protected: ::std::wstring commentTranslationKey;
	/// <summary>
	/// Display name by forwarding.
	/// </summary>
	protected: ::std::wstring label;
	/// <summary>
	/// Properties field of node.
	/// </summary>
	protected: ::std::wstring properties;
	/// <summary>
	/// Grouping of nodes for function takeWorkFlowNode.
	/// </summary>
	protected: int32_t departmentGroup;
	/// <summary>
	/// Return value of an end node.
	/// </summary>
	protected: int32_t retVal;
	/// <summary>
	/// Return value of an end node.
	/// </summary>
	protected: ::std::wstring returnValue;
	/// <summary>
	/// ID of the active sub-workflow.
	/// </summary>
	protected: int32_t subWorkflow;
	protected: ::std::wstring labelTranslationKey;
	/// <summary>
	/// ID of the sub-workflow template.
	/// </summary>
	protected: int32_t subWorkflowTemplate;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: WorkFlowActiveDoc();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: WorkFlowActiveDoc(int32_t flowId, int32_t nodeId, const ::std::wstring& flowName, const ::std::wstring& name, int32_t nodeType, int32_t succType, int32_t department, int32_t alertTo, int32_t alertFromBegin, int32_t alertWait, const ::std::wstring& yNCondition, const ::std::wstring& condition, const ::std::wstring& comment, int32_t succ_0, int32_t succ_1, int32_t succ_2, int32_t succ_3, int32_t succ_4, int32_t succ_5, int32_t succ_6, int32_t succ_7, int32_t succ_8, int32_t succ_9, int32_t succ_10, int32_t succ_11, int32_t succ_12, int32_t succ_13, int32_t succ_14, int32_t succ_15, int32_t succ_16, int32_t succ_17, int32_t succ_18, int32_t succ_19, int32_t locked, int32_t posX, int32_t posY, const ::std::wstring& onActivate, const ::std::wstring& onTerminate, int32_t nodeFlags, int32_t eloObjId, int32_t lockId, int32_t isNext, int32_t activate, int32_t terminate, int32_t inUseDate, int32_t completionDate, int32_t templateId, const ::std::wstring& userTerminate, int32_t tag, int32_t designDepartment, int32_t moveCyclePosX, int32_t department2, int32_t delayDays, int32_t delayDate, int32_t deleted, int32_t prio, int32_t userDelayDate, int32_t versionId, const ::std::wstring& versionName, int32_t alertTo2, int32_t alertWait2, int32_t alertTo3, int32_t alertWait3, const ::std::wstring& nextServerId, const ::std::wstring& versionTag, int32_t versionUserId, int32_t versionCreateDate, const ::std::wstring& iconId, const ::std::wstring& formSpec, const ::std::wstring& flowNameTranslationKey, const ::std::wstring& nameTranslationKey, const ::std::wstring& commentTranslationKey, const ::std::wstring& label, const ::std::wstring& properties, int32_t departmentGroup, int32_t retVal, const ::std::wstring& returnValue, int32_t subWorkflow, const ::std::wstring& labelTranslationKey, int32_t subWorkflowTemplate);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getFlowId() { return flowId; }
	public: void setFlowId(int32_t v);
	public: int32_t getNodeId() { return nodeId; }
	public: void setNodeId(int32_t v);
	public: ::std::wstring getFlowName() { return flowName; }
	public: void setFlowName(::std::wstring v);
	public: ::std::wstring getName() { return name; }
	public: void setName(::std::wstring v);
	public: int32_t getNodeType() { return nodeType; }
	public: void setNodeType(int32_t v);
	public: int32_t getSuccType() { return succType; }
	public: void setSuccType(int32_t v);
	public: int32_t getDepartment() { return department; }
	public: void setDepartment(int32_t v);
	public: int32_t getAlertTo() { return alertTo; }
	public: void setAlertTo(int32_t v);
	public: int32_t getAlertFromBegin() { return alertFromBegin; }
	public: void setAlertFromBegin(int32_t v);
	public: int32_t getAlertWait() { return alertWait; }
	public: void setAlertWait(int32_t v);
	public: ::std::wstring getYNCondition() { return yNCondition; }
	public: void setYNCondition(::std::wstring v);
	public: ::std::wstring getCondition() { return condition; }
	public: void setCondition(::std::wstring v);
	public: ::std::wstring getComment() { return comment; }
	public: void setComment(::std::wstring v);
	public: int32_t getSucc_0() { return succ_0; }
	public: void setSucc_0(int32_t v);
	public: int32_t getSucc_1() { return succ_1; }
	public: void setSucc_1(int32_t v);
	public: int32_t getSucc_2() { return succ_2; }
	public: void setSucc_2(int32_t v);
	public: int32_t getSucc_3() { return succ_3; }
	public: void setSucc_3(int32_t v);
	public: int32_t getSucc_4() { return succ_4; }
	public: void setSucc_4(int32_t v);
	public: int32_t getSucc_5() { return succ_5; }
	public: void setSucc_5(int32_t v);
	public: int32_t getSucc_6() { return succ_6; }
	public: void setSucc_6(int32_t v);
	public: int32_t getSucc_7() { return succ_7; }
	public: void setSucc_7(int32_t v);
	public: int32_t getSucc_8() { return succ_8; }
	public: void setSucc_8(int32_t v);
	public: int32_t getSucc_9() { return succ_9; }
	public: void setSucc_9(int32_t v);
	public: int32_t getSucc_10() { return succ_10; }
	public: void setSucc_10(int32_t v);
	public: int32_t getSucc_11() { return succ_11; }
	public: void setSucc_11(int32_t v);
	public: int32_t getSucc_12() { return succ_12; }
	public: void setSucc_12(int32_t v);
	public: int32_t getSucc_13() { return succ_13; }
	public: void setSucc_13(int32_t v);
	public: int32_t getSucc_14() { return succ_14; }
	public: void setSucc_14(int32_t v);
	public: int32_t getSucc_15() { return succ_15; }
	public: void setSucc_15(int32_t v);
	public: int32_t getSucc_16() { return succ_16; }
	public: void setSucc_16(int32_t v);
	public: int32_t getSucc_17() { return succ_17; }
	public: void setSucc_17(int32_t v);
	public: int32_t getSucc_18() { return succ_18; }
	public: void setSucc_18(int32_t v);
	public: int32_t getSucc_19() { return succ_19; }
	public: void setSucc_19(int32_t v);
	public: int32_t getLocked() { return locked; }
	public: void setLocked(int32_t v);
	public: int32_t getPosX() { return posX; }
	public: void setPosX(int32_t v);
	public: int32_t getPosY() { return posY; }
	public: void setPosY(int32_t v);
	public: ::std::wstring getOnActivate() { return onActivate; }
	public: void setOnActivate(::std::wstring v);
	public: ::std::wstring getOnTerminate() { return onTerminate; }
	public: void setOnTerminate(::std::wstring v);
	public: int32_t getNodeFlags() { return nodeFlags; }
	public: void setNodeFlags(int32_t v);
	public: int32_t getEloObjId() { return eloObjId; }
	public: void setEloObjId(int32_t v);
	public: int32_t getLockId() { return lockId; }
	public: void setLockId(int32_t v);
	public: int32_t getIsNext() { return isNext; }
	public: void setIsNext(int32_t v);
	public: int32_t getActivate() { return activate; }
	public: void setActivate(int32_t v);
	public: int32_t getTerminate() { return terminate; }
	public: void setTerminate(int32_t v);
	public: int32_t getInUseDate() { return inUseDate; }
	public: void setInUseDate(int32_t v);
	public: int32_t getCompletionDate() { return completionDate; }
	public: void setCompletionDate(int32_t v);
	public: int32_t getTemplateId() { return templateId; }
	public: void setTemplateId(int32_t v);
	public: ::std::wstring getUserTerminate() { return userTerminate; }
	public: void setUserTerminate(::std::wstring v);
	public: int32_t getTag() { return tag; }
	public: void setTag(int32_t v);
	public: int32_t getDesignDepartment() { return designDepartment; }
	public: void setDesignDepartment(int32_t v);
	public: int32_t getMoveCyclePosX() { return moveCyclePosX; }
	public: void setMoveCyclePosX(int32_t v);
	public: int32_t getDepartment2() { return department2; }
	public: void setDepartment2(int32_t v);
	public: int32_t getDelayDays() { return delayDays; }
	public: void setDelayDays(int32_t v);
	public: int32_t getDelayDate() { return delayDate; }
	public: void setDelayDate(int32_t v);
	public: int32_t getDeleted() { return deleted; }
	public: void setDeleted(int32_t v);
	public: int32_t getPrio() { return prio; }
	public: void setPrio(int32_t v);
	public: int32_t getUserDelayDate() { return userDelayDate; }
	public: void setUserDelayDate(int32_t v);
	public: int32_t getVersionId() { return versionId; }
	public: void setVersionId(int32_t v);
	public: ::std::wstring getVersionName() { return versionName; }
	public: void setVersionName(::std::wstring v);
	public: int32_t getAlertTo2() { return alertTo2; }
	public: void setAlertTo2(int32_t v);
	public: int32_t getAlertWait2() { return alertWait2; }
	public: void setAlertWait2(int32_t v);
	public: int32_t getAlertTo3() { return alertTo3; }
	public: void setAlertTo3(int32_t v);
	public: int32_t getAlertWait3() { return alertWait3; }
	public: void setAlertWait3(int32_t v);
	public: ::std::wstring getNextServerId() { return nextServerId; }
	public: void setNextServerId(::std::wstring v);
	public: ::std::wstring getVersionTag() { return versionTag; }
	public: void setVersionTag(::std::wstring v);
	public: int32_t getVersionUserId() { return versionUserId; }
	public: void setVersionUserId(int32_t v);
	public: int32_t getVersionCreateDate() { return versionCreateDate; }
	public: void setVersionCreateDate(int32_t v);
	public: ::std::wstring getIconId() { return iconId; }
	public: void setIconId(::std::wstring v);
	public: ::std::wstring getFormSpec() { return formSpec; }
	public: void setFormSpec(::std::wstring v);
	public: ::std::wstring getFlowNameTranslationKey() { return flowNameTranslationKey; }
	public: void setFlowNameTranslationKey(::std::wstring v);
	public: ::std::wstring getNameTranslationKey() { return nameTranslationKey; }
	public: void setNameTranslationKey(::std::wstring v);
	public: ::std::wstring getCommentTranslationKey() { return commentTranslationKey; }
	public: void setCommentTranslationKey(::std::wstring v);
	public: ::std::wstring getLabel() { return label; }
	public: void setLabel(::std::wstring v);
	public: ::std::wstring getProperties() { return properties; }
	public: void setProperties(::std::wstring v);
	public: int32_t getDepartmentGroup() { return departmentGroup; }
	public: void setDepartmentGroup(int32_t v);
	public: int32_t getRetVal() { return retVal; }
	public: void setRetVal(int32_t v);
	public: ::std::wstring getReturnValue() { return returnValue; }
	public: void setReturnValue(::std::wstring v);
	public: int32_t getSubWorkflow() { return subWorkflow; }
	public: void setSubWorkflow(int32_t v);
	public: ::std::wstring getLabelTranslationKey() { return labelTranslationKey; }
	public: void setLabelTranslationKey(::std::wstring v);
	public: int32_t getSubWorkflowTemplate() { return subWorkflowTemplate; }
	public: void setSubWorkflowTemplate(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// WorkFlowActiveDocC
// typeId=509854692

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// <p>Bit constants for members of WorkFlowActiveDoc</p>
/// <p>Copyright: Copyright (c) 2003</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </summary>
class WorkFlowActiveDocC : public BSerializable {
	/// <summary>
	/// DB column: wf_flowid
	/// </summary>
	public: const static int64_t mbFlowId = 1LL;
	/// <summary>
	/// DB column: wf_nodeid
	/// </summary>
	public: const static int64_t mbNodeId = 2LL;
	/// <summary>
	/// DB column: wf_flow_name
	/// </summary>
	public: const static int64_t mbFlowName = 4LL;
	/// <summary>
	/// DB column: wf_flow_name
	/// </summary>
	protected: int32_t lnFlowName;
	/// <summary>
	/// DB column: wf_name
	/// </summary>
	public: const static int64_t mbName = 8LL;
	/// <summary>
	/// DB column: wf_name
	/// </summary>
	protected: int32_t lnName;
	/// <summary>
	/// DB column: wf_node_type
	/// </summary>
	public: const static int64_t mbNodeType = 16LL;
	/// <summary>
	/// DB column: wf_department
	/// </summary>
	public: const static int64_t mbDepartment = 32LL;
	/// <summary>
	/// DB column: wf_alert_to
	/// </summary>
	public: const static int64_t mbAlertTo = 64LL;
	/// <summary>
	/// DB column: wf_alert_from_begin
	/// </summary>
	public: const static int64_t mbAlertFromBegin = 128LL;
	/// <summary>
	/// DB column: wf_alert_wait
	/// </summary>
	public: const static int64_t mbAlertWait = 256LL;
	/// <summary>
	/// DB column: wf_yesnocondition
	/// </summary>
	public: const static int64_t mbYNCondition = 512LL;
	/// <summary>
	/// DB column: wf_yesnocondition
	/// </summary>
	protected: int32_t lnYNCondition;
	/// <summary>
	/// DB column: wf_condition
	/// </summary>
	public: const static int64_t mbCondition = 1024LL;
	/// <summary>
	/// DB column: wf_condition
	/// </summary>
	protected: int32_t lnCondition;
	/// <summary>
	/// DB column: wf_comment
	/// </summary>
	public: const static int64_t mbComment = 2048LL;
	/// <summary>
	/// DB column: wf_comment
	/// </summary>
	protected: int32_t lnComment;
	/// <summary>
	/// DB column: wf_locked
	/// </summary>
	public: const static int64_t mbLocked = 4096LL;
	/// <summary>
	/// DB column: pos_x
	/// </summary>
	public: const static int64_t mbPosX = 8192LL;
	/// <summary>
	/// DB column: pos_y
	/// </summary>
	public: const static int64_t mbPosY = 16384LL;
	/// <summary>
	/// DB column: wf_ev_on_activate
	/// </summary>
	public: const static int64_t mbOnActivate = 32768LL;
	/// <summary>
	/// DB column: wf_ev_on_activate
	/// </summary>
	protected: int32_t lnOnActivate;
	/// <summary>
	/// DB column: wf_ev_on_terminate
	/// </summary>
	public: const static int64_t mbOnTerminate = 65536LL;
	/// <summary>
	/// DB column: wf_ev_on_terminate
	/// </summary>
	protected: int32_t lnOnTerminate;
	/// <summary>
	/// DB column: wf_nodeflags
	/// </summary>
	public: const static int64_t mbNodeFlags = 131072LL;
	/// <summary>
	/// DB column: wf_eloobjid
	/// </summary>
	public: const static int64_t mbEloObjId = 262144LL;
	/// <summary>
	/// DB column: wf_locked_owner
	/// </summary>
	public: const static int64_t mbLockId = 524288LL;
	/// <summary>
	/// DB column: wf_is_next
	/// </summary>
	public: const static int64_t mbIsNext = 1048576LL;
	/// <summary>
	/// DB column: wf_activate
	/// </summary>
	public: const static int64_t mbActivate = 2097152LL;
	/// <summary>
	/// DB column: wf_terminate
	/// </summary>
	public: const static int64_t mbTerminate = 4194304LL;
	/// <summary>
	/// DB column: wf_in_use_date
	/// </summary>
	public: const static int64_t mbInUseDate = 8388608LL;
	/// <summary>
	/// DB column: wf_completion_date
	/// </summary>
	public: const static int64_t mbCompletionDate = 16777216LL;
	/// <summary>
	/// DB column: wf_template
	/// </summary>
	public: const static int64_t mbTemplateId = 33554432LL;
	/// <summary>
	/// DB column: wf_userterminate
	/// </summary>
	public: const static int64_t mbUserTerminate = 67108864LL;
	/// <summary>
	/// DB column: wf_userterminate
	/// </summary>
	protected: int32_t lnUserTerminate;
	/// <summary>
	/// DB column: wf_tag
	/// </summary>
	public: const static int64_t mbTag = 134217728LL;
	/// <summary>
	/// DB column: wf_designdepartment
	/// </summary>
	public: const static int64_t mbDesignDepartment = 268435456LL;
	/// <summary>
	/// DB column: wf_dx
	/// </summary>
	public: const static int64_t mbMoveCyclePosX = 536870912LL;
	/// <summary>
	/// DB column: wf_department2
	/// </summary>
	public: const static int64_t mbDepartment2 = 1073741824LL;
	/// <summary>
	/// DB column: wf_delaydays
	/// </summary>
	public: const static int64_t mbDelayDays = 2147483648LL;
	/// <summary>
	/// DB column: wf_duedate
	/// </summary>
	public: const static int64_t mbDelayDate = 4294967296LL;
	/// <summary>
	/// DB column: wf_deleted
	/// </summary>
	public: const static int64_t mbDeleted = 8589934592LL;
	/// <summary>
	/// DB column: wf_prio
	/// </summary>
	public: const static int64_t mbPrio = 17179869184LL;
	/// <summary>
	/// Member bit: The workflow node is deferred until this date.
	/// </summary>
	/// <remarks>
	/// DB column: wf_user_delaydate
	/// </remarks>
	public: const static int64_t mbUserDelayDate = 34359738368LL;
	/// <summary>
	/// Member bit: Version ID.
	/// </summary>
	/// <remarks>
	/// DB column: wf_version
	/// </remarks>
	public: const static int64_t mbVersionId = 68719476736LL;
	/// <summary>
	/// Member bit: Version comment.
	/// </summary>
	/// <remarks>
	/// DB column: wf_version_name
	/// </remarks>
	public: const static int64_t mbVersionName = 137438953472LL;
	/// <summary>
	/// Column length: Version comment.
	/// </summary>
	/// <remarks>
	/// DB column: wf_version_name
	/// </remarks>
	protected: int32_t lnVersionName;
	/// <summary>
	/// Member bit: ID of user who should be informed,
	/// DB column: wf_alert_to2
	/// </summary>
	public: const static int64_t mbAlertTo2 = 274877906944LL;
	/// <summary>
	/// Member bit: Second Time-limit for a person node or begin node.
	/// </summary>
	/// <remarks>
	/// DB column: wf_alert_wait2
	/// </remarks>
	public: const static int64_t mbAlertWait2 = 549755813888LL;
	/// <summary>
	/// Member bit: ID of user who should be informed,
	/// DB column: wf_alert_to3
	/// </summary>
	public: const static int64_t mbAlertTo3 = 1099511627776LL;
	/// <summary>
	/// Member bit: Third Time-limit for a person node or begin node.
	/// </summary>
	/// <remarks>
	/// DB column: wf_alert_wait3
	/// </remarks>
	public: const static int64_t mbAlertWait3 = 2199023255552LL;
	/// <summary>
	/// Member bit: Next server name.
	/// </summary>
	/// <remarks>
	/// This value is used in replication environments
	/// DB column: nextserverid
	/// </remarks>
	public: const static int64_t mbNextServerId = 4398046511104LL;
	/// <summary>
	/// Column length: Next server name.
	/// </summary>
	/// <remarks>
	/// This value is used in replication environments
	/// DB column: nextserverid
	/// </remarks>
	protected: int32_t lnNextServerId;
	/// <summary>
	/// Member bit: Version number.
	/// </summary>
	/// <remarks>
	/// DB column: wf_version_tag
	/// </remarks>
	public: const static int64_t mbVersionTag = 8796093022208LL;
	/// <summary>
	/// Column length: Version number.
	/// </summary>
	/// <remarks>
	/// DB column: wf_version_tag
	/// </remarks>
	protected: int32_t lnVersionTag;
	/// <summary>
	/// Member bit: ID of the user who created the workflow version.
	/// </summary>
	/// <remarks>
	/// DB column: wf_version_userid
	/// </remarks>
	public: const static int64_t mbVersionUserId = 17592186044416LL;
	/// <summary>
	/// Member bit: ID of the user who created the workflow version.
	/// </summary>
	/// <remarks>
	/// DB column: wf_version_createdate
	/// </remarks>
	public: const static int64_t mbVersionCreateDate = 35184372088832LL;
	/// <summary>
	/// Member bit: Object-GUID of an icon file that is displayed in the designer.
	/// </summary>
	/// <remarks>
	/// DB column: wf_icon_guid
	/// </remarks>
	public: const static int64_t mbIconId = 70368744177664LL;
	/// <summary>
	/// Column length: Object-GUID of an icon file that is displayed in the designer.
	/// </summary>
	/// <remarks>
	/// DB column: wf_icon_guid
	/// </remarks>
	protected: int32_t lnIconId;
	/// <summary>
	/// Member bit: User defined data to be stored in the database.
	/// </summary>
	/// <remarks>
	/// DB column: wf_form_spec
	/// </remarks>
	public: const static int64_t mbFormSpec = 140737488355328LL;
	/// <summary>
	/// Column length: User defined data to be stored in the database.
	/// </summary>
	/// <remarks>
	/// DB column: wf_form_spec
	/// </remarks>
	protected: int32_t lnFormSpec;
	/// <summary>
	/// Member bit: Translation-keyword for {@link WFDiagram#name}.
	/// </summary>
	/// <remarks>
	/// DB column: wf_flownametrkey
	/// </remarks>
	public: const static int64_t mbFlowNameTranslationKey = 281474976710656LL;
	/// <summary>
	/// Column length: Translation-keyword for {@link WFDiagram#name}.
	/// </summary>
	/// <remarks>
	/// DB column: wf_flownametrkey
	/// </remarks>
	protected: int32_t lnFlowNameTranslationKey;
	/// <summary>
	/// Member bit: Translation-keyword for {@link WFNode#name}.
	/// </summary>
	/// <remarks>
	/// DB column: wf_nametrkey
	/// </remarks>
	public: const static int64_t mbNameTranslationKey = 562949953421312LL;
	/// <summary>
	/// Column length: Translation-keyword for {@link WFNode#name}.
	/// </summary>
	/// <remarks>
	/// DB column: wf_nametrkey
	/// </remarks>
	protected: int32_t lnNameTranslationKey;
	/// <summary>
	/// Member bit: Translation-keyword for {@link WFNode#comment}.
	/// </summary>
	/// <remarks>
	/// DB column: wf_commenttrkey
	/// </remarks>
	public: const static int64_t mbCommentTranslationKey = 1125899906842624LL;
	/// <summary>
	/// Column length: Translation-keyword for {@link WFNode#comment}.
	/// </summary>
	/// <remarks>
	/// DB column: wf_commenttrkey
	/// </remarks>
	protected: int32_t lnCommentTranslationKey;
	/// <summary>
	/// Member bit: Display name by forwarding.
	/// </summary>
	/// <remarks>
	/// DB column: wf_label
	/// </remarks>
	public: const static int64_t mbLabel = 2251799813685248LL;
	/// <summary>
	/// Column length: Display name by forwarding.
	/// </summary>
	/// <remarks>
	/// DB column: wf_label
	/// </remarks>
	protected: int32_t lnLabel;
	/// <summary>
	/// Member bit: Properties field of node.
	/// </summary>
	/// <remarks>
	/// DB column: wf_properties
	/// </remarks>
	public: const static int64_t mbProperties = 4503599627370496LL;
	/// <summary>
	/// Column length: Properties field of node.
	/// </summary>
	/// <remarks>
	/// DB column: wf_properties
	/// </remarks>
	protected: int32_t lnProperties;
	/// <summary>
	/// Member bit: Grouping of nodes for function takeWorkFlowNode.
	/// </summary>
	/// <remarks>
	/// DB column: wf_departmentgroup
	/// </remarks>
	public: const static int64_t mbDepartmentGroup = 9007199254740992LL;
	/// <summary>
	/// Member bit: Return value of an end node.
	/// </summary>
	/// <remarks>
	/// DB column: wf_retval
	/// </remarks>
	public: const static int64_t mbRetVal = 18014398509481984LL;
	/// <summary>
	/// Member bit: Return value of an end node.
	/// </summary>
	/// <remarks>
	/// DB column: wf_returnvalue
	/// </remarks>
	public: const static int64_t mbReturnValue = 36028797018963968LL;
	/// <summary>
	/// Column length: Return value of an end node.
	/// </summary>
	/// <remarks>
	/// DB column: wf_returnvalue
	/// </remarks>
	protected: int32_t lnReturnValue;
	/// <summary>
	/// Member bit: ID of the active sub-workflow.
	/// </summary>
	/// <remarks>
	/// DB column: wf_sub_wf
	/// </remarks>
	public: const static int64_t mbSubWorkflow = 72057594037927936LL;
	/// <summary>
	/// DB column: wf_labeltrkey
	/// </summary>
	public: const static int64_t mbLabelTranslationKey = 144115188075855872LL;
	/// <summary>
	/// DB column: wf_labeltrkey
	/// </summary>
	protected: int32_t lnLabelTranslationKey;
	/// <summary>
	/// Member bit: ID of the sub-workflow template.
	/// </summary>
	/// <remarks>
	/// DB column: wf_sub_wf_templ
	/// </remarks>
	public: const static int64_t mbSubWorkflowTemplate = 288230376151711744LL;
	/// <summary>
	/// All valid member bits.
	/// </summary>
	public: const static int64_t mbAllMembers = 576460752303423487LL;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: WorkFlowActiveDocC();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: WorkFlowActiveDocC(int64_t mbFlowId, int64_t mbNodeId, int64_t mbFlowName, int32_t lnFlowName, int64_t mbName, int32_t lnName, int64_t mbNodeType, int64_t mbDepartment, int64_t mbAlertTo, int64_t mbAlertFromBegin, int64_t mbAlertWait, int64_t mbYNCondition, int32_t lnYNCondition, int64_t mbCondition, int32_t lnCondition, int64_t mbComment, int32_t lnComment, int64_t mbLocked, int64_t mbPosX, int64_t mbPosY, int64_t mbOnActivate, int32_t lnOnActivate, int64_t mbOnTerminate, int32_t lnOnTerminate, int64_t mbNodeFlags, int64_t mbEloObjId, int64_t mbLockId, int64_t mbIsNext, int64_t mbActivate, int64_t mbTerminate, int64_t mbInUseDate, int64_t mbCompletionDate, int64_t mbTemplateId, int64_t mbUserTerminate, int32_t lnUserTerminate, int64_t mbTag, int64_t mbDesignDepartment, int64_t mbMoveCyclePosX, int64_t mbDepartment2, int64_t mbDelayDays, int64_t mbDelayDate, int64_t mbDeleted, int64_t mbPrio, int64_t mbUserDelayDate, int64_t mbVersionId, int64_t mbVersionName, int32_t lnVersionName, int64_t mbAlertTo2, int64_t mbAlertWait2, int64_t mbAlertTo3, int64_t mbAlertWait3, int64_t mbNextServerId, int32_t lnNextServerId, int64_t mbVersionTag, int32_t lnVersionTag, int64_t mbVersionUserId, int64_t mbVersionCreateDate, int64_t mbIconId, int32_t lnIconId, int64_t mbFormSpec, int32_t lnFormSpec, int64_t mbFlowNameTranslationKey, int32_t lnFlowNameTranslationKey, int64_t mbNameTranslationKey, int32_t lnNameTranslationKey, int64_t mbCommentTranslationKey, int32_t lnCommentTranslationKey, int64_t mbLabel, int32_t lnLabel, int64_t mbProperties, int32_t lnProperties, int64_t mbDepartmentGroup, int64_t mbRetVal, int64_t mbReturnValue, int32_t lnReturnValue, int64_t mbSubWorkflow, int64_t mbLabelTranslationKey, int32_t lnLabelTranslationKey, int64_t mbSubWorkflowTemplate, int64_t mbAllMembers);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getLnFlowName() { return lnFlowName; }
	public: void setLnFlowName(int32_t v);
	public: int32_t getLnName() { return lnName; }
	public: void setLnName(int32_t v);
	public: int32_t getLnYNCondition() { return lnYNCondition; }
	public: void setLnYNCondition(int32_t v);
	public: int32_t getLnCondition() { return lnCondition; }
	public: void setLnCondition(int32_t v);
	public: int32_t getLnComment() { return lnComment; }
	public: void setLnComment(int32_t v);
	public: int32_t getLnOnActivate() { return lnOnActivate; }
	public: void setLnOnActivate(int32_t v);
	public: int32_t getLnOnTerminate() { return lnOnTerminate; }
	public: void setLnOnTerminate(int32_t v);
	public: int32_t getLnUserTerminate() { return lnUserTerminate; }
	public: void setLnUserTerminate(int32_t v);
	public: int32_t getLnVersionName() { return lnVersionName; }
	public: void setLnVersionName(int32_t v);
	public: int32_t getLnNextServerId() { return lnNextServerId; }
	public: void setLnNextServerId(int32_t v);
	public: int32_t getLnVersionTag() { return lnVersionTag; }
	public: void setLnVersionTag(int32_t v);
	public: int32_t getLnIconId() { return lnIconId; }
	public: void setLnIconId(int32_t v);
	public: int32_t getLnFormSpec() { return lnFormSpec; }
	public: void setLnFormSpec(int32_t v);
	public: int32_t getLnFlowNameTranslationKey() { return lnFlowNameTranslationKey; }
	public: void setLnFlowNameTranslationKey(int32_t v);
	public: int32_t getLnNameTranslationKey() { return lnNameTranslationKey; }
	public: void setLnNameTranslationKey(int32_t v);
	public: int32_t getLnCommentTranslationKey() { return lnCommentTranslationKey; }
	public: void setLnCommentTranslationKey(int32_t v);
	public: int32_t getLnLabel() { return lnLabel; }
	public: void setLnLabel(int32_t v);
	public: int32_t getLnProperties() { return lnProperties; }
	public: void setLnProperties(int32_t v);
	public: int32_t getLnReturnValue() { return lnReturnValue; }
	public: void setLnReturnValue(int32_t v);
	public: int32_t getLnLabelTranslationKey() { return lnLabelTranslationKey; }
	public: void setLnLabelTranslationKey(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// WorkFlowHead
// typeId=37271022

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Helperclass to access the DB table workflowtemplhead, workflowactivedochead, ...
/// </summary>
class WorkFlowHead : public ValueClass {
	/// <summary>
	/// Workflow ID
	/// </summary>
	protected: int32_t flowId;
	/// <summary>
	/// Timestamp
	/// The format is JJJJ.MM.DD.hh.mm.ss
	/// </summary>
	protected: ::std::wstring tStamp;
	/// <summary>
	/// GUID
	/// </summary>
	protected: ::std::wstring guid;
	/// <summary>
	/// Status, !
	/// </summary>
	/// <remarks>
	/// = 0 means deleted
	/// </remarks>
	protected: int32_t status;
	/// <summary>
	/// Workflow type.
	/// </summary>
	protected: int32_t type;
	/// <summary>
	/// The current sever ID (resp. replication branch) where the
	/// workflow can be condinued.
	/// </summary>
	protected: ::std::wstring actServerId;
	/// <summary>
	/// Id of the main workflow.
	/// </summary>
	protected: int32_t parentWorkflow;
	/// <summary>
	/// The call node id of the main workflow, which call this sub workflow.
	/// </summary>
	protected: int32_t callNodeId;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: WorkFlowHead();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: WorkFlowHead(int32_t flowId, const ::std::wstring& tStamp, const ::std::wstring& guid, int32_t status, int32_t type, const ::std::wstring& actServerId, int32_t parentWorkflow, int32_t callNodeId);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getFlowId() { return flowId; }
	public: void setFlowId(int32_t v);
	public: ::std::wstring getTStamp() { return tStamp; }
	public: void setTStamp(::std::wstring v);
	public: ::std::wstring getGuid() { return guid; }
	public: void setGuid(::std::wstring v);
	public: int32_t getStatus() { return status; }
	public: void setStatus(int32_t v);
	public: int32_t getType() { return type; }
	public: void setType(int32_t v);
	public: ::std::wstring getActServerId() { return actServerId; }
	public: void setActServerId(::std::wstring v);
	public: int32_t getParentWorkflow() { return parentWorkflow; }
	public: void setParentWorkflow(int32_t v);
	public: int32_t getCallNodeId() { return callNodeId; }
	public: void setCallNodeId(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// WorkFlowHeadC
// typeId=807993720

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// <p>Bit constants for members of WorkFlowHead</p>
/// <p>Copyright: Copyright (c) 2003</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </summary>
class WorkFlowHeadC : public BSerializable {
	/// <summary>
	/// Member bit: Workflow ID
	/// DB column: wfflowid
	/// </summary>
	public: const static int64_t mbFlowId = 1LL;
	/// <summary>
	/// Member bit: Timestamp
	/// DB column: wftstamp
	/// </summary>
	public: const static int64_t mbTStamp = 2LL;
	/// <summary>
	/// Column length: Timestamp
	/// DB column: wftstamp
	/// </summary>
	protected: int32_t lnTStamp;
	/// <summary>
	/// Member bit: GUID
	/// DB column: wfguid
	/// </summary>
	public: const static int64_t mbGuid = 4LL;
	/// <summary>
	/// Column length: GUID
	/// DB column: wfguid
	/// </summary>
	protected: int32_t lnGuid;
	/// <summary>
	/// Member bit: Status, !
	/// </summary>
	/// <remarks>
	/// = 0 means deleted
	/// DB column: wfstatus
	/// </remarks>
	public: const static int64_t mbStatus = 8LL;
	/// <summary>
	/// Member bit: Workflow type.
	/// </summary>
	/// <remarks>
	/// DB column: wftype
	/// </remarks>
	public: const static int64_t mbType = 16LL;
	/// <summary>
	/// Member bit: The current sever ID (resp. replication branch) where the
	/// DB column: actserverid
	/// </summary>
	public: const static int64_t mbActServerId = 32LL;
	/// <summary>
	/// Column length: The current sever ID (resp. replication branch) where the
	/// DB column: actserverid
	/// </summary>
	protected: int32_t lnActServerId;
	/// <summary>
	/// Member bit: Id of the main workflow.
	/// </summary>
	/// <remarks>
	/// DB column: wfParent
	/// </remarks>
	public: const static int64_t mbParentWorkflow = 64LL;
	/// <summary>
	/// Member bit: The call node id of the main workflow, which call this sub workflow.
	/// </summary>
	/// <remarks>
	/// DB column: callnodeid
	/// </remarks>
	public: const static int64_t mbCallNodeId = 128LL;
	/// <summary>
	/// All valid member bits.
	/// </summary>
	public: const static int64_t mbAllMembers = 255LL;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: WorkFlowHeadC();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: WorkFlowHeadC(int64_t mbFlowId, int64_t mbTStamp, int32_t lnTStamp, int64_t mbGuid, int32_t lnGuid, int64_t mbStatus, int64_t mbType, int64_t mbActServerId, int32_t lnActServerId, int64_t mbParentWorkflow, int64_t mbCallNodeId, int64_t mbAllMembers);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getLnTStamp() { return lnTStamp; }
	public: void setLnTStamp(int32_t v);
	public: int32_t getLnGuid() { return lnGuid; }
	public: void setLnGuid(int32_t v);
	public: int32_t getLnActServerId() { return lnActServerId; }
	public: void setLnActServerId(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// WorkFlowNodeMatrix
// typeId=1337377725

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Helperclass to access the node matrix.
/// </summary>
class WorkFlowNodeMatrix : public ValueClass {
	/// <summary>
	/// Workflow ID
	/// </summary>
	protected: int32_t flowId;
	/// <summary>
	/// Node ID
	/// </summary>
	protected: int32_t nodeId;
	/// <summary>
	/// Contains 1, if this node is active.
	/// </summary>
	/// <remarks>
	/// DB column: wf_is_next
	/// </remarks>
	protected: int32_t isNext;
	/// <summary>
	/// ELO-date when the node was exited.
	/// </summary>
	/// <remarks>
	/// DB column: wf_terminate
	/// </remarks>
	protected: int32_t terminate;
	/// <summary>
	/// Type of successor node.
	/// </summary>
	protected: int32_t succType;
	protected: int32_t succ_0;
	protected: int32_t succ_1;
	protected: int32_t succ_2;
	protected: int32_t succ_3;
	protected: int32_t succ_4;
	protected: int32_t succ_5;
	protected: int32_t succ_6;
	protected: int32_t succ_7;
	protected: int32_t succ_8;
	protected: int32_t succ_9;
	protected: int32_t succ_10;
	protected: int32_t succ_11;
	protected: int32_t succ_12;
	protected: int32_t succ_13;
	protected: int32_t succ_14;
	protected: int32_t succ_15;
	protected: int32_t succ_16;
	protected: int32_t succ_17;
	protected: int32_t succ_18;
	protected: int32_t succ_19;
	/// <summary>
	/// Id of successor node, which should be activated by the escalation.
	/// </summary>
	protected: int32_t succOvertime;
	/// <summary>
	/// Version ID.
	/// </summary>
	protected: int32_t versionId;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: WorkFlowNodeMatrix();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: WorkFlowNodeMatrix(int32_t flowId, int32_t nodeId, int32_t isNext, int32_t terminate, int32_t succType, int32_t succ_0, int32_t succ_1, int32_t succ_2, int32_t succ_3, int32_t succ_4, int32_t succ_5, int32_t succ_6, int32_t succ_7, int32_t succ_8, int32_t succ_9, int32_t succ_10, int32_t succ_11, int32_t succ_12, int32_t succ_13, int32_t succ_14, int32_t succ_15, int32_t succ_16, int32_t succ_17, int32_t succ_18, int32_t succ_19, int32_t succOvertime, int32_t versionId);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getFlowId() { return flowId; }
	public: void setFlowId(int32_t v);
	public: int32_t getNodeId() { return nodeId; }
	public: void setNodeId(int32_t v);
	public: int32_t getIsNext() { return isNext; }
	public: void setIsNext(int32_t v);
	public: int32_t getTerminate() { return terminate; }
	public: void setTerminate(int32_t v);
	public: int32_t getSuccType() { return succType; }
	public: void setSuccType(int32_t v);
	public: int32_t getSucc_0() { return succ_0; }
	public: void setSucc_0(int32_t v);
	public: int32_t getSucc_1() { return succ_1; }
	public: void setSucc_1(int32_t v);
	public: int32_t getSucc_2() { return succ_2; }
	public: void setSucc_2(int32_t v);
	public: int32_t getSucc_3() { return succ_3; }
	public: void setSucc_3(int32_t v);
	public: int32_t getSucc_4() { return succ_4; }
	public: void setSucc_4(int32_t v);
	public: int32_t getSucc_5() { return succ_5; }
	public: void setSucc_5(int32_t v);
	public: int32_t getSucc_6() { return succ_6; }
	public: void setSucc_6(int32_t v);
	public: int32_t getSucc_7() { return succ_7; }
	public: void setSucc_7(int32_t v);
	public: int32_t getSucc_8() { return succ_8; }
	public: void setSucc_8(int32_t v);
	public: int32_t getSucc_9() { return succ_9; }
	public: void setSucc_9(int32_t v);
	public: int32_t getSucc_10() { return succ_10; }
	public: void setSucc_10(int32_t v);
	public: int32_t getSucc_11() { return succ_11; }
	public: void setSucc_11(int32_t v);
	public: int32_t getSucc_12() { return succ_12; }
	public: void setSucc_12(int32_t v);
	public: int32_t getSucc_13() { return succ_13; }
	public: void setSucc_13(int32_t v);
	public: int32_t getSucc_14() { return succ_14; }
	public: void setSucc_14(int32_t v);
	public: int32_t getSucc_15() { return succ_15; }
	public: void setSucc_15(int32_t v);
	public: int32_t getSucc_16() { return succ_16; }
	public: void setSucc_16(int32_t v);
	public: int32_t getSucc_17() { return succ_17; }
	public: void setSucc_17(int32_t v);
	public: int32_t getSucc_18() { return succ_18; }
	public: void setSucc_18(int32_t v);
	public: int32_t getSucc_19() { return succ_19; }
	public: void setSucc_19(int32_t v);
	public: int32_t getSuccOvertime() { return succOvertime; }
	public: void setSuccOvertime(int32_t v);
	public: int32_t getVersionId() { return versionId; }
	public: void setVersionId(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// WorkFlowNodeMatrixC
// typeId=813423307

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// <p>Bit constants for members of WorkFlowNodeMatrix</p>
/// <p>Copyright: Copyright (c) 2003</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </summary>
class WorkFlowNodeMatrixC : public BSerializable {
	/// <summary>
	/// Member bit: Sort order of edges.
	/// </summary>
	/// <remarks>
	/// DB column: wf_edges_ordinals
	/// </remarks>
	public: const static int64_t mbEdgesOrdinals = 1LL;
	/// <summary>
	/// Column length: Sort order of edges.
	/// </summary>
	/// <remarks>
	/// DB column: wf_edges_ordinals
	/// </remarks>
	protected: int32_t lnEdgesOrdinals;
	/// <summary>
	/// Member bit: Workflow ID
	/// DB column: wf_flowid
	/// </summary>
	public: const static int64_t mbFlowId = 2LL;
	/// <summary>
	/// Member bit: Node ID
	/// DB column: wf_nodeid
	/// </summary>
	public: const static int64_t mbNodeId = 4LL;
	/// <summary>
	/// Member bit: Contains 1, if this node is active.
	/// </summary>
	/// <remarks>
	/// DB column: wf_is_next
	/// </remarks>
	public: const static int64_t mbIsNext = 8LL;
	/// <summary>
	/// Member bit: ELO-date when the node was exited.
	/// </summary>
	/// <remarks>
	/// DB column: wf_terminate
	/// </remarks>
	public: const static int64_t mbTerminate = 16LL;
	/// <summary>
	/// Member bit: Type of successor node.
	/// </summary>
	/// <remarks>
	/// DB column: wf_succ_type
	/// </remarks>
	public: const static int64_t mbSuccType = 32LL;
	/// <summary>
	/// DB column: wf_succ_0
	/// </summary>
	public: const static int64_t mbSucc_0 = 64LL;
	/// <summary>
	/// DB column: wf_succ_1
	/// </summary>
	public: const static int64_t mbSucc_1 = 128LL;
	/// <summary>
	/// DB column: wf_succ_2
	/// </summary>
	public: const static int64_t mbSucc_2 = 256LL;
	/// <summary>
	/// DB column: wf_succ_3
	/// </summary>
	public: const static int64_t mbSucc_3 = 512LL;
	/// <summary>
	/// DB column: wf_succ_4
	/// </summary>
	public: const static int64_t mbSucc_4 = 1024LL;
	/// <summary>
	/// DB column: wf_succ_5
	/// </summary>
	public: const static int64_t mbSucc_5 = 2048LL;
	/// <summary>
	/// DB column: wf_succ_6
	/// </summary>
	public: const static int64_t mbSucc_6 = 4096LL;
	/// <summary>
	/// DB column: wf_succ_7
	/// </summary>
	public: const static int64_t mbSucc_7 = 8192LL;
	/// <summary>
	/// DB column: wf_succ_8
	/// </summary>
	public: const static int64_t mbSucc_8 = 16384LL;
	/// <summary>
	/// DB column: wf_succ_9
	/// </summary>
	public: const static int64_t mbSucc_9 = 32768LL;
	/// <summary>
	/// DB column: wf_succ_10
	/// </summary>
	public: const static int64_t mbSucc_10 = 65536LL;
	/// <summary>
	/// DB column: wf_succ_11
	/// </summary>
	public: const static int64_t mbSucc_11 = 131072LL;
	/// <summary>
	/// DB column: wf_succ_12
	/// </summary>
	public: const static int64_t mbSucc_12 = 262144LL;
	/// <summary>
	/// DB column: wf_succ_13
	/// </summary>
	public: const static int64_t mbSucc_13 = 524288LL;
	/// <summary>
	/// DB column: wf_succ_14
	/// </summary>
	public: const static int64_t mbSucc_14 = 1048576LL;
	/// <summary>
	/// DB column: wf_succ_15
	/// </summary>
	public: const static int64_t mbSucc_15 = 2097152LL;
	/// <summary>
	/// DB column: wf_succ_16
	/// </summary>
	public: const static int64_t mbSucc_16 = 4194304LL;
	/// <summary>
	/// DB column: wf_succ_17
	/// </summary>
	public: const static int64_t mbSucc_17 = 8388608LL;
	/// <summary>
	/// DB column: wf_succ_18
	/// </summary>
	public: const static int64_t mbSucc_18 = 16777216LL;
	/// <summary>
	/// DB column: wf_succ_19
	/// </summary>
	public: const static int64_t mbSucc_19 = 33554432LL;
	/// <summary>
	/// Member bit: Id of successor node, which should be activated by the escalation.
	/// </summary>
	/// <remarks>
	/// DB column: wf_succ_overtime
	/// </remarks>
	public: const static int64_t mbSuccOvertime = 67108864LL;
	/// <summary>
	/// Member bit: Version ID.
	/// </summary>
	/// <remarks>
	/// DB column: wf_version
	/// </remarks>
	public: const static int64_t mbVersionId = 134217728LL;
	/// <summary>
	/// All valid member bits.
	/// </summary>
	public: const static int64_t mbAllMembers = 268435455LL;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: WorkFlowNodeMatrixC();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: WorkFlowNodeMatrixC(int64_t mbEdgesOrdinals, int32_t lnEdgesOrdinals, int64_t mbFlowId, int64_t mbNodeId, int64_t mbIsNext, int64_t mbTerminate, int64_t mbSuccType, int64_t mbSucc_0, int64_t mbSucc_1, int64_t mbSucc_2, int64_t mbSucc_3, int64_t mbSucc_4, int64_t mbSucc_5, int64_t mbSucc_6, int64_t mbSucc_7, int64_t mbSucc_8, int64_t mbSucc_9, int64_t mbSucc_10, int64_t mbSucc_11, int64_t mbSucc_12, int64_t mbSucc_13, int64_t mbSucc_14, int64_t mbSucc_15, int64_t mbSucc_16, int64_t mbSucc_17, int64_t mbSucc_18, int64_t mbSucc_19, int64_t mbSuccOvertime, int64_t mbVersionId, int64_t mbAllMembers);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getLnEdgesOrdinals() { return lnEdgesOrdinals; }
	public: void setLnEdgesOrdinals(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// WorkflowExchangeInfo
// typeId=2070549585

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// This class represents a workflow export data.
/// </summary>
class WorkflowExchangeInfo : public ValueClass {
	/// <summary>
	/// The exchanged workflow.
	/// </summary>
	protected: PWFDiagram workflow;
	/// <summary>
	/// The users associated with the workflow
	/// </summary>
	protected: PMapIntegerUserName userNames;
	/// <summary>
	/// Map contains the all direct und indirect subworkflows.
	/// </summary>
	/// <remarks>
	/// The workflow ID is the key.
	/// </remarks>
	protected: PMapIntegerWFDiagram subWorkflowMap;
	/// <summary>
	/// The workflow version.
	/// </summary>
	protected: PArrayWFDiagram workflowVersions;
	/// <summary>
	/// Map contains the workflow verions of the sub workflows.
	/// </summary>
	protected: byps_ptr< ::std::map< int32_t , PVectorWFDiagram > > subWorkflowVersionMap;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: WorkflowExchangeInfo();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: WorkflowExchangeInfo(const PWFDiagram& workflow, const PMapIntegerUserName& userNames, const PMapIntegerWFDiagram& subWorkflowMap, const PArrayWFDiagram& workflowVersions, const byps_ptr< ::std::map< int32_t , PVectorWFDiagram > >& subWorkflowVersionMap);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: PWFDiagram getWorkflow() { return workflow; }
	public: void setWorkflow(PWFDiagram v);
	public: PMapIntegerUserName getUserNames() { return userNames; }
	public: void setUserNames(PMapIntegerUserName v);
	public: PMapIntegerWFDiagram getSubWorkflowMap() { return subWorkflowMap; }
	public: void setSubWorkflowMap(PMapIntegerWFDiagram v);
	public: PArrayWFDiagram getWorkflowVersions() { return workflowVersions; }
	public: void setWorkflowVersions(PArrayWFDiagram v);
	public: byps_ptr< ::std::map< int32_t , PVectorWFDiagram > > getSubWorkflowVersionMap() { return subWorkflowVersionMap; }
	public: void setSubWorkflowVersionMap(byps_ptr< ::std::map< int32_t , PVectorWFDiagram > > v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// WorkflowExportOptions
// typeId=402835780

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Structure for the options for the workflow-export.
/// </summary>
/// <remarks>
/// <p>
/// Copyright: Copyright (c) 2009
/// </p>
/// <p>
/// Organisation: ELO Digital Office GmbH
/// </p>
/// </remarks>
class WorkflowExportOptions : public BSerializable {
	/// <summary>
	/// Id of the workflow, that will be exported.
	/// </summary>
	protected: ::std::wstring flowId;
	/// <summary>
	/// Reserved.
	/// </summary>
	protected: ::std::wstring flowVersId;
	/// <summary>
	/// Character set for the export-data.
	/// </summary>
	protected: ::std::wstring characterSet;
	/// <summary>
	/// Word wrap for the export-data.
	/// </summary>
	protected: ::std::wstring wordWrap;
	/// <summary>
	/// Export format.
	/// </summary>
	protected: int32_t format;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: WorkflowExportOptions();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: WorkflowExportOptions(const ::std::wstring& flowId, const ::std::wstring& flowVersId, const ::std::wstring& characterSet, const ::std::wstring& wordWrap, int32_t format);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: ::std::wstring getFlowId() { return flowId; }
	public: void setFlowId(::std::wstring v);
	public: ::std::wstring getFlowVersId() { return flowVersId; }
	public: void setFlowVersId(::std::wstring v);
	public: ::std::wstring getCharacterSet() { return characterSet; }
	public: void setCharacterSet(::std::wstring v);
	public: ::std::wstring getWordWrap() { return wordWrap; }
	public: void setWordWrap(::std::wstring v);
	public: int32_t getFormat() { return format; }
	public: void setFormat(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// WorkflowExportOptionsC
// typeId=1063132081

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Contants related to the workflow export.
/// </summary>
class WorkflowExportOptionsC : public BSerializable {
	/// <summary>
	/// JSON format.
	/// </summary>
	public: const static int32_t FORMAT_JSON = 1;
	/// <summary>
	/// Workflow table format for compatibility with Windows Client.
	/// </summary>
	public: const static int32_t FORMAT_PLAIN_TABLE = 2;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: WorkflowExportOptionsC();
	
	public: virtual BTYPEID BSerializable_getTypeId();
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// WorkflowImportOptions
// typeId=449037977

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Options for the workflow import.
/// </summary>
class WorkflowImportOptions : public ValueClass {
	/// <summary>
	/// If this variable is set, the missing user is replaced by this user.
	/// </summary>
	/// <remarks>
	/// Otherwise the missing user will be created using a random password.
	/// </remarks>
	protected: ::std::wstring replaceMissingUserByUserId;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: WorkflowImportOptions();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: WorkflowImportOptions(const ::std::wstring& replaceMissingUserByUserId);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: ::std::wstring getReplaceMissingUserByUserId() { return replaceMissingUserByUserId; }
	public: void setReplaceMissingUserByUserId(::std::wstring v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// WorkflowNodeInfo
// typeId=1659862348

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

class WorkflowNodeInfo : public ValueClass {
	/// <summary>
	/// The node name
	/// </summary>
	protected: ::std::wstring nodeName;
	/// <summary>
	/// Control flags for the node, a combination of WFNode.C.FLAG_* constants.
	/// </summary>
	protected: int32_t flags;
	/// <summary>
	/// The template ID of the subworkflow to start.
	/// </summary>
	protected: ::std::wstring workflow;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: WorkflowNodeInfo();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: WorkflowNodeInfo(const ::std::wstring& nodeName, int32_t flags, const ::std::wstring& workflow);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: ::std::wstring getNodeName() { return nodeName; }
	public: void setNodeName(::std::wstring v);
	public: int32_t getFlags() { return flags; }
	public: void setFlags(int32_t v);
	public: ::std::wstring getWorkflow() { return workflow; }
	public: void setWorkflow(::std::wstring v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// WClientC
// typeId=1800529481

namespace de { namespace elo { namespace ix { namespace client { namespace compatibility { 

using namespace ::byps;

class WClientC : public BSerializable {
	public: const static int32_t NEW_VERSION = 1;
	public: const static int32_t WORK_VERSION_CHANGED = 2;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: WClientC();
	
	public: virtual BTYPEID BSerializable_getTypeId();
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// Action
// typeId=736351635

namespace de { namespace elo { namespace ix { namespace client { namespace feed { 

using namespace ::byps;

/// <summary>
/// This class describes an entry in a document feed.
/// </summary>
/// <remarks>
/// There are three kinds of entries/actions in general.
/// First, an action can be a comment added manually by a user.
/// Second, scripts or programs can insert actions e.g. to notify about a particular state.
/// Third, actions are generated by the system e.g. when a new document version is created.
/// In order to add an action to a feed, call {@link FeedService#checkinAction(de.elo.ix.client.ClientInfo, Action, ActionZ)}.
/// User comments can have a parent action to support a two level hierarchy of entries.
/// </remarks>
class Action : public de::elo::ix::client::ValueClass {
	/// <summary>
	/// Action GUID.
	/// </summary>
	/// <remarks>
	/// Unique identifier.
	/// </remarks>
	protected: ::std::wstring guid;
	/// <summary>
	/// Action type.
	/// </summary>
	protected: EActionType type;
	/// <summary>
	/// Feed GUID.
	/// </summary>
	/// <remarks>
	/// This action belongs to the feed identified by this GUID.
	/// </remarks>
	protected: ::std::wstring feedGuid;
	/// <summary>
	/// Parent action GUID.
	/// </summary>
	/// <remarks>
	/// This element is only valid for user comments, {@link EActionType#UserComment}.
	/// If not empty, this action is subordinated under the action given by this GUID.
	/// </remarks>
	protected: ::std::wstring parentGuid;
	/// <summary>
	/// User GUID.
	/// </summary>
	/// <remarks>
	/// The GUID of the user who has created this action.
	/// For actions of type {@link EActionType#SordCreated}, this member holds the GUID of Sord.ownerId.
	/// For actions of type {@link EActionType#VersionCreated}, this member holds the GUID of DocVersion.ownerId.
	/// </remarks>
	protected: ::std::wstring userGuid;
	/// <summary>
	/// User ID.
	/// </summary>
	/// <remarks>
	/// It is set to the numerical ID of the user given by {@link #userGuid}.
	/// This element is read-only.
	/// </remarks>
	protected: int32_t userId;
	/// <summary>
	/// User name.
	/// </summary>
	/// <remarks>
	/// It is set to the name of the user given by {@link #userGuid}.
	/// This element is read-only.
	/// </remarks>
	protected: ::std::wstring userName;
	/// <summary>
	/// Create date.
	/// </summary>
	/// <remarks>
	/// This element is the ISO formatted create date of the action.
	/// When this object is received from {@link FeedService#checkoutAction(de.elo.ix.client.ClientInfo, String, ActionZ)}
	/// or {@link FeedService#findFirstActions(de.elo.ix.client.ClientInfo, FindActionsInfo, int, ActionZ)} the value
	/// is supplied in the time zone of the client application - which is UTC by default.
	/// In case of the object is received by a notify message in {@link FeedNotification#updateAction(Action)} the
	/// value is relative to the UTC timezone.
	/// In order to convert this value into a date object, invoke function {@link de.elo.ix.client.IXConnection#isoToDate}.
	/// </remarks>
	protected: ::std::wstring createDateIso;
	/// <summary>
	/// Update date.
	/// </summary>
	/// <remarks>
	/// This element is only valid for {@link EActionType#UserComment}.
	/// It holds the ISO formatted update date.
	/// When this object is received from {@link FeedService#checkoutAction(de.elo.ix.client.ClientInfo, String, ActionZ)}
	/// or {@link FeedService#findFirstActions(de.elo.ix.client.ClientInfo, FindActionsInfo, int, ActionZ)} the value
	/// is supplied in the time zone of the client application - which is UTC by default.
	/// In case of the object is received by a notify message in {@link FeedNotification#updateAction(Action)} the
	/// value is relative to the UTC timezone.
	/// In order to convert this value into a date object, invoke function {@link de.elo.ix.client.IXConnection#isoToDate}.
	/// </remarks>
	protected: ::std::wstring updateDateIso;
	/// <summary>
	/// Counts the number of updates.
	/// </summary>
	/// <remarks>
	/// This element is only valid for {@link EActionType#UserComment}.
	/// It counts the number of updates made to the comment.
	/// </remarks>
	protected: int32_t changeCounter;
	/// <summary>
	/// Comment text.
	/// </summary>
	/// <remarks>
	/// This element is only valid for {@link EActionType#UserComment},
	/// and {@link EActionType#AutoComment}.
	/// </remarks>
	protected: ::std::wstring text;
	/// <summary>
	/// GUID of the associated document version.
	/// </summary>
	/// <remarks>
	/// This element is only valid for generated actions that belong to a document version,
	/// e.g. {@link EActionType#VersionCreated}.
	/// Read-only.
	/// </remarks>
	protected: ::std::wstring docVersionGuid;
	/// <summary>
	/// Document version object.
	/// </summary>
	/// <remarks>
	/// This element is only valid for generated actions that belong to a document version,
	/// e.g. {@link EActionType#VersionCreated}.
	/// Read-only.
	/// </remarks>
	protected: de::elo::ix::client::PDocVersion docVersion;
	/// <summary>
	/// GUID of the associated workflow.
	/// </summary>
	/// <remarks>
	/// This element is valid for action types that belong to a workflow.
	/// </remarks>
	protected: ::std::wstring workflowGuid;
	/// <summary>
	/// Workflow object.
	/// </summary>
	/// <remarks>
	/// This element is only valid for generated actions that belong to a workflow.
	/// Read-only.
	/// </remarks>
	protected: de::elo::ix::client::PWFDiagram workflow;
	/// <summary>
	/// Time stamp.
	/// </summary>
	/// <remarks>
	/// Time stamp of creation or modification.
	/// </remarks>
	protected: ::std::wstring TStamp;
	/// <summary>
	/// Change history of text member.
	/// </summary>
	/// <remarks>
	/// This list does not contain the current text.
	/// This member is null, if the text has not been changed.
	/// </remarks>
	protected: PVectorActionHistory history;
	/// <summary>
	/// Raw ACL representation.
	/// </summary>
	/// <remarks>
	/// Only valid for Actions of type {@link EActionType#UserComment} or {@link EActionType#AutoComment}.
	/// This member is ignored if {@link Action#aclItems} is not null.
	/// </remarks>
	protected: ::std::wstring acl;
	/// <summary>
	/// Access control list.
	/// </summary>
	/// <remarks>
	/// Only valid for Actions of type {@link EActionType#UserComment} or {@link EActionType#AutoComment}.
	/// This member has precedence before {@link Action#acl}.
	/// </remarks>
	protected: de::elo::ix::client::PArrayAclItem aclItems;
	/// <summary>
	/// Timestamp of this object's last export by the replication.
	/// </summary>
	protected: ::std::wstring TStampSync;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: Action();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: Action(const ::std::wstring& guid, EActionType type, const ::std::wstring& feedGuid, const ::std::wstring& parentGuid, const ::std::wstring& userGuid, int32_t userId, const ::std::wstring& userName, const ::std::wstring& createDateIso, const ::std::wstring& updateDateIso, int32_t changeCounter, const ::std::wstring& text, const ::std::wstring& docVersionGuid, const de::elo::ix::client::PDocVersion& docVersion, const ::std::wstring& workflowGuid, const de::elo::ix::client::PWFDiagram& workflow, const ::std::wstring& TStamp, const PVectorActionHistory& history, const ::std::wstring& acl, const de::elo::ix::client::PArrayAclItem& aclItems, const ::std::wstring& TStampSync);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: ::std::wstring getGuid() { return guid; }
	public: void setGuid(::std::wstring v);
	public: EActionType getType() { return type; }
	public: void setType(EActionType v);
	public: ::std::wstring getFeedGuid() { return feedGuid; }
	public: void setFeedGuid(::std::wstring v);
	public: ::std::wstring getParentGuid() { return parentGuid; }
	public: void setParentGuid(::std::wstring v);
	public: ::std::wstring getUserGuid() { return userGuid; }
	public: void setUserGuid(::std::wstring v);
	public: int32_t getUserId() { return userId; }
	public: void setUserId(int32_t v);
	public: ::std::wstring getUserName() { return userName; }
	public: void setUserName(::std::wstring v);
	public: ::std::wstring getCreateDateIso() { return createDateIso; }
	public: void setCreateDateIso(::std::wstring v);
	public: ::std::wstring getUpdateDateIso() { return updateDateIso; }
	public: void setUpdateDateIso(::std::wstring v);
	public: int32_t getChangeCounter() { return changeCounter; }
	public: void setChangeCounter(int32_t v);
	public: ::std::wstring getText() { return text; }
	public: void setText(::std::wstring v);
	public: ::std::wstring getDocVersionGuid() { return docVersionGuid; }
	public: void setDocVersionGuid(::std::wstring v);
	public: de::elo::ix::client::PDocVersion getDocVersion() { return docVersion; }
	public: void setDocVersion(de::elo::ix::client::PDocVersion v);
	public: ::std::wstring getWorkflowGuid() { return workflowGuid; }
	public: void setWorkflowGuid(::std::wstring v);
	public: de::elo::ix::client::PWFDiagram getWorkflow() { return workflow; }
	public: void setWorkflow(de::elo::ix::client::PWFDiagram v);
	public: ::std::wstring getTStamp() { return TStamp; }
	public: void setTStamp(::std::wstring v);
	public: PVectorActionHistory getHistory() { return history; }
	public: void setHistory(PVectorActionHistory v);
	public: ::std::wstring getAcl() { return acl; }
	public: void setAcl(::std::wstring v);
	public: de::elo::ix::client::PArrayAclItem getAclItems() { return aclItems; }
	public: void setAclItems(de::elo::ix::client::PArrayAclItem v);
	public: ::std::wstring getTStampSync() { return TStampSync; }
	public: void setTStampSync(::std::wstring v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// ActionDataC
// typeId=423487901

namespace de { namespace elo { namespace ix { namespace client { namespace feed { 

using namespace ::byps;

/// <summary>
/// <p>Bit constants for members of Action</p>
/// <p>Copyright: Copyright (c) 2003</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </summary>
class ActionDataC : public BSerializable {
	/// <summary>
	/// Member bit: Action GUID.
	/// </summary>
	/// <remarks>
	/// DB column: actionguid
	/// </remarks>
	public: const static int64_t mbGuid = 1LL;
	/// <summary>
	/// Column length: Action GUID.
	/// </summary>
	/// <remarks>
	/// DB column: actionguid
	/// </remarks>
	protected: int32_t lnGuid;
	/// <summary>
	/// Member bit: Action type.
	/// </summary>
	/// <remarks>
	/// DB column: actiontype
	/// </remarks>
	public: const static int64_t mbRawType = 2LL;
	/// <summary>
	/// Member bit: Feed GUID.
	/// </summary>
	/// <remarks>
	/// DB column: feedguid
	/// </remarks>
	public: const static int64_t mbFeedGuid = 4LL;
	/// <summary>
	/// Column length: Feed GUID.
	/// </summary>
	/// <remarks>
	/// DB column: feedguid
	/// </remarks>
	protected: int32_t lnFeedGuid;
	/// <summary>
	/// Member bit: Parent action GUID.
	/// </summary>
	/// <remarks>
	/// DB column: parentguid
	/// </remarks>
	public: const static int64_t mbParentGuid = 8LL;
	/// <summary>
	/// Column length: Parent action GUID.
	/// </summary>
	/// <remarks>
	/// DB column: parentguid
	/// </remarks>
	protected: int32_t lnParentGuid;
	/// <summary>
	/// Member bit: User GUID.
	/// </summary>
	/// <remarks>
	/// DB column: userguid
	/// </remarks>
	public: const static int64_t mbUserGuid = 16LL;
	/// <summary>
	/// Column length: User GUID.
	/// </summary>
	/// <remarks>
	/// DB column: userguid
	/// </remarks>
	protected: int32_t lnUserGuid;
	/// <summary>
	/// Member bit: Create date.
	/// </summary>
	/// <remarks>
	/// DB column: createdateiso
	/// </remarks>
	public: const static int64_t mbCreateDateIso = 32LL;
	/// <summary>
	/// Column length: Create date.
	/// </summary>
	/// <remarks>
	/// DB column: createdateiso
	/// </remarks>
	protected: int32_t lnCreateDateIso;
	/// <summary>
	/// Member bit: Update date.
	/// </summary>
	/// <remarks>
	/// DB column: updatedateiso
	/// </remarks>
	public: const static int64_t mbUpdateDateIso = 64LL;
	/// <summary>
	/// Column length: Update date.
	/// </summary>
	/// <remarks>
	/// DB column: updatedateiso
	/// </remarks>
	protected: int32_t lnUpdateDateIso;
	/// <summary>
	/// Member bit: Counts the number of updates.
	/// </summary>
	/// <remarks>
	/// DB column: changecounter
	/// </remarks>
	public: const static int64_t mbChangeCounter = 128LL;
	/// <summary>
	/// Member bit: Comment text.
	/// </summary>
	/// <remarks>
	/// DB column: actiontext
	/// </remarks>
	public: const static int64_t mbText = 256LL;
	/// <summary>
	/// Column length: Comment text.
	/// </summary>
	/// <remarks>
	/// DB column: actiontext
	/// </remarks>
	protected: int32_t lnText;
	/// <summary>
	/// Member bit: GUID of the associated document version.
	/// </summary>
	/// <remarks>
	/// DB column: docversionguid
	/// </remarks>
	public: const static int64_t mbDocVersionGuid = 512LL;
	/// <summary>
	/// Column length: GUID of the associated document version.
	/// </summary>
	/// <remarks>
	/// DB column: docversionguid
	/// </remarks>
	protected: int32_t lnDocVersionGuid;
	/// <summary>
	/// Member bit: GUID of the associated workflow.
	/// </summary>
	/// <remarks>
	/// DB column: workflowguid
	/// </remarks>
	public: const static int64_t mbWorkflowGuid = 1024LL;
	/// <summary>
	/// Column length: GUID of the associated workflow.
	/// </summary>
	/// <remarks>
	/// DB column: workflowguid
	/// </remarks>
	protected: int32_t lnWorkflowGuid;
	/// <summary>
	/// Member bit: Time stamp.
	/// </summary>
	/// <remarks>
	/// DB column: actiontstamp
	/// </remarks>
	public: const static int64_t mbTStamp = 2048LL;
	/// <summary>
	/// Column length: Time stamp.
	/// </summary>
	/// <remarks>
	/// DB column: actiontstamp
	/// </remarks>
	protected: int32_t lnTStamp;
	/// <summary>
	/// Member bit: Raw ACL representation.
	/// </summary>
	/// <remarks>
	/// DB column: actionacl
	/// </remarks>
	public: const static int64_t mbAcl = 4096LL;
	/// <summary>
	/// Column length: Raw ACL representation.
	/// </summary>
	/// <remarks>
	/// DB column: actionacl
	/// </remarks>
	protected: int32_t lnAcl;
	/// <summary>
	/// Member bit: Timestamp of this object's last export by the replication.
	/// </summary>
	/// <remarks>
	/// DB column: actiontstampsync
	/// </remarks>
	public: const static int64_t mbTStampSync = 8192LL;
	/// <summary>
	/// Column length: Timestamp of this object's last export by the replication.
	/// </summary>
	/// <remarks>
	/// DB column: actiontstampsync
	/// </remarks>
	protected: int32_t lnTStampSync;
	/// <summary>
	/// All valid member bits.
	/// </summary>
	public: const static int64_t mbAllMembers = 16383LL;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: ActionDataC();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: ActionDataC(int64_t mbGuid, int32_t lnGuid, int64_t mbRawType, int64_t mbFeedGuid, int32_t lnFeedGuid, int64_t mbParentGuid, int32_t lnParentGuid, int64_t mbUserGuid, int32_t lnUserGuid, int64_t mbCreateDateIso, int32_t lnCreateDateIso, int64_t mbUpdateDateIso, int32_t lnUpdateDateIso, int64_t mbChangeCounter, int64_t mbText, int32_t lnText, int64_t mbDocVersionGuid, int32_t lnDocVersionGuid, int64_t mbWorkflowGuid, int32_t lnWorkflowGuid, int64_t mbTStamp, int32_t lnTStamp, int64_t mbAcl, int32_t lnAcl, int64_t mbTStampSync, int32_t lnTStampSync, int64_t mbAllMembers);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getLnGuid() { return lnGuid; }
	public: void setLnGuid(int32_t v);
	public: int32_t getLnFeedGuid() { return lnFeedGuid; }
	public: void setLnFeedGuid(int32_t v);
	public: int32_t getLnParentGuid() { return lnParentGuid; }
	public: void setLnParentGuid(int32_t v);
	public: int32_t getLnUserGuid() { return lnUserGuid; }
	public: void setLnUserGuid(int32_t v);
	public: int32_t getLnCreateDateIso() { return lnCreateDateIso; }
	public: void setLnCreateDateIso(int32_t v);
	public: int32_t getLnUpdateDateIso() { return lnUpdateDateIso; }
	public: void setLnUpdateDateIso(int32_t v);
	public: int32_t getLnText() { return lnText; }
	public: void setLnText(int32_t v);
	public: int32_t getLnDocVersionGuid() { return lnDocVersionGuid; }
	public: void setLnDocVersionGuid(int32_t v);
	public: int32_t getLnWorkflowGuid() { return lnWorkflowGuid; }
	public: void setLnWorkflowGuid(int32_t v);
	public: int32_t getLnTStamp() { return lnTStamp; }
	public: void setLnTStamp(int32_t v);
	public: int32_t getLnAcl() { return lnAcl; }
	public: void setLnAcl(int32_t v);
	public: int32_t getLnTStampSync() { return lnTStampSync; }
	public: void setLnTStampSync(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// ActionC
// typeId=1988394652

namespace de { namespace elo { namespace ix { namespace client { namespace feed { 

using namespace ::byps;

/// <summary>
/// Constants for class Action.
/// </summary>
class ActionC : public ActionDataC {
	public: const static int64_t mbDocVersion = 1099511627776LL;
	public: const static int64_t mbWorkflow = 2199023255552LL;
	public: const static int64_t mbHistory = 4398046511104LL;
	public: const static int64_t mbAllMembers = -1LL;
	/// <summary>
	/// All Action members without text, docVersion and workflow.
	/// </summary>
	public: const static PActionZ mbMin;
	/// <summary>
	/// All Action members.
	/// </summary>
	public: const static PActionZ mbAll;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: ActionC();
	
	public: virtual BTYPEID BSerializable_getTypeId();
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// ActionHistDataC
// typeId=734763371

namespace de { namespace elo { namespace ix { namespace client { namespace feed { 

using namespace ::byps;

/// <summary>
/// <p>Bit constants for members of ActionHistory</p>
/// <p>Copyright: Copyright (c) 2003</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </summary>
class ActionHistDataC : public BSerializable {
	/// <summary>
	/// Member bit: Action GUID.
	/// </summary>
	/// <remarks>
	/// DB column: actionguid
	/// </remarks>
	public: const static int64_t mbActionGuid = 1LL;
	/// <summary>
	/// Column length: Action GUID.
	/// </summary>
	/// <remarks>
	/// DB column: actionguid
	/// </remarks>
	protected: int32_t lnActionGuid;
	/// <summary>
	/// Member bit: Create date.
	/// </summary>
	/// <remarks>
	/// DB column: createdateiso
	/// </remarks>
	public: const static int64_t mbCreateDateIso = 2LL;
	/// <summary>
	/// Column length: Create date.
	/// </summary>
	/// <remarks>
	/// DB column: createdateiso
	/// </remarks>
	protected: int32_t lnCreateDateIso;
	/// <summary>
	/// Member bit: Comment text.
	/// </summary>
	/// <remarks>
	/// DB column: actiontext
	/// </remarks>
	public: const static int64_t mbText = 4LL;
	/// <summary>
	/// Column length: Comment text.
	/// </summary>
	/// <remarks>
	/// DB column: actiontext
	/// </remarks>
	protected: int32_t lnText;
	/// <summary>
	/// All valid member bits.
	/// </summary>
	public: const static int64_t mbAllMembers = 7LL;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: ActionHistDataC();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: ActionHistDataC(int64_t mbActionGuid, int32_t lnActionGuid, int64_t mbCreateDateIso, int32_t lnCreateDateIso, int64_t mbText, int32_t lnText, int64_t mbAllMembers);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getLnActionGuid() { return lnActionGuid; }
	public: void setLnActionGuid(int32_t v);
	public: int32_t getLnCreateDateIso() { return lnCreateDateIso; }
	public: void setLnCreateDateIso(int32_t v);
	public: int32_t getLnText() { return lnText; }
	public: void setLnText(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// ActionHistory
// typeId=598833764

namespace de { namespace elo { namespace ix { namespace client { namespace feed { 

using namespace ::byps;

class ActionHistory : public de::elo::ix::client::ValueClass {
	/// <summary>
	/// Action GUID.
	/// </summary>
	/// <remarks>
	/// Unique identifier.
	/// </remarks>
	protected: ::std::wstring actionGuid;
	/// <summary>
	/// Create date.
	/// </summary>
	/// <remarks>
	/// This element is the ISO formatted create date of the action in the time zone of the client application.
	/// In order to convert this value into a date object, invoke function {@link de.elo.ix.client.IXConnection#isoToDate}.
	/// </remarks>
	protected: ::std::wstring createDateIso;
	/// <summary>
	/// Comment text.
	/// </summary>
	/// <remarks>
	/// This element is only valid for {@link EActionType#UserComment},
	/// and {@link EActionType#AutoComment}.
	/// </remarks>
	protected: ::std::wstring text;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: ActionHistory();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: ActionHistory(const ::std::wstring& actionGuid, const ::std::wstring& createDateIso, const ::std::wstring& text);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: ::std::wstring getActionGuid() { return actionGuid; }
	public: void setActionGuid(::std::wstring v);
	public: ::std::wstring getCreateDateIso() { return createDateIso; }
	public: void setCreateDateIso(::std::wstring v);
	public: ::std::wstring getText() { return text; }
	public: void setText(::std::wstring v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// ActionHistoryC
// typeId=442981425

namespace de { namespace elo { namespace ix { namespace client { namespace feed { 

using namespace ::byps;

class ActionHistoryC : public ActionHistDataC {
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: ActionHistoryC();
	
	public: virtual BTYPEID BSerializable_getTypeId();
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// ActionZ
// typeId=1006784044

namespace de { namespace elo { namespace ix { namespace client { namespace feed { 

using namespace ::byps;

/// <summary>
/// Type safe element selector for class Action.
/// </summary>
class ActionZ : public BSerializable {
	protected: int64_t bset;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: ActionZ();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: ActionZ(int64_t bset);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int64_t getBset() { return bset; }
	public: void setBset(int64_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// Feed
// typeId=556531185

namespace de { namespace elo { namespace ix { namespace client { namespace feed { 

using namespace ::byps;

/// <summary>
/// This class represents a document feed.
/// </summary>
/// <remarks>
/// Each Sord can have at most one Feed object. A Feed contains of a list of Action objects which can be user comments,
/// comments generated by scripts and actions generated by the system.
/// The Feed object acts like a header for the list of actions. Its main purpose is the mapping between feed actions and a Sord object.
/// In order to receive a feed of a Sord object inclusive all actions, call function {@link FeedService#findFirstActions(de.elo.ix.client.ClientInfo, FindActionsInfo, int, ActionZ)}.
/// </remarks>
class Feed : public de::elo::ix::client::ValueClass {
	/// <summary>
	/// Feed GUID.
	/// </summary>
	protected: ::std::wstring guid;
	/// <summary>
	/// Create date.
	/// </summary>
	/// <remarks>
	/// It holds the ISO formatted create date in the time zone of the client application.
	/// In order to convert this value into a date object, invoke function {@link de.elo.ix.client.IXConnection#isoToDate}.
	/// </remarks>
	protected: ::std::wstring createDateIso;
	/// <summary>
	/// Time stamp.
	/// </summary>
	/// <remarks>
	/// Time stamp of creation or modification.
	/// </remarks>
	protected: ::std::wstring tStamp;
	/// <summary>
	/// GUID of the associated Sord object.
	/// </summary>
	protected: ::std::wstring objGuid;
	/// <summary>
	/// Timestamp of this object's last export by the replication.
	/// </summary>
	protected: ::std::wstring TStampSync;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: Feed();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: Feed(const ::std::wstring& guid, const ::std::wstring& createDateIso, const ::std::wstring& tStamp, const ::std::wstring& objGuid, const ::std::wstring& TStampSync);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: ::std::wstring getGuid() { return guid; }
	public: void setGuid(::std::wstring v);
	public: ::std::wstring getCreateDateIso() { return createDateIso; }
	public: void setCreateDateIso(::std::wstring v);
	public: ::std::wstring getTStamp() { return tStamp; }
	public: void setTStamp(::std::wstring v);
	public: ::std::wstring getObjGuid() { return objGuid; }
	public: void setObjGuid(::std::wstring v);
	public: ::std::wstring getTStampSync() { return TStampSync; }
	public: void setTStampSync(::std::wstring v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// FeedDataC
// typeId=1837685365

namespace de { namespace elo { namespace ix { namespace client { namespace feed { 

using namespace ::byps;

/// <summary>
/// <p>Bit constants for members of Feed</p>
/// <p>Copyright: Copyright (c) 2003</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </summary>
class FeedDataC : public BSerializable {
	/// <summary>
	/// Member bit: Feed GUID.
	/// </summary>
	/// <remarks>
	/// DB column: feedguid
	/// </remarks>
	public: const static int64_t mbGuid = 1LL;
	/// <summary>
	/// Column length: Feed GUID.
	/// </summary>
	/// <remarks>
	/// DB column: feedguid
	/// </remarks>
	protected: int32_t lnGuid;
	/// <summary>
	/// Member bit: Create date.
	/// </summary>
	/// <remarks>
	/// DB column: createdateiso
	/// </remarks>
	public: const static int64_t mbCreateDateIso = 2LL;
	/// <summary>
	/// Column length: Create date.
	/// </summary>
	/// <remarks>
	/// DB column: createdateiso
	/// </remarks>
	protected: int32_t lnCreateDateIso;
	/// <summary>
	/// Member bit: Time stamp.
	/// </summary>
	/// <remarks>
	/// DB column: feedtstamp
	/// </remarks>
	public: const static int64_t mbTStamp = 4LL;
	/// <summary>
	/// Column length: Time stamp.
	/// </summary>
	/// <remarks>
	/// DB column: feedtstamp
	/// </remarks>
	protected: int32_t lnTStamp;
	/// <summary>
	/// Member bit: GUID of the associated Sord object.
	/// </summary>
	/// <remarks>
	/// DB column: objguid
	/// </remarks>
	public: const static int64_t mbObjGuid = 8LL;
	/// <summary>
	/// Column length: GUID of the associated Sord object.
	/// </summary>
	/// <remarks>
	/// DB column: objguid
	/// </remarks>
	protected: int32_t lnObjGuid;
	/// <summary>
	/// Member bit: Timestamp of this object's last export by the replication.
	/// </summary>
	/// <remarks>
	/// DB column: feedtstampsync
	/// </remarks>
	public: const static int64_t mbTStampSync = 16LL;
	/// <summary>
	/// Column length: Timestamp of this object's last export by the replication.
	/// </summary>
	/// <remarks>
	/// DB column: feedtstampsync
	/// </remarks>
	protected: int32_t lnTStampSync;
	/// <summary>
	/// All valid member bits.
	/// </summary>
	public: const static int64_t mbAllMembers = 31LL;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: FeedDataC();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: FeedDataC(int64_t mbGuid, int32_t lnGuid, int64_t mbCreateDateIso, int32_t lnCreateDateIso, int64_t mbTStamp, int32_t lnTStamp, int64_t mbObjGuid, int32_t lnObjGuid, int64_t mbTStampSync, int32_t lnTStampSync, int64_t mbAllMembers);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getLnGuid() { return lnGuid; }
	public: void setLnGuid(int32_t v);
	public: int32_t getLnCreateDateIso() { return lnCreateDateIso; }
	public: void setLnCreateDateIso(int32_t v);
	public: int32_t getLnTStamp() { return lnTStamp; }
	public: void setLnTStamp(int32_t v);
	public: int32_t getLnObjGuid() { return lnObjGuid; }
	public: void setLnObjGuid(int32_t v);
	public: int32_t getLnTStampSync() { return lnTStampSync; }
	public: void setLnTStampSync(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// FeedC
// typeId=1754071588

namespace de { namespace elo { namespace ix { namespace client { namespace feed { 

using namespace ::byps;

/// <summary>
/// Constants for class Feed.
/// </summary>
class FeedC : public FeedDataC {
	public: const static PFeedZ mbAll;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: FeedC();
	
	public: virtual BTYPEID BSerializable_getTypeId();
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// FeedZ
// typeId=126672288

namespace de { namespace elo { namespace ix { namespace client { namespace feed { 

using namespace ::byps;

/// <summary>
/// Type safe element selector for class Feed.
/// </summary>
class FeedZ : public BSerializable {
	protected: int64_t bset;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: FeedZ();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: FeedZ(int64_t bset);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int64_t getBset() { return bset; }
	public: void setBset(int64_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// FindActionsInfo
// typeId=1747180074

namespace de { namespace elo { namespace ix { namespace client { namespace feed { 

using namespace ::byps;

/// <summary>
/// Describes search criteria for
/// {@link FeedService#findFirstActions(de.elo.ix.client.ClientInfo, FindActionsInfo, int, ActionZ)}.
/// </summary>
/// <remarks>
/// <p>
/// If only objId is set, userId and createDateIso is empty, the entire
/// document feed of the given object is returned. The (main) actions are sorted
/// descending by create date. The answers (child actions) follow immediately
/// their associated main action. Answers are sorted ascending by create date.
/// </p>
/// <p>
/// If any other member is also set, or if objId is combined with another member, the search combines the elements by logical AND.
/// The result list contains all actions sorted descending by create date. The ordering does not distinguish between
/// main actions and child actions.
/// </p>
/// </remarks>
class FindActionsInfo : public BSerializable {
	/// <summary>
	/// Search by Sord ID, GUID, etc.
	/// </summary>
	/// <remarks>
	/// This value can be an ID, a GUID or an expression as defined
	/// in {@link de.elo.ix.client.IXServicePortIF#checkoutSord(de.elo.ix.client.ClientInfo, String, de.elo.ix.client.EditInfoZ, de.elo.ix.client.LockZ)}.
	/// </remarks>
	protected: ::std::wstring objId;
	/// <summary>
	/// Search by user ID, GUID, name.
	/// </summary>
	protected: ::std::wstring userId;
	/// <summary>
	/// Search by create date.
	/// </summary>
	/// <remarks>
	/// A date range can be specified by using the default range delimiter "..."
	/// or the one defined in {@link de.elo.ix.client.FindOptions#getRangeDelimiter()}.
	/// </remarks>
	protected: ::std::wstring createDateIso;
	/// <summary>
	/// Search by action types.
	/// </summary>
	/// <remarks>
	/// If this element is empty, actions of all types are returned.
	/// </remarks>
	protected: PVectorEActionType actionTypes;
	/// <summary>
	/// Search for notifications.
	/// </summary>
	/// <remarks>
	/// If this member is true, only those actions are found for which the
	/// user was notified.
	/// </remarks>
	protected: bool findNotifications;
	/// <summary>
	/// Search for HashTags
	/// If this member is true, all HashTags within the action will be returned
	/// </summary>
	protected: bool findHashTags;
	/// <summary>
	/// If true a Map<String, Subscription> will be set in the FindResult
	/// </summary>
	protected: bool findSubscriptions;
	/// <summary>
	/// Sord element selector.
	/// </summary>
	/// <remarks>
	/// If this member is not null or empty, the returned FindResult object
	/// contains the associated Sord objects in FindResult.sords.
	/// </remarks>
	protected: de::elo::ix::client::PSordZ sordZ;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: FindActionsInfo();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: FindActionsInfo(const ::std::wstring& objId, const ::std::wstring& userId, const ::std::wstring& createDateIso, const PVectorEActionType& actionTypes, bool findNotifications, bool findHashTags, bool findSubscriptions, const de::elo::ix::client::PSordZ& sordZ);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: ::std::wstring getObjId() { return objId; }
	public: void setObjId(::std::wstring v);
	public: ::std::wstring getUserId() { return userId; }
	public: void setUserId(::std::wstring v);
	public: ::std::wstring getCreateDateIso() { return createDateIso; }
	public: void setCreateDateIso(::std::wstring v);
	public: PVectorEActionType getActionTypes() { return actionTypes; }
	public: void setActionTypes(PVectorEActionType v);
	public: bool getFindNotifications() { return findNotifications; }
	public: void setFindNotifications(bool v);
	public: bool getFindHashTags() { return findHashTags; }
	public: void setFindHashTags(bool v);
	public: bool getFindSubscriptions() { return findSubscriptions; }
	public: void setFindSubscriptions(bool v);
	public: de::elo::ix::client::PSordZ getSordZ() { return sordZ; }
	public: void setSordZ(de::elo::ix::client::PSordZ v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// FindActionsInfoC
// typeId=815857210

namespace de { namespace elo { namespace ix { namespace client { namespace feed { 

using namespace ::byps;

/// <summary>
/// Constants for FindActionInfo and findFirstActions.
/// </summary>
class FindActionsInfoC : public BSerializable {
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: FindActionsInfoC();
	
	public: virtual BTYPEID BSerializable_getTypeId();
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// FindHashTagInfo
// typeId=256103952

namespace de { namespace elo { namespace ix { namespace client { namespace feed { 

using namespace ::byps;

class FindHashTagInfo : public BSerializable {
	/// <summary>
	/// HashTag Guid or Name
	/// </summary>
	protected: ::std::wstring hashtagGuidOrName;
	/// <summary>
	/// Search by create date.
	/// </summary>
	/// <remarks>
	/// A date range can be specified by using the default range delimiter "..."
	/// or the one defined in {@link de.elo.ix.client.FindOptions#getRangeDelimiter()}.
	/// </remarks>
	protected: ::std::wstring createDateIso;
	/// <summary>
	/// Search by last used.
	/// </summary>
	/// <remarks>
	/// A date range can be specified by using the default range delimiter "..."
	/// or the one defined in {@link de.elo.ix.client.FindOptions#getRangeDelimiter()}.
	/// </remarks>
	protected: ::std::wstring lastUsedIso;
	/// <summary>
	/// Filter the result by number of use.
	/// </summary>
	/// <remarks>
	/// Only HashTags with >= minCount will be returned
	/// </remarks>
	protected: int32_t minCount;
	/// <summary>
	/// Action element selector.
	/// </summary>
	protected: PActionZ actionZ;
	/// <summary>
	/// Sord element selector.
	/// </summary>
	protected: de::elo::ix::client::PSordZ sordZ;
	/// <summary>
	/// If true a Map<String, Feed> will be set in the FindResult.
	/// </summary>
	/// <remarks>
	/// by default true
	/// </remarks>
	protected: bool findFeeds;
	protected: bool findHashTags;
	/// <summary>
	/// If true a Map<String, Subscription> will be set in the FindResult
	/// </summary>
	protected: bool findSubscriptions;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: FindHashTagInfo();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: FindHashTagInfo(const ::std::wstring& hashtagGuidOrName, const ::std::wstring& createDateIso, const ::std::wstring& lastUsedIso, int32_t minCount, const PActionZ& actionZ, const de::elo::ix::client::PSordZ& sordZ, bool findFeeds, bool findHashTags, bool findSubscriptions);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: ::std::wstring getHashtagGuidOrName() { return hashtagGuidOrName; }
	public: void setHashtagGuidOrName(::std::wstring v);
	public: ::std::wstring getCreateDateIso() { return createDateIso; }
	public: void setCreateDateIso(::std::wstring v);
	public: ::std::wstring getLastUsedIso() { return lastUsedIso; }
	public: void setLastUsedIso(::std::wstring v);
	public: int32_t getMinCount() { return minCount; }
	public: void setMinCount(int32_t v);
	public: PActionZ getActionZ() { return actionZ; }
	public: void setActionZ(PActionZ v);
	public: de::elo::ix::client::PSordZ getSordZ() { return sordZ; }
	public: void setSordZ(de::elo::ix::client::PSordZ v);
	public: bool getFindFeeds() { return findFeeds; }
	public: void setFindFeeds(bool v);
	public: bool getFindHashTags() { return findHashTags; }
	public: void setFindHashTags(bool v);
	public: bool getFindSubscriptions() { return findSubscriptions; }
	public: void setFindSubscriptions(bool v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// FindNotificationInfo
// typeId=432579435

namespace de { namespace elo { namespace ix { namespace client { namespace feed { 

using namespace ::byps;

/// <summary>
/// FindInfo for FindFirstNotifications.
/// </summary>
class FindNotificationInfo : public BSerializable {
	/// <summary>
	/// GUID or ID or Name of the User.
	/// </summary>
	/// <remarks>
	/// If null, current user will be set.
	/// If GUID/ID is not the current user, admin rights are needed to preform the search
	/// </remarks>
	protected: ::std::wstring userGuidOrID;
	protected: int32_t what;
	/// <summary>
	/// Search by create date.
	/// </summary>
	/// <remarks>
	/// A date range can be specified by using the default range delimiter "..."
	/// or the one defined in {@link de.elo.ix.client.FindOptions#getRangeDelimiter()}.
	/// </remarks>
	protected: ::std::wstring createDateIso;
	/// <summary>
	/// If true and createDateIso is set, it will also return all Notifications marked as Important even if they are not
	/// in the specified createDate range.
	/// </summary>
	/// <remarks>
	/// If true and createDateIso is not set, it will return only Notifications marked as Important
	/// </remarks>
	protected: bool inclImportant;
	/// <summary>
	/// Sord element selector.
	/// </summary>
	protected: de::elo::ix::client::PSordZ sordZ;
	/// <summary>
	/// Action element selector.
	/// </summary>
	protected: PActionZ actionZ;
	/// <summary>
	/// If true a Map<String, Feed> will be set in the FindResult.
	/// </summary>
	/// <remarks>
	/// by default true
	/// </remarks>
	protected: bool findFeeds;
	/// <summary>
	/// If true a List<HashTagRelation> and a Map<String, HashTag> will be set in the FindResult
	/// </summary>
	protected: bool findHashTags;
	/// <summary>
	/// If true a Map<String, Subscription> will be set in the FindResult
	/// </summary>
	protected: bool findSubscriptions;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: FindNotificationInfo();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: FindNotificationInfo(const ::std::wstring& userGuidOrID, int32_t what, const ::std::wstring& createDateIso, bool inclImportant, const de::elo::ix::client::PSordZ& sordZ, const PActionZ& actionZ, bool findFeeds, bool findHashTags, bool findSubscriptions);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: ::std::wstring getUserGuidOrID() { return userGuidOrID; }
	public: void setUserGuidOrID(::std::wstring v);
	public: int32_t getWhat() { return what; }
	public: void setWhat(int32_t v);
	public: ::std::wstring getCreateDateIso() { return createDateIso; }
	public: void setCreateDateIso(::std::wstring v);
	public: bool getInclImportant() { return inclImportant; }
	public: void setInclImportant(bool v);
	public: de::elo::ix::client::PSordZ getSordZ() { return sordZ; }
	public: void setSordZ(de::elo::ix::client::PSordZ v);
	public: PActionZ getActionZ() { return actionZ; }
	public: void setActionZ(PActionZ v);
	public: bool getFindFeeds() { return findFeeds; }
	public: void setFindFeeds(bool v);
	public: bool getFindHashTags() { return findHashTags; }
	public: void setFindHashTags(bool v);
	public: bool getFindSubscriptions() { return findSubscriptions; }
	public: void setFindSubscriptions(bool v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// HashTag
// typeId=1143177929

namespace de { namespace elo { namespace ix { namespace client { namespace feed { 

using namespace ::byps;

/// <summary>
/// This class represents a HashTag
/// </summary>
class HashTag : public de::elo::ix::client::ValueClass {
	/// <summary>
	/// HashTag GUID.
	/// </summary>
	/// <remarks>
	/// Unique identifier.
	/// </remarks>
	protected: ::std::wstring hstgGuid;
	/// <summary>
	/// HashTag Name.
	/// </summary>
	protected: ::std::wstring hstgName;
	/// <summary>
	/// Create date.
	/// </summary>
	/// <remarks>
	/// It holds the ISO formatted create date in the time zone of the client application.
	/// In order to convert this value into a date object, invoke function {@link de.elo.ix.client.IXConnection#isoToDate}.
	/// </remarks>
	protected: ::std::wstring createDateIso;
	/// <summary>
	/// Last used.
	/// </summary>
	/// <remarks>
	/// It holds the ISO formatted date of the last use of this HashTag
	/// In order to convert this value into a date object, invoke function {@link de.elo.ix.client.IXConnection#isoToDate}.
	/// </remarks>
	protected: ::std::wstring lastUsedIso;
	/// <summary>
	/// Counter.
	/// </summary>
	/// <remarks>
	/// Counts how often this HashTag is used.
	/// </remarks>
	protected: int32_t counter;
	/// <summary>
	/// Timestamp for replication.
	/// </summary>
	protected: ::std::wstring tStamp;
	/// <summary>
	/// Status.
	/// </summary>
	protected: int32_t status;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: HashTag();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: HashTag(const ::std::wstring& hstgGuid, const ::std::wstring& hstgName, const ::std::wstring& createDateIso, const ::std::wstring& lastUsedIso, int32_t counter, const ::std::wstring& tStamp, int32_t status);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: ::std::wstring getHstgGuid() { return hstgGuid; }
	public: void setHstgGuid(::std::wstring v);
	public: ::std::wstring getHstgName() { return hstgName; }
	public: void setHstgName(::std::wstring v);
	public: ::std::wstring getCreateDateIso() { return createDateIso; }
	public: void setCreateDateIso(::std::wstring v);
	public: ::std::wstring getLastUsedIso() { return lastUsedIso; }
	public: void setLastUsedIso(::std::wstring v);
	public: int32_t getCounter() { return counter; }
	public: void setCounter(int32_t v);
	public: ::std::wstring getTStamp() { return tStamp; }
	public: void setTStamp(::std::wstring v);
	public: int32_t getStatus() { return status; }
	public: void setStatus(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// HashTagDataC
// typeId=513648569

namespace de { namespace elo { namespace ix { namespace client { namespace feed { 

using namespace ::byps;

/// <summary>
/// <p>Bit constants for members of HashTag</p>
/// <p>Copyright: Copyright (c) 2003</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </summary>
class HashTagDataC : public BSerializable {
	/// <summary>
	/// Member bit: HashTag GUID.
	/// </summary>
	/// <remarks>
	/// DB column: hstgguid
	/// </remarks>
	public: const static int64_t mbHstgGuid = 1LL;
	/// <summary>
	/// Column length: HashTag GUID.
	/// </summary>
	/// <remarks>
	/// DB column: hstgguid
	/// </remarks>
	protected: int32_t lnHstgGuid;
	/// <summary>
	/// Member bit: HashTag Name.
	/// </summary>
	/// <remarks>
	/// DB column: hstgname
	/// </remarks>
	public: const static int64_t mbHstgName = 2LL;
	/// <summary>
	/// Column length: HashTag Name.
	/// </summary>
	/// <remarks>
	/// DB column: hstgname
	/// </remarks>
	protected: int32_t lnHstgName;
	/// <summary>
	/// Member bit: Create date.
	/// </summary>
	/// <remarks>
	/// DB column: createdateiso
	/// </remarks>
	public: const static int64_t mbCreateDateIso = 4LL;
	/// <summary>
	/// Column length: Create date.
	/// </summary>
	/// <remarks>
	/// DB column: createdateiso
	/// </remarks>
	protected: int32_t lnCreateDateIso;
	/// <summary>
	/// Member bit: Last used.
	/// </summary>
	/// <remarks>
	/// DB column: lastusediso
	/// </remarks>
	public: const static int64_t mbLastUsedIso = 8LL;
	/// <summary>
	/// Column length: Last used.
	/// </summary>
	/// <remarks>
	/// DB column: lastusediso
	/// </remarks>
	protected: int32_t lnLastUsedIso;
	/// <summary>
	/// Member bit: Timestamp for replication.
	/// </summary>
	/// <remarks>
	/// DB column: tstamp
	/// </remarks>
	public: const static int64_t mbTStamp = 16LL;
	/// <summary>
	/// Column length: Timestamp for replication.
	/// </summary>
	/// <remarks>
	/// DB column: tstamp
	/// </remarks>
	protected: int32_t lnTStamp;
	/// <summary>
	/// Member bit: Status.
	/// </summary>
	/// <remarks>
	/// DB column: status
	/// </remarks>
	public: const static int64_t mbStatus = 32LL;
	/// <summary>
	/// All valid member bits.
	/// </summary>
	public: const static int64_t mbAllMembers = 63LL;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: HashTagDataC();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: HashTagDataC(int64_t mbHstgGuid, int32_t lnHstgGuid, int64_t mbHstgName, int32_t lnHstgName, int64_t mbCreateDateIso, int32_t lnCreateDateIso, int64_t mbLastUsedIso, int32_t lnLastUsedIso, int64_t mbTStamp, int32_t lnTStamp, int64_t mbStatus, int64_t mbAllMembers);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getLnHstgGuid() { return lnHstgGuid; }
	public: void setLnHstgGuid(int32_t v);
	public: int32_t getLnHstgName() { return lnHstgName; }
	public: void setLnHstgName(int32_t v);
	public: int32_t getLnCreateDateIso() { return lnCreateDateIso; }
	public: void setLnCreateDateIso(int32_t v);
	public: int32_t getLnLastUsedIso() { return lnLastUsedIso; }
	public: void setLnLastUsedIso(int32_t v);
	public: int32_t getLnTStamp() { return lnTStamp; }
	public: void setLnTStamp(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// HashTagC
// typeId=250741620

namespace de { namespace elo { namespace ix { namespace client { namespace feed { 

using namespace ::byps;

/// <summary>
/// Constants for class HashTag
/// </summary>
class HashTagC : public HashTagDataC {
	public: const static PHashTagZ mbAll;
	public: const static PHashTagZ mbGuid;
	public: const static PHashTagZ mbLastUsed;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: HashTagC();
	
	public: virtual BTYPEID BSerializable_getTypeId();
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// HashTagRelation
// typeId=1313473584

namespace de { namespace elo { namespace ix { namespace client { namespace feed { 

using namespace ::byps;

/// <summary>
/// This class represents the relation between HashTags and Actions.
/// </summary>
class HashTagRelation : public de::elo::ix::client::ValueClass {
	/// <summary>
	/// Guid of the HashTag.
	/// </summary>
	protected: ::std::wstring hashtagGuid;
	/// <summary>
	/// Guid of the Action in which the HashTag is used.
	/// </summary>
	protected: ::std::wstring actionGuid;
	/// <summary>
	/// Timestamp for replication.
	/// </summary>
	protected: ::std::wstring tStamp;
	/// <summary>
	/// Status.
	/// </summary>
	protected: int32_t status;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: HashTagRelation();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: HashTagRelation(const ::std::wstring& hashtagGuid, const ::std::wstring& actionGuid, const ::std::wstring& tStamp, int32_t status);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: ::std::wstring getHashtagGuid() { return hashtagGuid; }
	public: void setHashtagGuid(::std::wstring v);
	public: ::std::wstring getActionGuid() { return actionGuid; }
	public: void setActionGuid(::std::wstring v);
	public: ::std::wstring getTStamp() { return tStamp; }
	public: void setTStamp(::std::wstring v);
	public: int32_t getStatus() { return status; }
	public: void setStatus(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// HashTagRelationDataC
// typeId=2035445347

namespace de { namespace elo { namespace ix { namespace client { namespace feed { 

using namespace ::byps;

/// <summary>
/// <p>Bit constants for members of HashTagRelation</p>
/// <p>Copyright: Copyright (c) 2003</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </summary>
class HashTagRelationDataC : public BSerializable {
	/// <summary>
	/// Member bit: Guid of the HashTag.
	/// </summary>
	/// <remarks>
	/// DB column: hashtagguid
	/// </remarks>
	public: const static int64_t mbHashtagGuid = 1LL;
	/// <summary>
	/// Column length: Guid of the HashTag.
	/// </summary>
	/// <remarks>
	/// DB column: hashtagguid
	/// </remarks>
	protected: int32_t lnHashtagGuid;
	/// <summary>
	/// Member bit: Guid of the Action in which the HashTag is used.
	/// </summary>
	/// <remarks>
	/// DB column: actionguid
	/// </remarks>
	public: const static int64_t mbActionGuid = 2LL;
	/// <summary>
	/// Column length: Guid of the Action in which the HashTag is used.
	/// </summary>
	/// <remarks>
	/// DB column: actionguid
	/// </remarks>
	protected: int32_t lnActionGuid;
	/// <summary>
	/// Member bit: Timestamp for replication.
	/// </summary>
	/// <remarks>
	/// DB column: tstamp
	/// </remarks>
	public: const static int64_t mbTStamp = 4LL;
	/// <summary>
	/// Column length: Timestamp for replication.
	/// </summary>
	/// <remarks>
	/// DB column: tstamp
	/// </remarks>
	protected: int32_t lnTStamp;
	/// <summary>
	/// Member bit: Status.
	/// </summary>
	/// <remarks>
	/// DB column: status
	/// </remarks>
	public: const static int64_t mbStatus = 8LL;
	/// <summary>
	/// All valid member bits.
	/// </summary>
	public: const static int64_t mbAllMembers = 15LL;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: HashTagRelationDataC();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: HashTagRelationDataC(int64_t mbHashtagGuid, int32_t lnHashtagGuid, int64_t mbActionGuid, int32_t lnActionGuid, int64_t mbTStamp, int32_t lnTStamp, int64_t mbStatus, int64_t mbAllMembers);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getLnHashtagGuid() { return lnHashtagGuid; }
	public: void setLnHashtagGuid(int32_t v);
	public: int32_t getLnActionGuid() { return lnActionGuid; }
	public: void setLnActionGuid(int32_t v);
	public: int32_t getLnTStamp() { return lnTStamp; }
	public: void setLnTStamp(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// HashTagRelationC
// typeId=747134350

namespace de { namespace elo { namespace ix { namespace client { namespace feed { 

using namespace ::byps;

/// <summary>
/// Constants for class HashTag
/// </summary>
class HashTagRelationC : public HashTagRelationDataC {
	public: const static PHashTagRelationZ mbAll;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: HashTagRelationC();
	
	public: virtual BTYPEID BSerializable_getTypeId();
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// HashTagRelationZ
// typeId=509234307

namespace de { namespace elo { namespace ix { namespace client { namespace feed { 

using namespace ::byps;

class HashTagRelationZ : public BSerializable {
	protected: int64_t bset;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: HashTagRelationZ();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: HashTagRelationZ(int64_t bset);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int64_t getBset() { return bset; }
	public: void setBset(int64_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// HashTagZ
// typeId=1664941037

namespace de { namespace elo { namespace ix { namespace client { namespace feed { 

using namespace ::byps;

class HashTagZ : public BSerializable {
	protected: int64_t bset;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: HashTagZ();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: HashTagZ(int64_t bset);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int64_t getBset() { return bset; }
	public: void setBset(int64_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// HealthCheckInfo
// typeId=585951890

namespace de { namespace elo { namespace ix { namespace client { namespace health { 

using namespace ::byps;

/// <summary>
/// This class represents one value for health check evaluation.
/// </summary>
class HealthCheckInfo : public de::elo::ix::client::ValueClass {
	/// <summary>
	/// Value name.
	/// </summary>
	protected: ::std::wstring name;
	/// <summary>
	/// String value.
	/// </summary>
	/// <remarks>
	/// Either this or {@link #doubleValue} has to be set.
	/// </remarks>
	protected: ::std::wstring stringValue;
	/// <summary>
	/// Numeric value.
	/// </summary>
	/// <remarks>
	/// Either this value or {@link #stringValue} has to be set.
	/// </remarks>
	protected: double doubleValue;
	/// <summary>
	/// Sample size for mean values.
	/// </summary>
	/// <remarks>
	/// If {@link #doubleValue} is a arithmetic mean, this value gives the
	/// number of the underlying samples.
	/// If {@link #stringValue} is set, this value has to be 0.
	/// </remarks>
	protected: int64_t sampleSize;
	/// <summary>
	/// Operation to process when updating the value.
	/// </summary>
	protected: HealthCheckValueOperation operation;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: HealthCheckInfo();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: HealthCheckInfo(const ::std::wstring& name, const ::std::wstring& stringValue, double doubleValue, int64_t sampleSize, HealthCheckValueOperation operation);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: ::std::wstring getName() { return name; }
	public: void setName(::std::wstring v);
	public: ::std::wstring getStringValue() { return stringValue; }
	public: void setStringValue(::std::wstring v);
	public: double getDoubleValue() { return doubleValue; }
	public: void setDoubleValue(double v);
	public: int64_t getSampleSize() { return sampleSize; }
	public: void setSampleSize(int64_t v);
	public: HealthCheckValueOperation getOperation() { return operation; }
	public: void setOperation(HealthCheckValueOperation v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// HealthCheckInfoC
// typeId=526645641

namespace de { namespace elo { namespace ix { namespace client { namespace health { 

using namespace ::byps;

/// <summary>
/// <p>Bit constants for members of HealthCheckInfo</p>
/// <p>Copyright: Copyright (c) 2003</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </summary>
class HealthCheckInfoC : public BSerializable {
	/// <summary>
	/// Member bit: Value name.
	/// </summary>
	/// <remarks>
	/// DB column: name
	/// </remarks>
	public: const static int64_t mbName = 1LL;
	/// <summary>
	/// Column length: Value name.
	/// </summary>
	/// <remarks>
	/// DB column: name
	/// </remarks>
	protected: int32_t lnName;
	/// <summary>
	/// Member bit: String value.
	/// </summary>
	/// <remarks>
	/// DB column: stringValue
	/// </remarks>
	public: const static int64_t mbStringValue = 2LL;
	/// <summary>
	/// Column length: String value.
	/// </summary>
	/// <remarks>
	/// DB column: stringValue
	/// </remarks>
	protected: int32_t lnStringValue;
	/// <summary>
	/// Member bit: Numeric value.
	/// </summary>
	/// <remarks>
	/// DB column: doubleValue
	/// </remarks>
	public: const static int64_t mbDoubleValue = 4LL;
	/// <summary>
	/// Column length: Numeric value.
	/// </summary>
	/// <remarks>
	/// DB column: doubleValue
	/// </remarks>
	protected: int32_t lnDoubleValue;
	/// <summary>
	/// Member bit: Sample size for mean values.
	/// </summary>
	/// <remarks>
	/// DB column: sampleSize
	/// </remarks>
	public: const static int64_t mbSampleSize = 8LL;
	/// <summary>
	/// Column length: Sample size for mean values.
	/// </summary>
	/// <remarks>
	/// DB column: sampleSize
	/// </remarks>
	protected: int32_t lnSampleSize;
	/// <summary>
	/// All valid member bits.
	/// </summary>
	public: const static int64_t mbAllMembers = 15LL;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: HealthCheckInfoC();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: HealthCheckInfoC(int64_t mbName, int32_t lnName, int64_t mbStringValue, int32_t lnStringValue, int64_t mbDoubleValue, int32_t lnDoubleValue, int64_t mbSampleSize, int32_t lnSampleSize, int64_t mbAllMembers);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getLnName() { return lnName; }
	public: void setLnName(int32_t v);
	public: int32_t getLnStringValue() { return lnStringValue; }
	public: void setLnStringValue(int32_t v);
	public: int32_t getLnDoubleValue() { return lnDoubleValue; }
	public: void setLnDoubleValue(int32_t v);
	public: int32_t getLnSampleSize() { return lnSampleSize; }
	public: void setLnSampleSize(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// HealthCheckInfos
// typeId=333475674

namespace de { namespace elo { namespace ix { namespace client { namespace health { 

using namespace ::byps;

/// <summary>
/// This class holds the values for health check evaluation.
/// </summary>
class HealthCheckInfos : public de::elo::ix::client::ValueClass {
	/// <summary>
	/// Health check data.
	/// </summary>
	/// <remarks>
	/// If returned from {@link HealthCheckService#read(de.elo.ix.client.ClientInfo, List)},
	/// this list is sorted by {@link HealthCheckInfo#getName()}.
	/// </remarks>
	protected: PVectorHealthCheckInfo infos;
	/// <summary>
	/// Archive GUID.
	/// </summary>
	protected: ::std::wstring archiveGuid;
	/// <summary>
	/// MD5 hash of license key.
	/// </summary>
	/// <remarks>
	/// The part of the license key used to compute this hash can be obtained by
	/// <code><pre>conn.getServerInfo().getLicense().getSerno();</pre></code>
	/// </remarks>
	protected: ::std::wstring customerLicenseKeyHash;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: HealthCheckInfos();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: HealthCheckInfos(const PVectorHealthCheckInfo& infos, const ::std::wstring& archiveGuid, const ::std::wstring& customerLicenseKeyHash);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: PVectorHealthCheckInfo getInfos() { return infos; }
	public: void setInfos(PVectorHealthCheckInfo v);
	public: ::std::wstring getArchiveGuid() { return archiveGuid; }
	public: void setArchiveGuid(::std::wstring v);
	public: ::std::wstring getCustomerLicenseKeyHash() { return customerLicenseKeyHash; }
	public: void setCustomerLicenseKeyHash(::std::wstring v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// HealthCheckValueNameC
// typeId=2106201675

namespace de { namespace elo { namespace ix { namespace client { namespace health { 

using namespace ::byps;

/// <summary>
/// Predefined value names for HealthCheckInfo objects.
/// </summary>
class HealthCheckValueNameC : public BSerializable {
	/// <summary>
	/// Name of dynamically evaluated values starts with this prefix.
	/// </summary>
	public: const static ::std::wstring DYNAMIC;
	/// <summary>
	/// Number of logically documents.
	/// </summary>
	public: const static ::std::wstring NB_OF_DOCUMENTS;
	/// <summary>
	/// Number of document files (resp. number of document versions).
	/// </summary>
	public: const static ::std::wstring NB_OF_DOCUMENT_FILES;
	/// <summary>
	/// Total size of document files (resp. document versions).
	/// </summary>
	public: const static ::std::wstring TOTAL_SIZE_OF_DOCUMENT_FILES;
	/// <summary>
	/// Number of document files with backup.
	/// </summary>
	public: const static ::std::wstring NB_OF_DOCUMENT_FILES_WITH_BACKUP;
	/// <summary>
	/// Number of logically documents without backup.
	/// </summary>
	public: const static ::std::wstring NB_OF_DOCUMENT_FILES_WITHOUT_BACKUP;
	/// <summary>
	/// Number of failed logins.
	/// </summary>
	/// <remarks>
	/// Due to wrong name or password.
	/// </remarks>
	public: const static ::std::wstring NB_OF_FAILED_LOGINS;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: HealthCheckValueNameC();
	
	public: virtual BTYPEID BSerializable_getTypeId();
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// MyELOContent
// typeId=1585309177

namespace de { namespace elo { namespace ix { namespace client { namespace myelo { 

using namespace ::byps;

class MyELOContent : public de::elo::ix::client::ValueClass {
	/// <summary>
	/// Array of WorkflowDiagrams
	/// </summary>
	protected: de::elo::ix::client::PArrayWFDiagram workflows;
	/// <summary>
	/// Array of user tasks.
	/// </summary>
	protected: de::elo::ix::client::PArrayUserTask tasks;
	/// <summary>
	/// Array of <code>sord</code> objects.
	/// </summary>
	/// <remarks>
	/// This member is set if <code>sordC</code>
	/// </remarks>
	protected: de::elo::ix::client::PArraySord sords;
	/// <summary>
	/// Document feed actions.
	/// </summary>
	/// <remarks>
	/// This array is filled by findFirst/findNextActions of the interface FeedService.
	/// The associated Feed objects are returned in the collection {@link #feeds}.
	/// </remarks>
	protected: de::elo::ix::client::feed::PArrayAction actions;
	/// <summary>
	/// Document feeds.
	/// </summary>
	/// <remarks>
	/// Feed objects mapped to their GUID.
	/// </remarks>
	protected: de::elo::ix::client::feed::PMapStringFeed feeds;
	/// <summary>
	/// Subscriptions.
	/// </summary>
	/// <remarks>
	/// Subscription objects mapped to their Subscription.watchGuid.
	/// </remarks>
	protected: de::elo::ix::client::PMapStringSubscription subscriptions;
	/// <summary>
	/// Notifications.
	/// </summary>
	/// <remarks>
	/// Notification objects mapped to their Notification.watchGuid
	/// </remarks>
	protected: de::elo::ix::client::PMapStringNotification notifications;
	/// <summary>
	/// HashTag Relations.
	/// </summary>
	protected: de::elo::ix::client::feed::PVectorHashTagRelation hashTagRelations;
	/// <summary>
	/// HashTags.
	/// </summary>
	/// <remarks>
	/// HashTag Objects mapped to their HashTagGuid
	/// </remarks>
	protected: de::elo::ix::client::feed::PMapStringHashTag hashTags;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: MyELOContent();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: MyELOContent(const de::elo::ix::client::PArrayWFDiagram& workflows, const de::elo::ix::client::PArrayUserTask& tasks, const de::elo::ix::client::PArraySord& sords, const de::elo::ix::client::feed::PArrayAction& actions, const de::elo::ix::client::feed::PMapStringFeed& feeds, const de::elo::ix::client::PMapStringSubscription& subscriptions, const de::elo::ix::client::PMapStringNotification& notifications, const de::elo::ix::client::feed::PVectorHashTagRelation& hashTagRelations, const de::elo::ix::client::feed::PMapStringHashTag& hashTags);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: de::elo::ix::client::PArrayWFDiagram getWorkflows() { return workflows; }
	public: void setWorkflows(de::elo::ix::client::PArrayWFDiagram v);
	public: de::elo::ix::client::PArrayUserTask getTasks() { return tasks; }
	public: void setTasks(de::elo::ix::client::PArrayUserTask v);
	public: de::elo::ix::client::PArraySord getSords() { return sords; }
	public: void setSords(de::elo::ix::client::PArraySord v);
	public: de::elo::ix::client::feed::PArrayAction getActions() { return actions; }
	public: void setActions(de::elo::ix::client::feed::PArrayAction v);
	public: de::elo::ix::client::feed::PMapStringFeed getFeeds() { return feeds; }
	public: void setFeeds(de::elo::ix::client::feed::PMapStringFeed v);
	public: de::elo::ix::client::PMapStringSubscription getSubscriptions() { return subscriptions; }
	public: void setSubscriptions(de::elo::ix::client::PMapStringSubscription v);
	public: de::elo::ix::client::PMapStringNotification getNotifications() { return notifications; }
	public: void setNotifications(de::elo::ix::client::PMapStringNotification v);
	public: de::elo::ix::client::feed::PVectorHashTagRelation getHashTagRelations() { return hashTagRelations; }
	public: void setHashTagRelations(de::elo::ix::client::feed::PVectorHashTagRelation v);
	public: de::elo::ix::client::feed::PMapStringHashTag getHashTags() { return hashTags; }
	public: void setHashTags(de::elo::ix::client::feed::PMapStringHashTag v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// MyELOInfo
// typeId=455864090

namespace de { namespace elo { namespace ix { namespace client { namespace myelo { 

using namespace ::byps;

class MyELOInfo : public de::elo::ix::client::ValueClass {
	protected: de::elo::ix::client::feed::PFindNotificationInfo notificationInfo;
	protected: de::elo::ix::client::PFindWorkflowInfo workflowInfo;
	protected: de::elo::ix::client::PFindTasksInfo taskInfo;
	protected: ::std::wstring date;
	protected: int32_t max;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: MyELOInfo();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: MyELOInfo(const de::elo::ix::client::feed::PFindNotificationInfo& notificationInfo, const de::elo::ix::client::PFindWorkflowInfo& workflowInfo, const de::elo::ix::client::PFindTasksInfo& taskInfo, const ::std::wstring& date, int32_t max);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: de::elo::ix::client::feed::PFindNotificationInfo getNotificationInfo() { return notificationInfo; }
	public: void setNotificationInfo(de::elo::ix::client::feed::PFindNotificationInfo v);
	public: de::elo::ix::client::PFindWorkflowInfo getWorkflowInfo() { return workflowInfo; }
	public: void setWorkflowInfo(de::elo::ix::client::PFindWorkflowInfo v);
	public: de::elo::ix::client::PFindTasksInfo getTaskInfo() { return taskInfo; }
	public: void setTaskInfo(de::elo::ix::client::PFindTasksInfo v);
	public: ::std::wstring getDate() { return date; }
	public: void setDate(::std::wstring v);
	public: int32_t getMax() { return max; }
	public: void setMax(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// MyELOState
// typeId=1426941339

namespace de { namespace elo { namespace ix { namespace client { namespace myelo { 

using namespace ::byps;

class MyELOState : public de::elo::ix::client::ValueClass {
	protected: ::std::wstring userGuid;
	protected: bool newFeed;
	protected: bool newWorkflow;
	protected: bool newTask;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: MyELOState();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: MyELOState(const ::std::wstring& userGuid, bool newFeed, bool newWorkflow, bool newTask);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: ::std::wstring getUserGuid() { return userGuid; }
	public: void setUserGuid(::std::wstring v);
	public: bool getNewFeed() { return newFeed; }
	public: void setNewFeed(bool v);
	public: bool getNewWorkflow() { return newWorkflow; }
	public: void setNewWorkflow(bool v);
	public: bool getNewTask() { return newTask; }
	public: void setNewTask(bool v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// LanguageConfig
// typeId=2005992013

namespace de { namespace elo { namespace ix { namespace client { namespace search { 

using namespace ::byps;

class LanguageConfig : public de::elo::ix::client::ValueClass {
	protected: ::std::wstring languages;
	protected: ::std::wstring allowedLangs;
	protected: int32_t nbOfLangs;
	protected: ::std::wstring archiveLang;
	protected: byps::PMapStringString mapLanguageNames;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: LanguageConfig();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: LanguageConfig(const ::std::wstring& languages, const ::std::wstring& allowedLangs, int32_t nbOfLangs, const ::std::wstring& archiveLang, const byps::PMapStringString& mapLanguageNames);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: ::std::wstring getLanguages() { return languages; }
	public: void setLanguages(::std::wstring v);
	public: ::std::wstring getAllowedLangs() { return allowedLangs; }
	public: void setAllowedLangs(::std::wstring v);
	public: int32_t getNbOfLangs() { return nbOfLangs; }
	public: void setNbOfLangs(int32_t v);
	public: ::std::wstring getArchiveLang() { return archiveLang; }
	public: void setArchiveLang(::std::wstring v);
	public: byps::PMapStringString getMapLanguageNames() { return mapLanguageNames; }
	public: void setMapLanguageNames(byps::PMapStringString v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// OptimizerConfig
// typeId=645566676

namespace de { namespace elo { namespace ix { namespace client { namespace search { 

using namespace ::byps;

/// <summary>
/// Configuration and status of optimizer process.
/// </summary>
class OptimizerConfig : public de::elo::ix::client::ValueClass {
	protected: SearchIndexerStatus status;
	protected: BDateTime nextRunAt;
	protected: int32_t intervalHours;
	/// <summary>
	/// This Indexserver instance is processing the optimization.
	/// </summary>
	protected: ::std::wstring ixid;
	/// <summary>
	/// Last exception occured during processing.
	/// </summary>
	protected: ::std::wstring lastException;
	/// <summary>
	/// Process runs under this user account.
	/// </summary>
	protected: ::std::wstring lockName;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: OptimizerConfig();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: OptimizerConfig(SearchIndexerStatus status, const BDateTime& nextRunAt, int32_t intervalHours, const ::std::wstring& ixid, const ::std::wstring& lastException, const ::std::wstring& lockName);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: SearchIndexerStatus getStatus() { return status; }
	public: void setStatus(SearchIndexerStatus v);
	public: BDateTime getNextRunAt() { return nextRunAt; }
	public: void setNextRunAt(BDateTime v);
	public: int32_t getIntervalHours() { return intervalHours; }
	public: void setIntervalHours(int32_t v);
	public: ::std::wstring getIxid() { return ixid; }
	public: void setIxid(::std::wstring v);
	public: ::std::wstring getLastException() { return lastException; }
	public: void setLastException(::std::wstring v);
	public: ::std::wstring getLockName() { return lockName; }
	public: void setLockName(::std::wstring v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// ReindexerConfig
// typeId=1470978622

namespace de { namespace elo { namespace ix { namespace client { namespace search { 

using namespace ::byps;

/// <summary>
/// Configuration and status of Re-indexer process.
/// </summary>
class ReindexerConfig : public de::elo::ix::client::ValueClass {
	protected: SearchIndexerStatus status;
	protected: BDateTime startedAt;
	protected: int32_t progressInPercent;
	/// <summary>
	/// This Indexserver instance is processing the update.
	/// </summary>
	protected: ::std::wstring ixid;
	/// <summary>
	/// Last exception occured during processing.
	/// </summary>
	protected: ::std::wstring lastException;
	/// <summary>
	/// Lower and upper limit of object IDs processed by re-indexing process.
	/// </summary>
	protected: ::std::wstring objIdRange;
	/// <summary>
	/// Process runs under this user account.
	/// </summary>
	protected: ::std::wstring lockName;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: ReindexerConfig();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: ReindexerConfig(SearchIndexerStatus status, const BDateTime& startedAt, int32_t progressInPercent, const ::std::wstring& ixid, const ::std::wstring& lastException, const ::std::wstring& objIdRange, const ::std::wstring& lockName);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: SearchIndexerStatus getStatus() { return status; }
	public: void setStatus(SearchIndexerStatus v);
	public: BDateTime getStartedAt() { return startedAt; }
	public: void setStartedAt(BDateTime v);
	public: int32_t getProgressInPercent() { return progressInPercent; }
	public: void setProgressInPercent(int32_t v);
	public: ::std::wstring getIxid() { return ixid; }
	public: void setIxid(::std::wstring v);
	public: ::std::wstring getLastException() { return lastException; }
	public: void setLastException(::std::wstring v);
	public: ::std::wstring getObjIdRange() { return objIdRange; }
	public: void setObjIdRange(::std::wstring v);
	public: ::std::wstring getLockName() { return lockName; }
	public: void setLockName(::std::wstring v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// SearchIndexerConfig
// typeId=1425319615

namespace de { namespace elo { namespace ix { namespace client { namespace search { 

using namespace ::byps;

class SearchIndexerConfig : public de::elo::ix::client::ValueClass {
	protected: PUpdaterConfig updaterConfig;
	protected: POptimizerConfig optimizerConfig;
	protected: PReindexerConfig reindexerConfig;
	protected: PLanguageConfig languageConfig;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: SearchIndexerConfig();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: SearchIndexerConfig(const PUpdaterConfig& updaterConfig, const POptimizerConfig& optimizerConfig, const PReindexerConfig& reindexerConfig, const PLanguageConfig& languageConfig);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: PUpdaterConfig getUpdaterConfig() { return updaterConfig; }
	public: void setUpdaterConfig(PUpdaterConfig v);
	public: POptimizerConfig getOptimizerConfig() { return optimizerConfig; }
	public: void setOptimizerConfig(POptimizerConfig v);
	public: PReindexerConfig getReindexerConfig() { return reindexerConfig; }
	public: void setReindexerConfig(PReindexerConfig v);
	public: PLanguageConfig getLanguageConfig() { return languageConfig; }
	public: void setLanguageConfig(PLanguageConfig v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// UpdaterConfig
// typeId=1275243126

namespace de { namespace elo { namespace ix { namespace client { namespace search { 

using namespace ::byps;

/// <summary>
/// Configuration and status of updater process.
/// </summary>
class UpdaterConfig : public de::elo::ix::client::ValueClass {
	protected: SearchIndexerStatus status;
	protected: BDateTime nextRunAt;
	protected: int32_t intervalMinutes;
	protected: BDateTime updateNewerThan;
	protected: int32_t progressInPercent;
	/// <summary>
	/// This Indexserver instance is processing the update.
	/// </summary>
	protected: ::std::wstring ixid;
	/// <summary>
	/// Last exception occured during processing.
	/// </summary>
	protected: ::std::wstring lastException;
	/// <summary>
	/// Process runs under this user account.
	/// </summary>
	protected: ::std::wstring lockName;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: UpdaterConfig();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: UpdaterConfig(SearchIndexerStatus status, const BDateTime& nextRunAt, int32_t intervalMinutes, const BDateTime& updateNewerThan, int32_t progressInPercent, const ::std::wstring& ixid, const ::std::wstring& lastException, const ::std::wstring& lockName);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: SearchIndexerStatus getStatus() { return status; }
	public: void setStatus(SearchIndexerStatus v);
	public: BDateTime getNextRunAt() { return nextRunAt; }
	public: void setNextRunAt(BDateTime v);
	public: int32_t getIntervalMinutes() { return intervalMinutes; }
	public: void setIntervalMinutes(int32_t v);
	public: BDateTime getUpdateNewerThan() { return updateNewerThan; }
	public: void setUpdateNewerThan(BDateTime v);
	public: int32_t getProgressInPercent() { return progressInPercent; }
	public: void setProgressInPercent(int32_t v);
	public: ::std::wstring getIxid() { return ixid; }
	public: void setIxid(::std::wstring v);
	public: ::std::wstring getLastException() { return lastException; }
	public: void setLastException(::std::wstring v);
	public: ::std::wstring getLockName() { return lockName; }
	public: void setLockName(::std::wstring v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// ArchivReport
// typeId=1383534582

namespace de { namespace elo { namespace ix { namespace client { namespace system { 

using namespace ::byps;

class ArchivReport : public de::elo::ix::client::ValueClass {
	protected: ::std::wstring archivGUID;
	protected: PVectorArchivValue elodmdocs;
	protected: PVectorArchivValue objecte;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: ArchivReport();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: ArchivReport(const ::std::wstring& archivGUID, const PVectorArchivValue& elodmdocs, const PVectorArchivValue& objecte);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: ::std::wstring getArchivGUID() { return archivGUID; }
	public: void setArchivGUID(::std::wstring v);
	public: PVectorArchivValue getElodmdocs() { return elodmdocs; }
	public: void setElodmdocs(PVectorArchivValue v);
	public: PVectorArchivValue getObjecte() { return objecte; }
	public: void setObjecte(PVectorArchivValue v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// ArchivValue
// typeId=1695870218

namespace de { namespace elo { namespace ix { namespace client { namespace system { 

using namespace ::byps;

class ArchivValue : public de::elo::ix::client::ValueClass {
	protected: int32_t year;
	protected: int32_t count;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: ArchivValue();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: ArchivValue(int32_t year, int32_t count);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getYear() { return year; }
	public: void setYear(int32_t v);
	public: int32_t getCount() { return count; }
	public: void setCount(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// LicenseCounter
// typeId=189487184

namespace de { namespace elo { namespace ix { namespace client { namespace system { 

using namespace ::byps;

class LicenseCounter : public de::elo::ix::client::ValueClass {
	public: const static int32_t JAVA_CLIENT = 0;
	public: const static int32_t WINWOS_CLIENT = 6;
	public: const static int32_t FULL_USER = 0;
	public: const static int32_t IX_USER = 1;
	public: const static int32_t DELETED_USER = 2;
	public: const static int32_t FREE_USER = -1;
	protected: de::elo::ix::client::PUserInfo userInfo;
	protected: byps::PMapIntegerInteger accessMap;
	/// <summary>
	/// sum of AccessMap without keys 0,6,9
	/// </summary>
	protected: int32_t sumAccess;
	protected: bool disabled;
	protected: int32_t countType;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: LicenseCounter();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: LicenseCounter(int32_t JAVA_CLIENT, int32_t WINWOS_CLIENT, int32_t FULL_USER, int32_t IX_USER, int32_t DELETED_USER, int32_t FREE_USER, const de::elo::ix::client::PUserInfo& userInfo, const byps::PMapIntegerInteger& accessMap, int32_t sumAccess, bool disabled, int32_t countType);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: de::elo::ix::client::PUserInfo getUserInfo() { return userInfo; }
	public: void setUserInfo(de::elo::ix::client::PUserInfo v);
	public: byps::PMapIntegerInteger getAccessMap() { return accessMap; }
	public: void setAccessMap(byps::PMapIntegerInteger v);
	public: int32_t getSumAccess() { return sumAccess; }
	public: void setSumAccess(int32_t v);
	public: bool getDisabled() { return disabled; }
	public: void setDisabled(bool v);
	public: int32_t getCountType() { return countType; }
	public: void setCountType(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// LicenseReport
// typeId=1320348587

namespace de { namespace elo { namespace ix { namespace client { namespace system { 

using namespace ::byps;

class LicenseReport : public de::elo::ix::client::ValueClass {
	/// <summary>
	/// Number of server licenses.
	/// </summary>
	protected: int32_t nbOfServerLicenses;
	/// <summary>
	/// Number of ELO Internet Gateway users.
	/// </summary>
	protected: int32_t nbOfIgLicenses;
	/// <summary>
	/// License key.
	/// </summary>
	protected: ::std::wstring serno;
	protected: PVectorLicenseCounter counterList;
	protected: int32_t fullUser;
	protected: int32_t ixUser;
	protected: int32_t deletedUser;
	protected: int32_t freeUser;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: LicenseReport();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: LicenseReport(int32_t nbOfServerLicenses, int32_t nbOfIgLicenses, const ::std::wstring& serno, const PVectorLicenseCounter& counterList, int32_t fullUser, int32_t ixUser, int32_t deletedUser, int32_t freeUser);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getNbOfServerLicenses() { return nbOfServerLicenses; }
	public: void setNbOfServerLicenses(int32_t v);
	public: int32_t getNbOfIgLicenses() { return nbOfIgLicenses; }
	public: void setNbOfIgLicenses(int32_t v);
	public: ::std::wstring getSerno() { return serno; }
	public: void setSerno(::std::wstring v);
	public: PVectorLicenseCounter getCounterList() { return counterList; }
	public: void setCounterList(PVectorLicenseCounter v);
	public: int32_t getFullUser() { return fullUser; }
	public: void setFullUser(int32_t v);
	public: int32_t getIxUser() { return ixUser; }
	public: void setIxUser(int32_t v);
	public: int32_t getDeletedUser() { return deletedUser; }
	public: void setDeletedUser(int32_t v);
	public: int32_t getFreeUser() { return freeUser; }
	public: void setFreeUser(int32_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// SystemInfo
// typeId=2061316528

namespace de { namespace elo { namespace ix { namespace client { namespace system { 

using namespace ::byps;

class SystemInfo : public de::elo::ix::client::ValueClass {
	protected: int32_t storePathID;
	protected: int64_t startDate;
	protected: int64_t endDate;
	protected: int64_t userReportMode;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: SystemInfo();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: SystemInfo(int32_t storePathID, int64_t startDate, int64_t endDate, int64_t userReportMode);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int32_t getStorePathID() { return storePathID; }
	public: void setStorePathID(int32_t v);
	public: int64_t getStartDate() { return startDate; }
	public: void setStartDate(int64_t v);
	public: int64_t getEndDate() { return endDate; }
	public: void setEndDate(int64_t v);
	public: int64_t getUserReportMode() { return userReportMode; }
	public: void setUserReportMode(int64_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// SystemReport
// typeId=276702696

namespace de { namespace elo { namespace ix { namespace client { namespace system { 

using namespace ::byps;

class SystemReport : public de::elo::ix::client::ValueClass {
	protected: int64_t doccount;
	protected: int64_t docsize;
	protected: int64_t ftsize;
	protected: int64_t previewsize;
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: SystemReport();
	// checkpoint byps.gen.cpp.GenApiClass:535
	public: SystemReport(int64_t doccount, int64_t docsize, int64_t ftsize, int64_t previewsize);	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: int64_t getDoccount() { return doccount; }
	public: void setDoccount(int64_t v);
	public: int64_t getDocsize() { return docsize; }
	public: void setDocsize(int64_t v);
	public: int64_t getFtsize() { return ftsize; }
	public: void setFtsize(int64_t v);
	public: int64_t getPreviewsize() { return previewsize; }
	public: void setPreviewsize(int64_t v);
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}}

// checkpoint byps.gen.cpp.GenApiClass:652
//-------------------------------------------------
// UserReport
// typeId=18214274

namespace de { namespace elo { namespace ix { namespace client { namespace system { 

using namespace ::byps;

class UserReport : public de::elo::ix::client::ValueClass {
	
	// checkpoint byps.gen.cpp.GenApiClass:488
	public: UserReport();
	
	public: virtual BTYPEID BSerializable_getTypeId();
	// checkpoint byps.gen.cpp.GenApiClass:870
	public: void serialize(BIO& ar, const BVERSION version);
};

}}}}}

//-------------------------------------------------
// IXEventBusHandler

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// Handler interface for event bus events.
/// </summary>
class IXEventBusHandler : public virtual BRemote {
	
	public: virtual void processEventBusEvents(int64_t subsId, const PArrayEvent& events)  = 0;
	public: virtual void processEventBusEvents(int64_t subsId, const PArrayEvent& events, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	
};

}}}}
//-------------------------------------------------
// Skeleton class BSkeleton_IXEventBusHandler
// Your interface implementation class has to be derived from this skeleton.
// Either provide an asynchronous or a synchronous function in your subclass.

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

class BSkeleton_IXEventBusHandler;
typedef byps_ptr<BSkeleton_IXEventBusHandler> PSkeleton_IXEventBusHandler;

class BSkeleton_IXEventBusHandler : public BSkeleton, public virtual IXEventBusHandler {
	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: virtual void processEventBusEvents(int64_t subsId, const PArrayEvent& events) ;
	public: virtual void processEventBusEvents(int64_t subsId, const PArrayEvent& events, ::std::function< void (bool, BException ex) > asyncResult) ;
	
	
};
}}}}

//-------------------------------------------------
// Stub class BStub_IXEventBusHandler

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

class BStub_IXEventBusHandler;
typedef byps_ptr<BStub_IXEventBusHandler> PStub_IXEventBusHandler;

class BStub_IXEventBusHandler : public BStub, public virtual IXEventBusHandler {
	
	public: BStub_IXEventBusHandler(PTransport transport);	
	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: virtual void processEventBusEvents(int64_t subsId, const PArrayEvent& events) ;
	public: virtual void processEventBusEvents(int64_t subsId, const PArrayEvent& events, ::std::function< void (bool, BException ex) > asyncResult) ;
	
};
}}}}


//-------------------------------------------------
// IXServerEvents

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// The IndexServer fires this events while processing API calls.
/// </summary>
/// <remarks>
/// Event handler functions can be written in JavaScript and their
/// script files have to be stored below the archive folder
/// "Administration/IndexServer Scripting Base".
/// <p>The first level of entries in
/// "Administration/IndexServer Scripting Base" consists of
/// the mandatory folder "_ALL" and optional folders that
/// are named like the IndexServer instances. An IndexServer instance
/// name is usually the computer name on which the IndexServer is running.
/// But an arbitary name can be explicitly assigned by setting the
/// servlet parameter "ixid" in the web.xml or config.xml files.
/// </p><p>
/// The second level below "Administration/IndexServer Scripting Base"
/// shold contain folders named by the person or company that
/// provide the JavaScript modules.
/// </p><p>
/// The IndexServer recursively searches in the folder
/// "_ALL" and the folder with the instance name
/// for JavaScript files with extension ".js". All functions
/// in this files named like the functions defined in this interface are
/// recognized as event handler functions. There might be more than one
/// handler per event. All handers are executed in a random order, if the
/// event is raised.
/// </p>
/// </remarks>
class IXServerEvents : public virtual BRemote {
	
	/// <summary>
	/// This mandatory method returns information about the application that implements
	/// the interface.
	/// </summary>
	/// <remarks>
	/// It should return the application name and version and
	/// the implementors name.
	/// The returned String is printed into the log file and is added to
	/// error messages.
	/// This method is mandatory.
	/// </remarks>
	public: virtual ::std::wstring getAppInfo(const PIXServerEventsContext& ec)  = 0;
	public: virtual void getAppInfo(const PIXServerEventsContext& ec, ::std::function< void (::std::wstring, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// This mandatory method tests, wether an interace method is implemented.
	/// </summary>
	/// <remarks>
	/// The IndexServer calls this function for each method, before the method
	/// is called the first time.
	/// </remarks>
	public: virtual bool hasMethod(const PIXServerEventsContext& ec, const ::std::wstring& methodName)  = 0;
	public: virtual void hasMethod(const PIXServerEventsContext& ec, const ::std::wstring& methodName, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// This synchronous event is raised before a Sord object is written.
	/// </summary>
	/// <remarks>
	/// It is raised in checkinSord, checkinDocEnd, checkinDocsEnd, startImport.
	/// </remarks>
	public: virtual void onBeforeCheckinSord(const PIXServerEventsContext& ec, const PSord& sord, const PSord& sordDB, const PSord& parentSord, const PSordZ& sordZ, const PLockZ& unlockZ)  = 0;
	public: virtual void onBeforeCheckinSord(const PIXServerEventsContext& ec, const PSord& sord, const PSord& sordDB, const PSord& parentSord, const PSordZ& sordZ, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// This asynchronous event is raised after a Sord object has been written.
	/// </summary>
	/// <remarks>
	/// It is raised in checkinSord, checkinDocEnd, checkinDocsEnd, checkinSordPath, startImport.
	/// </remarks>
	public: virtual void onAfterCheckinSord(const PIXServerEventsContext& ec, const PSord& sord, const PSord& sordDB, const PSord& parentSord, const PSordZ& sordZ, const PLockZ& unlockZ)  = 0;
	public: virtual void onAfterCheckinSord(const PIXServerEventsContext& ec, const PSord& sord, const PSord& sordDB, const PSord& parentSord, const PSordZ& sordZ, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// This synchronous event is raised before a document or a document version is checked in.
	/// </summary>
	/// <remarks>
	/// It is raised in checkinDocEnd, checkinDocsEnd, startImport.
	/// </remarks>
	public: virtual void onBeforeCheckinDocEnd(const PIXServerEventsContext& ec, const PSord& sord, const PSord& sordDB, const PSord& parentSord, const PDocument& doc, const PSordZ& sordZ, const PLockZ& unlockZ)  = 0;
	public: virtual void onBeforeCheckinDocEnd(const PIXServerEventsContext& ec, const PSord& sord, const PSord& sordDB, const PSord& parentSord, const PDocument& doc, const PSordZ& sordZ, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// This asynchronous event is raised after a document or a document version has been checked in.
	/// </summary>
	/// <remarks>
	/// It is raised in checkinDocEnd, checkinDocsEnd, startImport.
	/// </remarks>
	public: virtual void onAfterCheckinDocEnd(const PIXServerEventsContext& ec, const PSord& sord, const PSord& sordDB, const PSord& parentSord, const PDocument& doc, const PSordZ& sordZ, const PLockZ& unlockZ)  = 0;
	public: virtual void onAfterCheckinDocEnd(const PIXServerEventsContext& ec, const PSord& sord, const PSord& sordDB, const PSord& parentSord, const PDocument& doc, const PSordZ& sordZ, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// This synchronous event is raised before a Sord is deleted.
	/// </summary>
	/// <remarks>
	/// It is raised in deleteSord, cleanupStart.
	/// </remarks>
	public: virtual void onBeforeDeleteSord(const PIXServerEventsContext& ec, const PSord& parentSord, const PSord& sord, const PLockZ& unlockZ, const PDeleteOptions& delOpts)  = 0;
	public: virtual void onBeforeDeleteSord(const PIXServerEventsContext& ec, const PSord& parentSord, const PSord& sord, const PLockZ& unlockZ, const PDeleteOptions& delOpts, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// This asynchronous event is raised after a Sord is deleted.
	/// </summary>
	/// <remarks>
	/// It is raised in deleteSord, cleanupStart.
	/// </remarks>
	public: virtual void onAfterDeleteSord(const PIXServerEventsContext& ec, const PSord& parentSord, const PSord& sord, const PLockZ& unlockZ, const PDeleteOptions& delOpts, bool ret)  = 0;
	public: virtual void onAfterDeleteSord(const PIXServerEventsContext& ec, const PSord& parentSord, const PSord& sord, const PLockZ& unlockZ, const PDeleteOptions& delOpts, bool ret, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// This synchronous event is raised before a Sord is moved or a reference is created.
	/// </summary>
	/// <remarks>
	/// It is raised in refSord, copySord.
	/// </remarks>
	public: virtual void onBeforeRefSord(const PIXServerEventsContext& ec, const PSord& parentSordOld, const PSord& parentSordNew, const PSord& sord, int32_t manSortIndex)  = 0;
	public: virtual void onBeforeRefSord(const PIXServerEventsContext& ec, const PSord& parentSordOld, const PSord& parentSordNew, const PSord& sord, int32_t manSortIndex, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// This asynchronous event is raised after a Sord is moved or a reference is created.
	/// </summary>
	/// <remarks>
	/// It is raised in refSord, copySord.
	/// </remarks>
	public: virtual void onAfterRefSord(const PIXServerEventsContext& ec, const PSord& parentSordOld, const PSord& parentSordNew, const PSord& sord, int32_t manSortIndex)  = 0;
	public: virtual void onAfterRefSord(const PIXServerEventsContext& ec, const PSord& parentSordOld, const PSord& parentSordNew, const PSord& sord, int32_t manSortIndex, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// This asynchronous event is raised after a workflow node is forwarded by
	/// endEditWorkFlowNode.
	/// </summary>
	public: virtual void onAfterEndEditWorkFlowNode(const PIXServerEventsContext& ec, const PWFDiagram& workflow, int32_t nodeId, const PSord& sord, const PSordZ& sordZ)  = 0;
	public: virtual void onAfterEndEditWorkFlowNode(const PIXServerEventsContext& ec, const PWFDiagram& workflow, int32_t nodeId, const PSord& sord, const PSordZ& sordZ, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// This asynchronous event is raised after checkinReminder was called.
	/// </summary>
	public: virtual void onAfterCheckinReminder(const PIXServerEventsContext& ec, const PArrayReminder& remiArray, const PSord& sord, const PSordZ& sordZ, const PLockZ& unlockZ)  = 0;
	public: virtual void onAfterCheckinReminder(const PIXServerEventsContext& ec, const PArrayReminder& remiArray, const PSord& sord, const PSordZ& sordZ, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// This event is raised when the IXServicePortIF function executeRegisteredFunction is called.
	/// </summary>
	public: virtual PAny executeRegisteredFunction(const PIXServerEventsContext& ec, const ::std::wstring& functionName, const PAny& any)  = 0;
	public: virtual void executeRegisteredFunction(const PIXServerEventsContext& ec, const ::std::wstring& functionName, const PAny& any, ::std::function< void (PAny, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// This event is raised when the IXServicePortIF function executeRegisteredFunctionString is called.
	/// </summary>
	public: virtual ::std::wstring executeRegisteredFunctionString(const PIXServerEventsContext& ec, const ::std::wstring& functionName, const ::std::wstring& args)  = 0;
	public: virtual void executeRegisteredFunctionString(const PIXServerEventsContext& ec, const ::std::wstring& functionName, const ::std::wstring& args, ::std::function< void (::std::wstring, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// This synchronous event is raised before a workflow is started.
	/// </summary>
	public: virtual void onBeforeStartWorkFlow(const PIXServerEventsContext& ec, const PWFDiagram& workflow, const PSord& sord, const PSordZ& sordZ)  = 0;
	public: virtual void onBeforeStartWorkFlow(const PIXServerEventsContext& ec, const PWFDiagram& workflow, const PSord& sord, const PSordZ& sordZ, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// This asynchronous event is raised after a workflow is started.
	/// </summary>
	public: virtual void onAfterStartWorkFlow(const PIXServerEventsContext& ec, const PWFDiagram& workflow, const PSord& sord, const PSordZ& sordZ)  = 0;
	public: virtual void onAfterStartWorkFlow(const PIXServerEventsContext& ec, const PWFDiagram& workflow, const PSord& sord, const PSordZ& sordZ, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// This event is raised before an activity is written.
	/// </summary>
	/// <remarks>
	/// The event is invoked too, if the activity is to be deleted. An activity is called deleted, if member activity.backAt is not empty.
	/// </remarks>
	public: virtual void onBeforeCheckinActivity(const PIXServerEventsContext& ec, const PActivity& act, bool isNew, const PSord& sord, const PSordZ& sordZ, const PLockZ& unlockZ)  = 0;
	public: virtual void onBeforeCheckinActivity(const PIXServerEventsContext& ec, const PActivity& act, bool isNew, const PSord& sord, const PSordZ& sordZ, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// This event is raised asynchronously after an activity is written.
	/// </summary>
	/// <remarks>
	/// The event is invoked too, if the activity was deleted. An activity is called deleted, if member activity.backAt is not empty.
	/// </remarks>
	public: virtual void onAfterCheckinActivity(const PIXServerEventsContext& ec, const PActivity& act, bool isNew, const PSord& sord, const PSordZ& sordZ, const PLockZ& unlockZ)  = 0;
	public: virtual void onAfterCheckinActivity(const PIXServerEventsContext& ec, const PActivity& act, bool isNew, const PSord& sord, const PSordZ& sordZ, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// This synchronous event is raised before a Note object is written.
	/// </summary>
	/// <remarks>
	/// It is raised in checkinNotes
	/// </remarks>
	public: virtual void onBeforeCheckinNotes(const PIXServerEventsContext& ec, const PArrayNote& notes, const PArraySord& sords, int64_t noteC, const PLockZ& unlockZ)  = 0;
	public: virtual void onBeforeCheckinNotes(const PIXServerEventsContext& ec, const PArrayNote& notes, const PArraySord& sords, int64_t noteC, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// This asynchronous event is raised after a Note object has been written.
	/// </summary>
	/// <remarks>
	/// It is raised in
	/// </remarks>
	public: virtual void onAfterCheckinNotes(const PIXServerEventsContext& ec, const PArrayNote& notes, const PArraySord& sords, int64_t noteC, const PLockZ& unlockZ)  = 0;
	public: virtual void onAfterCheckinNotes(const PIXServerEventsContext& ec, const PArrayNote& notes, const PArraySord& sords, int64_t noteC, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// This event is raised after files has been uploaded by the JSON API to build the response message.
	/// </summary>
	/// <remarks>
	/// The response message depends on the file upload solution used by the client side JavaScript.
	/// This event can only be implemented as a JavaScript function. It is not possible to process it in a WEB-service like other events in this interface.
	/// </remarks>
	public: virtual void onFileUploadBuildResponse(const PIXServerEventsContext& ec, const PDocVersion& dv, const ::std::wstring& fileName, const PHttpRequestInfo& requestInfo, const PHttpResponseInfo& responseInfo)  = 0;
	public: virtual void onFileUploadBuildResponse(const PIXServerEventsContext& ec, const PDocVersion& dv, const ::std::wstring& fileName, const PHttpRequestInfo& requestInfo, const PHttpResponseInfo& responseInfo, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Get lean user and group information.
	/// </summary>
	/// <remarks>
	/// This method is called to internally process the API function {@link IXServicePortIF#getUserNames(ClientInfo, String[], CheckoutUsersZ)}.
	/// This method should call {@link IXServicePortIF#getUserNames(ClientInfo, String[], CheckoutUsersZ)} internally and should
	/// only modify {@link UserName#flags2} or {@link UserName#flags2} in the returned array. E.g. {@link UserName#flags2} can
	/// be changed in order to hide particular users by removing the bit {@link AccessC#FLAG2_VISIBLE_USER}.
	/// </remarks>
	public: virtual PArrayUserName getUserNames(const PIXServerEventsContext& ec, const PArrayString& ids, const PCheckoutUsersZ& checkoutUsersZ)  = 0;
	public: virtual void getUserNames(const PIXServerEventsContext& ec, const PArrayString& ids, const PCheckoutUsersZ& checkoutUsersZ, ::std::function< void (PArrayUserName, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Modify the Sord information returned in checkoutSord, checkoutDoc, findFirstSords, etc.
	/// </summary>
	/// <remarks>
	/// This function is called, before a Sord object is returned to the client application.
	/// It can be used to modify or delete some of the transmitted data. But it must not change the
	/// members sord.id and sord.guid. Furthermore it cannot prevent the Sord object from being transmitted.
	/// This method cannot be implemented by services because of the output parameters.
	/// This method is frequently called and should perform as fast as possible.
	/// </remarks>
	public: virtual void onReadSord(const PIXServerEventsContext& ec, const PSord& sord, const PSordZ& sordZ, const PDocument& doc, const PLockZ& lockZ)  = 0;
	public: virtual void onReadSord(const PIXServerEventsContext& ec, const PSord& sord, const PSordZ& sordZ, const PDocument& doc, const PLockZ& lockZ, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Check access to Sord object.
	/// </summary>
	/// <remarks>
	/// Use this method to replace the internal access checking of the ACL for Sord objects.
	/// In order to deny access to the given sord, return false, otherwise return true.
	/// <p>
	/// This method should not be implemented by services for performance reasons. It is frequently called
	/// and should perform as fast as possible.
	/// </p><p>
	/// The Indexserver's access check function can be called via class de.elo.ix.jscript.Access.
	/// Example code:
	/// <code><pre>
	/// function onCheckSordAccess(ec, sord, sordZ, lur, opts) {
	/// var acc = new Packages.de.elo.ix.jscript.Access();
	/// var succ = acc.checkAccess(sord, lur);
	/// return succ;
	/// }
	/// </pre></code>
	/// </p>
	/// </remarks>
	public: virtual bool onCheckSordAccess(const PIXServerEventsContext& ec, const PSord& sord, const PSordZ& sordZ, int32_t lur, const PCheckAccessOptions& opts)  = 0;
	public: virtual void onCheckSordAccess(const PIXServerEventsContext& ec, const PSord& sord, const PSordZ& sordZ, int32_t lur, const PCheckAccessOptions& opts, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Before a user is authenticated the IX calls this method.
	/// </summary>
	/// <remarks>
	/// Use it to allow or
	/// deny the the login to the user. If the user is not allowed to login
	/// according to the {@link LoginScriptOptions} opts, an exception has to be
	/// thrown.
	/// <p>
	/// Example code:
	/// <code><pre>
	/// function onBeforeLogin(ec, user, opts) {
	/// if (username == "OnlyWithWebClient" && options.getClientName() != LoginScriptOptionsC.CLIENT_NAME_WEBCLIENT) {
	/// throw "User may login only with the WebClient";
	/// }
	/// }
	/// </pre></code>
	/// </p>
	/// </remarks>
	public: virtual void onBeforeLogin(const PIXServerEventsContext& ec, const ::std::wstring& userName, const PLoginScriptOptions& opts)  = 0;
	public: virtual void onBeforeLogin(const PIXServerEventsContext& ec, const ::std::wstring& userName, const PLoginScriptOptions& opts, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// This method is called asynchronously after a user has been successfully authenticated.
	/// </summary>
	public: virtual void onAfterLogin(const PIXServerEventsContext& ec, const ::std::wstring& userName, const PLoginScriptOptions& opts)  = 0;
	public: virtual void onAfterLogin(const PIXServerEventsContext& ec, const ::std::wstring& userName, const PLoginScriptOptions& opts, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// This event is triggered in createSord, checkinSordPath and optionally in createDoc.
	/// </summary>
	/// <remarks>
	/// Use this event in order to customize the initialization of an EditInfo resp. Sord object.
	/// The script can call the {@link IXServicePortIF#createSord(ClientInfo, String, String, EditInfoZ)} function
	/// in order to get a new EditInfo object. The script can return null, if the standard initialization
	/// should be used. Before the EditInfo object created by this function is returned to the client application,
	/// the following mebers are overwritten: EditInfo.sord.id=-1, EditInfo.sord.guid=<random GUID>.
	/// All members in EditInfo that are not assigned by this function but requested from the element selector editZ,
	/// are assigned (as far as possible) before the EditInfo object is returned to the client.
	/// Hint: Although this function is named createSord, it has to return an EditInfo object.
	/// This event is not triggered, if there is an onCreateDoc event customized.
	/// </remarks>
	public: virtual PEditInfo onCreateSord(const PIXServerEventsContext& ec, const ::std::wstring& parentId, const ::std::wstring& maskId, const PEditInfoZ& editZ)  = 0;
	public: virtual void onCreateSord(const PIXServerEventsContext& ec, const ::std::wstring& parentId, const ::std::wstring& maskId, const PEditInfoZ& editZ, ::std::function< void (PEditInfo, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// This event is triggered in createDoc.
	/// </summary>
	/// <remarks>
	/// If an onCreateDoc event is configured, the event onCreateSord is not triggered in onCreateSord.
	/// </remarks>
	public: virtual PEditInfo onCreateDoc(const PIXServerEventsContext& ec, const ::std::wstring& parentId, const ::std::wstring& maskId, const ::std::wstring& docTemplate, const PEditInfoZ& editInfoZ)  = 0;
	public: virtual void onCreateDoc(const PIXServerEventsContext& ec, const ::std::wstring& parentId, const ::std::wstring& maskId, const ::std::wstring& docTemplate, const PEditInfoZ& editInfoZ, ::std::function< void (PEditInfo, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// This event is invoked before {@link IXServicePortIF#checkinUsers(ClientInfo, UserInfo[], CheckinUsersZ, LockZ)} processes the supplied UserInfo objects.
	/// </summary>
	public: virtual PArrayUserInfo onBeforeCheckinUsers(const PIXServerEventsContext& ec, const PArrayUserInfo& userInfos, const PCheckinUsersZ& checkinUsersZ, const PLockZ& unlockZ)  = 0;
	public: virtual void onBeforeCheckinUsers(const PIXServerEventsContext& ec, const PArrayUserInfo& userInfos, const PCheckinUsersZ& checkinUsersZ, const PLockZ& unlockZ, ::std::function< void (PArrayUserInfo, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// This event is called after {@link IXServicePortIF#checkinUsers(ClientInfo, UserInfo[], CheckinUsersZ, LockZ)} has processed the supplied UserInfo objects.
	/// </summary>
	/// <remarks>
	/// Indexserver invokes this event asynchronously after the users have been written.
	/// </remarks>
	public: virtual void onAfterCheckinUsers(const PIXServerEventsContext& ec, const PArrayUserInfo& userInfos, const PCheckinUsersZ& checkinUsersZ, const PLockZ& unlockZ)  = 0;
	public: virtual void onAfterCheckinUsers(const PIXServerEventsContext& ec, const PArrayUserInfo& userInfos, const PCheckinUsersZ& checkinUsersZ, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// This event is called before {@link IXServicePortIF#checkinMap(ClientInfo, String, String, int, KeyValue[], LockZ)} is executed.
	/// </summary>
	public: virtual PArrayKeyValue onBeforeCheckinMap(const PIXServerEventsContext& ec, const ::std::wstring& domainName, const ::std::wstring& id, int32_t objId, const PArrayKeyValue& data, const PLockZ& unlockZ)  = 0;
	public: virtual void onBeforeCheckinMap(const PIXServerEventsContext& ec, const ::std::wstring& domainName, const ::std::wstring& id, int32_t objId, const PArrayKeyValue& data, const PLockZ& unlockZ, ::std::function< void (PArrayKeyValue, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// This event is called after {@link IXServicePortIF#checkinMap(ClientInfo, String, String, int, KeyValue[], LockZ)} has processed.
	/// </summary>
	public: virtual void onAfterCheckinMap(const PIXServerEventsContext& ec, const ::std::wstring& domainName, const ::std::wstring& id, int32_t objId, const PArrayKeyValue& data, const PLockZ& unlockZ)  = 0;
	public: virtual void onAfterCheckinMap(const PIXServerEventsContext& ec, const ::std::wstring& domainName, const ::std::wstring& id, int32_t objId, const PArrayKeyValue& data, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// This event is called before {@link IXServicePortIF#deleteMap(ClientInfo, String, String, String[], LockZ)} is executed.
	/// </summary>
	public: virtual PArrayString onBeforeDeleteMap(const PIXServerEventsContext& ec, const ::std::wstring& domainName, const ::std::wstring& id, const PArrayString& keyNames, const PLockZ& unlockZ)  = 0;
	public: virtual void onBeforeDeleteMap(const PIXServerEventsContext& ec, const ::std::wstring& domainName, const ::std::wstring& id, const PArrayString& keyNames, const PLockZ& unlockZ, ::std::function< void (PArrayString, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// This event is called after {@link IXServicePortIF#deleteMap(ClientInfo, String, String, String[], LockZ)} has processed.
	/// </summary>
	public: virtual void onAfterDeleteMap(const PIXServerEventsContext& ec, const ::std::wstring& domainName, const ::std::wstring& id, const PArrayString& keyNames, const PLockZ& unlockZ)  = 0;
	public: virtual void onAfterDeleteMap(const PIXServerEventsContext& ec, const ::std::wstring& domainName, const ::std::wstring& id, const PArrayString& keyNames, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// This event is fired before {@link IXServicePortIF#takeWorkFlowNode(ClientInfo, int, int, String, int, LockZ)} is processed.
	/// </summary>
	public: virtual void onBeforeTakeWorkFlowNode(const PIXServerEventsContext& ec, const PWFDiagram& workflow, const PWFNode& node, const PUserInfo& user, int32_t flags, const PLockZ& lockZ)  = 0;
	public: virtual void onBeforeTakeWorkFlowNode(const PIXServerEventsContext& ec, const PWFDiagram& workflow, const PWFNode& node, const PUserInfo& user, int32_t flags, const PLockZ& lockZ, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// This event is fired before the FindInfo object passed in findFirstSords is evaluated.
	/// </summary>
	/// <remarks>
	/// The passed findInfo object can be modified.
	/// </remarks>
	public: virtual void onBeforeFindSords(const PIXServerEventsContext& ec, const PFindInfo& findInfo, const PSordZ& sordZ)  = 0;
	public: virtual void onBeforeFindSords(const PIXServerEventsContext& ec, const PFindInfo& findInfo, const PSordZ& sordZ, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// This event is fired before findFirstSords executes the search statement.
	/// </summary>
	/// <remarks>
	/// Be aware of the fact that there is no guaranty about the generated FindSql data.
	/// Subsequent IX versions can create different FindSql objects for the same FindInfo object.
	/// Hence, modifications of the FindSql data might not work in future releases.
	/// Prefer to use {@link IXServerEvents#onBeforeFindSords(IXServerEventsContext, FindInfo, SordZ)} wherever possible.
	/// </remarks>
	public: virtual void onBeforeFindSordsInternalSQL(const PIXServerEventsContext& ec, const PFindInfo& findInfo, const PSordZ& sordZ, const PFindInfoAsInternalSQL& findSql)  = 0;
	public: virtual void onBeforeFindSordsInternalSQL(const PIXServerEventsContext& ec, const PFindInfo& findInfo, const PSordZ& sordZ, const PFindInfoAsInternalSQL& findSql, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// This event is called for find results found by findFirstSords and findNextSords.
	/// </summary>
	public: virtual void onFindSordsResult(const PIXServerEventsContext& ec, const PFindInfo& findInfo, const PSordZ& sordZ, const PFindResult& findResult)  = 0;
	public: virtual void onFindSordsResult(const PIXServerEventsContext& ec, const PFindInfo& findInfo, const PSordZ& sordZ, const PFindResult& findResult, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// This event is called when a search via findFirstSords/findNextSords is closed.
	/// </summary>
	public: virtual void onFindClose(const PIXServerEventsContext& ec, const PSerializable& findInfo)  = 0;
	public: virtual void onFindClose(const PIXServerEventsContext& ec, const PSerializable& findInfo, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// This event is called when index values are inherited.
	/// </summary>
	/// <remarks>
	/// <p>
	/// Example:
	/// <pre>
	/// <code class="example">
	/// function onInheritKeywording(ec, sord, parent, okeyNames, reserved) {
	/// for (var i = 0; i < okeyNames.length; i++) {
	/// var key = okeyNames[i];
	/// var value = getObjKey(parent, key);
	/// log.info("inherit " + key + ", value=" + value);
	/// setObjKey(sord, key, value);
	/// }
	/// return InheritKeywordingResult.INHERITED;
	/// }
	/// </code>
	/// </pre>
	/// </p>
	/// </remarks>
	public: virtual InheritKeywordingResult onInheritKeywording(const PIXServerEventsContext& ec, const PSord& sord, const PSord& parentSord, const PArrayString& okeyNames, const PSerializable& reserved)  = 0;
	public: virtual void onInheritKeywording(const PIXServerEventsContext& ec, const PSord& sord, const PSord& parentSord, const PArrayString& okeyNames, const PSerializable& reserved, ::std::function< void (InheritKeywordingResult, BException ex) > asyncResult)  = 0;
	
	
};

}}}}
//-------------------------------------------------
// Skeleton class BSkeleton_IXServerEvents
// Your interface implementation class has to be derived from this skeleton.
// Either provide an asynchronous or a synchronous function in your subclass.

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

class BSkeleton_IXServerEvents;
typedef byps_ptr<BSkeleton_IXServerEvents> PSkeleton_IXServerEvents;

class BSkeleton_IXServerEvents : public BSkeleton, public virtual IXServerEvents {
	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: virtual ::std::wstring getAppInfo(const PIXServerEventsContext& ec) ;
	public: virtual void getAppInfo(const PIXServerEventsContext& ec, ::std::function< void (::std::wstring, BException ex) > asyncResult) ;
	
	public: virtual bool hasMethod(const PIXServerEventsContext& ec, const ::std::wstring& methodName) ;
	public: virtual void hasMethod(const PIXServerEventsContext& ec, const ::std::wstring& methodName, ::std::function< void (bool, BException ex) > asyncResult) ;
	
	public: virtual void onBeforeCheckinSord(const PIXServerEventsContext& ec, const PSord& sord, const PSord& sordDB, const PSord& parentSord, const PSordZ& sordZ, const PLockZ& unlockZ) ;
	public: virtual void onBeforeCheckinSord(const PIXServerEventsContext& ec, const PSord& sord, const PSord& sordDB, const PSord& parentSord, const PSordZ& sordZ, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult) ;
	
	public: virtual void onAfterCheckinSord(const PIXServerEventsContext& ec, const PSord& sord, const PSord& sordDB, const PSord& parentSord, const PSordZ& sordZ, const PLockZ& unlockZ) ;
	public: virtual void onAfterCheckinSord(const PIXServerEventsContext& ec, const PSord& sord, const PSord& sordDB, const PSord& parentSord, const PSordZ& sordZ, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult) ;
	
	public: virtual void onBeforeCheckinDocEnd(const PIXServerEventsContext& ec, const PSord& sord, const PSord& sordDB, const PSord& parentSord, const PDocument& doc, const PSordZ& sordZ, const PLockZ& unlockZ) ;
	public: virtual void onBeforeCheckinDocEnd(const PIXServerEventsContext& ec, const PSord& sord, const PSord& sordDB, const PSord& parentSord, const PDocument& doc, const PSordZ& sordZ, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult) ;
	
	public: virtual void onAfterCheckinDocEnd(const PIXServerEventsContext& ec, const PSord& sord, const PSord& sordDB, const PSord& parentSord, const PDocument& doc, const PSordZ& sordZ, const PLockZ& unlockZ) ;
	public: virtual void onAfterCheckinDocEnd(const PIXServerEventsContext& ec, const PSord& sord, const PSord& sordDB, const PSord& parentSord, const PDocument& doc, const PSordZ& sordZ, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult) ;
	
	public: virtual void onBeforeDeleteSord(const PIXServerEventsContext& ec, const PSord& parentSord, const PSord& sord, const PLockZ& unlockZ, const PDeleteOptions& delOpts) ;
	public: virtual void onBeforeDeleteSord(const PIXServerEventsContext& ec, const PSord& parentSord, const PSord& sord, const PLockZ& unlockZ, const PDeleteOptions& delOpts, ::std::function< void (bool, BException ex) > asyncResult) ;
	
	public: virtual void onAfterDeleteSord(const PIXServerEventsContext& ec, const PSord& parentSord, const PSord& sord, const PLockZ& unlockZ, const PDeleteOptions& delOpts, bool ret) ;
	public: virtual void onAfterDeleteSord(const PIXServerEventsContext& ec, const PSord& parentSord, const PSord& sord, const PLockZ& unlockZ, const PDeleteOptions& delOpts, bool ret, ::std::function< void (bool, BException ex) > asyncResult) ;
	
	public: virtual void onBeforeRefSord(const PIXServerEventsContext& ec, const PSord& parentSordOld, const PSord& parentSordNew, const PSord& sord, int32_t manSortIndex) ;
	public: virtual void onBeforeRefSord(const PIXServerEventsContext& ec, const PSord& parentSordOld, const PSord& parentSordNew, const PSord& sord, int32_t manSortIndex, ::std::function< void (bool, BException ex) > asyncResult) ;
	
	public: virtual void onAfterRefSord(const PIXServerEventsContext& ec, const PSord& parentSordOld, const PSord& parentSordNew, const PSord& sord, int32_t manSortIndex) ;
	public: virtual void onAfterRefSord(const PIXServerEventsContext& ec, const PSord& parentSordOld, const PSord& parentSordNew, const PSord& sord, int32_t manSortIndex, ::std::function< void (bool, BException ex) > asyncResult) ;
	
	public: virtual void onAfterEndEditWorkFlowNode(const PIXServerEventsContext& ec, const PWFDiagram& workflow, int32_t nodeId, const PSord& sord, const PSordZ& sordZ) ;
	public: virtual void onAfterEndEditWorkFlowNode(const PIXServerEventsContext& ec, const PWFDiagram& workflow, int32_t nodeId, const PSord& sord, const PSordZ& sordZ, ::std::function< void (bool, BException ex) > asyncResult) ;
	
	public: virtual void onAfterCheckinReminder(const PIXServerEventsContext& ec, const PArrayReminder& remiArray, const PSord& sord, const PSordZ& sordZ, const PLockZ& unlockZ) ;
	public: virtual void onAfterCheckinReminder(const PIXServerEventsContext& ec, const PArrayReminder& remiArray, const PSord& sord, const PSordZ& sordZ, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult) ;
	
	public: virtual PAny executeRegisteredFunction(const PIXServerEventsContext& ec, const ::std::wstring& functionName, const PAny& any) ;
	public: virtual void executeRegisteredFunction(const PIXServerEventsContext& ec, const ::std::wstring& functionName, const PAny& any, ::std::function< void (PAny, BException ex) > asyncResult) ;
	
	public: virtual ::std::wstring executeRegisteredFunctionString(const PIXServerEventsContext& ec, const ::std::wstring& functionName, const ::std::wstring& args) ;
	public: virtual void executeRegisteredFunctionString(const PIXServerEventsContext& ec, const ::std::wstring& functionName, const ::std::wstring& args, ::std::function< void (::std::wstring, BException ex) > asyncResult) ;
	
	public: virtual void onBeforeStartWorkFlow(const PIXServerEventsContext& ec, const PWFDiagram& workflow, const PSord& sord, const PSordZ& sordZ) ;
	public: virtual void onBeforeStartWorkFlow(const PIXServerEventsContext& ec, const PWFDiagram& workflow, const PSord& sord, const PSordZ& sordZ, ::std::function< void (bool, BException ex) > asyncResult) ;
	
	public: virtual void onAfterStartWorkFlow(const PIXServerEventsContext& ec, const PWFDiagram& workflow, const PSord& sord, const PSordZ& sordZ) ;
	public: virtual void onAfterStartWorkFlow(const PIXServerEventsContext& ec, const PWFDiagram& workflow, const PSord& sord, const PSordZ& sordZ, ::std::function< void (bool, BException ex) > asyncResult) ;
	
	public: virtual void onBeforeCheckinActivity(const PIXServerEventsContext& ec, const PActivity& act, bool isNew, const PSord& sord, const PSordZ& sordZ, const PLockZ& unlockZ) ;
	public: virtual void onBeforeCheckinActivity(const PIXServerEventsContext& ec, const PActivity& act, bool isNew, const PSord& sord, const PSordZ& sordZ, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult) ;
	
	public: virtual void onAfterCheckinActivity(const PIXServerEventsContext& ec, const PActivity& act, bool isNew, const PSord& sord, const PSordZ& sordZ, const PLockZ& unlockZ) ;
	public: virtual void onAfterCheckinActivity(const PIXServerEventsContext& ec, const PActivity& act, bool isNew, const PSord& sord, const PSordZ& sordZ, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult) ;
	
	public: virtual void onBeforeCheckinNotes(const PIXServerEventsContext& ec, const PArrayNote& notes, const PArraySord& sords, int64_t noteC, const PLockZ& unlockZ) ;
	public: virtual void onBeforeCheckinNotes(const PIXServerEventsContext& ec, const PArrayNote& notes, const PArraySord& sords, int64_t noteC, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult) ;
	
	public: virtual void onAfterCheckinNotes(const PIXServerEventsContext& ec, const PArrayNote& notes, const PArraySord& sords, int64_t noteC, const PLockZ& unlockZ) ;
	public: virtual void onAfterCheckinNotes(const PIXServerEventsContext& ec, const PArrayNote& notes, const PArraySord& sords, int64_t noteC, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult) ;
	
	public: virtual void onFileUploadBuildResponse(const PIXServerEventsContext& ec, const PDocVersion& dv, const ::std::wstring& fileName, const PHttpRequestInfo& requestInfo, const PHttpResponseInfo& responseInfo) ;
	public: virtual void onFileUploadBuildResponse(const PIXServerEventsContext& ec, const PDocVersion& dv, const ::std::wstring& fileName, const PHttpRequestInfo& requestInfo, const PHttpResponseInfo& responseInfo, ::std::function< void (bool, BException ex) > asyncResult) ;
	
	public: virtual PArrayUserName getUserNames(const PIXServerEventsContext& ec, const PArrayString& ids, const PCheckoutUsersZ& checkoutUsersZ) ;
	public: virtual void getUserNames(const PIXServerEventsContext& ec, const PArrayString& ids, const PCheckoutUsersZ& checkoutUsersZ, ::std::function< void (PArrayUserName, BException ex) > asyncResult) ;
	
	public: virtual void onReadSord(const PIXServerEventsContext& ec, const PSord& sord, const PSordZ& sordZ, const PDocument& doc, const PLockZ& lockZ) ;
	public: virtual void onReadSord(const PIXServerEventsContext& ec, const PSord& sord, const PSordZ& sordZ, const PDocument& doc, const PLockZ& lockZ, ::std::function< void (bool, BException ex) > asyncResult) ;
	
	public: virtual bool onCheckSordAccess(const PIXServerEventsContext& ec, const PSord& sord, const PSordZ& sordZ, int32_t lur, const PCheckAccessOptions& opts) ;
	public: virtual void onCheckSordAccess(const PIXServerEventsContext& ec, const PSord& sord, const PSordZ& sordZ, int32_t lur, const PCheckAccessOptions& opts, ::std::function< void (bool, BException ex) > asyncResult) ;
	
	public: virtual void onBeforeLogin(const PIXServerEventsContext& ec, const ::std::wstring& userName, const PLoginScriptOptions& opts) ;
	public: virtual void onBeforeLogin(const PIXServerEventsContext& ec, const ::std::wstring& userName, const PLoginScriptOptions& opts, ::std::function< void (bool, BException ex) > asyncResult) ;
	
	public: virtual void onAfterLogin(const PIXServerEventsContext& ec, const ::std::wstring& userName, const PLoginScriptOptions& opts) ;
	public: virtual void onAfterLogin(const PIXServerEventsContext& ec, const ::std::wstring& userName, const PLoginScriptOptions& opts, ::std::function< void (bool, BException ex) > asyncResult) ;
	
	public: virtual PEditInfo onCreateSord(const PIXServerEventsContext& ec, const ::std::wstring& parentId, const ::std::wstring& maskId, const PEditInfoZ& editZ) ;
	public: virtual void onCreateSord(const PIXServerEventsContext& ec, const ::std::wstring& parentId, const ::std::wstring& maskId, const PEditInfoZ& editZ, ::std::function< void (PEditInfo, BException ex) > asyncResult) ;
	
	public: virtual PEditInfo onCreateDoc(const PIXServerEventsContext& ec, const ::std::wstring& parentId, const ::std::wstring& maskId, const ::std::wstring& docTemplate, const PEditInfoZ& editInfoZ) ;
	public: virtual void onCreateDoc(const PIXServerEventsContext& ec, const ::std::wstring& parentId, const ::std::wstring& maskId, const ::std::wstring& docTemplate, const PEditInfoZ& editInfoZ, ::std::function< void (PEditInfo, BException ex) > asyncResult) ;
	
	public: virtual PArrayUserInfo onBeforeCheckinUsers(const PIXServerEventsContext& ec, const PArrayUserInfo& userInfos, const PCheckinUsersZ& checkinUsersZ, const PLockZ& unlockZ) ;
	public: virtual void onBeforeCheckinUsers(const PIXServerEventsContext& ec, const PArrayUserInfo& userInfos, const PCheckinUsersZ& checkinUsersZ, const PLockZ& unlockZ, ::std::function< void (PArrayUserInfo, BException ex) > asyncResult) ;
	
	public: virtual void onAfterCheckinUsers(const PIXServerEventsContext& ec, const PArrayUserInfo& userInfos, const PCheckinUsersZ& checkinUsersZ, const PLockZ& unlockZ) ;
	public: virtual void onAfterCheckinUsers(const PIXServerEventsContext& ec, const PArrayUserInfo& userInfos, const PCheckinUsersZ& checkinUsersZ, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult) ;
	
	public: virtual PArrayKeyValue onBeforeCheckinMap(const PIXServerEventsContext& ec, const ::std::wstring& domainName, const ::std::wstring& id, int32_t objId, const PArrayKeyValue& data, const PLockZ& unlockZ) ;
	public: virtual void onBeforeCheckinMap(const PIXServerEventsContext& ec, const ::std::wstring& domainName, const ::std::wstring& id, int32_t objId, const PArrayKeyValue& data, const PLockZ& unlockZ, ::std::function< void (PArrayKeyValue, BException ex) > asyncResult) ;
	
	public: virtual void onAfterCheckinMap(const PIXServerEventsContext& ec, const ::std::wstring& domainName, const ::std::wstring& id, int32_t objId, const PArrayKeyValue& data, const PLockZ& unlockZ) ;
	public: virtual void onAfterCheckinMap(const PIXServerEventsContext& ec, const ::std::wstring& domainName, const ::std::wstring& id, int32_t objId, const PArrayKeyValue& data, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult) ;
	
	public: virtual PArrayString onBeforeDeleteMap(const PIXServerEventsContext& ec, const ::std::wstring& domainName, const ::std::wstring& id, const PArrayString& keyNames, const PLockZ& unlockZ) ;
	public: virtual void onBeforeDeleteMap(const PIXServerEventsContext& ec, const ::std::wstring& domainName, const ::std::wstring& id, const PArrayString& keyNames, const PLockZ& unlockZ, ::std::function< void (PArrayString, BException ex) > asyncResult) ;
	
	public: virtual void onAfterDeleteMap(const PIXServerEventsContext& ec, const ::std::wstring& domainName, const ::std::wstring& id, const PArrayString& keyNames, const PLockZ& unlockZ) ;
	public: virtual void onAfterDeleteMap(const PIXServerEventsContext& ec, const ::std::wstring& domainName, const ::std::wstring& id, const PArrayString& keyNames, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult) ;
	
	public: virtual void onBeforeTakeWorkFlowNode(const PIXServerEventsContext& ec, const PWFDiagram& workflow, const PWFNode& node, const PUserInfo& user, int32_t flags, const PLockZ& lockZ) ;
	public: virtual void onBeforeTakeWorkFlowNode(const PIXServerEventsContext& ec, const PWFDiagram& workflow, const PWFNode& node, const PUserInfo& user, int32_t flags, const PLockZ& lockZ, ::std::function< void (bool, BException ex) > asyncResult) ;
	
	public: virtual void onBeforeFindSords(const PIXServerEventsContext& ec, const PFindInfo& findInfo, const PSordZ& sordZ) ;
	public: virtual void onBeforeFindSords(const PIXServerEventsContext& ec, const PFindInfo& findInfo, const PSordZ& sordZ, ::std::function< void (bool, BException ex) > asyncResult) ;
	
	public: virtual void onBeforeFindSordsInternalSQL(const PIXServerEventsContext& ec, const PFindInfo& findInfo, const PSordZ& sordZ, const PFindInfoAsInternalSQL& findSql) ;
	public: virtual void onBeforeFindSordsInternalSQL(const PIXServerEventsContext& ec, const PFindInfo& findInfo, const PSordZ& sordZ, const PFindInfoAsInternalSQL& findSql, ::std::function< void (bool, BException ex) > asyncResult) ;
	
	public: virtual void onFindSordsResult(const PIXServerEventsContext& ec, const PFindInfo& findInfo, const PSordZ& sordZ, const PFindResult& findResult) ;
	public: virtual void onFindSordsResult(const PIXServerEventsContext& ec, const PFindInfo& findInfo, const PSordZ& sordZ, const PFindResult& findResult, ::std::function< void (bool, BException ex) > asyncResult) ;
	
	public: virtual void onFindClose(const PIXServerEventsContext& ec, const PSerializable& findInfo) ;
	public: virtual void onFindClose(const PIXServerEventsContext& ec, const PSerializable& findInfo, ::std::function< void (bool, BException ex) > asyncResult) ;
	
	public: virtual InheritKeywordingResult onInheritKeywording(const PIXServerEventsContext& ec, const PSord& sord, const PSord& parentSord, const PArrayString& okeyNames, const PSerializable& reserved) ;
	public: virtual void onInheritKeywording(const PIXServerEventsContext& ec, const PSord& sord, const PSord& parentSord, const PArrayString& okeyNames, const PSerializable& reserved, ::std::function< void (InheritKeywordingResult, BException ex) > asyncResult) ;
	
	
};
}}}}

//-------------------------------------------------
// Stub class BStub_IXServerEvents

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

class BStub_IXServerEvents;
typedef byps_ptr<BStub_IXServerEvents> PStub_IXServerEvents;

class BStub_IXServerEvents : public BStub, public virtual IXServerEvents {
	
	public: BStub_IXServerEvents(PTransport transport);	
	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: virtual ::std::wstring getAppInfo(const PIXServerEventsContext& ec) ;
	public: virtual void getAppInfo(const PIXServerEventsContext& ec, ::std::function< void (::std::wstring, BException ex) > asyncResult) ;
	public: virtual bool hasMethod(const PIXServerEventsContext& ec, const ::std::wstring& methodName) ;
	public: virtual void hasMethod(const PIXServerEventsContext& ec, const ::std::wstring& methodName, ::std::function< void (bool, BException ex) > asyncResult) ;
	public: virtual void onBeforeCheckinSord(const PIXServerEventsContext& ec, const PSord& sord, const PSord& sordDB, const PSord& parentSord, const PSordZ& sordZ, const PLockZ& unlockZ) ;
	public: virtual void onBeforeCheckinSord(const PIXServerEventsContext& ec, const PSord& sord, const PSord& sordDB, const PSord& parentSord, const PSordZ& sordZ, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult) ;
	public: virtual void onAfterCheckinSord(const PIXServerEventsContext& ec, const PSord& sord, const PSord& sordDB, const PSord& parentSord, const PSordZ& sordZ, const PLockZ& unlockZ) ;
	public: virtual void onAfterCheckinSord(const PIXServerEventsContext& ec, const PSord& sord, const PSord& sordDB, const PSord& parentSord, const PSordZ& sordZ, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult) ;
	public: virtual void onBeforeCheckinDocEnd(const PIXServerEventsContext& ec, const PSord& sord, const PSord& sordDB, const PSord& parentSord, const PDocument& doc, const PSordZ& sordZ, const PLockZ& unlockZ) ;
	public: virtual void onBeforeCheckinDocEnd(const PIXServerEventsContext& ec, const PSord& sord, const PSord& sordDB, const PSord& parentSord, const PDocument& doc, const PSordZ& sordZ, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult) ;
	public: virtual void onAfterCheckinDocEnd(const PIXServerEventsContext& ec, const PSord& sord, const PSord& sordDB, const PSord& parentSord, const PDocument& doc, const PSordZ& sordZ, const PLockZ& unlockZ) ;
	public: virtual void onAfterCheckinDocEnd(const PIXServerEventsContext& ec, const PSord& sord, const PSord& sordDB, const PSord& parentSord, const PDocument& doc, const PSordZ& sordZ, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult) ;
	public: virtual void onBeforeDeleteSord(const PIXServerEventsContext& ec, const PSord& parentSord, const PSord& sord, const PLockZ& unlockZ, const PDeleteOptions& delOpts) ;
	public: virtual void onBeforeDeleteSord(const PIXServerEventsContext& ec, const PSord& parentSord, const PSord& sord, const PLockZ& unlockZ, const PDeleteOptions& delOpts, ::std::function< void (bool, BException ex) > asyncResult) ;
	public: virtual void onAfterDeleteSord(const PIXServerEventsContext& ec, const PSord& parentSord, const PSord& sord, const PLockZ& unlockZ, const PDeleteOptions& delOpts, bool ret) ;
	public: virtual void onAfterDeleteSord(const PIXServerEventsContext& ec, const PSord& parentSord, const PSord& sord, const PLockZ& unlockZ, const PDeleteOptions& delOpts, bool ret, ::std::function< void (bool, BException ex) > asyncResult) ;
	public: virtual void onBeforeRefSord(const PIXServerEventsContext& ec, const PSord& parentSordOld, const PSord& parentSordNew, const PSord& sord, int32_t manSortIndex) ;
	public: virtual void onBeforeRefSord(const PIXServerEventsContext& ec, const PSord& parentSordOld, const PSord& parentSordNew, const PSord& sord, int32_t manSortIndex, ::std::function< void (bool, BException ex) > asyncResult) ;
	public: virtual void onAfterRefSord(const PIXServerEventsContext& ec, const PSord& parentSordOld, const PSord& parentSordNew, const PSord& sord, int32_t manSortIndex) ;
	public: virtual void onAfterRefSord(const PIXServerEventsContext& ec, const PSord& parentSordOld, const PSord& parentSordNew, const PSord& sord, int32_t manSortIndex, ::std::function< void (bool, BException ex) > asyncResult) ;
	public: virtual void onAfterEndEditWorkFlowNode(const PIXServerEventsContext& ec, const PWFDiagram& workflow, int32_t nodeId, const PSord& sord, const PSordZ& sordZ) ;
	public: virtual void onAfterEndEditWorkFlowNode(const PIXServerEventsContext& ec, const PWFDiagram& workflow, int32_t nodeId, const PSord& sord, const PSordZ& sordZ, ::std::function< void (bool, BException ex) > asyncResult) ;
	public: virtual void onAfterCheckinReminder(const PIXServerEventsContext& ec, const PArrayReminder& remiArray, const PSord& sord, const PSordZ& sordZ, const PLockZ& unlockZ) ;
	public: virtual void onAfterCheckinReminder(const PIXServerEventsContext& ec, const PArrayReminder& remiArray, const PSord& sord, const PSordZ& sordZ, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult) ;
	public: virtual PAny executeRegisteredFunction(const PIXServerEventsContext& ec, const ::std::wstring& functionName, const PAny& any) ;
	public: virtual void executeRegisteredFunction(const PIXServerEventsContext& ec, const ::std::wstring& functionName, const PAny& any, ::std::function< void (PAny, BException ex) > asyncResult) ;
	public: virtual ::std::wstring executeRegisteredFunctionString(const PIXServerEventsContext& ec, const ::std::wstring& functionName, const ::std::wstring& args) ;
	public: virtual void executeRegisteredFunctionString(const PIXServerEventsContext& ec, const ::std::wstring& functionName, const ::std::wstring& args, ::std::function< void (::std::wstring, BException ex) > asyncResult) ;
	public: virtual void onBeforeStartWorkFlow(const PIXServerEventsContext& ec, const PWFDiagram& workflow, const PSord& sord, const PSordZ& sordZ) ;
	public: virtual void onBeforeStartWorkFlow(const PIXServerEventsContext& ec, const PWFDiagram& workflow, const PSord& sord, const PSordZ& sordZ, ::std::function< void (bool, BException ex) > asyncResult) ;
	public: virtual void onAfterStartWorkFlow(const PIXServerEventsContext& ec, const PWFDiagram& workflow, const PSord& sord, const PSordZ& sordZ) ;
	public: virtual void onAfterStartWorkFlow(const PIXServerEventsContext& ec, const PWFDiagram& workflow, const PSord& sord, const PSordZ& sordZ, ::std::function< void (bool, BException ex) > asyncResult) ;
	public: virtual void onBeforeCheckinActivity(const PIXServerEventsContext& ec, const PActivity& act, bool isNew, const PSord& sord, const PSordZ& sordZ, const PLockZ& unlockZ) ;
	public: virtual void onBeforeCheckinActivity(const PIXServerEventsContext& ec, const PActivity& act, bool isNew, const PSord& sord, const PSordZ& sordZ, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult) ;
	public: virtual void onAfterCheckinActivity(const PIXServerEventsContext& ec, const PActivity& act, bool isNew, const PSord& sord, const PSordZ& sordZ, const PLockZ& unlockZ) ;
	public: virtual void onAfterCheckinActivity(const PIXServerEventsContext& ec, const PActivity& act, bool isNew, const PSord& sord, const PSordZ& sordZ, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult) ;
	public: virtual void onBeforeCheckinNotes(const PIXServerEventsContext& ec, const PArrayNote& notes, const PArraySord& sords, int64_t noteC, const PLockZ& unlockZ) ;
	public: virtual void onBeforeCheckinNotes(const PIXServerEventsContext& ec, const PArrayNote& notes, const PArraySord& sords, int64_t noteC, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult) ;
	public: virtual void onAfterCheckinNotes(const PIXServerEventsContext& ec, const PArrayNote& notes, const PArraySord& sords, int64_t noteC, const PLockZ& unlockZ) ;
	public: virtual void onAfterCheckinNotes(const PIXServerEventsContext& ec, const PArrayNote& notes, const PArraySord& sords, int64_t noteC, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult) ;
	public: virtual void onFileUploadBuildResponse(const PIXServerEventsContext& ec, const PDocVersion& dv, const ::std::wstring& fileName, const PHttpRequestInfo& requestInfo, const PHttpResponseInfo& responseInfo) ;
	public: virtual void onFileUploadBuildResponse(const PIXServerEventsContext& ec, const PDocVersion& dv, const ::std::wstring& fileName, const PHttpRequestInfo& requestInfo, const PHttpResponseInfo& responseInfo, ::std::function< void (bool, BException ex) > asyncResult) ;
	public: virtual PArrayUserName getUserNames(const PIXServerEventsContext& ec, const PArrayString& ids, const PCheckoutUsersZ& checkoutUsersZ) ;
	public: virtual void getUserNames(const PIXServerEventsContext& ec, const PArrayString& ids, const PCheckoutUsersZ& checkoutUsersZ, ::std::function< void (PArrayUserName, BException ex) > asyncResult) ;
	public: virtual void onReadSord(const PIXServerEventsContext& ec, const PSord& sord, const PSordZ& sordZ, const PDocument& doc, const PLockZ& lockZ) ;
	public: virtual void onReadSord(const PIXServerEventsContext& ec, const PSord& sord, const PSordZ& sordZ, const PDocument& doc, const PLockZ& lockZ, ::std::function< void (bool, BException ex) > asyncResult) ;
	public: virtual bool onCheckSordAccess(const PIXServerEventsContext& ec, const PSord& sord, const PSordZ& sordZ, int32_t lur, const PCheckAccessOptions& opts) ;
	public: virtual void onCheckSordAccess(const PIXServerEventsContext& ec, const PSord& sord, const PSordZ& sordZ, int32_t lur, const PCheckAccessOptions& opts, ::std::function< void (bool, BException ex) > asyncResult) ;
	public: virtual void onBeforeLogin(const PIXServerEventsContext& ec, const ::std::wstring& userName, const PLoginScriptOptions& opts) ;
	public: virtual void onBeforeLogin(const PIXServerEventsContext& ec, const ::std::wstring& userName, const PLoginScriptOptions& opts, ::std::function< void (bool, BException ex) > asyncResult) ;
	public: virtual void onAfterLogin(const PIXServerEventsContext& ec, const ::std::wstring& userName, const PLoginScriptOptions& opts) ;
	public: virtual void onAfterLogin(const PIXServerEventsContext& ec, const ::std::wstring& userName, const PLoginScriptOptions& opts, ::std::function< void (bool, BException ex) > asyncResult) ;
	public: virtual PEditInfo onCreateSord(const PIXServerEventsContext& ec, const ::std::wstring& parentId, const ::std::wstring& maskId, const PEditInfoZ& editZ) ;
	public: virtual void onCreateSord(const PIXServerEventsContext& ec, const ::std::wstring& parentId, const ::std::wstring& maskId, const PEditInfoZ& editZ, ::std::function< void (PEditInfo, BException ex) > asyncResult) ;
	public: virtual PEditInfo onCreateDoc(const PIXServerEventsContext& ec, const ::std::wstring& parentId, const ::std::wstring& maskId, const ::std::wstring& docTemplate, const PEditInfoZ& editInfoZ) ;
	public: virtual void onCreateDoc(const PIXServerEventsContext& ec, const ::std::wstring& parentId, const ::std::wstring& maskId, const ::std::wstring& docTemplate, const PEditInfoZ& editInfoZ, ::std::function< void (PEditInfo, BException ex) > asyncResult) ;
	public: virtual PArrayUserInfo onBeforeCheckinUsers(const PIXServerEventsContext& ec, const PArrayUserInfo& userInfos, const PCheckinUsersZ& checkinUsersZ, const PLockZ& unlockZ) ;
	public: virtual void onBeforeCheckinUsers(const PIXServerEventsContext& ec, const PArrayUserInfo& userInfos, const PCheckinUsersZ& checkinUsersZ, const PLockZ& unlockZ, ::std::function< void (PArrayUserInfo, BException ex) > asyncResult) ;
	public: virtual void onAfterCheckinUsers(const PIXServerEventsContext& ec, const PArrayUserInfo& userInfos, const PCheckinUsersZ& checkinUsersZ, const PLockZ& unlockZ) ;
	public: virtual void onAfterCheckinUsers(const PIXServerEventsContext& ec, const PArrayUserInfo& userInfos, const PCheckinUsersZ& checkinUsersZ, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult) ;
	public: virtual PArrayKeyValue onBeforeCheckinMap(const PIXServerEventsContext& ec, const ::std::wstring& domainName, const ::std::wstring& id, int32_t objId, const PArrayKeyValue& data, const PLockZ& unlockZ) ;
	public: virtual void onBeforeCheckinMap(const PIXServerEventsContext& ec, const ::std::wstring& domainName, const ::std::wstring& id, int32_t objId, const PArrayKeyValue& data, const PLockZ& unlockZ, ::std::function< void (PArrayKeyValue, BException ex) > asyncResult) ;
	public: virtual void onAfterCheckinMap(const PIXServerEventsContext& ec, const ::std::wstring& domainName, const ::std::wstring& id, int32_t objId, const PArrayKeyValue& data, const PLockZ& unlockZ) ;
	public: virtual void onAfterCheckinMap(const PIXServerEventsContext& ec, const ::std::wstring& domainName, const ::std::wstring& id, int32_t objId, const PArrayKeyValue& data, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult) ;
	public: virtual PArrayString onBeforeDeleteMap(const PIXServerEventsContext& ec, const ::std::wstring& domainName, const ::std::wstring& id, const PArrayString& keyNames, const PLockZ& unlockZ) ;
	public: virtual void onBeforeDeleteMap(const PIXServerEventsContext& ec, const ::std::wstring& domainName, const ::std::wstring& id, const PArrayString& keyNames, const PLockZ& unlockZ, ::std::function< void (PArrayString, BException ex) > asyncResult) ;
	public: virtual void onAfterDeleteMap(const PIXServerEventsContext& ec, const ::std::wstring& domainName, const ::std::wstring& id, const PArrayString& keyNames, const PLockZ& unlockZ) ;
	public: virtual void onAfterDeleteMap(const PIXServerEventsContext& ec, const ::std::wstring& domainName, const ::std::wstring& id, const PArrayString& keyNames, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult) ;
	public: virtual void onBeforeTakeWorkFlowNode(const PIXServerEventsContext& ec, const PWFDiagram& workflow, const PWFNode& node, const PUserInfo& user, int32_t flags, const PLockZ& lockZ) ;
	public: virtual void onBeforeTakeWorkFlowNode(const PIXServerEventsContext& ec, const PWFDiagram& workflow, const PWFNode& node, const PUserInfo& user, int32_t flags, const PLockZ& lockZ, ::std::function< void (bool, BException ex) > asyncResult) ;
	public: virtual void onBeforeFindSords(const PIXServerEventsContext& ec, const PFindInfo& findInfo, const PSordZ& sordZ) ;
	public: virtual void onBeforeFindSords(const PIXServerEventsContext& ec, const PFindInfo& findInfo, const PSordZ& sordZ, ::std::function< void (bool, BException ex) > asyncResult) ;
	public: virtual void onBeforeFindSordsInternalSQL(const PIXServerEventsContext& ec, const PFindInfo& findInfo, const PSordZ& sordZ, const PFindInfoAsInternalSQL& findSql) ;
	public: virtual void onBeforeFindSordsInternalSQL(const PIXServerEventsContext& ec, const PFindInfo& findInfo, const PSordZ& sordZ, const PFindInfoAsInternalSQL& findSql, ::std::function< void (bool, BException ex) > asyncResult) ;
	public: virtual void onFindSordsResult(const PIXServerEventsContext& ec, const PFindInfo& findInfo, const PSordZ& sordZ, const PFindResult& findResult) ;
	public: virtual void onFindSordsResult(const PIXServerEventsContext& ec, const PFindInfo& findInfo, const PSordZ& sordZ, const PFindResult& findResult, ::std::function< void (bool, BException ex) > asyncResult) ;
	public: virtual void onFindClose(const PIXServerEventsContext& ec, const PSerializable& findInfo) ;
	public: virtual void onFindClose(const PIXServerEventsContext& ec, const PSerializable& findInfo, ::std::function< void (bool, BException ex) > asyncResult) ;
	public: virtual InheritKeywordingResult onInheritKeywording(const PIXServerEventsContext& ec, const PSord& sord, const PSord& parentSord, const PArrayString& okeyNames, const PSerializable& reserved) ;
	public: virtual void onInheritKeywording(const PIXServerEventsContext& ec, const PSord& sord, const PSord& parentSord, const PArrayString& okeyNames, const PSerializable& reserved, ::std::function< void (InheritKeywordingResult, BException ex) > asyncResult) ;
	
};
}}}}


//-------------------------------------------------
// IXServicePortIF

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// IndexServer Interface.
/// </summary>
/// <remarks>
/// <p>Hint: This documentation is automatically generated from the server side
/// source files of IndexServer. Many of the functions are not available on the
/// client side. The only functions you can call are the members of
/// <code>IXServicePortIF</code>. All other classes are simple data structures
/// without functions - although the functions are documented here.</p>
/// 
/// <p>This interface contains all methods IndexServer provides for accessing
/// an ELO archive. Since IndexServer runs (usually) as a SOAP-WEB-Service you can
/// access it from all common programming languages and development environments.
/// The examples are written in C#, because the majority of client programs will
/// be written in C# or Java, which is very similar to C#. Find a complete
/// C# example project via the link below.</p>
/// 
/// <p>For performance reason, uploading and downloading of document files are
/// not implemented by SOAP calls. The transport of document files run over
/// HTTP with a separate connection to IndexServer. It is also possible to access
/// the ELO Document Manager directly to improve performance. But be aware of the
/// fact that ELO Document Manager does not make any access checking and this might
/// be a security whole in your environment.</p>
/// 
/// <p>To help C# and Java programmers in writing IndexServer client applications,
/// there is a client helper class resp. a helper package available, see links below.</p>
/// 
/// <p>Note (1): "object ID" or "entry ID" is a numeric value that uniquely defines
/// an object of indexing information in the archive database. Indexing
/// information objects are represented as objects of class <code>Sord</code>. The
/// member <code>Sord.id</code> contains the object ID. Object ID parameters are
/// often named "objId", "parentId". </p>
/// <p>Note (2): "document ID" or "attachment ID" is a numeric value that uniquely
/// defines a document resp. attachment file version in the archive database.
/// Document versions are represented as objects of class <code>DocHistory</code>.
/// The member <code>DocHistory.docId</code> contains the document ID. Document ID
/// parameters are often named "docId", "attId". </p>
/// <p>Note (3): The SOAP transport layer eliminates "\r" in strings. For
/// multi-line input values (e. g. Sord.desc) IX automatically transforms
/// a "\n" into a "\r\n" before storing the string into database.</p>
/// <p>Note (4): IX eliminates leading and trailing blanks from all strings
/// before storing them into database.</p>
/// <p>Copyright: Copyright (c) 2004</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </remarks>
class IXServicePortIF : public virtual BRemote {
	
	/// <summary>
	/// Extends the ticket lifetime.
	/// </summary>
	public: virtual void alive(const PClientInfo& ci)  = 0;
	public: virtual void alive(const PClientInfo& ci, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Locks a person task node of an active workflow inside the database and returns data needed to edit it.
	/// </summary>
	/// <remarks>
	/// If lockZ is not set to <code>LockC.NO</code>, <code>WFNode.inUseDate</code> will be set to now.
	/// </remarks>
	public: virtual PWFEditNode beginEditWorkFlowNode(const PClientInfo& ci, int32_t nFlowId, int32_t nNodeId, const PLockZ& lockZ)  = 0;
	public: virtual void beginEditWorkFlowNode(const PClientInfo& ci, int32_t nFlowId, int32_t nNodeId, const PLockZ& lockZ, ::std::function< void (PWFEditNode, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Changes the storage mask of a archive entry.
	/// </summary>
	/// <remarks>
	/// <p>
	/// The function does not update the object in the database.
	/// The method <code>checkinSord</code> must be used to write the changes into the database.
	/// </p><p>
	/// For new Sord objects (Sord.id &lt; 0), ACL items are replaced by the definitions
	/// of the mask. Existing objects keep the previous ACL setting.
	/// </p><p>
	/// ObjKeys with IDs &lt; ID_LINK (=50) are converted into the format of the
	/// new associated DocMaskLine. ObjKeys with IDs &gt;= ID_LINK are not changed.
	/// </p>
	/// </remarks>
	public: virtual PEditInfo changeSordMask(const PClientInfo& ci, const PSord& sord, const ::std::wstring& maskId, const PEditInfoZ& editInfoZ)  = 0;
	public: virtual void changeSordMask(const PClientInfo& ci, const PSord& sord, const ::std::wstring& maskId, const PEditInfoZ& editInfoZ, ::std::function< void (PEditInfo, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Check-in the marker definitions (colors for the archive entries).
	/// </summary>
	/// <remarks>
	/// This method
	/// deletes the current markers and inserts the supplied ones in <code>colors</code>.
	/// To insert a new color, set its Id to -1. If the supplied <code>colors</code>
	/// array does not contain a system color (Id == 0), a new system color object is created.
	/// The objects must have unique IDs (or -1) and unique names.
	/// </remarks>
	public: virtual void checkinColors(const PClientInfo& ci, const PArrayColorData& colors, const PLockZ& unlockZ)  = 0;
	public: virtual void checkinColors(const PClientInfo& ci, const PArrayColorData& colors, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Uploads configuration files to the configuration directory on the server.
	/// </summary>
	public: virtual void checkinConfigFiles(const PClientInfo& ci, const PArrayConfigFile& configFiles, const PLockZ& unlockZ)  = 0;
	public: virtual void checkinConfigFiles(const PClientInfo& ci, const PArrayConfigFile& configFiles, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Prepare ConfigFile objects with URLs to upload configuration or intray files.
	/// </summary>
	/// <remarks>
	/// The <code>names[.]</code> the must contain the destination directory and file name.
	/// <table border="2">
	/// <tr><td>example for file names</td><td>description</td></tr>
	/// <tr><td><code>names[.]=peter/postbox/file1.txt</code></td>
	/// <td>Prepares a <code>ConfigFile</code> object to write file1.txt into peter s server side intray directory</td></tr>
	/// <tr><td><code>configFile[.].dir=eloscripts/file1.txt</code></td>
	/// <td>Prepares a <code>ConfigFile</code> object to write file1.txt into the directory for scripts.</td></tr>
	/// </table>
	/// <pre><code>
	/// //Example for uploading a file into the server side intray of a user.<br/>
	/// String userName = ...;
	/// File file = ...;
	/// String destFile = userName + "/" + CONST.CONFIG_FILE.POSTBOX + "/" + file.getName();<br/>
	/// ConfigFile[] configFiles = ix.ix.checkinConfigFilesBegin(ci, new String[] {destFile});<br/>
	/// configFiles[0].uploadResult = ix.upload(configFiles[0].url, file);<br/>
	/// configFiles = ix.ix.checkinConfigFilesEnd(ci, configFiles);<br/>
	/// </code></pre>
	/// </p>
	/// </remarks>
	public: virtual PArrayConfigFile checkinConfigFilesBegin(const PClientInfo& ci, const PArrayString& names)  = 0;
	public: virtual void checkinConfigFilesBegin(const PClientInfo& ci, const PArrayString& names, ::std::function< void (PArrayConfigFile, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Finishes a check-in procedure for configuration files.
	/// </summary>
	/// <remarks>
	/// <p>For files that have been uploaded into the in-tray folder of other users,
	/// no <code>ConfigFile</code> object can be returned, because the in-tray folders
	/// of other users are not readable. </p>
	/// </remarks>
	public: virtual PArrayConfigFile checkinConfigFilesEnd(const PClientInfo& ci, const PArrayConfigFile& configFiles, const PLockZ& unlockZ)  = 0;
	public: virtual void checkinConfigFilesEnd(const PClientInfo& ci, const PArrayConfigFile& configFiles, const PLockZ& unlockZ, ::std::function< void (PArrayConfigFile, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Update counter values or create new counters.
	/// </summary>
	public: virtual void checkinCounters(const PClientInfo& ci, const PArrayCounterInfo& counterInfos, const PLockZ& unlockZ)  = 0;
	public: virtual void checkinCounters(const PClientInfo& ci, const PArrayCounterInfo& counterInfos, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Prepares the IndexServer to enable a document to be checked in.
	/// </summary>
	/// <remarks>
	/// <p>
	/// The check in procedure consists of three steps. First a call to <code>checkinDocBegin</code>
	/// prepares the IndexServer to upload a document. The function returns among
	/// other things the URL to which the document must be up loaded. In the second
	/// step the document is uploaded to this URL. The final step is to call <code>checkinDocEnd</code>
	/// with the result of the upload process. The upload result is interpreted by
	/// the IndexServer and the document is inserted into the database.
	/// </p><p>
	/// The upload URL accesses the ELODM (document manager service)
	/// directly due to performance reasons . The URL is valid as long as the session ticket is valid.
	/// </p><p>
	/// It is possible to insert more than one document or attachment versions and a signature file.
	/// </p><p>
	/// The parameter <code>document</code> of <code>checkinDocBegin</code> must contain
	/// a minimum of one version in <code>document.docs</code>, <code>document.atts</code> or
	/// <code>document.sig</code>. The minimum that must be set in the version object is the member <code>DocVersion.ext</code>.
	/// </p><p>
	/// <b>Examples</b>
	/// </p><p>
	/// <b>1. New document</b><br/>
	/// <code>IXServicePortIF db = ... </code><br/>
	/// <code>ClientInfo ci = ... </code><br/>
	/// <code>EditInfo ed = db.createDoc(ci, "1", null, null, EditInfoC.mbSordDocAtt);</code><br/>
	/// <code>ed.sord.short="new document";</code><br/>
	/// <code>ed.document.docs = new DocVersion[1];</code><br/>
	/// <code>ed.document.docs[0] = new DocVersion();</code><br/>
	/// <code>ed.document.docs[0].ext = "TIF";</code><br/>
	/// <code>ed.document.docs[0].pathId = ed.sord.path;</code><br/>
	/// <code>ed.document.docs[0].encryptionSet = ed.sord.details.encryptionSet;</code><br/>
	/// <code>ed.document = db.checkinDocBegin(ci, ed.document);</code><br/>
	/// <code>ed.document.docs[0].uploadResult = ...upload(ed.document.docs[0].url, file);</code><br/>
	/// <code>ed.document = db.checkinDocEnd(ci, ed.sord, SORD.mbAll, ed.document, LockC.NO);</code><br/>
	/// </p><p>
	/// <b>2. New document (file) version</b><br/>
	/// <code>IXServicePortIF db = ... </code><br/>
	/// <code>ClientInfo ci = ... </code><br/>
	/// <code>EditInfo ed = db.checkoutDoc(ci, "[object-ID]", null, EditInfoC.mbSordDocAtt, LockC.IF_FREE);</code><br/>
	/// <code>Document doc = new Document()</code><br/>
	/// <code>doc.docs = new DocVersion[1];</code><br/>
	/// <code>doc.docs[0] = new DocVersion();</code><br/>
	/// <code>doc.docs[0].ext = "TIF";</code><br/>
	/// <code>doc.docs[0].pathId = ed.sord.path;</code><br/>
	/// <code>doc.objId = 1234;</code><br/>
	/// <code>doc = db.checkinDocBegin(ci, doc);</code><br/>
	/// <code>doc.docs[0].uploadResult = ...upload(doc.docs[0].url, file);</code><br/>
	/// <code>doc = db.checkinDocEnd(ci, null, null, doc, LockC.YES);</code><br/>
	/// </p>
	/// </remarks>
	public: virtual PDocument checkinDocBegin(const PClientInfo& ci, const PDocument& document)  = 0;
	public: virtual void checkinDocBegin(const PClientInfo& ci, const PDocument& document, ::std::function< void (PDocument, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Checks-in already existing documents again.
	/// </summary>
	/// <remarks>
	/// <p>This method is used to reduce transmission
	/// time as the document does not have to be checked-out.</p>
	/// </remarks>
	public: virtual PDocument checkinDocDupl(const PClientInfo& ci, const PSord& sord, const PSordZ& sordZ, const PDocument& document, const PLockZ& unlockZ)  = 0;
	public: virtual void checkinDocDupl(const PClientInfo& ci, const PSord& sord, const PSordZ& sordZ, const PDocument& document, const PLockZ& unlockZ, ::std::function< void (PDocument, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Checks in an uploaded document.
	/// </summary>
	/// <remarks>
	/// <p>
	/// See <code>checkinDocBegin</code>, if you want to checkin new document or attachment version(s).
	/// </p>
	/// <p>
	/// Changing the document or attachment work version, version number, comment, flags or status:
	/// <code><br/><br/>
	/// Document doc = new Document();<br/>
	/// doc.objId = an object ID or GUID<br/>
	/// doc.docs = new DocVersion[] {new DocVersion()};<br/>
	/// doc.docs[0].id = a document ID;<br/>
	/// doc.docs[0].workVersion = true;<br/>
	/// doc.docs[0].version = "2.0";<br/>
	/// doc.docs[0].comment = "new comment";<br/>
	/// doc.docs[0].milestone = true;<br/>
	/// doc.docs[0].deleted = false;<br/>
	/// ix.checkinDocEnd(ci, null, null, doc, LOCK.NO);<br/>
	/// </code>
	/// </p>
	/// <p>
	/// If the supplied sord has <code>sord.type==LBT_DOCUMENT</code>, sord.type will be detected from
	/// the file extension of the given work version.
	/// </p>
	/// <p>
	/// If the document is only to be unlocked, see <code>checkinSord</code>.
	/// </p>
	/// </remarks>
	public: virtual PDocument checkinDocEnd(const PClientInfo& ci, const PSord& sord, const PSordZ& sordZ, const PDocument& document, const PLockZ& unlockZ)  = 0;
	public: virtual void checkinDocEnd(const PClientInfo& ci, const PSord& sord, const PSordZ& sordZ, const PDocument& document, const PLockZ& unlockZ, ::std::function< void (PDocument, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Writes a keywording form into the database.
	/// </summary>
	/// <remarks>
	/// A new mask is inserted when <code>docMask.no</code> is less than 0.
	/// <p>
	/// If an existing keywording form is written with modified group names (DocMaskLine.key), a
	/// background thread is started to update the existing index values (Sord.objKeys[.].name).
	/// Use collectJobState to watch the state of the background job. Its name is
	/// &quot;Update existing index values for keywording form=...&quot;
	/// </p>
	/// </remarks>
	public: virtual int32_t checkinDocMask(const PClientInfo& ci, const PDocMask& docMask, const PDocMaskZ& docMaskZ, const PLockZ& unlockZ)  = 0;
	public: virtual void checkinDocMask(const PClientInfo& ci, const PDocMask& docMask, const PDocMaskZ& docMaskZ, const PLockZ& unlockZ, ::std::function< void (int32_t, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// This method prepares the Index Server to allow multiple documents to be checked in at one time.
	/// </summary>
	/// <remarks>
	/// Utilized in the
	/// same manner as <code>checkinDocBegin</code> but is for multiple documents.
	/// </remarks>
	public: virtual PArrayDocument checkinDocsBegin(const PClientInfo& ci, const PArrayDocument& documents)  = 0;
	public: virtual void checkinDocsBegin(const PClientInfo& ci, const PArrayDocument& documents, ::std::function< void (PArrayDocument, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// This method checks-in uploaded documents.
	/// </summary>
	/// <remarks>
	/// Utilized in the same manner as <code>checkinDocEnd</code>
	/// but for multiple documents and sords.
	/// </remarks>
	public: virtual PArrayDocument checkinDocsEnd(const PClientInfo& ci, const PArraySord& sords, const PArraySordZ& sordZs, const PArrayDocument& documents, const PLockZ& unlockZ)  = 0;
	public: virtual void checkinDocsEnd(const PClientInfo& ci, const PArraySord& sords, const PArraySordZ& sordZs, const PArrayDocument& documents, const PLockZ& unlockZ, ::std::function< void (PArrayDocument, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Writes or inserts key objects.
	/// </summary>
	/// <remarks>
	/// <p>
	/// If key data is only to be unlocked then the method should be called with
	/// <code>keyInfos=null</code> and <code>lockZ=lockZ.YES</code>.
	/// </p><p>
	/// The key objects with <code>KeyInfo[].id=-1</code> will be inserted in the database. Objects
	/// with <code>KeyInfo[].id>=0</code> will be updated.
	/// </p><p>
	/// Since the function requires an exclusive access to the user data, the data
	/// must be locked for the current user or must not be locked for anyone. To
	/// check in regardless of a lock supply <code>lockZ.FORCE</code>
	/// in <code>lockZ</code>.
	/// </remarks>
	public: virtual PArrayInt checkinKeys(const PClientInfo& ci, const PArrayKeyInfo& keyInfos, const PLockZ& unlockZ)  = 0;
	public: virtual void checkinKeys(const PClientInfo& ci, const PArrayKeyInfo& keyInfos, const PLockZ& unlockZ, ::std::function< void (PArrayInt, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Insert keywords and all their children.
	/// </summary>
	/// <remarks>
	/// The keyword IDs specify whether to insert or update.
	/// <p>
	/// <table border="2">
	/// <tr><td><code>kws[.].id={existing ID}</code></td>
	/// <td>
	/// Updates the keyword tree branch below the keyword with <code>kws[.].id</code>.
	/// The keyword must exist.
	/// </td></tr>
	/// <tr><td><code>kws[.].id={new root ID}</code></td>
	/// <td>Inserts or updates a new keyword list.</td></tr>
	/// </table>
	/// </p><p>
	/// <table border="2">
	/// <tr><th>Operations</th><th>Solution</td>
	/// <tr>
	/// <td>Insert a new child into an existing parent keyword</td>
	/// <td>Check-in the parent keyword with all current children plus the new child.
	/// Setting the text members and children arrays of the current children to <code>null</code> leaves them unchanged.
	/// </td>
	/// </tr>
	/// <tr>
	/// <td>Delete a child of an existing parent keyword</td>
	/// <td>Check-in the parent keyword with all current children minus the child to be deleted.
	/// Setting the text members and children arrays of the current children to <code>null</code> leaves them unchanged.
	/// </td>
	/// </tr>
	/// <tr>
	/// <td>Update <code>text, add, enabled</code> of an existing keyword</td>
	/// <td>Check-in the keyword with a non empty text member. Only when the text is not <code>null</code>
	/// and not an empty string will the members <code>add</code> and <code>enabled</code> be written into the database.
	/// </td>
	/// </tr>
	/// </table>
	/// </p>
	/// <p><b>IMPORTANT: This function assigns new IDs to all branches of the
	/// keyword trees below the parent keywords of the given keywords.
	/// The client program should read the parent keyword and all children below
	/// again to receive the new IDs. </b></p>
	/// <p>The access rights <code>AccessC.FLAG_EDITCONFIG</code> and
	/// <code>AccessC.FLAG_EDITSWL</code> are required to check-in keywords.<p>
	/// </remarks>
	public: virtual void checkinKeywords(const PClientInfo& ci, const PArrayKeyword& kws, const PLockZ& unlockZ)  = 0;
	public: virtual void checkinKeywords(const PClientInfo& ci, const PArrayKeyword& kws, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Write or insert Notes.
	/// </summary>
	/// <remarks>
	/// <p>Only Sord objects that reference documents can have notes.
	/// It is also possible to delete a Note: <code>notes[.].setDeleted(true);</code>.</p>
	/// <p> NOTE: When checking changed notes of annotation in stamp type notes or annotations
	/// can only be checked in once. When attempting to check in stamp type notes that already
	/// exist an exception will be returned. Use <code>MbOnlyLock</code> to unlock notes and annotations.</p>
	/// </remarks>
	public: virtual PArrayInt checkinNotes(const PClientInfo& ci, const ::std::wstring& objId, const PArrayNote& notes, const PNoteZ& noteZ, const PLockZ& unlockZ)  = 0;
	public: virtual void checkinNotes(const PClientInfo& ci, const ::std::wstring& objId, const PArrayNote& notes, const PNoteZ& noteZ, const PLockZ& unlockZ, ::std::function< void (PArrayInt, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Inserts or updates a Notification object
	/// 
	/// if userGuid is null, the own Guid will be taken
	/// if userGuid is not the own Guid, admin rights are needed
	/// </summary>
	public: virtual PNotification checkinNotification(const PClientInfo& ci, const PNotification& notif, const PNotificationZ& notiZ)  = 0;
	public: virtual void checkinNotification(const PClientInfo& ci, const PNotification& notif, const PNotificationZ& notiZ, ::std::function< void (PNotification, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Inserts or updates a reminder object.
	/// </summary>
	/// <remarks>
	/// <p><code>Reminder.receiverId = -1</code> should be set if receiverId is to be ignored.
	/// <code>Reminder.receiverName = null</code> should be set if the receiverName is to be ignored.</p>
	/// </remarks>
	public: virtual PArrayInt checkinReminder(const PClientInfo& ci, const PReminder& remi, const PArrayString& receiverIds, bool expandGroups, const PLockZ& unlockZ)  = 0;
	public: virtual void checkinReminder(const PClientInfo& ci, const PReminder& remi, const PArrayString& receiverIds, bool expandGroups, const PLockZ& unlockZ, ::std::function< void (PArrayInt, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Writes replication set names.
	/// </summary>
	public: virtual void checkinReplNames(const PClientInfo& ci, const PArrayReplSetName& replNames, const PLockZ& unlockZ)  = 0;
	public: virtual void checkinReplNames(const PClientInfo& ci, const PArrayReplSetName& replNames, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Writes the report options.
	/// </summary>
	public: virtual void checkinReportOptions(const PClientInfo& ci, const PReportOptions& options, const PLockZ& unlockZ)  = 0;
	public: virtual void checkinReportOptions(const PClientInfo& ci, const PReportOptions& options, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Writes or inserts a archive entry into the database.
	/// </summary>
	/// <remarks>
	/// <p>
	/// A new object does not have to be created with <code>createSord</code>. If the
	/// object is missing a GUID then a new one is created.
	/// </p>
	/// <p>
	/// If the Sord object is only to be unlocked <code>sordZ = SordC.mbOnlyUnlock</code> should be used
	/// and a minimum of <code>Sord.id</code> or <code>Sord.guid</code> must be set.
	/// </p>
	/// </remarks>
	public: virtual int32_t checkinSord(const PClientInfo& ci, const PSord& sord, const PSordZ& sordZ, const PLockZ& unlockZ)  = 0;
	public: virtual void checkinSord(const PClientInfo& ci, const PSord& sord, const PSordZ& sordZ, const PLockZ& unlockZ, ::std::function< void (int32_t, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Checks the existence of an archive path and creates missing entries if necessary by
	/// traversing top-down through the Sords array.
	/// </summary>
	/// <remarks>
	/// <p>The folders are inserted inside the same database transaction. Thus either all folders
	/// are created or none.</p>
	/// <p>This function allows only one process at a given time to create a structure. This prevents
	/// from creating the same archive path twice by two parallel working processes.</p>
	/// <p>In order to write index values (Sord.objKeys), parameter sordZ has to contain SordC.mbObjKeys.
	/// If sord.objKeys == null or sordZ does not contain SordC.mbObjKeys, the index values defaults
	/// defined by the keywording form are written.
	/// </p>
	/// </remarks>
	public: virtual PArrayInt checkinSordPath(const PClientInfo& ci, const ::std::wstring& parentId, const PArraySord& sords, const PSordZ& sordZ)  = 0;
	public: virtual void checkinSordPath(const PClientInfo& ci, const ::std::wstring& parentId, const PArraySord& sords, const PSordZ& sordZ, ::std::function< void (PArrayInt, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Write or insert sord type information.
	/// </summary>
	public: virtual void checkinSordTypes(const PClientInfo& ci, const PArraySordType& sordTypes, const PLockZ& unlockZ)  = 0;
	public: virtual void checkinSordTypes(const PClientInfo& ci, const PArraySordType& sordTypes, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// This method passes path information to the document manager.
	/// </summary>
	public: virtual PArrayStoreInfo checkinStorage(const PClientInfo& ci, const PArrayStoreInfo& storeInfos, const PLockZ& unlockZ)  = 0;
	public: virtual void checkinStorage(const PClientInfo& ci, const PArrayStoreInfo& storeInfos, const PLockZ& unlockZ, ::std::function< void (PArrayStoreInfo, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Insert deputy/substitute information.
	/// </summary>
	public: virtual void checkinSubs(const PClientInfo& ci, const PArraySubsInfo& deps, const PLockZ& unlockZ)  = 0;
	public: virtual void checkinSubs(const PClientInfo& ci, const PArraySubsInfo& deps, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Write (add) user profile options.
	/// </summary>
	public: virtual void checkinUserProfile(const PClientInfo& ci, const PUserProfile& userProfile, const PLockZ& unlockZ)  = 0;
	public: virtual void checkinUserProfile(const PClientInfo& ci, const PUserProfile& userProfile, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Writes or inserts users or groups.
	/// </summary>
	/// <remarks>
	/// <p>
	/// When inserting users or groups either <code>UserInfo.id=-1</code> should be
	/// set or the bit <code>CheckinUsersC.NEW_USER</code> in
	/// <code>checkinUsersC</code> should be used.
	/// The second case allows a complete user and group structure to be checked in with
	/// a single call of <code>checkinUsers</code>. Therefore the IDs in the submitted
	/// <code>UserInfo</code> objects must be unique and cannot be used by other users or groups in
	/// the archive database.
	/// </p><p>
	/// If only the user data is to be unlocked then the method should be called with
	/// <code>userInfos=null</code> and <code>lockZ=lockZ.YES</code>.
	/// </p><p>
	/// If the user of the current session is a sub-administrator (has right AccessC.FLAG_SUBADMIN)
	/// the <code>UserInfo.parent</code> members of the users in <code>userInfos</code>
	/// are internally set to the current users ID. In other words: sub-administrators
	/// are not free to define the parent of the users or groups.
	/// </p><p>
	/// The method checks whether the users or groups to be checked-in have
	/// more rights than their parents (administrators).
	/// </p><p>
	/// Since the function requires an exclusive access to the user data, the data
	/// must be locked for the current user or must not be locked for anyone. To
	/// check in regardless of a lock  <code>lockZ.FORCE</code> must be supplied
	/// in <code>lockZ</code>.
	/// </p><p>
	/// The users password is only written for new users or if
	/// <code>CheckinUsersC.PASSWORD</code> for the parameter <code>checkinUsersZ</code>
	/// is supplied along with the password member <code>UserInfo.pwd!=null</code>.
	/// In this case, the userInfos array must be of length=1. The user does not
	/// need to have the right AccessC.FLAG_SUBADMIN, but must have the right AccessC.FLAG_CHANGEPW.
	/// Only the members UserInfo.id and UserInfo.pwd are taken into account. This is how to
	/// change a password:
	/// <code>UserInfo ui = new UserInfo();</code><br/>
	/// <code>ui.id = current user id;</code><br/>
	/// <code>ui.pwd = new password;</code><br/>
	/// <code>ix.checkinUsers(ci, new UserInfo[] {ui}, CheckinUsersC.PASSWORD, LockC.NO);</code>
	/// </p><p>
	/// Password rules are checked, if the user changes the password or if a new user is stored.
	/// The password rules are defined in the user profile value at key UserProfileC.KEY_PASSWORD_RULES.
	/// If the password violates the password rules, an exception is throw with message "[ELOIX:3007]...".
	/// The error number (3007) is defined in IXExceptionC.PASSWORD_DENIED.
	/// </p><p>
	/// The password expiring date is handled. If the password is changed, the expiring date in the
	/// user data is updated: UserInfo.userProps[UserInfoC.PROP_ACTION] = "EX{iso-date-without-time}".
	/// Interactive client applications should check the action field in order display a dialog, if the
	/// password has to be changed. They do not need to check the "EX<iso-date>", because it is replaced
	/// by "PWf" (must change password) for the UserInfo object in the LoginResult object return by the
	/// login() functions, resp. the create() functions of IXConnFactory.
	/// The following code is recommended:
	/// <code>IXConnection conn = ...</code><br/>
	/// <code>String action = conn.getLoginResult().getUser().userProps[UserInfoC.PROP_ACTION];</code><br/>
	/// <code>boolean userShouldChangePassword = action.indexOf(UserInfoC.PROP_ACTION_USER_SHOULD_CHANGE_PASSWORD) >= 0;</code><br/>
	/// <code>boolean userMustChangePassword = action.indexOf(UserInfoC.PROP_ACTION_USER_MUST_CHANGE_PASSWORD) >= 0;</code>
	/// </p>
	/// </remarks>
	public: virtual PArrayInt checkinUsers(const PClientInfo& ci, const PArrayUserInfo& userInfos, const PCheckinUsersZ& checkinUsersZ, const PLockZ& unlockZ)  = 0;
	public: virtual void checkinUsers(const PClientInfo& ci, const PArrayUserInfo& userInfos, const PCheckinUsersZ& checkinUsersZ, const PLockZ& unlockZ, ::std::function< void (PArrayInt, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Inserts or updates organizational units.
	/// </summary>
	/// <remarks>
	/// <p>
	/// When inserting a new OU, <code>OrgUnitInfo.id=-1</code> has to be set.
	/// More than one OU can be checked in with a single call of
	/// <code>checkinOrgUnit</code>. Therefore the names, IDs and GUIDs in the
	/// submitted <code>OrgUnitInfo</code> objects must be unique and cannot be
	/// used by other OUs in the archive database.
	/// </p><p>
	/// If only the user and OU data is to be unlocked then the method should be
	/// called with <code>orgUnitInfos=null</code> and <code>lockZ=lockZ.YES</code>.
	/// </p>
	/// </remarks>
	public: virtual PMapIntegerOrgUnitInfo checkinOrgUnits(const PClientInfo& ci, const PArrayOrgUnitInfo& orgUnitInfos, const PCheckinOrgUnitInfo& reserved, const PLockZ& unlockZ)  = 0;
	public: virtual void checkinOrgUnits(const PClientInfo& ci, const PArrayOrgUnitInfo& orgUnitInfos, const PCheckinOrgUnitInfo& reserved, const PLockZ& unlockZ, ::std::function< void (PMapIntegerOrgUnitInfo, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Delete OUs.
	/// </summary>
	public: virtual void deleteOrgUnits(const PClientInfo& ci, const PArrayString& ids, const PLockZ& unlockZ)  = 0;
	public: virtual void deleteOrgUnits(const PClientInfo& ci, const PArrayString& ids, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Read the data of all OUs.
	/// </summary>
	public: virtual PMapIntegerOrgUnitInfo checkoutOrgUnits(const PClientInfo& ci, const PCheckoutOrgUnitInfo& reserved, const PLockZ& lockZ)  = 0;
	public: virtual void checkoutOrgUnits(const PClientInfo& ci, const PCheckoutOrgUnitInfo& reserved, const PLockZ& lockZ, ::std::function< void (PMapIntegerOrgUnitInfo, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Write/create a workflow.
	/// </summary>
	/// <remarks>
	/// <p>In case of a new workflow object of type WFTypeC.ACTIVE, the workflow is
	/// immediately started after written into database. This requires a valid WFDiagram.getObjId().</p>
	/// </remarks>
	public: virtual int32_t checkinWorkFlow(const PClientInfo& ci, const PWFDiagram& wf, const PWFDiagramZ& workFlowDiagramZ, const PLockZ& unlockZ)  = 0;
	public: virtual void checkinWorkFlow(const PClientInfo& ci, const PWFDiagram& wf, const PWFDiagramZ& workFlowDiagramZ, const PLockZ& unlockZ, ::std::function< void (int32_t, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Checkout the markers definitions (colors of archive entries).
	/// </summary>
	public: virtual PArrayColorData checkoutColors(const PClientInfo& ci, const PLockZ& lockZ)  = 0;
	public: virtual void checkoutColors(const PClientInfo& ci, const PLockZ& lockZ, ::std::function< void (PArrayColorData, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Read config file names and file data.
	/// </summary>
	/// <remarks>
	/// <p>
	/// The <code>names</code> parameter selects the config files. Each element in
	/// this array contains the virtual path to a file. A path private to a user starts
	/// with the user s name. Paths may contain the wildcard <code>*</code> instead
	/// of a file name. In this case all files in the directory are returned.
	/// </p><p>
	/// <table border="2">
	/// <tr><td>Example</td><td>Description</td></tr>
	/// <tr><td><code>name[.]=peter/template/*</code></td>
	/// <td>Selects all private document templates of user peter (document templates are currently not supported!)</td></tr>
	/// <tr><td><code>name[.]=peter/postbox/*</code></td>
	/// <td>Selects peters server side postbox files</td></tr>
	/// <tr><td><code>name[.]=template/*</code></td>
	/// <td>Selects all document templates available for all users (document templates are currently not supported!)</td></tr>
	/// <tr><td><code>name[.]=eloscripts/*</code></td>
	/// <td>Selects all scripts</td></tr>
	/// </table>
	/// </p>
	/// </remarks>
	public: virtual PArrayConfigFile checkoutConfigFiles(const PClientInfo& ci, const PArrayString& names, const PConfigFileZ& configFileZ, const PLockZ& lockZ)  = 0;
	public: virtual void checkoutConfigFiles(const PClientInfo& ci, const PArrayString& names, const PConfigFileZ& configFileZ, const PLockZ& lockZ, ::std::function< void (PArrayConfigFile, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Get counter information.
	/// </summary>
	public: virtual PArrayCounterInfo checkoutCounters(const PClientInfo& ci, const PArrayString& counterNames, bool incrementCounters, const PLockZ& lockZ)  = 0;
	public: virtual void checkoutCounters(const PClientInfo& ci, const PArrayString& counterNames, bool incrementCounters, const PLockZ& lockZ, ::std::function< void (PArrayCounterInfo, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Reads the indexing information and the download URL of a document.
	/// </summary>
	/// <remarks>
	/// </p><p>
	/// At least one of the parameters <code>objId</code> and <code>docId</code> must
	/// be supplied.
	/// If only <code>objId</code> is supplied, the function reads the information
	/// for the current work version of the document. If <code>docId</code> is supplied,
	/// the function reads the information for a specific document or attachment version.
	/// All versions are returned if <code>docId="-1"</code> is supplied.
	/// </p><p>
	/// The document member of the returned object contains the URL from where the
	/// document file can be read. Use raw HTTP functions to download the file.
	/// </p>
	/// <p>
	/// If the document is only to be unlocked, see <code>checkinSord</code>.
	/// </p>
	/// </remarks>
	public: virtual PEditInfo checkoutDoc(const PClientInfo& ci, const ::std::wstring& objId, const ::std::wstring& docId, const PEditInfoZ& editInfoZ, const PLockZ& lockZ)  = 0;
	public: virtual void checkoutDoc(const PClientInfo& ci, const ::std::wstring& objId, const ::std::wstring& docId, const PEditInfoZ& editInfoZ, const PLockZ& lockZ, ::std::function< void (PEditInfo, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Reads a storage mask from the database.
	/// </summary>
	public: virtual PDocMask checkoutDocMask(const PClientInfo& ci, const ::std::wstring& maskId, const PDocMaskZ& docMaskZ, const PLockZ& lockZ)  = 0;
	public: virtual void checkoutDocMask(const PClientInfo& ci, const ::std::wstring& maskId, const PDocMaskZ& docMaskZ, const PLockZ& lockZ, ::std::function< void (PDocMask, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Reads a list of key objects.
	/// </summary>
	public: virtual PArrayKeyInfo checkoutKeys(const PClientInfo& ci, const PArrayString& ids, const PLockZ& lockZ)  = 0;
	public: virtual void checkoutKeys(const PClientInfo& ci, const PArrayString& ids, const PLockZ& lockZ, ::std::function< void (PArrayKeyInfo, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Collects keywords and their children.
	/// </summary>
	/// <remarks>
	/// <p>The keyword objects with the given <code>kwids[.]</code> will be read.
	/// <table border="2">
	/// <tr><td rowspan=4><code>kwids[.]=</code></td><td><code>KeywordC.KWID_*</code>,</td></tr>
	/// <tr><td>an index row name,</td></tr>
	/// <tr><td>an ID of a previously read keyword.</td></tr>
	/// <tr><td>null, to read all toplevel keyword lists. Parameter <code>max</code> is ignored.</td></tr>
	/// </table>
	/// </p>
	/// <p>The parameter <code>max</code> controls how many keywords will be read.
	/// <table border="2">
	/// <tr><td>max = 0</td><td>Only the first level directly below the given
	/// <code>kwids[.]</code> is read (up to 676 keywords). The children of the
	/// returned keywords are <code>null</code></td></tr>
	/// <tr><td><code>max</code> = -1</td><td>Entire tree below <code>kwid</code> is read.</td></tr>
	/// <tr><td><code>max</code> &gt; 0</td><td>Approximately up to this number of keywords are read.
	/// The children of a keyword are always read completely or they are <code>null</code>.
	/// Thus up to <code>max</code>+675 keywords could be returned.</td></tr>
	/// </table>
	/// </p>
	/// <p>
	/// Hint: if <code>max</code> &gt;= 0 and the <code>Keyword.children</code>
	/// of a keyword is an empty array (not <code>null</code>), the keyword has definitely no children.
	/// If <code>Keyword.children = null</code>, query the children with a further
	/// call to <code>collectKeywords</code>.
	/// </p>
	/// <p>
	/// Before one of the returned keywords can be used as an index value the
	/// members <code>Keyword.enabled</code> and <code>Keyword.raw</code> must be
	/// analyzed, see <code>Keyword</code> documentation.</p>
	/// <p>You need the access right <code>AccessC.FLAG_EDITCONFIG</code> to lock keywords against concurrent modification.<p>
	/// </remarks>
	public: virtual PArrayKeyword checkoutKeywords(const PClientInfo& ci, const PArrayString& kwids, const PKeywordZ& keywordZ, int32_t max, const PLockZ& lockZ)  = 0;
	public: virtual void checkoutKeywords(const PClientInfo& ci, const PArrayString& kwids, const PKeywordZ& keywordZ, int32_t max, const PLockZ& lockZ, ::std::function< void (PArrayKeyword, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Read notes of a given Sord.
	/// </summary>
	public: virtual PArrayNote checkoutNotes(const PClientInfo& ci, const ::std::wstring& objId, const PArrayString& noteIds, const PNoteZ& noteZ, const PLockZ& lockZ)  = 0;
	public: virtual void checkoutNotes(const PClientInfo& ci, const ::std::wstring& objId, const PArrayString& noteIds, const PNoteZ& noteZ, const PLockZ& lockZ, ::std::function< void (PArrayNote, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Reads Notification for a watchGuid / userGuid combination
	/// 
	/// if userGuid is null, the own Guid will be taken
	/// if userGuid is not the own Guid, admin rights are needed
	/// </summary>
	public: virtual PNotification checkoutNotification(const PClientInfo& ci, const ::std::wstring& watchGuid, const ::std::wstring& userGuid)  = 0;
	public: virtual void checkoutNotification(const PClientInfo& ci, const ::std::wstring& watchGuid, const ::std::wstring& userGuid, ::std::function< void (PNotification, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Reads and locks a reminder object.
	/// </summary>
	public: virtual PArrayReminder checkoutReminders(const PClientInfo& ci, const PArrayInt& reminderIds, const PLockZ& lockZ)  = 0;
	public: virtual void checkoutReminders(const PClientInfo& ci, const PArrayInt& reminderIds, const PLockZ& lockZ, ::std::function< void (PArrayReminder, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Reads replication set names.
	/// </summary>
	public: virtual PArrayReplSetName checkoutReplNames(const PClientInfo& ci, const PLockZ& lockZ)  = 0;
	public: virtual void checkoutReplNames(const PClientInfo& ci, const PLockZ& lockZ, ::std::function< void (PArrayReplSetName, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Reads the report options.
	/// </summary>
	public: virtual PReportOptions checkoutReportOptions(const PClientInfo& ci, const PLockZ& lockZ)  = 0;
	public: virtual void checkoutReportOptions(const PClientInfo& ci, const PLockZ& lockZ, ::std::function< void (PReportOptions, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Reads the data needed to edit an existing archive entry.
	/// </summary>
	/// <remarks>
	/// <table border="2">
	/// <tr>
	/// <td>Possible object identifiers (parameter objId)</td>
	/// <td>Usage</td>
	/// </tr><tr>
	/// <td>ID</td>
	/// <td>A numeric object number corresponding to Sord.getId() converted to string</td>
	/// </tr><tr>
	/// <td>GUID</td>
	/// <td>A GUID corresponding to Sord.getGuid()</td>
	/// </tr><tr>
	/// <td>Index value</td>
	/// <td>Use "OKEY:&lt;index-group-name&gt;=&lt;index-value&gt;" to select an object by an index value, example: "OKEY:SAPPATH=123124109824123/data".
	/// The wildcards &quot;%&quot; or &quot;*&quot; can be used in &lt;index-group-name&gt; or &lt;index-value&gt; to return all or any data that matches.
	/// </td>
	/// </tr><tr>
	/// <td>Index match value</td>
	/// <td>Use "LMATCH:&lt;index-group-name&gt;=&lt;fix-value&gt;%&lt;match-value&gt;"
	/// to select an object by an index value that starts with &lt;fix-value&gt; and
	/// might be followed by &lt;match-value&gt;. The object that fits most characters
	/// in &lt;match-value&gt; is selected.
	/// Example: "LMATCH:ELOINDEX=S%CH".
	/// The wildcards &quot;%&quot; or &quot;*&quot; can be used in &lt;index-group-name&gt; or &lt;match-value&gt; to return all or any data that matches.
	/// This selection mode only be utilized on non-deleted Sords.
	/// </td>
	/// </tr><tr>
	/// <td>Archive path</td>
	/// <td>Use "ARCPATH:&lt;delim-char&gt;&lt;SordName1&gt;&lt;delim-char&gt;&lt;SordName2&gt;..."
	/// to select an object by an archive path.
	/// This selection mode only be utilized on non-deleted Sords.
	/// </td>
	/// </tr><tr>
	/// <td>Archive path with base ID</td>
	/// <td>Use "ARCPATH[&lt;ID&gt;]:&lt;delim-char&gt;&lt;SordName1&gt;&lt;delim-char&gt;&lt;SordName2&gt;..." to select an object by an archive path</td>
	/// </tr>
	/// </tr><tr>
	/// <td>MD5 hash</td>
	/// <td>Use "MD5:&lt;MD5-hash-hex-string&gt;" to select an object by an MD5 hash. Use upper case letters for hexadecimal characters for the hash value.</td>
	/// </tr>
	/// </table>
	/// <p>
	/// The object can be locked against concurrent modification if <code>lockZ</code>
	/// is set to <code>lockZ.YES</code>.
	/// </remarks>
	public: virtual PEditInfo checkoutSord(const PClientInfo& ci, const ::std::wstring& objId, const PEditInfoZ& editInfoZ, const PLockZ& lockZ)  = 0;
	public: virtual void checkoutSord(const PClientInfo& ci, const ::std::wstring& objId, const PEditInfoZ& editInfoZ, const PLockZ& lockZ, ::std::function< void (PEditInfo, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// <code>checkoutSordHistory</code> retrieves all history entries related to a given object.
	/// </summary>
	public: virtual PArraySordHist checkoutSordHistory(const PClientInfo& ci, const ::std::wstring& objId)  = 0;
	public: virtual void checkoutSordHistory(const PClientInfo& ci, const ::std::wstring& objId, ::std::function< void (PArraySordHist, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Get sord type information.
	/// </summary>
	/// <remarks>
	/// <p>SordType objects give access to labels,
	/// icons and extensions corresponding to <code>Sord.type.</code></p>
	/// <p>Parameter <code>sordTypes</code> can be:
	/// <table border="2">
	/// <tr><th>sordType</th><th>return</th></tr>
	/// <tr><td>Array of type numbers or names</td><td>Returns for each type number (resp. name) the associated SordType information</td></tr>
	/// <tr><td>null</td><td>Returns SordType information for all types</td></tr>
	/// </table>
	/// </p><p>
	/// Parameter <code>sordTypeZ</code> specifies which members of the returned objects should be filled.
	/// It also contains the content type of the image data to be returned. This content type correspond
	/// to directories named "jpg", "ico" resp. "bmp" below ".../am-eloam/configuration/initdata/images/sordtypes/".
	/// Use ELO CLIENT to fill the directories with images of the required type.
	/// </p>
	/// </remarks>
	public: virtual PArraySordType checkoutSordTypes(const PClientInfo& ci, const PArrayInt& sordTypeIds, const PSordTypeZ& sordTypeZ, const PLockZ& lockZ)  = 0;
	public: virtual void checkoutSordTypes(const PClientInfo& ci, const PArrayInt& sordTypeIds, const PSordTypeZ& sordTypeZ, const PLockZ& lockZ, ::std::function< void (PArraySordType, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// checkoutStorage retrieves an array of configured paths from the Document
	/// Manager.
	/// </summary>
	/// <remarks>
	/// The contents matches the table &lt;elodmpath&gt;.
	/// </remarks>
	public: virtual PArrayStoreInfo checkoutStorage(const PClientInfo& ci, const PArrayString& ids, const PLockZ& lockZ)  = 0;
	public: virtual void checkoutStorage(const PClientInfo& ci, const PArrayString& ids, const PLockZ& lockZ, ::std::function< void (PArrayStoreInfo, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Read the substitute information for the given user.
	/// </summary>
	/// <remarks>
	/// <p>The returned array
	/// contains the relations/users for which the given user is the substituted person
	/// or the substitute.</p>
	/// </remarks>
	public: virtual PArraySubsInfo checkoutSubs(const PClientInfo& ci, const ::std::wstring& userId, const PLockZ& lockZ)  = 0;
	public: virtual void checkoutSubs(const PClientInfo& ci, const ::std::wstring& userId, const PLockZ& lockZ, ::std::function< void (PArraySubsInfo, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Read user profile options.
	/// </summary>
	/// <remarks>
	/// <p>
	/// Set <code>userProfile.userId</code> to the current user, to read her or his entire option set.
	/// This means that the default values for all users and the options inherited from the users groups are included too.
	/// </p>
	/// <p>
	/// In order to read the user specific options without defaults and group options, set <code>userProfile.excludeDefaultValues=true</code>
	/// and <code>userProfile.excludeGroupValues=true</code>.
	/// </p>
	/// </remarks>
	public: virtual PUserProfile checkoutUserProfile(const PClientInfo& ci, const PUserProfile& userProfile, const PLockZ& lockZ)  = 0;
	public: virtual void checkoutUserProfile(const PClientInfo& ci, const PUserProfile& userProfile, const PLockZ& lockZ, ::std::function< void (PUserProfile, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Reads the user data for users or groups.
	/// </summary>
	/// <remarks>
	/// <p>
	/// The function has various options for specifying which users are to read, e. g. all users,
	/// users of a specific group or groups of a specific user. The options are controlled
	/// with the bit-mask parameter <code>checkoutUsersC</code>. Possible values are
	/// combinations of <code>CheckoutUsersC</code> values.
	/// </p><p>
	/// Supplying <code>lockZ.YES</code> or <code>lockZ.FORCE</code> for the parameter
	/// <code>lockZ</code> locks the user data against concurrent modification.
	/// The lock can be released with <code>checkinUsers</code> or <code>deleteUsers</code>.
	/// </p><p>
	/// All returned <code>UserInfo</code> objects have empty passwords because the
	/// passwords cannot be read from the archive database.
	/// </p>
	/// </remarks>
	public: virtual PArrayUserInfo checkoutUsers(const PClientInfo& ci, const PArrayString& ids, const PCheckoutUsersZ& checkoutUsersZ, const PLockZ& lockZ)  = 0;
	public: virtual void checkoutUsers(const PClientInfo& ci, const PArrayString& ids, const PCheckoutUsersZ& checkoutUsersZ, const PLockZ& lockZ, ::std::function< void (PArrayUserInfo, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Reads a workflow definition.
	/// </summary>
	public: virtual PWFDiagram checkoutWorkFlow(const PClientInfo& ci, const ::std::wstring& flowId, const PWFTypeZ& typeZ, const PWFDiagramZ& workFlowDiagramZ, const PLockZ& lockZ)  = 0;
	public: virtual void checkoutWorkFlow(const PClientInfo& ci, const ::std::wstring& flowId, const PWFTypeZ& typeZ, const PWFDiagramZ& workFlowDiagramZ, const PLockZ& lockZ, ::std::function< void (PWFDiagram, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// <code>cleanupStart(ClientInfo ci)</code> removes all deleted objects and related
	/// entries from the archive database.
	/// </summary>
	/// <remarks>
	/// <p>Once started the call returns immediately,
	/// while the unique background thread cleans the archive until it finishes or
	/// <code>cleanupStart(ClientInfo ci)</code> is called. Only users owning main administrator
	/// rights may clean up archives.</p>
	/// </remarks>
	public: virtual bool cleanupStart(const PClientInfo& ci, const PDeleteOptions& deleteOptions)  = 0;
	public: virtual void cleanupStart(const PClientInfo& ci, const PDeleteOptions& deleteOptions, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// <code>cleanupState(ClientInfo ci)</code> returns state information in
	/// a <code>BackgroundThreadInfo</code>.
	/// </summary>
	/// <remarks>
	/// <p>
	/// <table>
	/// <tr><td>IsRunning       </td><td>true/false;</td></tr>
	/// <tr><td>ThreadStart     </td><td>ISO date containing the cleaner s start;</td></tr>
	/// <tr><td>CountProcessed  </td><td>visited archive entries</td></tr>
	/// <tr><td>CountErrors     </td><td>erroneous entries</td></tr>
	/// <tr><td>LastID          </td><td>object ID of the last visited entry</td></tr>
	/// <tr><td>LastGUID        </td><td>object GUID of the last visited entry</td></tr>
	/// </table>
	/// </p>
	/// </remarks>
	public: virtual PJobState cleanupState(const PClientInfo& ci)  = 0;
	public: virtual void cleanupState(const PClientInfo& ci, ::std::function< void (PJobState, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// <code>cleanupStop(ClientInfo ci)</code> stops the cleaning as soon as possible
	/// finishing open transactions first.
	/// </summary>
	/// <remarks>
	/// <p>The call returns, when the background cleaner has
	/// been stopped. Only users owning main administrative rights may clean up archives.</p>
	/// </remarks>
	public: virtual bool cleanupStop(const PClientInfo& ci)  = 0;
	public: virtual void cleanupStop(const PClientInfo& ci, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// <code>collectJobStates</code> lists all the states of currently existing jobs from the IX backround job pool
	/// running or finished, but still listed.
	/// </summary>
	public: virtual PArrayJobState collectJobStates(const PClientInfo& ci, bool activeJobs, bool finishedJobs, bool fullInfo)  = 0;
	public: virtual void collectJobStates(const PClientInfo& ci, bool activeJobs, bool finishedJobs, bool fullInfo, ::std::function< void (PArrayJobState, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Collect workflow nodes.
	/// </summary>
	public: virtual PArrayWFCollectNode collectWorkFlowNodes(const PClientInfo& ci, const ::std::wstring& flowName, const PWFTypeZ& wfTypeZ, const ::std::wstring& nodeName, int32_t nodeType, const ::std::wstring& objId, const ::std::wstring& enterDateIso, const ::std::wstring& exitDateIso, const PArrayString& userIds, bool onlyActive, bool onlyStartNodes)  = 0;
	public: virtual void collectWorkFlowNodes(const PClientInfo& ci, const ::std::wstring& flowName, const PWFTypeZ& wfTypeZ, const ::std::wstring& nodeName, int32_t nodeType, const ::std::wstring& objId, const ::std::wstring& enterDateIso, const ::std::wstring& exitDateIso, const PArrayString& userIds, bool onlyActive, bool onlyStartNodes, ::std::function< void (PArrayWFCollectNode, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Collects workflow names.
	/// </summary>
	/// <remarks>
	/// <p><b>This method will be deprecated in future versions of the ELO IndexServer</b>.
	/// It is recommended that the findFirstTasks() and findNextTasks() methods are used for retrieving
	/// workflow information from the IndexServer.</p>
	/// </remarks>
	public: virtual PArrayIdName collectWorkFlows(const PClientInfo& ci, const PWFTypeZ& typeZ)  = 0;
	public: virtual void collectWorkFlows(const PClientInfo& ci, const PWFTypeZ& typeZ, ::std::function< void (PArrayIdName, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Finds active workflows.
	/// </summary>
	/// <remarks>
	/// <p>This method returns all active workflows for the current user.</p>
	/// </remarks>
	public: virtual PFindResult findFirstWorkflows(const PClientInfo& ci, const PFindWorkflowInfo& findInfo, int32_t max, const PWFDiagramZ& wfDiagramZ)  = 0;
	public: virtual void findFirstWorkflows(const PClientInfo& ci, const PFindWorkflowInfo& findInfo, int32_t max, const PWFDiagramZ& wfDiagramZ, ::std::function< void (PFindResult, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Finds more active workflows.
	/// </summary>
	/// <remarks>
	/// <p>This method returns all active workflows for the current user.</p>
	/// </remarks>
	public: virtual PFindResult findNextWorkflows(const PClientInfo& ci, const ::std::wstring& searchId, int32_t index, int32_t maxResults)  = 0;
	public: virtual void findNextWorkflows(const PClientInfo& ci, const ::std::wstring& searchId, int32_t index, int32_t maxResults, ::std::function< void (PFindResult, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Replaces control sequences in the text of a keyword.
	/// </summary>
	public: virtual ::std::wstring cookKeyword(const PClientInfo& ci, const ::std::wstring& kwid)  = 0;
	public: virtual void cookKeyword(const PClientInfo& ci, const ::std::wstring& kwid, ::std::function< void (::std::wstring, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Moves an archive entry or creates a relation (logical copy).
	/// </summary>
	/// <remarks>
	/// <p>
	/// <b>1. Move</b><br/>
	/// To move an archive entry into another parent set bit <code>CopySordC.MOVE</code>
	/// in <code>copySordC</code>. Put the ID or GUID of the new parent into <code>newParentId</code>.
	/// If a reference shold be moved instead of an original, parameter <code>copyInfo</code> has to be passed with
	/// {@link CopyInfo#oldParentId} set to the current parent ID of the relation.
	/// In order to control the manual sort order, supply a <code>copyInfo</code> object with {@link CopyInfo#manSortIdx}.
	/// </p><p>
	/// <b>2. Relation</b><br/>
	/// Bit <code>CopySordC.REFERENCE</code> in <code>copySordC</code> should be used to
	/// create a logical copy of the archive entry in <code>newParentId</code>. <br/>
	/// Set <code>copyInfo=null</code> or supply an object and set the <code>CopyInfo.manSortIdx</code>
	/// to control the manual sort order. <br/>
	/// <p>References can be deleted with <code>deleteSord</code></p>
	/// </remarks>
	public: virtual int32_t copySord(const PClientInfo& ci, const ::std::wstring& newParentId, const ::std::wstring& objId, const PCopyInfo& copyInfo, const PCopySordZ& copySordZ)  = 0;
	public: virtual void copySord(const PClientInfo& ci, const ::std::wstring& newParentId, const ::std::wstring& objId, const PCopyInfo& copyInfo, const PCopySordZ& copySordZ, ::std::function< void (int32_t, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Creates a new document with indexing information.
	/// </summary>
	/// <remarks>
	/// </p><p>
	/// Currently the same as <code>createSord</code> but the type member of the
	/// returned indexing information (if any) is set to <code>SordC.LBT_DOCUMENT</code>.
	/// </p><p>
	/// If <code>maskId</code> is null or empty, the function tries to assign the
	/// mask defined in the configuration options of the Windows CLIENT.
	/// If this mask cannot be found, the behavior is unpredictable and
	/// -1 might be returned in sord.mask.
	/// </p>
	/// </remarks>
	public: virtual PEditInfo createDoc(const PClientInfo& ci, const ::std::wstring& parentId, const ::std::wstring& maskId, const ::std::wstring& docTemplate, const PEditInfoZ& editInfoZ)  = 0;
	public: virtual void createDoc(const PClientInfo& ci, const ::std::wstring& parentId, const ::std::wstring& maskId, const ::std::wstring& docTemplate, const PEditInfoZ& editInfoZ, ::std::function< void (PEditInfo, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Creates a storage mask object and assigns default values.
	/// </summary>
	/// <remarks>
	/// <p>
	/// This function does not insert the mask object into the database. Initial
	/// values can be copied from the mask specified with <code>maskId</code>.<p>
	/// </remarks>
	public: virtual PDocMask createDocMask(const PClientInfo& ci, const ::std::wstring& maskId)  = 0;
	public: virtual void createDocMask(const PClientInfo& ci, const ::std::wstring& maskId, ::std::function< void (PDocMask, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Creates and initializes a key object.
	/// </summary>
	public: virtual PKeyInfo createKey(const PClientInfo& ci)  = 0;
	public: virtual void createKey(const PClientInfo& ci, ::std::function< void (PKeyInfo, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Returns an initialized, temporary Note object.
	/// </summary>
	public: virtual PNote createNote(const PClientInfo& ci, const ::std::wstring& objId)  = 0;
	public: virtual void createNote(const PClientInfo& ci, const ::std::wstring& objId, ::std::function< void (PNote, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Returns an initialized, temporary Note object.
	/// </summary>
	/// <remarks>
	/// <p>The object is initialized by the given note template. Placeholders are
	/// replaced by the current values.</p>
	/// </remarks>
	public: virtual PNote createNote2(const PClientInfo& ci, const ::std::wstring& objId, int32_t noteType, const ::std::wstring& templId)  = 0;
	public: virtual void createNote2(const PClientInfo& ci, const ::std::wstring& objId, int32_t noteType, const ::std::wstring& templId, ::std::function< void (PNote, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Creates a reminder for the Sord specified by objId.
	/// </summary>
	public: virtual PReminder createReminder(const PClientInfo& ci, const ::std::wstring& objId)  = 0;
	public: virtual void createReminder(const PClientInfo& ci, const ::std::wstring& objId, ::std::function< void (PReminder, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Creates an object containing all the data needed to edit the
	/// indexing information of a new archive entry.
	/// </summary>
	/// <remarks>
	/// <p>
	/// The function does not insert
	/// the new object into the database. <code>checkinSord</code> is used to insert a
	/// new object in the database.</p>
	/// <p>
	/// This function can also be used to retrieve the lists of storage masks, markers (colours)
	/// etc. For this purpose parameter <code>parentId=null</code> must be set along with
	/// <code>maskId=null</code> and supply <code>EditInfoC.mbBasicData</code> for <code>editInfoZ</code>.
	/// </p><p>
	/// To create and initialize an object for indexing information, parameter
	/// <code>editInfoZ</code> must include bit <code>EditInfoZ.mbSordMembers</code>, e. g. <code>EditInfoZ.mbSord</code>.
	/// Parameter <code>parentId</code> can specify the ID or GUID of the parent entry
	/// in the archive hierarchy. Access rights and replication information
	/// are initialized from the parent.
	/// </p><p>The <code>maskId</code> parameter
	/// is the name or ID of a storage mask that defines a template for the indexing
	/// information. If <code>maskId</code> is null or empty, the function tries to assign the
	/// mask with GUID <code>DocMaskC.GUID_FOLDER</code>. If this mask cannot be found, the
	/// default folder mask defined in the configuration options of the Windows CLIENT is used.
	/// If this mask is also not found, the behavior is unpredictable and a -1 might be returned in sord.mask.
	/// </p><p>
	/// The parameters <code>parentId</code> and <code>maskId</code> are unchecked if an event script
	/// {@link IXServerEvents#onCreateSord(IXServerEventsContext, String, String, EditInfoZ)} is configured.
	/// In this case, both can have arbitrary values.
	/// </p>
	/// </remarks>
	public: virtual PEditInfo createSord(const PClientInfo& ci, const ::std::wstring& parentId, const ::std::wstring& maskId, const PEditInfoZ& editInfoZ)  = 0;
	public: virtual void createSord(const PClientInfo& ci, const ::std::wstring& parentId, const ::std::wstring& maskId, const PEditInfoZ& editInfoZ, ::std::function< void (PEditInfo, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Creates an object for user data.
	/// </summary>
	/// <remarks>
	/// <p>
	/// The returned <code>UserInfo</code> object is initialized with default values.
	/// User rights and keys are copied from the user <code>rightsAsUserId</code>.</p>
	/// 
	/// <p>This function does not create a new user in the archive database. To insert a new
	/// user into the database the function <code>checkinUsers</code> must be used after the user has been
	/// created with<code>createUser</code>.</p>
	/// 
	/// <p>If the user calling this function is a main administrator (has right
	/// AccessC.FLAG_ADMIN), the created user will have the same <code>UserInfo.parent</code>
	/// as the user specified in <code>rightsAsUserId</code>. If the user calling
	/// this function is a sub-administrator (has right AccessC.FLAG_SUBADMIN), the
	/// parent of the created user is the id of the calling user.</p>
	/// </remarks>
	public: virtual PUserInfo createUser(const PClientInfo& ci, const ::std::wstring& rightsAsUserId)  = 0;
	public: virtual void createUser(const PClientInfo& ci, const ::std::wstring& rightsAsUserId, ::std::function< void (PUserInfo, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Initalizes a WFNode object.
	/// </summary>
	/// <remarks>
	/// <p>WFNode.userId is set to WFNodeC.USERID_OWNER if the supplied type is a person node.</p>
	/// </remarks>
	public: virtual PWFNode createWFNode(const PClientInfo& ci, int32_t nodeId, int32_t nodeTypeC)  = 0;
	public: virtual void createWFNode(const PClientInfo& ci, int32_t nodeId, int32_t nodeTypeC, ::std::function< void (PWFNode, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Prepares a WFDiagram structure.
	/// </summary>
	public: virtual PWFDiagram createWorkFlow(const PClientInfo& ci, const ::std::wstring& wfName, const PWFTypeZ& typeZ)  = 0;
	public: virtual void createWorkFlow(const PClientInfo& ci, const ::std::wstring& wfName, const PWFTypeZ& typeZ, ::std::function< void (PWFDiagram, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Deletes configuration files.
	/// </summary>
	public: virtual void deleteConfigFiles(const PClientInfo& ci, const PArrayString& names, const PLockZ& unlockZ)  = 0;
	public: virtual void deleteConfigFiles(const PClientInfo& ci, const PArrayString& names, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Delete counters.
	/// </summary>
	/// <remarks>
	/// <p>This function is currently not implemented and always throws
	/// an exception. Counters cannot be deleted.</p>
	/// </remarks>
	public: virtual void deleteCounters(const PClientInfo& ci, const PArrayString& counterNames, const PLockZ& unlockZ)  = 0;
	public: virtual void deleteCounters(const PClientInfo& ci, const PArrayString& counterNames, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Deletes a storage mask.
	/// </summary>
	/// <remarks>
	/// </p><p>
	/// If archive entries connected to the mask still exist in the database, another
	/// mask <code>assignMaskId</code> can be assigned to them.
	/// </p><p>
	/// If <code>assignMaskId</code> is not defined and there are objects connected
	/// to the mask in the database the method throws an exception.
	/// </p><p>
	/// </remarks>
	public: virtual bool deleteDocMask(const PClientInfo& ci, const ::std::wstring& maskId, const ::std::wstring& assignMaskId, const PLockZ& unlockZ)  = 0;
	public: virtual void deleteDocMask(const PClientInfo& ci, const ::std::wstring& maskId, const ::std::wstring& assignMaskId, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Deletes keys.
	/// </summary>
	/// <remarks>
	/// <p>
	/// Since the function requires an exclusive access to the user data, the data
	/// must be locked for the current user or must not be locked for anyone. To
	/// check in regardless of a lock supply <code>lockZ.FORCE</code>
	/// in <code>lockZ</code>.
	/// </remarks>
	public: virtual void deleteKeys(const PClientInfo& ci, const PArrayString& ids, const PLockZ& unlockZ)  = 0;
	public: virtual void deleteKeys(const PClientInfo& ci, const PArrayString& ids, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Deletes the keywords with the given IDs.
	/// </summary>
	/// <remarks>
	/// <p><b>IMPORTANT: This function assigns new IDs to all branches of the
	/// keyword trees below the parent keywords of the given IDs.
	/// The client program should read the parent keyword and all children below
	/// again to receive the new IDs. </b></p>
	/// <p>The access rights <code>AccessC.FLAG_EDITCONFIG</code> and
	/// <code>AccessC.FLAG_EDITSWL</code> are required to delete keywords.<p>
	/// </remarks>
	public: virtual void deleteKeywords(const PClientInfo& ci, const PArrayString& kwids, const PLockZ& unlockZ)  = 0;
	public: virtual void deleteKeywords(const PClientInfo& ci, const PArrayString& kwids, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Deletes notes.
	/// </summary>
	/// <remarks>
	/// <p>After a note or annotation has been deleted it should not be checked in again with MbAll. In
	/// this case the isDeleted() value is overwritten and the note or annotation will no longer be
	/// deleted. In this case MbOnlyLock should be used to remove the lock on the notes.</p>
	/// </remarks>
	public: virtual void deleteNotes(const PClientInfo& ci, const PArrayString& noteIds, const PLockZ& unlockZ)  = 0;
	public: virtual void deleteNotes(const PClientInfo& ci, const PArrayString& noteIds, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Deleting the Notification identified by objGuid / userGuid combination
	/// if the Notification has child Notifications, they will be deleted as well.
	/// </summary>
	public: virtual int32_t deleteNotification(const PClientInfo& ci, const ::std::wstring& objGuid, const ::std::wstring& userGuid)  = 0;
	public: virtual void deleteNotification(const PClientInfo& ci, const ::std::wstring& objGuid, const ::std::wstring& userGuid, ::std::function< void (int32_t, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Deletes the reminders (logically) with the the given IDs.
	/// </summary>
	public: virtual void deleteReminders(const PClientInfo& ci, const PArrayInt& reminderIds, const PLockZ& unlockZ)  = 0;
	public: virtual void deleteReminders(const PClientInfo& ci, const PArrayInt& reminderIds, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Deletes report entries until <code>endDateISO</code>.
	/// </summary>
	public: virtual void deleteReport(const PClientInfo& ci, const ::std::wstring& endDateISO)  = 0;
	public: virtual void deleteReport(const PClientInfo& ci, const ::std::wstring& endDateISO, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Deletes an archive entry and all child entries or deletes a relation (logical copy).
	/// </summary>
	/// <remarks>
	/// </p><p>
	/// A reference is deleted if <code>parentId</code> specifies an entry which is
	/// not the main parent of <code>objId</code>. The main parent can be found
	/// in <code>Sord.parent</code> after reading the indexing information for
	/// <code>objId</code> using <code>checkoutSord</code>. References are never deleted physically.
	/// </p><p>
	/// A archive entry is deleted if <code>parentId</code> is set to <code>null</code>
	/// or the id of its main parent.
	/// </p><p>
	/// If <code>deleteFinally=true</code>, all already logically deleted objects in the subtree of objId will be deleted physically.
	/// All related data (document versions, attachments, workflows, etc.) will also be physically deleted. Use this parameter with caution,
	/// since a reverse operation does not exist.
	/// </p><p>
	/// To delete logically set <code>deleteFinally=false</code>, which only sets the the delete flag within the database.
	/// </p><p>
	/// </remarks>
	public: virtual bool deleteSord(const PClientInfo& ci, const ::std::wstring& parentId, const ::std::wstring& objId, const PLockZ& unlockZ, const PDeleteOptions& deleteOptions)  = 0;
	public: virtual void deleteSord(const PClientInfo& ci, const ::std::wstring& parentId, const ::std::wstring& objId, const PLockZ& unlockZ, const PDeleteOptions& deleteOptions, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Write or insert sord type information.
	/// </summary>
	public: virtual void deleteSordTypes(const PClientInfo& ci, const PArrayInt& sordTypeIds, const PLockZ& unlockZ)  = 0;
	public: virtual void deleteSordTypes(const PClientInfo& ci, const PArrayInt& sordTypeIds, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Delete deputy information.
	/// </summary>
	public: virtual void deleteSubs(const PClientInfo& ci, const PArraySubsInfo& deps, const PLockZ& unlockZ)  = 0;
	public: virtual void deleteSubs(const PClientInfo& ci, const PArraySubsInfo& deps, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Deletes profile options.
	/// </summary>
	public: virtual void deleteUserProfile(const PClientInfo& ci, const PUserProfile& userProfile, const PLockZ& unlockZ)  = 0;
	public: virtual void deleteUserProfile(const PClientInfo& ci, const PUserProfile& userProfile, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Deletes users or groups.
	/// </summary>
	/// <remarks>
	/// </p><p>
	/// Since this function requires exclusive access to the user data, the data
	/// must be locked for the current user or must not be locked for anyone. To
	/// check in regardless of a lock  <code>lockZ.FORCE</code>
	/// in <code>lockZ</code> must be supplied.
	/// </remarks>
	public: virtual void deleteUsers(const PClientInfo& ci, const PArrayString& ids, const PLockZ& unlockZ)  = 0;
	public: virtual void deleteUsers(const PClientInfo& ci, const PArrayString& ids, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Deletes a workflow.
	/// </summary>
	/// <remarks>
	/// <p> WOrkflows that are deleted are not physically deleted and can be retrieved using checkoutWorkFlow().
	/// Deleted workflows return true when the WFDiagram.isDeleted() method is called.</p>
	/// </remarks>
	public: virtual void deleteWorkFlow(const PClientInfo& ci, const ::std::wstring& flowId, const PWFTypeZ& typeZ, const PLockZ& unlockZ)  = 0;
	public: virtual void deleteWorkFlow(const PClientInfo& ci, const ::std::wstring& flowId, const PWFTypeZ& typeZ, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Stores an edited person node of an active workflow into the database and unlocks the workflow.
	/// </summary>
	/// <remarks>
	/// <p>The workflow is forwarded to the successor nodes as passed in parameter <code>arrEnterNodesIds</code>.</p>
	/// </remarks>
	public: virtual void endEditWorkFlowNode(const PClientInfo& ci, int32_t nFlowId, int32_t nNodeId, bool bTerminate, bool bCancel, const ::std::wstring& sName, const ::std::wstring& sComment, const PArrayInt& arrEnterNodesIds)  = 0;
	public: virtual void endEditWorkFlowNode(const PClientInfo& ci, int32_t nFlowId, int32_t nNodeId, bool bTerminate, bool bCancel, const ::std::wstring& sName, const ::std::wstring& sComment, const PArrayInt& arrEnterNodesIds, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Deletes the search results explicitly in the IndexServer process to save memory.
	/// </summary>
	public: virtual void findClose(const PClientInfo& ci, const ::std::wstring& searchId)  = 0;
	public: virtual void findClose(const PClientInfo& ci, const ::std::wstring& searchId, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Finds configuration or postbox files.
	/// </summary>
	public: virtual PFindResult findFirstConfigFiles(const PClientInfo& ci, const PFindConfigFileInfo& findInfo, int32_t max, const PConfigFileZ& configFileZ)  = 0;
	public: virtual void findFirstConfigFiles(const PClientInfo& ci, const PFindConfigFileInfo& findInfo, int32_t max, const PConfigFileZ& configFileZ, ::std::function< void (PFindResult, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Finds report entries.
	/// </summary>
	public: virtual PFindResult findFirstReportInfos(const PClientInfo& ci, const PFindReportInfo& opts, int32_t max)  = 0;
	public: virtual void findFirstReportInfos(const PClientInfo& ci, const PFindReportInfo& opts, int32_t max, ::std::function< void (PFindResult, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Find archive entries and retrieve  the first <code>max</code> objects.
	/// </summary>
	/// <remarks>
	/// <p>
	/// This function performs a search over indexing information, full text,
	/// or hierarchy (child lists).
	/// </p><p>
	/// It returns either an ID array or a <code>Sord</code> object array. The maximum
	/// array length is restricted to the value of the <code>max</code> parameter.
	/// Further results can be read with <code>findNextSords</code> using the search ID
	/// <code>FindResult.searchId</code> returned by this function. The search ID has
	/// a limited lifetime which can be configured. The default value is 5 minutes.
	/// The search results can be explicitly deleted with <code>findClose</code> to
	/// save memory on the server side.
	/// </p>
	/// <p>
	/// This function does not write report entries ReportInfoC.ACT_IX_CHECKOUT_SORD for
	/// the results although it can return as much indexing information as checkoutSord does.
	/// </p>
	/// </remarks>
	public: virtual PFindResult findFirstSords(const PClientInfo& ci, const PFindInfo& findInfo, int32_t max, const PSordZ& sordZ)  = 0;
	public: virtual void findFirstSords(const PClientInfo& ci, const PFindInfo& findInfo, int32_t max, const PSordZ& sordZ, ::std::function< void (PFindResult, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Finds reminders, activities and active workflow nodes.
	/// </summary>
	public: virtual PFindResult findFirstTasks(const PClientInfo& ci, const PFindTasksInfo& findInfo, int32_t max)  = 0;
	public: virtual void findFirstTasks(const PClientInfo& ci, const PFindTasksInfo& findInfo, int32_t max, ::std::function< void (PFindResult, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Finds next configuration files.
	/// </summary>
	public: virtual PFindResult findNextConfigFiles(const PClientInfo& ci, const ::std::wstring& searchId, int32_t idx, int32_t max, const PConfigFileZ& configFileZ)  = 0;
	public: virtual void findNextConfigFiles(const PClientInfo& ci, const ::std::wstring& searchId, int32_t idx, int32_t max, const PConfigFileZ& configFileZ, ::std::function< void (PFindResult, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Finds report entries.
	/// </summary>
	public: virtual PFindResult findNextReportInfos(const PClientInfo& ci, const ::std::wstring& searchId, int32_t idx, int32_t max)  = 0;
	public: virtual void findNextReportInfos(const PClientInfo& ci, const ::std::wstring& searchId, int32_t idx, int32_t max, ::std::function< void (PFindResult, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Retrieves further results of a previous search with <code>findFirstSords</code>.
	/// </summary>
	public: virtual PFindResult findNextSords(const PClientInfo& ci, const ::std::wstring& searchId, int32_t idx, int32_t max, const PSordZ& sordZ)  = 0;
	public: virtual void findNextSords(const PClientInfo& ci, const ::std::wstring& searchId, int32_t idx, int32_t max, const PSordZ& sordZ, ::std::function< void (PFindResult, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Continues the find process started with findFirstTasks.
	/// </summary>
	public: virtual PFindResult findNextTasks(const PClientInfo& ci, const ::std::wstring& searchId, int32_t idx, int32_t max)  = 0;
	public: virtual void findNextTasks(const PClientInfo& ci, const ::std::wstring& searchId, int32_t idx, int32_t max, ::std::function< void (PFindResult, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Removes temp-files after an export.
	/// </summary>
	/// <remarks>
	/// <p>This method should be called, after the generated
	/// ZIP-archive has been successfully downloaded.</p>
	/// </remarks>
	public: virtual void finishExport(const PClientInfo& ci, const ::std::wstring& exportId)  = 0;
	public: virtual void finishExport(const PClientInfo& ci, const ::std::wstring& exportId, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Retrieves the constants.
	/// </summary>
	/// <remarks>
	/// <p>Constants are provided as objects to provide the advantage of type checking.
	/// (Java 1.4 does not support enumeration types).</p>
	/// </remarks>
	public: virtual PIXServicePortC getConstants(const PClientInfo& ci)  = 0;
	public: virtual void getConstants(const PClientInfo& ci, ::std::function< void (PIXServicePortC, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Gets the URL for downloading the generated ZIP-archive of this export.
	/// </summary>
	public: virtual ::std::wstring getExportZipUrl(const PClientInfo& ci, const ::std::wstring& exportId)  = 0;
	public: virtual void getExportZipUrl(const PClientInfo& ci, const ::std::wstring& exportId, ::std::function< void (::std::wstring, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Retrieves the URL for uploading the ZIP-archive for this import.
	/// </summary>
	public: virtual ::std::wstring getImportZipUrl(const PClientInfo& ci, const ::std::wstring& importId)  = 0;
	public: virtual void getImportZipUrl(const PClientInfo& ci, const ::std::wstring& importId, ::std::function< void (::std::wstring, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Retrieves configurational information, e.g. license key, additional IndexServers, etc
	/// </summary>
	public: virtual PServerInfo getServerInfo(const PClientInfo& ci)  = 0;
	public: virtual void getServerInfo(const PClientInfo& ci, ::std::function< void (PServerInfo, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Sets the writable members of ServerInfo.
	/// </summary>
	public: virtual void setServerInfo(const PClientInfo& ci, const PServerInfo& serverInfo)  = 0;
	public: virtual void setServerInfo(const PClientInfo& ci, const PServerInfo& serverInfo, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Gets DM configuration information.
	/// </summary>
	public: virtual PServerInfoDM getServerInfoDM(const PClientInfo& ci)  = 0;
	public: virtual void getServerInfoDM(const PClientInfo& ci, ::std::function< void (PServerInfoDM, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Sets the writable members of the DM configuration.
	/// </summary>
	public: virtual void setServerInfoDM(const PClientInfo& ci, const PServerInfoDM& serverInfo)  = 0;
	public: virtual void setServerInfoDM(const PClientInfo& ci, const PServerInfoDM& serverInfo, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Retrieve the current session options.
	/// </summary>
	public: virtual PSessionOptions getSessionOptions(const PClientInfo& ci)  = 0;
	public: virtual void getSessionOptions(const PClientInfo& ci, ::std::function< void (PSessionOptions, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Reads user or group names and IDs.
	/// </summary>
	/// <remarks>
	/// <p>
	/// The method performs an internal call to <code>checkoutUsers</code>. <b>Note:</b> Only
	/// the names and IDs are returned and not the complete user data.
	/// </p><p>
	/// If the current user is assigned to organisation units, the function returns only
	/// users and groups assigned to at least one of the users organisation units.
	/// </p>
	/// </remarks>
	public: virtual PArrayUserName getUserNames(const PClientInfo& ci, const PArrayString& ids, const PCheckoutUsersZ& checkoutUsersZ)  = 0;
	public: virtual void getUserNames(const PClientInfo& ci, const PArrayString& ids, const PCheckoutUsersZ& checkoutUsersZ, ::std::function< void (PArrayUserName, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Imports a workflow template from a file.
	/// </summary>
	/// <remarks>
	/// <p>To export a workflow template
	/// into a file, use the workflow design dialogue in ELO-CLIENT.</p>
	/// </remarks>
	public: virtual int32_t importWorkFlow(const PClientInfo& ci, const ::std::wstring& flowName, const PBytes& fileData)  = 0;
	public: virtual void importWorkFlow(const PClientInfo& ci, const ::std::wstring& flowName, const PBytes& fileData, ::std::function< void (int32_t, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Imports a workflow template from a file.
	/// </summary>
	/// <remarks>
	/// <p>To export a workflow template
	/// into a file, use the workflow design dialogue in ELO-CLIENT.</p>
	/// </remarks>
	public: virtual int32_t importWorkFlow2(const PClientInfo& ci, const ::std::wstring& flowName, const PBytes& fileData, const PWorkflowImportOptions& importOptions)  = 0;
	public: virtual void importWorkFlow2(const PClientInfo& ci, const ::std::wstring& flowName, const PBytes& fileData, const PWorkflowImportOptions& importOptions, ::std::function< void (int32_t, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Links archive entries.
	/// </summary>
	/// <remarks>
	/// <p>Links are associations between archive entries and are
	/// independent from the archive hierarchy.
	/// </p><p>
	/// The links to or from an archive entry are listed in <code>Sord.linksGoOut</code>
	/// and <code>Sord.linksComeIn</code>. In the database structure and in the Indexserver API,
	/// links are vectors that point from one Sord to one or more other Sords. But the client applications
	/// usually do not take care of the direction. They add the links found in Sord.linksGoOut and
	/// Sord.linksComeIn in order to show the liked objects.
	/// </p><p>
	/// There are two different types of links: pairs and cross-links. A pair connects exactly two
	/// Sord objects. Each pair has its own link-ID in the database. A cross-link connects a group of objects
	/// under the same link-ID. At the first glance it seems, that each object has a pair-link to each other object.
	/// But there is a significant difference when deleting links.
	/// E.g. if the Sord objects sord1, sord2, sord3 are connected with a cross-link, function checkoutSord will return
	/// for sord1: {sord2, sord3}, sord2: {sord1, sord3} and sord3: {sord1, sord2}. If function unlinkSords
	/// is called for the link sord1-sord2 (fromSord=sord1, toSords=[sord2]), the next calls to checkoutSord will return
	/// for sord1: {sord3}, sord2: {}, sord3: {sord1}. If the objects were connected by pair-links, the result would
	/// be sord1: {sord3}, sord2: {sord3}, sord3: {sord1, sord2}.
	/// </p>
	/// </remarks>
	public: virtual void linkSords(const PClientInfo& ci, const ::std::wstring& fromId, const PArrayString& toIds, const PLinkSordZ& linkZ)  = 0;
	public: virtual void linkSords(const PClientInfo& ci, const ::std::wstring& fromId, const PArrayString& toIds, const PLinkSordZ& linkZ, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Locks the archive with the specified key or retrieves the lock on the archive.
	/// </summary>
	/// <remarks>
	/// <p>If no key is specified (null or empty string), the current archive key is returned.
	/// To unlock the archive, call this function with <code>keyId="0"</code>.</p>
	/// </remarks>
	public: virtual int32_t lockArchive(const PClientInfo& ci, const ::std::wstring& keyId)  = 0;
	public: virtual void lockArchive(const PClientInfo& ci, const ::std::wstring& keyId, ::std::function< void (int32_t, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Log on to IndexServer.
	/// </summary>
	/// <remarks>
	/// <p>If the function succeeds, the return value is an object containing a ticket
	/// that allows access to all the other interface functions.
	/// </p><p>This ticket has a limited lifetime as returned in <code>LoginResult.ticketDuration</code>.
	/// The life time can be extended by calling <code>alive</code>.
	/// </p><p>The <code>runAsUser</code> parameter is used in Single-Sign-On environments.
	/// The login is performed for every user with the same SSO account specific to the application
	/// and the <runAsUser> parameter specifies the security context for the IndexServer
	/// connection. The SSO account must have administrator privileges.
	/// </p><p>
	/// <p><b>Examples:</b></p>
	/// <p>
	/// <code>// Initialize ClientInfo with language specific data </code><br/>
	/// <code>ClientInfo ci = new ClientInfo();</code><br/>
	/// <code>ci.setLanguage("de");</code><br/>
	/// <code>ci.setCountry("DE");</code><br/>
	/// <br/>
	/// <code>// Fritz logs on to IndexServer </code><br/>
	/// <code>LoginResult lr = eloix.login(ci, "Fritz", "fritzchen", "Fritz computer", null);</code><br/>
	/// <br/>
	/// <code>// The returned object contains a second ClientInfo object including the ticket. </code><br/>
	/// <code>// This ClientInfo should be used for all subsequent calls .</code><br/>
	/// <code>ci = lr.ci;</code><br/>
	/// <br/>
	/// <code>// Dump ticket and lifetime. </code><br/>
	/// <code>System.out.println("Ticket=" + ci.getTicket());</code><br/>
	/// <code>System.out.println("Lifetime=" + lr.getTicketLifetime());</code><br/>
	/// <br/>
	/// <code>// Logout </code><br/>
	/// <code>eloix.logout(ci);</code><br/>
	/// </p>
	/// 
	/// <p><b>Example for Single-Sign-On:</b></p>
	/// <p>
	/// <code>// Initialize ClientInfo with language specific data.</code><br/>
	/// <code>ClientInfo ci = new ClientInfo();</code><br/>
	/// <code>ci.setLanguage("de");</code><br/>
	/// <code>ci.setCountry("DE");</code><br/>
	/// <br/>
	/// <code>// Fritz logs on to IndexServer with SSO account "MyApp" </code><br/>
	/// <code>LoginResult lr = eloix.login(ci, "MyApp", "myapp", "Fritz computer", "Fritz");</code><br/>
	/// <br/>
	/// <code>// The returned object contains a second ClientInfo object including the ticket. </code><br/>
	/// <code>// Use for all subsequent calls this ClientInfo.</code><br/>
	/// <code>ci = lr.ci;</code><br/>
	/// <br/>
	/// <code>// Dump ticket and lifetime. </code><br/>
	/// <code>System.out.println("Ticket=" + ci.getTicket());</code><br/>
	/// <code>System.out.println("Lifetime=" + lr.getTicketLifetime());</code><br/>
	/// <code>System.out.println("user=" + lr.getUser().getName()); // =Fritz </code><br/>
	/// <br/>
	/// <code>// Logout </code><br/>
	/// <code>eloix.logout(ci);</code><br/>
	/// </p>
	/// </remarks>
	public: virtual PLoginResult login(const PClientInfo& ci, const ::std::wstring& userName, const ::std::wstring& userPwd, const ::std::wstring& clientComputer, const ::std::wstring& runAsUser)  = 0;
	public: virtual void login(const PClientInfo& ci, const ::std::wstring& userName, const ::std::wstring& userPwd, const ::std::wstring& clientComputer, const ::std::wstring& runAsUser, ::std::function< void (PLoginResult, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Login any user as an administrator.
	/// </summary>
	/// <remarks>
	/// <p>This function logs on the user given in <code>reportAsUser</code> as an
	/// administrator. The effective rights of the resulting session are not constrained
	/// to the rights of the given user.
	/// The client application is responsible for access checking.</p>
	/// </remarks>
	public: virtual PLoginResult loginAdmin(const PClientInfo& ci, const ::std::wstring& userName, const ::std::wstring& userPwd, const ::std::wstring& clientComputer, const ::std::wstring& reportAsUser)  = 0;
	public: virtual void loginAdmin(const PClientInfo& ci, const ::std::wstring& userName, const ::std::wstring& userPwd, const ::std::wstring& clientComputer, const ::std::wstring& reportAsUser, ::std::function< void (PLoginResult, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// This login is used by ELOprofessional applications if the IndexServer is used to
	/// forward workflows (WorkflowServer).
	/// </summary>
	/// <remarks>
	/// <p>This login returns a limited connection to the
	/// IndexServer. It is not possible to access documents or user data.</p>
	/// </remarks>
	public: virtual PLoginResult loginEloProf(const PClientInfo& ci, int32_t userId, const ::std::wstring& certificate, const ::std::wstring& clientComputer)  = 0;
	public: virtual void loginEloProf(const PClientInfo& ci, int32_t userId, const ::std::wstring& certificate, const ::std::wstring& clientComputer, ::std::function< void (PLoginResult, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Login method fÃ¼r Kerberos.
	/// </summary>
	public: virtual PLoginResult loginKerberos(const PClientInfo& ci, const PBytes& ticket, const ::std::wstring& clientComputer)  = 0;
	public: virtual void loginKerberos(const PClientInfo& ci, const PBytes& ticket, const ::std::wstring& clientComputer, ::std::function< void (PLoginResult, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Log out user.
	/// </summary>
	/// <remarks>
	/// <p>The ticket contained in <code>ci</code> becomes invalid.</p>
	/// </remarks>
	public: virtual void logout(const PClientInfo& ci)  = 0;
	public: virtual void logout(const PClientInfo& ci, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Parses the given string of an exception into a structured IXExceptionData object.
	/// </summary>
	/// <remarks>
	/// <p>If the given string does not represent an IXException, the exceptionType NOT_IX
	/// is returned (value -1) and the given exception string can be found in "message".
	/// </remarks>
	public: virtual PIXExceptionData parseException(const PClientInfo& ci, const ::std::wstring& exceptionString)  = 0;
	public: virtual void parseException(const PClientInfo& ci, const ::std::wstring& exceptionString, ::std::function< void (PIXExceptionData, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Executes the processing information given by <code>processInfo</code> for all objects
	/// found by a <code>findFirstSords</code> call.
	/// </summary>
	public: virtual PJobState processFindResult(const PClientInfo& ci, const ::std::wstring& searchId, const PProcessInfo& procInfo)  = 0;
	public: virtual void processFindResult(const PClientInfo& ci, const ::std::wstring& searchId, const PProcessInfo& procInfo, ::std::function< void (PJobState, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// <code>processTrees</code> extends ValueClass implements a generic tree walk for all subtrees specified in
	/// <code>navInfo</code>.
	/// </summary>
	/// <remarks>
	/// <p>Specific operations for each node are queued in <code>procInfo</code>
	/// and will be applied in order of appearance.</p>
	/// </remarks>
	public: virtual PJobState processTrees(const PClientInfo& ci, const PNavigationInfo& navigationInfo, const PProcessInfo& procInfo)  = 0;
	public: virtual void processTrees(const PClientInfo& ci, const PNavigationInfo& navigationInfo, const PProcessInfo& procInfo, ::std::function< void (PJobState, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Returns the job state for a given job GUID.
	/// </summary>
	public: virtual PJobState queryJobState(const PClientInfo& ci, const ::std::wstring& jobGuid, bool activeJobs, bool finishedJobs, bool fullInfo)  = 0;
	public: virtual void queryJobState(const PClientInfo& ci, const ::std::wstring& jobGuid, bool activeJobs, bool finishedJobs, bool fullInfo, ::std::function< void (PJobState, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Creates a new object relationship.
	/// </summary>
	public: virtual void refSord(const PClientInfo& ci, const ::std::wstring& oldParentId, const ::std::wstring& newParentId, const ::std::wstring& objId, int32_t manSortIdx)  = 0;
	public: virtual void refSord(const PClientInfo& ci, const ::std::wstring& oldParentId, const ::std::wstring& newParentId, const ::std::wstring& objId, int32_t manSortIdx, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Restores an archive entry, its references and notes.
	/// </summary>
	/// <remarks>
	/// <p>
	/// Passing true for <code>singleObject</code> restores only the object represented by
	/// <code>objId</code>.<br/> Otherwise, the complete subtree beginning at <code>objId</code> will be restored.
	/// </p><p>
	/// </remarks>
	public: virtual bool restoreSord(const PClientInfo& ci, const ::std::wstring& objId, const PRestoreOptions& restoreOptions)  = 0;
	public: virtual void restoreSord(const PClientInfo& ci, const ::std::wstring& objId, const PRestoreOptions& restoreOptions, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// This function sets options related to the session identified by the given
	/// ticket.
	/// </summary>
	public: virtual void setSessionOptions(const PClientInfo& ci, const PSessionOptions& opts)  = 0;
	public: virtual void setSessionOptions(const PClientInfo& ci, const PSessionOptions& opts, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Starts an Ad Hoc Workflow.
	/// </summary>
	public: virtual int32_t startAdHocWorkFlow(const PClientInfo& ci, const ::std::wstring& name, const ::std::wstring& objId, const PArrayString& arrUserIds, const ::std::wstring& nodeName, bool forValidation, bool serialFlow, const ::std::wstring& cancelUserId, const ::std::wstring& cancelMessage, const ::std::wstring& finishedUserId, const ::std::wstring& finishedMessage, const ::std::wstring& finishedScript)  = 0;
	public: virtual void startAdHocWorkFlow(const PClientInfo& ci, const ::std::wstring& name, const ::std::wstring& objId, const PArrayString& arrUserIds, const ::std::wstring& nodeName, bool forValidation, bool serialFlow, const ::std::wstring& cancelUserId, const ::std::wstring& cancelMessage, const ::std::wstring& finishedUserId, const ::std::wstring& finishedMessage, const ::std::wstring& finishedScript, ::std::function< void (int32_t, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Starts an export-job.
	/// </summary>
	/// <remarks>
	/// <p>The given IDs and their children will be exported as specified in the
	/// options.</p>
	/// </remarks>
	public: virtual ::std::wstring startExport(const PClientInfo& ci, const PArrayString& topLevelIDs, int64_t options)  = 0;
	public: virtual void startExport(const PClientInfo& ci, const PArrayString& topLevelIDs, int64_t options, ::std::function< void (::std::wstring, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Starts an export-job.
	/// </summary>
	/// <remarks>
	/// <p>This is an enhanced version which works with the
	/// same options as the ones in Windows Client</p>
	/// </remarks>
	public: virtual ::std::wstring startExportExt(const PClientInfo& ci, const PExportExtOptions& options)  = 0;
	public: virtual void startExportExt(const PClientInfo& ci, const PExportExtOptions& options, ::std::function< void (::std::wstring, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Starts an import-job.
	/// </summary>
	/// <remarks>
	/// <p>The given IDs and their children will be imported as specified in the
	/// options.</p>
	/// </remarks>
	public: virtual ::std::wstring startImport(const PClientInfo& ci, const ::std::wstring& filingPath, int32_t guidMethod, int64_t options)  = 0;
	public: virtual void startImport(const PClientInfo& ci, const ::std::wstring& filingPath, int32_t guidMethod, int64_t options, ::std::function< void (::std::wstring, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Starts a workflow from a workflow template.
	/// </summary>
	public: virtual int32_t startWorkFlow(const PClientInfo& ci, const ::std::wstring& templFlowId, const ::std::wstring& flowName, const ::std::wstring& objId)  = 0;
	public: virtual void startWorkFlow(const PClientInfo& ci, const ::std::wstring& templFlowId, const ::std::wstring& flowName, const ::std::wstring& objId, ::std::function< void (int32_t, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Assign a node to a user.
	/// </summary>
	/// <remarks>
	/// <p>This function is useful in two situations:<br/>
	/// 1. A user calls this function to assume a task for exclusive use.
	/// The task must be assigned to one of the user s groups or to a user
	/// substituted by the current user. Supply an empty <code>sUserId</code>.<br/>
	/// 2. A user calls this function to pass the task to another user. The task
	/// must be assigned to the current user. Supply any user name or ID in sUserId.
	/// </p>
	/// The function assigns in addition to the given node all nodes with the same {@link WFNode#departmentGroup}.
	/// </remarks>
	public: virtual void takeWorkFlowNode(const PClientInfo& ci, int32_t nFlowId, int32_t nNodeId, const ::std::wstring& sUserId, int32_t nFlags, const PLockZ& lockZ)  = 0;
	public: virtual void takeWorkFlowNode(const PClientInfo& ci, int32_t nFlowId, int32_t nNodeId, const ::std::wstring& sUserId, int32_t nFlags, const PLockZ& lockZ, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Terminates a workflow.
	/// </summary>
	public: virtual int32_t terminateWorkFlow(const PClientInfo& ci, const ::std::wstring& flowId, const PLockZ& unlockZ)  = 0;
	public: virtual void terminateWorkFlow(const PClientInfo& ci, const ::std::wstring& flowId, const PLockZ& unlockZ, ::std::function< void (int32_t, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Delegates the specified workflow node to another user.
	/// </summary>
	/// <remarks>
	/// <p>An additional person node is inserted into the workflow for the given user and the
	/// workflow is forwarded to this node. If {@link WFDelegateNodeInfo#backNodeName} is set,
	/// a further node is added after the delegation node for the current user.</p>
	/// </remarks>
	public: virtual void delegateWorkFlowNode(const PClientInfo& ci, const PWFDelegateNodeInfo& delegateNodeInfo, const PLockZ& lockZ)  = 0;
	public: virtual void delegateWorkFlowNode(const PClientInfo& ci, const PWFDelegateNodeInfo& delegateNodeInfo, const PLockZ& lockZ, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// <p>Sets the value userDelayDateIso of the given node.
	/// </summary>
	/// <remarks>
	/// </p>
	/// </remarks>
	public: virtual void deferWorkFlowNode(const PClientInfo& ci, const ::std::wstring& flowId, int32_t nodeId, const ::std::wstring& userDelayDateIso, const PLockZ& lockZ)  = 0;
	public: virtual void deferWorkFlowNode(const PClientInfo& ci, const ::std::wstring& flowId, int32_t nodeId, const ::std::wstring& userDelayDateIso, const PLockZ& lockZ, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// This function is used for testing.
	/// </summary>
	/// <remarks>
	/// <p>In productive environments it always throws
	/// an exception.</p>
	/// </remarks>
	public: virtual PArrayString testAdapter(const PClientInfo& ci, const ::std::wstring& fn, const PArrayString& params)  = 0;
	public: virtual void testAdapter(const PClientInfo& ci, const ::std::wstring& fn, const PArrayString& params, ::std::function< void (PArrayString, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Remove links between archive entries.
	/// </summary>
	public: virtual void unlinkSords(const PClientInfo& ci, const ::std::wstring& fromId, const PArrayString& toIds, const PLinkSordZ& linkZ)  = 0;
	public: virtual void unlinkSords(const PClientInfo& ci, const ::std::wstring& fromId, const PArrayString& toIds, const PLinkSordZ& linkZ, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Read and optionally lock the password information for document encryption.
	/// </summary>
	public: virtual PArrayCryptInfo checkoutCryptInfos(const PClientInfo& ci, const PArrayString& ids, const PLockZ& lockZ)  = 0;
	public: virtual void checkoutCryptInfos(const PClientInfo& ci, const PArrayString& ids, const PLockZ& lockZ, ::std::function< void (PArrayCryptInfo, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Write and optionally unlock encryption information.
	/// </summary>
	/// <remarks>
	/// <p>
	/// The passwords supplied in cryptInfos must be encrypted with the
	/// IXClient.encryptPassword function.
	/// </p><p>
	/// Administrators are allowed to alter internal keys and encryption set names.
	/// <table border="2">
	/// <tr><td>cryptInfos[.].keyInfo</td><td>Description</td></tr>
	/// <tr><td>*</td><td>Generate new internal keys and set cryptInfos[.].pwd as external password.</td></tr>
	/// <tr><td>Value from another ELO system</td><td>Set this value as internal and external key pair. cryptInfos[.].pwd is ignored.</td></tr>
	/// </table>
	/// </p>
	/// </remarks>
	public: virtual void checkinCryptInfos(const PClientInfo& ci, const PArrayCryptInfo& cryptInfos, const PLockZ& unlockZ)  = 0;
	public: virtual void checkinCryptInfos(const PClientInfo& ci, const PArrayCryptInfo& cryptInfos, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Provide a password to be used in the current session for encrypting and
	/// decrypting of documents.
	/// </summary>
	/// <remarks>
	/// <p>The given password must be encrypted with the IXClient.encryptPassword
	/// function to hide it from administrators. An unencrypted password will cause
	/// an exception.
	/// </p><p>
	/// To use the encryption/decryption functionality of IndexServer, the
	/// session option &lt;ix.encryptDocuments&gt; resp. &lt;ix.decryptDocuments&gt;
	/// has to be &lt;true&gt;.
	/// Then, IndexServer generates special URLs that cause it to encrypt documents on
	/// upload and decrypt documents on download.
	/// </p>
	/// Be aware of the fact that encryption/decryption happens between IndexServer
	/// and Document Manager communication and not between IndexServer and the client
	/// application. Thus it is strongly recommended to use HTTPS between the client
	/// application and IndexServer. The IndexServer configuration option
	/// &quot;ixUrlBase&quot; can be helpful to achieve this.
	/// </remarks>
	public: virtual void provideCryptPassword(const PClientInfo& ci, const ::std::wstring& encryptionSet, const ::std::wstring& pwd)  = 0;
	public: virtual void provideCryptPassword(const PClientInfo& ci, const ::std::wstring& encryptionSet, const ::std::wstring& pwd, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Invalidate the internally used caches for users, storage masks, etc.
	/// </summary>
	public: virtual void invalidateCache(const PClientInfo& ci, int32_t flags)  = 0;
	public: virtual void invalidateCache(const PClientInfo& ci, int32_t flags, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Invalidate the internally used caches.
	/// </summary>
	public: virtual PInvalidateCacheResult invalidateCache2(const PClientInfo& ci, const PInvalidateCacheInfo& info)  = 0;
	public: virtual void invalidateCache2(const PClientInfo& ci, const PInvalidateCacheInfo& info, ::std::function< void (PInvalidateCacheResult, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Find terms for which a translation is available.
	/// </summary>
	/// <remarks>
	/// <p>Close the search results with a call to findClose.</p>
	/// </remarks>
	public: virtual PFindResult findFirstTranslateTerms(const PClientInfo& ci, const PFindTranslateTermInfo& findInfo, int32_t max)  = 0;
	public: virtual void findFirstTranslateTerms(const PClientInfo& ci, const PFindTranslateTermInfo& findInfo, int32_t max, ::std::function< void (PFindResult, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Find next terms.
	/// </summary>
	public: virtual PFindResult findNextTranslateTerms(const PClientInfo& ci, const ::std::wstring& searchId, int32_t idx, int32_t max)  = 0;
	public: virtual void findNextTranslateTerms(const PClientInfo& ci, const ::std::wstring& searchId, int32_t idx, int32_t max, ::std::function< void (PFindResult, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Read terms from translation table for viewing or editing.
	/// </summary>
	/// <remarks>
	/// <p>
	/// It can also be used to retrieve the supported languages.
	/// Use this function, if only a few terms should be returned.
	/// Otherwise call <code>findFirstTranslateTerms</code>.
	/// </p>
	/// </remarks>
	public: virtual PArrayTranslateTerm checkoutTranslateTerms(const PClientInfo& ci, const PArrayString& termIds, const PLockZ& lockZ)  = 0;
	public: virtual void checkoutTranslateTerms(const PClientInfo& ci, const PArrayString& termIds, const PLockZ& lockZ, ::std::function< void (PArrayTranslateTerm, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Write or insert terms into the translation table.
	/// </summary>
	/// <remarks>
	/// <p>
	/// This function should not be called frequently, because it causes the translation cache to be reloaded.
	/// </p>
	/// </remarks>
	public: virtual PArrayString checkinTranslateTerms(const PClientInfo& ci, const PArrayTranslateTerm& tterms, const PLockZ& unlockZ)  = 0;
	public: virtual void checkinTranslateTerms(const PClientInfo& ci, const PArrayTranslateTerm& tterms, const PLockZ& unlockZ, ::std::function< void (PArrayString, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Delete terms from the translation table.
	/// </summary>
	/// <remarks>
	/// <p>
	/// This function should not be called frequently, because it causes the translation cache to be reloaded.
	/// </p>
	/// </remarks>
	public: virtual void deleteTranslateTerms(const PClientInfo& ci, const PArrayString& termIds, const PLockZ& unlockZ)  = 0;
	public: virtual void deleteTranslateTerms(const PClientInfo& ci, const PArrayString& termIds, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Reads the version information of all versions of the given workflow.
	/// </summary>
	public: virtual PArrayWFVersion getWorkflowTemplateVersions(const PClientInfo& ci, const ::std::wstring& flowId, bool onlyDeleted)  = 0;
	public: virtual void getWorkflowTemplateVersions(const PClientInfo& ci, const ::std::wstring& flowId, bool onlyDeleted, ::std::function< void (PArrayWFVersion, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Check out versions of a workflow template.
	/// </summary>
	public: virtual PWFDiagram checkoutWorkflowTemplate(const PClientInfo& ci, const ::std::wstring& flowId, const ::std::wstring& versionId, const PWFDiagramZ& wfZ, const PLockZ& lockZ)  = 0;
	public: virtual void checkoutWorkflowTemplate(const PClientInfo& ci, const ::std::wstring& flowId, const ::std::wstring& versionId, const PWFDiagramZ& wfZ, const PLockZ& lockZ, ::std::function< void (PWFDiagram, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Check in a workflow template as a new version or overwrite an existing version.
	/// </summary>
	public: virtual PArrayInt checkinWorkflowTemplate(const PClientInfo& ci, const PWFDiagram& wf, const PWFDiagramZ& wfZ, const PLockZ& unlockZ)  = 0;
	public: virtual void checkinWorkflowTemplate(const PClientInfo& ci, const PWFDiagram& wf, const PWFDiagramZ& wfZ, const PLockZ& unlockZ, ::std::function< void (PArrayInt, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Deletes a workflow template version.
	/// </summary>
	public: virtual void deleteWorkflowTemplate(const PClientInfo& ci, const ::std::wstring& flowId, const ::std::wstring& versionId, const PLockZ& unlockZ)  = 0;
	public: virtual void deleteWorkflowTemplate(const PClientInfo& ci, const ::std::wstring& flowId, const ::std::wstring& versionId, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Read the stamp definitions from the users options.
	/// </summary>
	public: virtual PArrayNoteTemplate checkoutNoteTemplates(const PClientInfo& ci, const ::std::wstring& userId, const PArrayString& ids, const PNoteTemplateZ& ntemplZ, const PLockZ& lockZ)  = 0;
	public: virtual void checkoutNoteTemplates(const PClientInfo& ci, const ::std::wstring& userId, const PArrayString& ids, const PNoteTemplateZ& ntemplZ, const PLockZ& lockZ, ::std::function< void (PArrayNoteTemplate, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Initializes a new NoteTemplate object.
	/// </summary>
	public: virtual PNoteTemplate createNoteTemplate(const PClientInfo& ci, const ::std::wstring& userId)  = 0;
	public: virtual void createNoteTemplate(const PClientInfo& ci, const ::std::wstring& userId, ::std::function< void (PNoteTemplate, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Delete the stamp definition with the given ID.
	/// </summary>
	public: virtual void deleteNoteTemplates(const PClientInfo& ci, const ::std::wstring& userId, const PArrayString& ids, const PLockZ& unlockZ)  = 0;
	public: virtual void deleteNoteTemplates(const PClientInfo& ci, const ::std::wstring& userId, const PArrayString& ids, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Writes the given stamp definition into the database.
	/// </summary>
	public: virtual PArrayInt checkinNoteTemplates(const PClientInfo& ci, const PArrayNoteTemplate& noteTemplates, const PNoteTemplateZ& ntemplZ, const PLockZ& unlockZ)  = 0;
	public: virtual void checkinNoteTemplates(const PClientInfo& ci, const PArrayNoteTemplate& noteTemplates, const PNoteTemplateZ& ntemplZ, const PLockZ& unlockZ, ::std::function< void (PArrayInt, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// This function reloads all internal objects.
	/// </summary>
	/// <remarks>
	/// <p>
	/// Call this function with administrator privileges,
	/// if configuration options,
	/// scripts or configuration files are modified.
	/// Current sessions and processes are tried to be kept alive.
	/// But under some conditions, sessions get lost and running
	/// processes terminate with an exception!
	/// </p>
	/// </remarks>
	public: virtual void reload(const PClientInfo& ci)  = 0;
	public: virtual void reload(const PClientInfo& ci, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// This function reloads all scripts.
	/// </summary>
	/// <remarks>
	/// <p>
	/// Call this function with administrator privileges,
	/// </p>
	/// if some scripts are modified.
	/// </remarks>
	public: virtual void reloadScripts(const PClientInfo& ci)  = 0;
	public: virtual void reloadScripts(const PClientInfo& ci, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// This function returns a map containing information of all compiled scripts.
	/// </summary>
	public: virtual byps::PMapIntegerString getCompiledScripts(const PClientInfo& ci)  = 0;
	public: virtual void getCompiledScripts(const PClientInfo& ci, ::std::function< void (byps::PMapIntegerString, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// This function returns the list of the scripts which are currently debugged,
	/// i.e. the property "scriptsToDebug".
	/// </summary>
	public: virtual ::std::wstring getScriptsToDebug(const PClientInfo& ci)  = 0;
	public: virtual void getScriptsToDebug(const PClientInfo& ci, ::std::function< void (::std::wstring, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// This function allows to set the the property "scriptsToDebug".
	/// </summary>
	public: virtual void setScriptsToDebug(const PClientInfo& ci, const ::std::wstring& scriptsToDebug)  = 0;
	public: virtual void setScriptsToDebug(const PClientInfo& ci, const ::std::wstring& scriptsToDebug, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// This function returns debugger's port.
	/// </summary>
	public: virtual int32_t getDebuggerPort(const PClientInfo& ci)  = 0;
	public: virtual void getDebuggerPort(const PClientInfo& ci, ::std::function< void (int32_t, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Deletes a keyword list.
	/// </summary>
	public: virtual void deleteKeywordList(const PClientInfo& ci, const ::std::wstring& kwid, const PLockZ& unlockZ)  = 0;
	public: virtual void deleteKeywordList(const PClientInfo& ci, const ::std::wstring& kwid, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Reads a keyword list.
	/// </summary>
	/// <remarks>
	/// <p>
	/// This function internally calls checkoutKeywords.
	/// </p>
	/// </remarks>
	public: virtual PKeywordList checkoutKeywordList(const PClientInfo& ci, const ::std::wstring& kwid, const PKeywordZ& keywordZ, int32_t max, const PLockZ& lockZ)  = 0;
	public: virtual void checkoutKeywordList(const PClientInfo& ci, const ::std::wstring& kwid, const PKeywordZ& keywordZ, int32_t max, const PLockZ& lockZ, ::std::function< void (PKeywordList, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Write or insert a keyword list.
	/// </summary>
	/// <remarks>
	/// <p>
	/// This function internally calls checkinKeywords.
	/// </p>
	/// </remarks>
	public: virtual void checkinKeywordList(const PClientInfo& ci, const PKeywordList& kwList, const PLockZ& unlockZ)  = 0;
	public: virtual void checkinKeywordList(const PClientInfo& ci, const PKeywordList& kwList, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Compares the given ACLs and computes the sum, difference and intersection.
	/// </summary>
	/// <remarks>
	/// <p>
	/// To remove the duplicate entries in an ACL, call this function with a null value for the rhs parameter.
	/// The CombineAclResult.sum contains the ACL without duplicates.
	/// </p>
	/// </remarks>
	public: virtual PCombineAclResult combineAcl(const PClientInfo& ci, const PArrayAclItem& lhs, const PArrayAclItem& rhs, const PCombineAclOptions& options)  = 0;
	public: virtual void combineAcl(const PClientInfo& ci, const PArrayAclItem& lhs, const PArrayAclItem& rhs, const PCombineAclOptions& options, ::std::function< void (PCombineAclResult, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Returns the access of the given ACL.
	/// </summary>
	public: virtual PAclAccessResult getAclAccess(const PClientInfo& ci, const PAclAccessInfo& aai)  = 0;
	public: virtual void getAclAccess(const PClientInfo& ci, const PAclAccessInfo& aai, ::std::function< void (PAclAccessResult, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Returns the EditInfo-Objects from the FileData-Objects.
	/// </summary>
	/// <remarks>
	/// <p>
	/// The rows "IXDTEXT",
	/// "ISCRYPT", "ATTACHID" and "SIGID" in the esw-file are not supported in this version.
	/// </p>
	/// </remarks>
	public: virtual PArrayEditInfo getEditInfoFromESW(const PClientInfo& ci, const PArrayFileData& fileDatas, const PEditInfoEswOptions& eswOptions)  = 0;
	public: virtual void getEditInfoFromESW(const PClientInfo& ci, const PArrayFileData& fileDatas, const PEditInfoEswOptions& eswOptions, ::std::function< void (PArrayEditInfo, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Returns the FileData-Objects from the EditInfo-Objects.
	/// </summary>
	/// <remarks>
	/// <p>
	/// Caution: sord.XDateIso and sord.IDateIso have to contain a value related to the servers timezone.
	/// </p>
	/// </remarks>
	public: virtual PArrayFileData getESWFromEditInfo(const PClientInfo& ci, const PArrayEditInfo& editInfos, const PEditInfoEswOptions& eswOptions)  = 0;
	public: virtual void getESWFromEditInfo(const PClientInfo& ci, const PArrayEditInfo& editInfos, const PEditInfoEswOptions& eswOptions, ::std::function< void (PArrayFileData, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Returns the LoginResult object that represents the session of the ticket contained in the given ClientInfo object.
	/// </summary>
	public: virtual PLoginResult getSessionFromTicket(const PClientInfo& ci, int32_t options)  = 0;
	public: virtual void getSessionFromTicket(const PClientInfo& ci, int32_t options, ::std::function< void (PLoginResult, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Returns the SessionInfo-Objects about all the active connections.
	/// </summary>
	public: virtual PArraySessionInfo getSessionInfos(const PClientInfo& ci, const PSessionInfoParams& params)  = 0;
	public: virtual void getSessionInfos(const PClientInfo& ci, const PSessionInfoParams& params, ::std::function< void (PArraySessionInfo, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Execute a script.
	/// </summary>
	public: virtual PExecuteScriptResult executeScript(const PClientInfo& ci, const PExecuteScriptParams& params)  = 0;
	public: virtual void executeScript(const PClientInfo& ci, const PExecuteScriptParams& params, ::std::function< void (PExecuteScriptResult, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Exports the workflow-version.
	/// </summary>
	public: virtual PFileData exportWorkflow(const PClientInfo& ci, const PWorkflowExportOptions& wfExportOptions)  = 0;
	public: virtual void exportWorkflow(const PClientInfo& ci, const PWorkflowExportOptions& wfExportOptions, ::std::function< void (PFileData, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Read all distinct values from the database that are used for the given ObjKey
	/// name, potentionally causing an enormous database load.
	/// </summary>
	public: virtual PValuesOfObjKey getDistinctValuesOfObjKey(const PClientInfo& ci, const ::std::wstring& okeyName, const PValuesOfObjKeyOptions& opts)  = 0;
	public: virtual void getDistinctValuesOfObjKey(const PClientInfo& ci, const ::std::wstring& okeyName, const PValuesOfObjKeyOptions& opts, ::std::function< void (PValuesOfObjKey, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Read characteristical properties of the archive.
	/// </summary>
	public: virtual PArchiveStatistics getArchiveStatistics(const PClientInfo& ci, int64_t opts)  = 0;
	public: virtual void getArchiveStatistics(const PClientInfo& ci, int64_t opts, ::std::function< void (PArchiveStatistics, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Collects the existing map domains.
	/// </summary>
	/// <remarks>
	/// <p>
	/// This function does not return the special domain MapDomainC.DOMAIN_IX_OPTIONS.
	/// </p>
	/// </remarks>
	public: virtual PArrayMapDomain collectMapDomains(const PClientInfo& ci)  = 0;
	public: virtual void collectMapDomains(const PClientInfo& ci, ::std::function< void (PArrayMapDomain, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Creates or updates a map domain.
	/// </summary>
	public: virtual void checkinMapDomain(const PClientInfo& ci, const PMapDomain& mapDomain, const PLockZ& unlockZ)  = 0;
	public: virtual void checkinMapDomain(const PClientInfo& ci, const PMapDomain& mapDomain, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Reads the data of a map domain.
	/// </summary>
	public: virtual PMapDomain checkoutMapDomain(const PClientInfo& ci, const ::std::wstring& domainName, const PLockZ& lockZ)  = 0;
	public: virtual void checkoutMapDomain(const PClientInfo& ci, const ::std::wstring& domainName, const PLockZ& lockZ, ::std::function< void (PMapDomain, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Deletes a map domain and removes the associated database tables.
	/// </summary>
	public: virtual void deleteMapDomain(const PClientInfo& ci, const ::std::wstring& domainName, const PLockZ& unlockZ)  = 0;
	public: virtual void deleteMapDomain(const PClientInfo& ci, const ::std::wstring& domainName, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Inserts or updates the given key-value-pairs in <code>data</code> in the map specified by <code>id</code>.
	/// </summary>
	/// <remarks>
	/// <p>
	/// The map can be associated to a Sord object by setting the parameter <code>objId</code> to a valid Sord ID.
	/// This implies, that the map is deleted, if the Sord object is finally deleted. Furthermore, the map can
	/// be copied with the Sord object. Therefore, the map ID must be equal to the Sord ID and the map domain
	/// must be prepared to copy items by setting <code>MapDomain.copy=true</code>.
	/// </p>
	/// <p>
	/// If domainName is set to MapDomainC.DOMAIN_IX_OPTIONS, the IndexServer configuration options from table
	/// eloixopt can be written. Therefore the key items in <code>data</code> must be formatted as
	/// data[.].key = &qt;[&qt; + ixid + &qt;]&qt; + optname. Whereby ixid is &qt;_ALL&qt; or the
	/// IndexServer ID specified in the web.xml or config.xml. The parameter <code>id</code> is ignored when
	/// reading IndexServer options. The <code>unlockZ</code> parameter is ignored too, because the options
	/// table does not support locking. Only Administrators are allowed to access the IndexServer options.
	/// </p>
	/// <p>
	/// Since ELO10: Map items can be of type {@link MapValue} which allows to store a BLOB.
	/// The maximum BLOB size should be at most {@link FileDataC#MAX_BLOB_LENGTH}.
	/// <pre><code>
	/// InputStream istream = new FileInputStream(new File("c:\test.txt")); // is closed in checkinMap
	/// FileData fileData = new FileData();
	/// fileData.setContentType("text/plain");
	/// fileData.setStream(istream);
	/// MapValue mapValue = new MapValue();
	/// mapValue.setKey("myfile");
	/// mapValue.setBlobValue(fileData);
	/// conn.ix().checkinMap( "MyMapDomain", "1", 0, new KeyValue[] { mapValue }, LockC.NO );
	/// </code></pre>
	/// </p>
	/// </remarks>
	public: virtual void checkinMap(const PClientInfo& ci, const ::std::wstring& domainName, const ::std::wstring& id, int32_t objId, const PArrayKeyValue& data, const PLockZ& unlockZ)  = 0;
	public: virtual void checkinMap(const PClientInfo& ci, const ::std::wstring& domainName, const ::std::wstring& id, int32_t objId, const PArrayKeyValue& data, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Reads a map or parts of a map.
	/// </summary>
	/// <remarks>
	/// <p>
	/// Since ELO10: In order to access BLOB values, lookup the value in the returned element {@link MapData#mapItems} or cast
	/// the related object in {@link MapData#items} to {@link MapValue}.
	/// <pre><code>
	/// MapData map = conn.ix().checkoutMap( mapDomainName, "1", new String[] {"myfile"}, LockC.NO );
	/// MapValue mapValue = map.getMapItems().get("myfile");
	/// InputStream istream = mapValueR.getBlobValue().getStream();
	/// try {
	/// ...
	/// } finally {
	/// istream.close();
	/// }
	/// </code></pre>
	/// </p>
	/// </remarks>
	public: virtual PMapData checkoutMap(const PClientInfo& ci, const ::std::wstring& domainName, const ::std::wstring& id, const PArrayString& keyNames, const PLockZ& lockZ)  = 0;
	public: virtual void checkoutMap(const PClientInfo& ci, const ::std::wstring& domainName, const ::std::wstring& id, const PArrayString& keyNames, const PLockZ& lockZ, ::std::function< void (PMapData, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Delete map items.
	/// </summary>
	public: virtual void deleteMap(const PClientInfo& ci, const ::std::wstring& domainName, const ::std::wstring& id, const PArrayString& keyNames, const PLockZ& unlockZ)  = 0;
	public: virtual void deleteMap(const PClientInfo& ci, const ::std::wstring& domainName, const ::std::wstring& id, const PArrayString& keyNames, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Find terms for faceted search.
	/// </summary>
	public: virtual PArrayContextTerm getContextTerms(const PClientInfo& ci, const PFindInfo& findInfo, const ::std::wstring& field, int32_t max)  = 0;
	public: virtual void getContextTerms(const PClientInfo& ci, const PFindInfo& findInfo, const ::std::wstring& field, int32_t max, ::std::function< void (PArrayContextTerm, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Execute a registered function defined in a JavaScript or in an event handler.
	/// </summary>
	public: virtual PAny executeRegisteredFunction(const PClientInfo& ci, const ::std::wstring& functionName, const PAny& param)  = 0;
	public: virtual void executeRegisteredFunction(const PClientInfo& ci, const ::std::wstring& functionName, const PAny& param, ::std::function< void (PAny, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Execute a registered function defined in a JavaScript or in an event handler.
	/// </summary>
	public: virtual ::std::wstring executeRegisteredFunctionString(const PClientInfo& ci, const ::std::wstring& functionName, const ::std::wstring& param)  = 0;
	public: virtual void executeRegisteredFunctionString(const PClientInfo& ci, const ::std::wstring& functionName, const ::std::wstring& param, ::std::function< void (::std::wstring, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Get alternative terms for an iSearch search.
	/// </summary>
	/// <remarks>
	/// <p>
	/// This function can be used to list all index values currently used for a given index group.
	/// To achieve this, pass termType=SearchTermsC.TERMS and set findInfo.findDirect.query = "LINE." + indexgroup + ":" + valueprefix.
	/// If more than 10 values shoud be returned, set findInfo.findOptions.totalCount to the maximum
	/// values to be returned.
	/// </p>
	/// </remarks>
	public: virtual PArrayString getSearchTerms(const PClientInfo& ci, const PFindInfo& findInfo, int32_t termType)  = 0;
	public: virtual void getSearchTerms(const PClientInfo& ci, const PFindInfo& findInfo, int32_t termType, ::std::function< void (PArrayString, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Queries, enters or leaves the administration mode.
	/// </summary>
	/// <remarks>
	/// <p>
	/// In administration mode, only main administrators can logon to the archive.
	/// </p>
	/// </remarks>
	public: virtual int32_t adminMode(const PClientInfo& ci, int32_t mode)  = 0;
	public: virtual void adminMode(const PClientInfo& ci, int32_t mode, ::std::function< void (int32_t, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Get or set the fulltext configuration.
	/// </summary>
	public: virtual PFulltextConfig configureFulltext(const PClientInfo& ci, const ::std::wstring& userId, const PFulltextConfig& opts)  = 0;
	public: virtual void configureFulltext(const PClientInfo& ci, const ::std::wstring& userId, const PFulltextConfig& opts, ::std::function< void (PFulltextConfig, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// This function notifies the IndexServer about an operation of the client program.
	/// </summary>
	/// <remarks>
	/// <p>
	/// Use this function in order to notify the license management, when a write access
	/// has been processed, e.g. scan a document or perform OCR analysis on a document.
	/// </p>
	/// </remarks>
	public: virtual PNotifyServerResult notifyServer(const PClientInfo& ci, const PNotifyServerInfo& msg)  = 0;
	public: virtual void notifyServer(const PClientInfo& ci, const PNotifyServerInfo& msg, ::std::function< void (PNotifyServerResult, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Query or send backup profile information of the ELOdm.
	/// </summary>
	/// <remarks>
	/// <p>
	/// The user calling this method must have the main administrator right
	/// (AccessC.FLAG_ADMIN).
	/// </p>
	/// </remarks>
	public: virtual PArrayBackupProfile configureBackup(const PClientInfo& ci, const PArrayBackupProfile& backupProfiles)  = 0;
	public: virtual void configureBackup(const PClientInfo& ci, const PArrayBackupProfile& backupProfiles, ::std::function< void (PArrayBackupProfile, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Query the status of the backup and purge tasks of the ELOdm.
	/// </summary>
	/// <remarks>
	/// <p>
	/// In addition, the backup and purge tasks can be started or stopped.
	/// The user calling this method must have the main administrator right
	/// (AccessC.FLAG_ADMIN).
	/// </p>
	/// </remarks>
	public: virtual PBackupPurgeStatus controlBackup(const PClientInfo& ci, const PControlBackupInfo& controlBackupInfo)  = 0;
	public: virtual void controlBackup(const PClientInfo& ci, const PControlBackupInfo& controlBackupInfo, ::std::function< void (PBackupPurgeStatus, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Query or send the purge task settings of the ELOdm.
	/// </summary>
	/// <remarks>
	/// <p>
	/// The user calling this method must have the main administrator right
	/// (AccessC.FLAG_ADMIN).
	/// </p>
	/// </remarks>
	public: virtual PPurgeSettings configurePurge(const PClientInfo& ci, const PPurgeSettings& purgeSettings)  = 0;
	public: virtual void configurePurge(const PClientInfo& ci, const PPurgeSettings& purgeSettings, ::std::function< void (PPurgeSettings, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Adds additional params to an upload or download URL.
	/// </summary>
	/// <remarks>
	/// <p>
	/// Currently, additional params are only available for download URLs.
	/// </p>
	/// </remarks>
	public: virtual ::std::wstring addUrlParams(const PClientInfo& ci, const ::std::wstring& url, const PUrlParams& params)  = 0;
	public: virtual void addUrlParams(const PClientInfo& ci, const ::std::wstring& url, const PUrlParams& params, ::std::function< void (::std::wstring, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Open a new event bus.
	/// </summary>
	/// <remarks>
	/// <p>
	/// Caution: the event bus API functions cannot be used with SOAP communication.
	/// </p><p>
	/// An event bus is like a communication channel between two or more subscribers. One subscriber sends an
	/// event and the bus dispatches it to the subscribers that are listening.
	/// </p><p>
	/// Before an application can send events, it has to call the function <code>createEventBusSubscriber</code>
	/// in order to create a subscriber ID. A subscriber can send events to an event bus or listen to events from an event bus.
	/// To send an event, the function <code>sendEvents</code> has to be called.<br>
	/// In order to revive events from event busses, event listeners have to be registered with the event busses first.
	/// An event listener specifies a list of <code>EventFilter</code> objects which describe the requested event types and busses from which to receive events.
	/// A subscriber can register any number of event listeners to potentially different event busses with a single call to <code>createEventBusListener</code>.
	/// Further event listeners can be added by this function or deleted with <code>deleteEventBusListener</code> at any time.
	/// </p><p>
	/// A helper object of <code>IXConnection</code>, which can be obtained by <code>IXConnection.getEventBusApi()</code>,
	/// listens for incoming events and forwards them to an object that implements the <code>IXEventBusHandler</code> interface.
	/// This object has to be provided by the client application and must be passed in a call to <code>IXConnection.getEventBusApi().setHandler(...)</code>.
	/// </p><p>
	/// Normally, client applications will use the predefined busses listed in <code>EventBusC</code>.
	/// This class defines a broadcast bus and busses related to users. Any subscriber can receive events from the broadcast
	/// bus. In difference to that, user busses can be listened only by the owner - a user bus acts somewhat like a mailbox.
	/// <p></p>
	/// There is no constraint to subscribers for sending events to busses. A subscriber can send any event to a bus, if it knows the bus ID.
	/// <p></p>
	/// In some circumstances, it is useful to work with a private channel between particular subscribers. This could be a channel used
	/// for chat messages between users. Another example is a channel between separated components of an application that share the same
	/// ticket an have to synchronize the user interfaces.
	/// <p></p>
	/// Use this function to open an event bus e.g. to establish a private communication channel between
	/// two or more applications. The returned bus ID is built upon the given information in <code>params</code>.
	/// Two applications, that supply equal params objects, will receive equal bus IDs.
	/// At least one of the applications has to close the bus with <code>closeEventBus</code> if it is needed no more.
	/// </p>
	/// </remarks>
	public: virtual int64_t openEventBus(const PClientInfo& ci, const PEventBusParams& params)  = 0;
	public: virtual void openEventBus(const PClientInfo& ci, const PEventBusParams& params, ::std::function< void (int64_t, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Close an event bus opened by <code>openEventBus</code>.
	/// </summary>
	/// <remarks>
	/// <p>
	/// Any subscriber that knows the bus ID can close this event bus.
	/// When a bus is closed, all outstanding events in the ELOix are deleted.
	/// After a bus is closed, neither listener will receive anymore events from this bus.
	/// This function ignores unknown or already closed bus IDs or bus IDs defined in <code>EventBusC</code>.
	/// </p>
	/// </remarks>
	public: virtual void closeEventBus(const PClientInfo& ci, int64_t busId)  = 0;
	public: virtual void closeEventBus(const PClientInfo& ci, int64_t busId, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Create an event bus subscriber.
	/// </summary>
	/// <remarks>
	/// <p>
	/// A subscriber sends events to an event bus or receives events from an event bus.
	/// An application resp. an <code>IXConnection</code> can open any number of subscribers.
	/// A subscriber has to be deleted with <code>deleteEventBusSubscriber</code> when it is no more needed.
	/// A bus is also deleted, if the last event listener is deleted. This might happen when <code>deleteEventBusSubscriber</code> or <code>deleteEventBusListener</code> is called.
	/// In this case, it is not necessary to call <code>deleteEventBusSubscriber</code>.
	/// </p>
	/// </remarks>
	public: virtual int64_t createEventBusSubscriber(const PClientInfo& ci)  = 0;
	public: virtual void createEventBusSubscriber(const PClientInfo& ci, ::std::function< void (int64_t, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Deletes an event bus subscriber.
	/// </summary>
	/// <remarks>
	/// <p>
	/// This function deletes a subscriber an all its event listeners.
	/// </p>
	/// </remarks>
	public: virtual void deleteEventBusSubscriber(const PClientInfo& ci, int64_t subsId)  = 0;
	public: virtual void deleteEventBusSubscriber(const PClientInfo& ci, int64_t subsId, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Creates an event bus listener.
	/// </summary>
	/// <remarks>
	/// <p>
	/// This function creates an event bus listener that filters events from the event bus as described in the filter list of the <code>eventListener</code> parameter.
	/// Event bus listeners have to be deleted by either <code>deleteEventBusListener</code> or by deleting the subscriber with <code>deleteEventBusSubscriber</code>.
	/// </p>
	/// </remarks>
	public: virtual int64_t createEventBusListener(const PClientInfo& ci, int64_t subsId, const PEventListener& eventListener)  = 0;
	public: virtual void createEventBusListener(const PClientInfo& ci, int64_t subsId, const PEventListener& eventListener, ::std::function< void (int64_t, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Deletes an event bus listener.
	/// </summary>
	/// <remarks>
	/// <p>
	/// This function deletes an event bus listener that was created by a call to <code>createEventBusListener</code>.
	/// The function does not throw an exception, if the Listener ID does not exist.
	/// </p>
	/// </remarks>
	public: virtual void deleteEventBusListener(const PClientInfo& ci, int64_t lsnId)  = 0;
	public: virtual void deleteEventBusListener(const PClientInfo& ci, int64_t lsnId, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Read events from the server.
	/// </summary>
	/// <remarks>
	/// <p>
	/// This function should not be called directly. It is used internally by the event bus helper object of <code>IXConnection</code>.
	/// </p>
	/// </remarks>
	public: virtual PArrayEvent internalReceiveEvents(const PClientInfo& ci, int64_t subsId, int64_t timeoutMillis)  = 0;
	public: virtual void internalReceiveEvents(const PClientInfo& ci, int64_t subsId, int64_t timeoutMillis, ::std::function< void (PArrayEvent, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Send events to event busses.
	/// </summary>
	/// <remarks>
	/// <p>
	/// Call this function to send events to event busses.
	/// </p>
	/// </remarks>
	public: virtual void sendEvents(const PClientInfo& ci, int64_t subsId, const PArrayEvent& events)  = 0;
	public: virtual void sendEvents(const PClientInfo& ci, int64_t subsId, const PArrayEvent& events, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Helper function to create a RSA key pair.
	/// </summary>
	public: virtual PArrayString createRsaKeys(const PClientInfo& ci)  = 0;
	public: virtual void createRsaKeys(const PClientInfo& ci, ::std::function< void (PArrayString, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Encrypt or decrypt a string using the RSA algorithm.
	/// </summary>
	/// <remarks>
	/// <p>
	/// This function encrypts or decrypts the string <code>data</code> using the RSA algorithm.
	/// The string must not be longer than 768 characters.
	/// Pass the public RSA key in <code>key</code>, if the string should be encrypted.
	/// In order to decrypt the string, the private key has to be passed.
	/// Both keys must be created with <code>createRsaKeys</code>.
	/// </p>
	/// </remarks>
	public: virtual ::std::wstring encryptStringRsa(const PClientInfo& ci, const ::std::wstring& key, const ::std::wstring& data, bool encryptNotDecrypt)  = 0;
	public: virtual void encryptStringRsa(const PClientInfo& ci, const ::std::wstring& key, const ::std::wstring& data, bool encryptNotDecrypt, ::std::function< void (::std::wstring, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// This function creates an activity project in memory.
	/// </summary>
	/// <remarks>
	/// <p>
	/// If projectName is not null and not empty, the function checks whether the name is already used.
	/// The current session must have the permission AccessC.FLAG_EDITACT in order to call this function.
	/// </p>
	/// </remarks>
	public: virtual PActivityProject createActivityProject(const PClientInfo& ci, const ::std::wstring& projectName)  = 0;
	public: virtual void createActivityProject(const PClientInfo& ci, const ::std::wstring& projectName, ::std::function< void (PActivityProject, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// This function writes an activity project into the database.
	/// </summary>
	/// <remarks>
	/// <p>
	/// The current session must have the permission AccessC.FLAG_EDITACT in order to call this function.
	/// </p>
	/// </remarks>
	public: virtual ::std::wstring checkinActivityProject(const PClientInfo& ci, const PActivityProject& actProj, const PLockZ& unlockZ)  = 0;
	public: virtual void checkinActivityProject(const PClientInfo& ci, const PActivityProject& actProj, const PLockZ& unlockZ, ::std::function< void (::std::wstring, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// This function reads and optionally locks an activity project.
	/// </summary>
	public: virtual PActivityProject checkoutActivityProject(const PClientInfo& ci, const ::std::wstring& projectName, const PLockZ& lockZ)  = 0;
	public: virtual void checkoutActivityProject(const PClientInfo& ci, const ::std::wstring& projectName, const PLockZ& lockZ, ::std::function< void (PActivityProject, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// This function deletes an activity project from the database.
	/// </summary>
	/// <remarks>
	/// <p>
	/// The current session must have the permission AccessC.FLAG_EDITACT in order to call this function.
	/// </p>
	/// </remarks>
	public: virtual void deleteActivityProject(const PClientInfo& ci, const ::std::wstring& projectName, const PLockZ& unlockZ)  = 0;
	public: virtual void deleteActivityProject(const PClientInfo& ci, const ::std::wstring& projectName, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// This function reads all activity projects.
	/// </summary>
	public: virtual PArrayActivityProject findActivityProjects(const PClientInfo& ci, const PFindActivityProjectsInfo& findInfo)  = 0;
	public: virtual void findActivityProjects(const PClientInfo& ci, const PFindActivityProjectsInfo& findInfo, ::std::function< void (PArrayActivityProject, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// This function creates an activity in memory based on the given project and assigned to the given object.
	/// </summary>
	/// <remarks>
	/// <p>
	/// The current session must have read access to the Sord, if parameter objId is specified.
	/// </p>
	/// </remarks>
	public: virtual PActivity createActivity(const PClientInfo& ci, const ::std::wstring& projectName, const ::std::wstring& objId)  = 0;
	public: virtual void createActivity(const PClientInfo& ci, const ::std::wstring& projectName, const ::std::wstring& objId, ::std::function< void (PActivity, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// This function inserts or updates an activity.
	/// </summary>
	/// <remarks>
	/// <p>
	/// The current session must have read access to the given Sord.
	/// In order to update an existing activity, the current session must be sender or receiver of the activity (Acitivty.senderId, Activity.receiverId).
	/// </p>
	/// </remarks>
	public: virtual ::std::wstring checkinActivity(const PClientInfo& ci, const PActivity& act, const PLockZ& unlockZ)  = 0;
	public: virtual void checkinActivity(const PClientInfo& ci, const PActivity& act, const PLockZ& unlockZ, ::std::function< void (::std::wstring, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// This function deletes an activity.
	/// </summary>
	/// <remarks>
	/// <p>
	/// The current session must be sender or receiver of the activity (Acitivty.senderId, Activity.receiverId).
	/// </p>
	/// </remarks>
	public: virtual void deleteActivity(const PClientInfo& ci, const ::std::wstring& actGuid, const PDeleteActivityOptions& deleteOptions, const PLockZ& unlockZ)  = 0;
	public: virtual void deleteActivity(const PClientInfo& ci, const ::std::wstring& actGuid, const PDeleteActivityOptions& deleteOptions, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// This function reads and optionally locks an activity.
	/// </summary>
	/// <remarks>
	/// <p>
	/// The current session must be sender or receiver of the activity (Acitivty.senderId, Activity.receiverId).
	/// </p>
	/// </remarks>
	public: virtual PActivity checkoutActivity(const PClientInfo& ci, const ::std::wstring& actGuid, const PLockZ& lockZ)  = 0;
	public: virtual void checkoutActivity(const PClientInfo& ci, const ::std::wstring& actGuid, const PLockZ& lockZ, ::std::function< void (PActivity, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// This function reads the activities of an object.
	/// </summary>
	public: virtual PFindResult findFirstActivities(const PClientInfo& ci, const PFindActivityInfo& findInfo, int32_t max, const PActivityZ& activityZ)  = 0;
	public: virtual void findFirstActivities(const PClientInfo& ci, const PFindActivityInfo& findInfo, int32_t max, const PActivityZ& activityZ, ::std::function< void (PFindResult, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// This function reads the next activites of an object.
	/// </summary>
	public: virtual PFindResult findNextActivities(const PClientInfo& ci, const ::std::wstring& searchId, int32_t idx, int32_t max, const PActivityZ& activityZ)  = 0;
	public: virtual void findNextActivities(const PClientInfo& ci, const ::std::wstring& searchId, int32_t idx, int32_t max, const PActivityZ& activityZ, ::std::function< void (PFindResult, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// This function is called from an OCR worker process to notify Indexserver about its state.
	/// </summary>
	/// <remarks>
	/// <p>
	/// The behavior of a OCR worker process is beyond the API documentation. Contact ELO support,
	/// if a different OCR has to be integrated.
	/// </p>
	/// </remarks>
	public: virtual POcrWorker registerOcrWorker(const PClientInfo& ci, const POcrWorker& ocrWorker)  = 0;
	public: virtual void registerOcrWorker(const PClientInfo& ci, const POcrWorker& ocrWorker, ::std::function< void (POcrWorker, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Compute OCR on the given image data or on an archived document.
	/// </summary>
	/// <remarks>
	/// <p>
	/// <i>In order to use this function, the ELO OCR Service 8.0 has to be installed somewhere on the network and
	/// has to be configured for Indexserver access.</i>
	/// </p><p>
	/// The request can be performed synchronously or asynchronously.
	/// In asynchronous processing, the result is sent via the Indexserver Event API.
	/// In order to receive the result, the client application has to register a listener for the event type
	/// EventBusC.EVENT_OCR_RESULT.
	/// </p><p>
	/// Use an empty OcrInfo object to check, whether OCR is available.
	/// </p><p>
	/// This is a simple example for synchronous OCR processing:
	/// <pre><code>
	/// IXConnection conn = ...
	/// String imageFile = ... // Input file in TIFF, etc. format
	/// String textFile = ... // Output file in text format
	/// <br/>
	/// // Is OCR via IX available? - Pass an empty OcrInfo object to processOcr in order to find it out.
	/// OcrInfo ocrInfo = new OcrInfo();
	/// bool isOcrAvail = conn.Ix.processOcr(ocrInfo) != null;
	/// if (!isOcrAvail) return;
	/// <br/>
	/// // Query the languages supported by the OCR Engine
	/// OcrInfo ocrInfoLangs = new OcrInfo();
	/// ocrInfoLangs.queryLanguages = new OcrInfoQueryLanguages();
	/// OcrResult ocrResultLangs = conn.Ix.processOcr(ocrInfoLangs);
	/// <br/>
	/// // Anaylze file
	/// // Load entire image into memory
	/// OcrInfo ocrInfo = new OcrInfo();
	/// ocrInfo.recognizeFile = new OcrInfoRecognizeFile();
	/// ocrInfo.recognizeFile.imageData = new FileData();
	/// ocrInfo.recognizeFile.imageData.data = File.ReadAllBytes(imageFile);
	/// ocrInfo.recognizeFile.imageData.contentType = Path.GetExtension(imageFile);
	/// ocrInfo.recognizeFile.pageNo = -1; // analyze all pages
	/// ocrInfo.recognizeFile.outputFormat = OcrInfoC.TEXT; // return result as String
	/// ocrInfo.recognizeFile.recognizeLangs = new String[] {"German", "Czech"}; // Choosen from ocrResultLangs.internalLangs
	/// <br/>
	/// // Process OCR
	/// OcrResult ocrResult = conn.Ix.processOcr(ocrInfo);
	/// <br/>
	/// // Write text output to file
	/// File.WriteAllText(textFile, ocrResult.recognizeFile.text, Encoding.UTF8);
	/// </code></pre>
	/// </p>
	/// </remarks>
	public: virtual POcrResult processOcr(const PClientInfo& ci, const POcrInfo& ocrInfo)  = 0;
	public: virtual void processOcr(const PClientInfo& ci, const POcrInfo& ocrInfo, ::std::function< void (POcrResult, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Evaluate the destination archive path based on filing definitions of a keywording from.
	/// </summary>
	/// <remarks>
	/// <p>
	/// This function evaluates the parent folder of a Sord object based on the filing
	/// definition of a keywording form WITHOUT storing the Sord object.
	/// This is in contrast to the checkinSord and checkinDocEnd functions which store the Sord object
	/// in the resulting parent.
	/// </p>
	/// </remarks>
	public: virtual PAutoFilingResult evalAutoFiling(const PClientInfo& ci, const ::std::wstring& maskId, const PSord& sord, const PAutoFilingOptions& opts)  = 0;
	public: virtual void evalAutoFiling(const PClientInfo& ci, const ::std::wstring& maskId, const PSord& sord, const PAutoFilingOptions& opts, ::std::function< void (PAutoFilingResult, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Reads the history entries for the given map.
	/// </summary>
	/// <remarks>
	/// <p>
	/// History entries are only written for MapDomain objects with {@link MapDomain#history}=true.
	/// For MapDomain objects with {@link MapDomain#history}=false, an empty array is returned.
	/// If no history entries exist for the given domainName and mapId, an empty array is returned.
	/// </p>
	/// </remarks>
	public: virtual PArrayMapHist checkoutMapHistory(const PClientInfo& ci, const ::std::wstring& domainName, const ::std::wstring& mapId, const PMapHistZ& membersZ)  = 0;
	public: virtual void checkoutMapHistory(const PClientInfo& ci, const ::std::wstring& domainName, const ::std::wstring& mapId, const PMapHistZ& membersZ, ::std::function< void (PArrayMapHist, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Prepares the IndexServer to enable a document to be checked in.
	/// </summary>
	/// <remarks>
	/// <p>
	/// Retrieves path id and encryption set from the sord object and sets these values in document versions
	/// of this document.
	/// In case of limited release document, work version is set to false.
	/// Document id will not be set to 0, if "keepIds" is true in option "opts" (when no new document but
	/// only signature should be added for a version controlled document, up to this version clients had
	/// to reset the actual document id after running method checkinDocBegin)
	/// </p>
	/// </remarks>
	public: virtual PDocument checkinDocBegin2(const PClientInfo& ci, const PSord& sord, const PDocument& document, const PCheckinDocOptions& opts)  = 0;
	public: virtual void checkinDocBegin2(const PClientInfo& ci, const PSord& sord, const PDocument& document, const PCheckinDocOptions& opts, ::std::function< void (PDocument, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Query the status of the job and control its state.
	/// </summary>
	/// <remarks>
	/// <p>
	/// Using this method the job can be cancelled. The user calling this method
	/// must have started the job or must have the administrator right
	/// (AccessC.FLAG_ADMIN).
	/// </p>
	/// </remarks>
	public: virtual PJobState controlBackgroundThread(const PClientInfo& ci, const PJobState& jobState)  = 0;
	public: virtual void controlBackgroundThread(const PClientInfo& ci, const PJobState& jobState, ::std::function< void (PJobState, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Query all jobs executed in the background.
	/// </summary>
	/// <remarks>
	/// <p>
	/// The method returns all jobs started by the calling user. If the user has
	/// the administrator right (AccessC.FLAG_ADMIN) the
	/// findBackgroundThreadOptions parameter can filter for users.
	/// </p>
	/// </remarks>
	public: virtual PFindResult findBackgroundThreads(const PClientInfo& ci, const PFindBackgroundThreadOptions& findBackgroundThreadOptions)  = 0;
	public: virtual void findBackgroundThreads(const PClientInfo& ci, const PFindBackgroundThreadOptions& findBackgroundThreadOptions, ::std::function< void (PFindResult, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Query the protocol of a background thread.
	/// </summary>
	/// <remarks>
	/// <p>
	/// The method returns all log messages that matches the restrictions given by
	/// the parameter queryJobProtocolInfo, and that are cached at the IndexServer.
	/// The amount of cached entries is configurable at the log4j configuration
	/// file.
	/// </p>
	/// </remarks>
	public: virtual PQueryJobProtocolResult queryJobProtocol(const PClientInfo& ci, const PQueryJobProtocolInfo& queryJobProtocolInfo)  = 0;
	public: virtual void queryJobProtocol(const PClientInfo& ci, const PQueryJobProtocolInfo& queryJobProtocolInfo, ::std::function< void (PQueryJobProtocolResult, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Queries dynamic keyword lists.
	/// </summary>
	/// <remarks>
	/// <p>
	/// A server script generates the data of dynamic keyword lists from external
	/// resources. Such resources may be databases of CRMs, webservices like
	/// twitter, an e-M@il provider, etc. The default installation does not provide
	/// any server scripts. They must be implemented by the end-user.
	/// </p>
	/// </remarks>
	public: virtual PKeywordsDynamicResult checkoutKeywordsDynamic(const PClientInfo& ci, const PKeywordsDynamicInfo& keywordsDynamicInfo)  = 0;
	public: virtual void checkoutKeywordsDynamic(const PClientInfo& ci, const PKeywordsDynamicInfo& keywordsDynamicInfo, ::std::function< void (PKeywordsDynamicResult, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Gets the list of Sord object which are the predecessors of the sord given by the objId.
	/// </summary>
	/// <remarks>
	/// <p>
	/// If csi.inclRefPaths is set, all the sord of the referenced paths are also returned.
	/// </p>
	/// </remarks>
	public: virtual PSordPaths checkoutSordPath(const PClientInfo& ci, const ::std::wstring& objId, const PSordZ& sordZ, const PCheckoutSordPathInfo& csi)  = 0;
	public: virtual void checkoutSordPath(const PClientInfo& ci, const ::std::wstring& objId, const PSordZ& sordZ, const PCheckoutSordPathInfo& csi, ::std::function< void (PSordPaths, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Generates URLs for preview images of documents.
	/// </summary>
	public: virtual PPreviewImageResult checkoutPreviewImageURLs(const PClientInfo& ci, const PPreviewImageInfo& previewImageInfo)  = 0;
	public: virtual void checkoutPreviewImageURLs(const PClientInfo& ci, const PPreviewImageInfo& previewImageInfo, ::std::function< void (PPreviewImageResult, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Specify, which notifications should be sent by the server.
	/// </summary>
	public: virtual PApplyForNotificationsInfo applyForNotifications(const PClientInfo& ci, const PApplyForNotificationsInfo& info)  = 0;
	public: virtual void applyForNotifications(const PClientInfo& ci, const PApplyForNotificationsInfo& info, ::std::function< void (PApplyForNotificationsInfo, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Gets the public downloads.
	/// </summary>
	public: virtual PVectorPublicDownload getPublicDownloads(const PClientInfo& ci, const PPublicDownloadOptions& opts)  = 0;
	public: virtual void getPublicDownloads(const PClientInfo& ci, const PPublicDownloadOptions& opts, ::std::function< void (PVectorPublicDownload, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Deletes the public downloads
	/// </summary>
	public: virtual void terminatePublicDownloadUrls(const PClientInfo& ci, const PPublicDownloadOptions& opts)  = 0;
	public: virtual void terminatePublicDownloadUrls(const PClientInfo& ci, const PPublicDownloadOptions& opts, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Edits the public downloads
	/// </summary>
	public: virtual void editPublicDownloadUrls(const PClientInfo& ci, const PPublicDownloadOptions& opts)  = 0;
	public: virtual void editPublicDownloadUrls(const PClientInfo& ci, const PPublicDownloadOptions& opts, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Resolves the rights of a user.
	/// </summary>
	/// <remarks>
	/// <p>
	/// This function calculates the effective rights of a given user. Hereby, the
	/// given parameter userInfo will not be checked in. This way it is possible to
	/// set hypothetical groups for the user and retrieve the results of the change
	/// without applying them. The effective rights always are calculated for every
	/// right.
	/// </p>
	/// <p>
	/// The groups of the given users will be combined with the groups he already
	/// is a member of. This combination works like the logical "or" function. If
	/// you want the result without a specific group, ignore the corresponding
	/// {@link ResolveRightsResult} which has set {@link ResolveRightsResult#type}=
	/// {@link ResolveRightsResultC#DIRECT}.
	/// </p>
	/// </remarks>
	public: virtual PVectorResolveRightsResult resolveRights(const PClientInfo& ci, const PUserInfo& ui, const PResolveRightsInfo& info)  = 0;
	public: virtual void resolveRights(const PClientInfo& ci, const PUserInfo& ui, const PResolveRightsInfo& info, ::std::function< void (PVectorResolveRightsResult, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Starts an Ad Hoc Workflow.
	/// </summary>
	public: virtual int32_t startAdHocWorkFlow2(const PClientInfo& ci, const ::std::wstring& name, const ::std::wstring& objId, const PArrayUserNodeInfo& userNodeInfo, const PStartAdHocWorkflowInfo& startWfInfo)  = 0;
	public: virtual void startAdHocWorkFlow2(const PClientInfo& ci, const ::std::wstring& name, const ::std::wstring& objId, const PArrayUserNodeInfo& userNodeInfo, const PStartAdHocWorkflowInfo& startWfInfo, ::std::function< void (int32_t, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Starts an Ad Hoc Workflow.
	/// </summary>
	public: virtual int32_t startAdHocWorkFlow3(const PClientInfo& ci, const ::std::wstring& name, const ::std::wstring& objId, const PStartAdHocWorkflowInfo& startWfInfo)  = 0;
	public: virtual void startAdHocWorkFlow3(const PClientInfo& ci, const ::std::wstring& name, const ::std::wstring& objId, const PStartAdHocWorkflowInfo& startWfInfo, ::std::function< void (int32_t, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Creates and inserts a new public download
	/// </summary>
	public: virtual PPublicDownload insertPublicDownload(const PClientInfo& ci, const PPublicDownloadOptions& opts)  = 0;
	public: virtual void insertPublicDownload(const PClientInfo& ci, const PPublicDownloadOptions& opts, ::std::function< void (PPublicDownload, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Initialize a subscription object.
	/// </summary>
	public: virtual PSubscription createSubscription(const PClientInfo& ci, const ::std::wstring& watchGuid)  = 0;
	public: virtual void createSubscription(const PClientInfo& ci, const ::std::wstring& watchGuid, ::std::function< void (PSubscription, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Add a subscription.
	/// </summary>
	public: virtual PSubscription checkinSubscription(const PClientInfo& ci, const PSubscription& subs, const PSubscriptionZ& subsZ)  = 0;
	public: virtual void checkinSubscription(const PClientInfo& ci, const PSubscription& subs, const PSubscriptionZ& subsZ, ::std::function< void (PSubscription, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Delete a subscription.
	/// </summary>
	public: virtual void deleteSubscription(const PClientInfo& ci, const PSubscription& subs)  = 0;
	public: virtual void deleteSubscription(const PClientInfo& ci, const PSubscription& subs, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Find first max subscriptions.
	/// </summary>
	/// <remarks>
	/// This function finds the subscriptions of the current user.
	/// </remarks>
	public: virtual PFindResult findFirstSubscriptions(const PClientInfo& ci, const PFindSubscriptionInfo& findInfo, int32_t max, const PSubscriptionZ& subsZ)  = 0;
	public: virtual void findFirstSubscriptions(const PClientInfo& ci, const PFindSubscriptionInfo& findInfo, int32_t max, const PSubscriptionZ& subsZ, ::std::function< void (PFindResult, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Find next max subscriptions beginning at index idx.
	/// </summary>
	public: virtual PFindResult findNextSubscriptions(const PClientInfo& ci, const ::std::wstring& searchId, int32_t idx, int32_t max, const PSubscriptionZ& subsZ)  = 0;
	public: virtual void findNextSubscriptions(const PClientInfo& ci, const ::std::wstring& searchId, int32_t idx, int32_t max, const PSubscriptionZ& subsZ, ::std::function< void (PFindResult, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Find first notes.
	/// </summary>
	/// <remarks>
	/// This function starts a search for Note object and returns the first objects found in {@link FindResult#notes}.
	/// At least {@link FindInfo#findByNotes} must be set. The member {@link FindInfo#findChildren} optionally
	/// constrain the results to a folder.
	/// The search must be closed with {@link #findClose(ClientInfo, String)} in order to release internally cached data.
	/// </remarks>
	public: virtual PFindResult findFirstNotes(const PClientInfo& ci, const PFindInfo& findInfo, int32_t max, const PNoteZ& noteZ)  = 0;
	public: virtual void findFirstNotes(const PClientInfo& ci, const PFindInfo& findInfo, int32_t max, const PNoteZ& noteZ, ::std::function< void (PFindResult, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Find next notes.
	/// </summary>
	/// <remarks>
	/// This function continues a search for Note objects startet with function {@link #findFirstNotes(ClientInfo, FindInfo, int, NoteZ)}.
	/// </remarks>
	public: virtual PFindResult findNextNotes(const PClientInfo& ci, const ::std::wstring& searchId, int32_t idx, int32_t max, const PNoteZ& noteZ)  = 0;
	public: virtual void findNextNotes(const PClientInfo& ci, const ::std::wstring& searchId, int32_t idx, int32_t max, const PNoteZ& noteZ, ::std::function< void (PFindResult, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Inserts custom report entries.
	/// </summary>
	/// <remarks>
	/// <p>
	/// This function writes new entries into the report table. These entries always
	/// are appended to the report table. Once in the report table, no data will be
	/// overwritten by this function. The ReportInfo element must provide an action
	/// number {@link ReportInfo#actionNo} at least. The action number has to be
	/// within the range {@link ReportInfoC#ACT_CUSTOM_FIRST} and
	/// {@link ReportInfoC#ACT_CUSTOM_LAST}. Besides the action number, the report
	/// entry can hold custom data in the fields objId, extra1, extra2, text and
	/// extraInfo. If specified, the object in extraInfo must be Serializable.
	/// If the report entry to insert does not belong to a {@link Sord}, set the
	/// objId value to 0.
	/// </p>
	/// </remarks>
	public: virtual void checkinReport(const PClientInfo& ci, const PReportInfo& report, const PCheckinReportInfo& reserved, const PLockZ& lockZ)  = 0;
	public: virtual void checkinReport(const PClientInfo& ci, const PReportInfo& report, const PCheckinReportInfo& reserved, const PLockZ& lockZ, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Links archive entries like {@link #linkSords}.
	/// </summary>
	/// <remarks>
	/// <p>This method provides the additional parameter {@link LinkSordInfo} to
	/// specify more options for linking sords together.</p>
	/// </remarks>
	public: virtual void linkSords2(const PClientInfo& ci, const ::std::wstring& fromId, const PArrayString& toIds, const PLinkSordZ& linkSordZ, const PLinkSordInfo& linkSordInfo)  = 0;
	public: virtual void linkSords2(const PClientInfo& ci, const ::std::wstring& fromId, const PArrayString& toIds, const PLinkSordZ& linkSordZ, const PLinkSordInfo& linkSordInfo, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Returns the WebDAV path from an Object ID.
	/// </summary>
	public: virtual ::std::wstring getWebDAVPathFromObjID(const PClientInfo& ci, const ::std::wstring& objId)  = 0;
	public: virtual void getWebDAVPathFromObjID(const PClientInfo& ci, const ::std::wstring& objId, ::std::function< void (::std::wstring, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Returns the WebDAV path from an Object ID.
	/// </summary>
	public: virtual PGetWebDAVPathResult getWebDAVPathFromObjID2(const PClientInfo& ci, const PGetWebDAVPathOptions& options)  = 0;
	public: virtual void getWebDAVPathFromObjID2(const PClientInfo& ci, const PGetWebDAVPathOptions& options, ::std::function< void (PGetWebDAVPathResult, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Reads the histories of a node or a whole workflow.
	/// </summary>
	public: virtual PCheckoutWorkflowHistoryResult checkoutWorkflowHistory(const PClientInfo& ci, const PCheckoutWorkflowHistoryParams& checkoutWorkflowHistoryParams)  = 0;
	public: virtual void checkoutWorkflowHistory(const PClientInfo& ci, const PCheckoutWorkflowHistoryParams& checkoutWorkflowHistoryParams, ::std::function< void (PCheckoutWorkflowHistoryResult, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Writes a keyword template into the database.
	/// </summary>
	/// <remarks>
	/// If this keyword template is already used in keywording forms, these keywording forms will be updated.
	/// This function requires ELO 10 license.
	/// </remarks>
	public: virtual int32_t checkinDocMaskLineTemplate(const PClientInfo& ci, const PDocMaskLineTemplate& dmlt, const PDocMaskLineTemplateZ& dmltZ, const PCheckInDocMaskLineTemplateOptions& options, const PLockZ& lockZ)  = 0;
	public: virtual void checkinDocMaskLineTemplate(const PClientInfo& ci, const PDocMaskLineTemplate& dmlt, const PDocMaskLineTemplateZ& dmltZ, const PCheckInDocMaskLineTemplateOptions& options, const PLockZ& lockZ, ::std::function< void (int32_t, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Check out keyword templates.
	/// </summary>
	/// <remarks>
	/// This function requires ELO 10 license.
	/// </remarks>
	public: virtual PArrayDocMaskLineTemplate checkoutDocMaskLineTemplates(const PClientInfo& ci, const PArrayString& groups, const PDocMaskLineTemplateZ& dmltZ, const PLockZ& lockZ)  = 0;
	public: virtual void checkoutDocMaskLineTemplates(const PClientInfo& ci, const PArrayString& groups, const PDocMaskLineTemplateZ& dmltZ, const PLockZ& lockZ, ::std::function< void (PArrayDocMaskLineTemplate, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Delete keyword templates
	/// This function requires ELO 10 license.
	/// </summary>
	public: virtual void deleteDocMaskLineTemplates(const PClientInfo& ci, const PArrayString& groups, const PLockZ& unlockZ)  = 0;
	public: virtual void deleteDocMaskLineTemplates(const PClientInfo& ci, const PArrayString& groups, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Prepare forwarding of a workflow node.
	/// </summary>
	/// <remarks>
	/// Use this function to lock a workflow and get the data required for forwarding a node.
	/// </remarks>
	public: virtual PWFEditNode beginForwardWorkflowNode(const PClientInfo& ci, int32_t flowId, int32_t nodeId, const PBeginForwardWorkflowNodeInfo& fwdInfo, const PLockZ& lockZ)  = 0;
	public: virtual void beginForwardWorkflowNode(const PClientInfo& ci, int32_t flowId, int32_t nodeId, const PBeginForwardWorkflowNodeInfo& fwdInfo, const PLockZ& lockZ, ::std::function< void (PWFEditNode, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Forward a workflow node, terminate a workflow or modify node data.
	/// </summary>
	/// <remarks>
	/// <h2>Example 1: Forward a workflow node:</h2>
	/// <p>
	/// <pre><code>
	/// // Lock workflow and read node data
	/// WFEditNode editNode = conn.ix().beginForwardWorkflowNode(flowId, nodeId, null, LockC.IF_FREE);
	/// // Select successor nodes to be activated
	/// // Make sure to select only one successor if: (editNode.getNode().getFlags() & WFNodeC.FLAG_ONE_SUCCESSOR) != 0
	/// List<Integer> succNodes = Arrays.asList(editNode.getSuccNodes()[0].getId());
	/// // Optionally: change node name and comment
	/// WFNode activeNode = editNode.getNode();
	/// activeNode.setName("new name");
	/// activeNode.setComment("new comment");
	/// // Forward
	/// ForwardWorkflowNodeInfo fwdInfo = new ForwardWorkflowNodeInfo();
	/// fwdInfo.setNode(activeNode);
	/// fwdInfo.setSuccessorNodesToActivate(succNodes);
	/// connU.ix().forwardWorkflowNode(flowId, nodeId, fwdInfo, LockC.YES);
	/// </code></pre>
	/// </p>
	/// <h2>Example 2: Cancel forwarding after beginForwardWorkflowNode has locked the workflow</h2>
	/// <p>
	/// <pre><code>
	/// // Lock workflow and read node data
	/// WFEditNode editNode = conn.ix().beginForwardWorkflowNode(flowId, nodeId, null, LockC.IF_FREE);
	/// // Cancel forward
	/// ForwardWorkflowNodeInfo fwdInfo = null;
	/// connU.ix().forwardWorkflowNode(flowId, nodeId, fwdInfo, LockC.YES);
	/// </code></pre>
	/// </p>
	/// <h2>Example 3: Change node priority, name and comment</h2>
	/// <p>
	/// <pre><code>
	/// </p>
	/// // Lock workflow
	/// WFEditNode editNode = conn.ix().beginForwardWorkflowNode(flowId, nodeId, null, LockC.IF_FREE);
	/// // Change node priority, name and comment
	/// WFNode activeNode = editNode.getNode();
	/// activeNode.setPrio(UserTaskPriorityC.HIGHEST);
	/// activeNode.setName("new name");
	/// activeNode.setComment("new comment");
	/// // Update node and unlock
	/// ForwardWorkflowNodeInfo fwdInfo = new ForwardWorkflowNodeInfo();
	/// fwdInfo.setNode(activeNode);
	/// connU.ix().forwardWorkflowNode(flowId, nodeId, fwdInfo, LockC.YES);
	/// </code></pre>
	/// </p>
	/// </remarks>
	public: virtual PForwardWorkflowNodeResult forwardWorkflowNode(const PClientInfo& ci, int32_t flowId, int32_t nodeId, const PForwardWorkflowNodeInfo& fwdInfo, const PLockZ& unlockZ)  = 0;
	public: virtual void forwardWorkflowNode(const PClientInfo& ci, int32_t flowId, int32_t nodeId, const PForwardWorkflowNodeInfo& fwdInfo, const PLockZ& unlockZ, ::std::function< void (PForwardWorkflowNodeResult, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Find user data.
	/// </summary>
	/// <remarks>
	/// This function allows to find users by their name, description, or one of their properties.
	/// Wildcards can be used as defined in the session options, see {@link SessionOptionsC#DB_WILDCARDS}.
	/// <p>
	/// Example:
	/// <pre><code class="example">
	/// FindUserInfo findUserInfo = new FindUserInfo();
	/// findUserInfo.setName("testFind?sers-*");
	/// int idx = 0, max = 100;
	/// FindResult fr = conn.ix().findFirstUsers(findUserInfo, max);
	/// try {
	/// while (true) {
	/// for (UserName userName : fr.getUserNames().values()) {
	/// // process userName object
	/// }
	/// 
	/// if (!fr.isMoreResults()) break;
	/// 
	/// idx += fr.getUserNames().length;
	/// fr = conn.ix().findNextUsers(fr.getSearchId(), idx, max);
	/// }
	/// }
	/// catch (RemoteException e) {
	/// // process exception
	/// throw e;
	/// }
	/// finally {
	/// conn.ix().findClose(fr.getSearchId());
	/// }
	/// </code></pre>
	/// </p>
	/// </remarks>
	public: virtual PFindResult findFirstUsers(const PClientInfo& ci, const PFindUserInfo& findUserInfo, int32_t max)  = 0;
	public: virtual void findFirstUsers(const PClientInfo& ci, const PFindUserInfo& findUserInfo, int32_t max, ::std::function< void (PFindResult, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Find next user data.
	/// </summary>
	public: virtual PFindResult findNextUsers(const PClientInfo& ci, const ::std::wstring& searchId, int32_t idx, int32_t max)  = 0;
	public: virtual void findNextUsers(const PClientInfo& ci, const ::std::wstring& searchId, int32_t idx, int32_t max, ::std::function< void (PFindResult, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Check licensing information.
	/// </summary>
	/// <remarks>
	/// This function checks the given license information using proprietary algorithms.
	/// </remarks>
	public: virtual PLicenseResult checkLicense(const PClientInfo& ci, const PLicenseInfo& licenseInfo)  = 0;
	public: virtual void checkLicense(const PClientInfo& ci, const PLicenseInfo& licenseInfo, ::std::function< void (PLicenseResult, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Move documents from one storage path to another storage path.
	/// </summary>
	public: virtual PJobState moveDocuments(const PClientInfo& ci, const PMoveDocumentsInfo& moveDocumentsInfo)  = 0;
	public: virtual void moveDocuments(const PClientInfo& ci, const PMoveDocumentsInfo& moveDocumentsInfo, ::std::function< void (PJobState, BException ex) > asyncResult)  = 0;
	
	
};

}}}}

//-------------------------------------------------
// IXServicePortIFAuth

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

/// <summary>
/// IndexServer Interface.
/// </summary>
/// <remarks>
/// <p>Hint: This documentation is automatically generated from the server side
/// source files of IndexServer. Many of the functions are not available on the
/// client side. The only functions you can call are the members of
/// <code>IXServicePortIF</code>. All other classes are simple data structures
/// without functions - although the functions are documented here.</p>
/// 
/// <p>This interface contains all methods IndexServer provides for accessing
/// an ELO archive. Since IndexServer runs (usually) as a SOAP-WEB-Service you can
/// access it from all common programming languages and development environments.
/// The examples are written in C#, because the majority of client programs will
/// be written in C# or Java, which is very similar to C#. Find a complete
/// C# example project via the link below.</p>
/// 
/// <p>For performance reason, uploading and downloading of document files are
/// not implemented by SOAP calls. The transport of document files run over
/// HTTP with a separate connection to IndexServer. It is also possible to access
/// the ELO Document Manager directly to improve performance. But be aware of the
/// fact that ELO Document Manager does not make any access checking and this might
/// be a security whole in your environment.</p>
/// 
/// <p>To help C# and Java programmers in writing IndexServer client applications,
/// there is a client helper class resp. a helper package available, see links below.</p>
/// 
/// <p>Note (1): "object ID" or "entry ID" is a numeric value that uniquely defines
/// an object of indexing information in the archive database. Indexing
/// information objects are represented as objects of class <code>Sord</code>. The
/// member <code>Sord.id</code> contains the object ID. Object ID parameters are
/// often named "objId", "parentId". </p>
/// <p>Note (2): "document ID" or "attachment ID" is a numeric value that uniquely
/// defines a document resp. attachment file version in the archive database.
/// Document versions are represented as objects of class <code>DocHistory</code>.
/// The member <code>DocHistory.docId</code> contains the document ID. Document ID
/// parameters are often named "docId", "attId". </p>
/// <p>Note (3): The SOAP transport layer eliminates "\r" in strings. For
/// multi-line input values (e. g. Sord.desc) IX automatically transforms
/// a "\n" into a "\r\n" before storing the string into database.</p>
/// <p>Note (4): IX eliminates leading and trailing blanks from all strings
/// before storing them into database.</p>
/// <p>Copyright: Copyright (c) 2004</p>
/// <p>Organisation: ELO Digital Office GmbH</p>
/// </remarks>
class IXServicePortIFAuth : public virtual BRemote {
	
	/// <summary>
	/// Extends the ticket lifetime.
	/// </summary>
	public: virtual void alive()  = 0;
	public: virtual void alive(::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Locks a person task node of an active workflow inside the database and returns data needed to edit it.
	/// </summary>
	/// <remarks>
	/// If lockZ is not set to <code>LockC.NO</code>, <code>WFNode.inUseDate</code> will be set to now.
	/// </remarks>
	public: virtual PWFEditNode beginEditWorkFlowNode(int32_t nFlowId, int32_t nNodeId, const PLockZ& lockZ)  = 0;
	public: virtual void beginEditWorkFlowNode(int32_t nFlowId, int32_t nNodeId, const PLockZ& lockZ, ::std::function< void (PWFEditNode, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Changes the storage mask of a archive entry.
	/// </summary>
	/// <remarks>
	/// <p>
	/// The function does not update the object in the database.
	/// The method <code>checkinSord</code> must be used to write the changes into the database.
	/// </p><p>
	/// For new Sord objects (Sord.id &lt; 0), ACL items are replaced by the definitions
	/// of the mask. Existing objects keep the previous ACL setting.
	/// </p><p>
	/// ObjKeys with IDs &lt; ID_LINK (=50) are converted into the format of the
	/// new associated DocMaskLine. ObjKeys with IDs &gt;= ID_LINK are not changed.
	/// </p>
	/// </remarks>
	public: virtual PEditInfo changeSordMask(const PSord& sord, const ::std::wstring& maskId, const PEditInfoZ& editInfoZ)  = 0;
	public: virtual void changeSordMask(const PSord& sord, const ::std::wstring& maskId, const PEditInfoZ& editInfoZ, ::std::function< void (PEditInfo, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Check-in the marker definitions (colors for the archive entries).
	/// </summary>
	/// <remarks>
	/// This method
	/// deletes the current markers and inserts the supplied ones in <code>colors</code>.
	/// To insert a new color, set its Id to -1. If the supplied <code>colors</code>
	/// array does not contain a system color (Id == 0), a new system color object is created.
	/// The objects must have unique IDs (or -1) and unique names.
	/// </remarks>
	public: virtual void checkinColors(const PArrayColorData& colors, const PLockZ& unlockZ)  = 0;
	public: virtual void checkinColors(const PArrayColorData& colors, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Uploads configuration files to the configuration directory on the server.
	/// </summary>
	public: virtual void checkinConfigFiles(const PArrayConfigFile& configFiles, const PLockZ& unlockZ)  = 0;
	public: virtual void checkinConfigFiles(const PArrayConfigFile& configFiles, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Prepare ConfigFile objects with URLs to upload configuration or intray files.
	/// </summary>
	/// <remarks>
	/// The <code>names[.]</code> the must contain the destination directory and file name.
	/// <table border="2">
	/// <tr><td>example for file names</td><td>description</td></tr>
	/// <tr><td><code>names[.]=peter/postbox/file1.txt</code></td>
	/// <td>Prepares a <code>ConfigFile</code> object to write file1.txt into peter s server side intray directory</td></tr>
	/// <tr><td><code>configFile[.].dir=eloscripts/file1.txt</code></td>
	/// <td>Prepares a <code>ConfigFile</code> object to write file1.txt into the directory for scripts.</td></tr>
	/// </table>
	/// <pre><code>
	/// //Example for uploading a file into the server side intray of a user.<br/>
	/// String userName = ...;
	/// File file = ...;
	/// String destFile = userName + "/" + CONST.CONFIG_FILE.POSTBOX + "/" + file.getName();<br/>
	/// ConfigFile[] configFiles = ix.ix.checkinConfigFilesBegin(ci, new String[] {destFile});<br/>
	/// configFiles[0].uploadResult = ix.upload(configFiles[0].url, file);<br/>
	/// configFiles = ix.ix.checkinConfigFilesEnd(ci, configFiles);<br/>
	/// </code></pre>
	/// </p>
	/// </remarks>
	public: virtual PArrayConfigFile checkinConfigFilesBegin(const PArrayString& names)  = 0;
	public: virtual void checkinConfigFilesBegin(const PArrayString& names, ::std::function< void (PArrayConfigFile, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Finishes a check-in procedure for configuration files.
	/// </summary>
	/// <remarks>
	/// <p>For files that have been uploaded into the in-tray folder of other users,
	/// no <code>ConfigFile</code> object can be returned, because the in-tray folders
	/// of other users are not readable. </p>
	/// </remarks>
	public: virtual PArrayConfigFile checkinConfigFilesEnd(const PArrayConfigFile& configFiles, const PLockZ& unlockZ)  = 0;
	public: virtual void checkinConfigFilesEnd(const PArrayConfigFile& configFiles, const PLockZ& unlockZ, ::std::function< void (PArrayConfigFile, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Update counter values or create new counters.
	/// </summary>
	public: virtual void checkinCounters(const PArrayCounterInfo& counterInfos, const PLockZ& unlockZ)  = 0;
	public: virtual void checkinCounters(const PArrayCounterInfo& counterInfos, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Prepares the IndexServer to enable a document to be checked in.
	/// </summary>
	/// <remarks>
	/// <p>
	/// The check in procedure consists of three steps. First a call to <code>checkinDocBegin</code>
	/// prepares the IndexServer to upload a document. The function returns among
	/// other things the URL to which the document must be up loaded. In the second
	/// step the document is uploaded to this URL. The final step is to call <code>checkinDocEnd</code>
	/// with the result of the upload process. The upload result is interpreted by
	/// the IndexServer and the document is inserted into the database.
	/// </p><p>
	/// The upload URL accesses the ELODM (document manager service)
	/// directly due to performance reasons . The URL is valid as long as the session ticket is valid.
	/// </p><p>
	/// It is possible to insert more than one document or attachment versions and a signature file.
	/// </p><p>
	/// The parameter <code>document</code> of <code>checkinDocBegin</code> must contain
	/// a minimum of one version in <code>document.docs</code>, <code>document.atts</code> or
	/// <code>document.sig</code>. The minimum that must be set in the version object is the member <code>DocVersion.ext</code>.
	/// </p><p>
	/// <b>Examples</b>
	/// </p><p>
	/// <b>1. New document</b><br/>
	/// <code>IXServicePortIF db = ... </code><br/>
	/// <code>ClientInfo ci = ... </code><br/>
	/// <code>EditInfo ed = db.createDoc(ci, "1", null, null, EditInfoC.mbSordDocAtt);</code><br/>
	/// <code>ed.sord.short="new document";</code><br/>
	/// <code>ed.document.docs = new DocVersion[1];</code><br/>
	/// <code>ed.document.docs[0] = new DocVersion();</code><br/>
	/// <code>ed.document.docs[0].ext = "TIF";</code><br/>
	/// <code>ed.document.docs[0].pathId = ed.sord.path;</code><br/>
	/// <code>ed.document.docs[0].encryptionSet = ed.sord.details.encryptionSet;</code><br/>
	/// <code>ed.document = db.checkinDocBegin(ci, ed.document);</code><br/>
	/// <code>ed.document.docs[0].uploadResult = ...upload(ed.document.docs[0].url, file);</code><br/>
	/// <code>ed.document = db.checkinDocEnd(ci, ed.sord, SORD.mbAll, ed.document, LockC.NO);</code><br/>
	/// </p><p>
	/// <b>2. New document (file) version</b><br/>
	/// <code>IXServicePortIF db = ... </code><br/>
	/// <code>ClientInfo ci = ... </code><br/>
	/// <code>EditInfo ed = db.checkoutDoc(ci, "[object-ID]", null, EditInfoC.mbSordDocAtt, LockC.IF_FREE);</code><br/>
	/// <code>Document doc = new Document()</code><br/>
	/// <code>doc.docs = new DocVersion[1];</code><br/>
	/// <code>doc.docs[0] = new DocVersion();</code><br/>
	/// <code>doc.docs[0].ext = "TIF";</code><br/>
	/// <code>doc.docs[0].pathId = ed.sord.path;</code><br/>
	/// <code>doc.objId = 1234;</code><br/>
	/// <code>doc = db.checkinDocBegin(ci, doc);</code><br/>
	/// <code>doc.docs[0].uploadResult = ...upload(doc.docs[0].url, file);</code><br/>
	/// <code>doc = db.checkinDocEnd(ci, null, null, doc, LockC.YES);</code><br/>
	/// </p>
	/// </remarks>
	public: virtual PDocument checkinDocBegin(const PDocument& document)  = 0;
	public: virtual void checkinDocBegin(const PDocument& document, ::std::function< void (PDocument, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Checks-in already existing documents again.
	/// </summary>
	/// <remarks>
	/// <p>This method is used to reduce transmission
	/// time as the document does not have to be checked-out.</p>
	/// </remarks>
	public: virtual PDocument checkinDocDupl(const PSord& sord, const PSordZ& sordZ, const PDocument& document, const PLockZ& unlockZ)  = 0;
	public: virtual void checkinDocDupl(const PSord& sord, const PSordZ& sordZ, const PDocument& document, const PLockZ& unlockZ, ::std::function< void (PDocument, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Checks in an uploaded document.
	/// </summary>
	/// <remarks>
	/// <p>
	/// See <code>checkinDocBegin</code>, if you want to checkin new document or attachment version(s).
	/// </p>
	/// <p>
	/// Changing the document or attachment work version, version number, comment, flags or status:
	/// <code><br/><br/>
	/// Document doc = new Document();<br/>
	/// doc.objId = an object ID or GUID<br/>
	/// doc.docs = new DocVersion[] {new DocVersion()};<br/>
	/// doc.docs[0].id = a document ID;<br/>
	/// doc.docs[0].workVersion = true;<br/>
	/// doc.docs[0].version = "2.0";<br/>
	/// doc.docs[0].comment = "new comment";<br/>
	/// doc.docs[0].milestone = true;<br/>
	/// doc.docs[0].deleted = false;<br/>
	/// ix.checkinDocEnd(ci, null, null, doc, LOCK.NO);<br/>
	/// </code>
	/// </p>
	/// <p>
	/// If the supplied sord has <code>sord.type==LBT_DOCUMENT</code>, sord.type will be detected from
	/// the file extension of the given work version.
	/// </p>
	/// <p>
	/// If the document is only to be unlocked, see <code>checkinSord</code>.
	/// </p>
	/// </remarks>
	public: virtual PDocument checkinDocEnd(const PSord& sord, const PSordZ& sordZ, const PDocument& document, const PLockZ& unlockZ)  = 0;
	public: virtual void checkinDocEnd(const PSord& sord, const PSordZ& sordZ, const PDocument& document, const PLockZ& unlockZ, ::std::function< void (PDocument, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Writes a keywording form into the database.
	/// </summary>
	/// <remarks>
	/// A new mask is inserted when <code>docMask.no</code> is less than 0.
	/// <p>
	/// If an existing keywording form is written with modified group names (DocMaskLine.key), a
	/// background thread is started to update the existing index values (Sord.objKeys[.].name).
	/// Use collectJobState to watch the state of the background job. Its name is
	/// &quot;Update existing index values for keywording form=...&quot;
	/// </p>
	/// </remarks>
	public: virtual int32_t checkinDocMask(const PDocMask& docMask, const PDocMaskZ& docMaskZ, const PLockZ& unlockZ)  = 0;
	public: virtual void checkinDocMask(const PDocMask& docMask, const PDocMaskZ& docMaskZ, const PLockZ& unlockZ, ::std::function< void (int32_t, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// This method prepares the Index Server to allow multiple documents to be checked in at one time.
	/// </summary>
	/// <remarks>
	/// Utilized in the
	/// same manner as <code>checkinDocBegin</code> but is for multiple documents.
	/// </remarks>
	public: virtual PArrayDocument checkinDocsBegin(const PArrayDocument& documents)  = 0;
	public: virtual void checkinDocsBegin(const PArrayDocument& documents, ::std::function< void (PArrayDocument, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// This method checks-in uploaded documents.
	/// </summary>
	/// <remarks>
	/// Utilized in the same manner as <code>checkinDocEnd</code>
	/// but for multiple documents and sords.
	/// </remarks>
	public: virtual PArrayDocument checkinDocsEnd(const PArraySord& sords, const PArraySordZ& sordZs, const PArrayDocument& documents, const PLockZ& unlockZ)  = 0;
	public: virtual void checkinDocsEnd(const PArraySord& sords, const PArraySordZ& sordZs, const PArrayDocument& documents, const PLockZ& unlockZ, ::std::function< void (PArrayDocument, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Writes or inserts key objects.
	/// </summary>
	/// <remarks>
	/// <p>
	/// If key data is only to be unlocked then the method should be called with
	/// <code>keyInfos=null</code> and <code>lockZ=lockZ.YES</code>.
	/// </p><p>
	/// The key objects with <code>KeyInfo[].id=-1</code> will be inserted in the database. Objects
	/// with <code>KeyInfo[].id>=0</code> will be updated.
	/// </p><p>
	/// Since the function requires an exclusive access to the user data, the data
	/// must be locked for the current user or must not be locked for anyone. To
	/// check in regardless of a lock supply <code>lockZ.FORCE</code>
	/// in <code>lockZ</code>.
	/// </remarks>
	public: virtual PArrayInt checkinKeys(const PArrayKeyInfo& keyInfos, const PLockZ& unlockZ)  = 0;
	public: virtual void checkinKeys(const PArrayKeyInfo& keyInfos, const PLockZ& unlockZ, ::std::function< void (PArrayInt, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Insert keywords and all their children.
	/// </summary>
	/// <remarks>
	/// The keyword IDs specify whether to insert or update.
	/// <p>
	/// <table border="2">
	/// <tr><td><code>kws[.].id={existing ID}</code></td>
	/// <td>
	/// Updates the keyword tree branch below the keyword with <code>kws[.].id</code>.
	/// The keyword must exist.
	/// </td></tr>
	/// <tr><td><code>kws[.].id={new root ID}</code></td>
	/// <td>Inserts or updates a new keyword list.</td></tr>
	/// </table>
	/// </p><p>
	/// <table border="2">
	/// <tr><th>Operations</th><th>Solution</td>
	/// <tr>
	/// <td>Insert a new child into an existing parent keyword</td>
	/// <td>Check-in the parent keyword with all current children plus the new child.
	/// Setting the text members and children arrays of the current children to <code>null</code> leaves them unchanged.
	/// </td>
	/// </tr>
	/// <tr>
	/// <td>Delete a child of an existing parent keyword</td>
	/// <td>Check-in the parent keyword with all current children minus the child to be deleted.
	/// Setting the text members and children arrays of the current children to <code>null</code> leaves them unchanged.
	/// </td>
	/// </tr>
	/// <tr>
	/// <td>Update <code>text, add, enabled</code> of an existing keyword</td>
	/// <td>Check-in the keyword with a non empty text member. Only when the text is not <code>null</code>
	/// and not an empty string will the members <code>add</code> and <code>enabled</code> be written into the database.
	/// </td>
	/// </tr>
	/// </table>
	/// </p>
	/// <p><b>IMPORTANT: This function assigns new IDs to all branches of the
	/// keyword trees below the parent keywords of the given keywords.
	/// The client program should read the parent keyword and all children below
	/// again to receive the new IDs. </b></p>
	/// <p>The access rights <code>AccessC.FLAG_EDITCONFIG</code> and
	/// <code>AccessC.FLAG_EDITSWL</code> are required to check-in keywords.<p>
	/// </remarks>
	public: virtual void checkinKeywords(const PArrayKeyword& kws, const PLockZ& unlockZ)  = 0;
	public: virtual void checkinKeywords(const PArrayKeyword& kws, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Write or insert Notes.
	/// </summary>
	/// <remarks>
	/// <p>Only Sord objects that reference documents can have notes.
	/// It is also possible to delete a Note: <code>notes[.].setDeleted(true);</code>.</p>
	/// <p> NOTE: When checking changed notes of annotation in stamp type notes or annotations
	/// can only be checked in once. When attempting to check in stamp type notes that already
	/// exist an exception will be returned. Use <code>MbOnlyLock</code> to unlock notes and annotations.</p>
	/// </remarks>
	public: virtual PArrayInt checkinNotes(const ::std::wstring& objId, const PArrayNote& notes, const PNoteZ& noteZ, const PLockZ& unlockZ)  = 0;
	public: virtual void checkinNotes(const ::std::wstring& objId, const PArrayNote& notes, const PNoteZ& noteZ, const PLockZ& unlockZ, ::std::function< void (PArrayInt, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Inserts or updates a Notification object
	/// 
	/// if userGuid is null, the own Guid will be taken
	/// if userGuid is not the own Guid, admin rights are needed
	/// </summary>
	public: virtual PNotification checkinNotification(const PNotification& notif, const PNotificationZ& notiZ)  = 0;
	public: virtual void checkinNotification(const PNotification& notif, const PNotificationZ& notiZ, ::std::function< void (PNotification, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Inserts or updates a reminder object.
	/// </summary>
	/// <remarks>
	/// <p><code>Reminder.receiverId = -1</code> should be set if receiverId is to be ignored.
	/// <code>Reminder.receiverName = null</code> should be set if the receiverName is to be ignored.</p>
	/// </remarks>
	public: virtual PArrayInt checkinReminder(const PReminder& remi, const PArrayString& receiverIds, bool expandGroups, const PLockZ& unlockZ)  = 0;
	public: virtual void checkinReminder(const PReminder& remi, const PArrayString& receiverIds, bool expandGroups, const PLockZ& unlockZ, ::std::function< void (PArrayInt, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Writes replication set names.
	/// </summary>
	public: virtual void checkinReplNames(const PArrayReplSetName& replNames, const PLockZ& unlockZ)  = 0;
	public: virtual void checkinReplNames(const PArrayReplSetName& replNames, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Writes the report options.
	/// </summary>
	public: virtual void checkinReportOptions(const PReportOptions& options, const PLockZ& unlockZ)  = 0;
	public: virtual void checkinReportOptions(const PReportOptions& options, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Writes or inserts a archive entry into the database.
	/// </summary>
	/// <remarks>
	/// <p>
	/// A new object does not have to be created with <code>createSord</code>. If the
	/// object is missing a GUID then a new one is created.
	/// </p>
	/// <p>
	/// If the Sord object is only to be unlocked <code>sordZ = SordC.mbOnlyUnlock</code> should be used
	/// and a minimum of <code>Sord.id</code> or <code>Sord.guid</code> must be set.
	/// </p>
	/// </remarks>
	public: virtual int32_t checkinSord(const PSord& sord, const PSordZ& sordZ, const PLockZ& unlockZ)  = 0;
	public: virtual void checkinSord(const PSord& sord, const PSordZ& sordZ, const PLockZ& unlockZ, ::std::function< void (int32_t, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Checks the existence of an archive path and creates missing entries if necessary by
	/// traversing top-down through the Sords array.
	/// </summary>
	/// <remarks>
	/// <p>The folders are inserted inside the same database transaction. Thus either all folders
	/// are created or none.</p>
	/// <p>This function allows only one process at a given time to create a structure. This prevents
	/// from creating the same archive path twice by two parallel working processes.</p>
	/// <p>In order to write index values (Sord.objKeys), parameter sordZ has to contain SordC.mbObjKeys.
	/// If sord.objKeys == null or sordZ does not contain SordC.mbObjKeys, the index values defaults
	/// defined by the keywording form are written.
	/// </p>
	/// </remarks>
	public: virtual PArrayInt checkinSordPath(const ::std::wstring& parentId, const PArraySord& sords, const PSordZ& sordZ)  = 0;
	public: virtual void checkinSordPath(const ::std::wstring& parentId, const PArraySord& sords, const PSordZ& sordZ, ::std::function< void (PArrayInt, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Write or insert sord type information.
	/// </summary>
	public: virtual void checkinSordTypes(const PArraySordType& sordTypes, const PLockZ& unlockZ)  = 0;
	public: virtual void checkinSordTypes(const PArraySordType& sordTypes, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// This method passes path information to the document manager.
	/// </summary>
	public: virtual PArrayStoreInfo checkinStorage(const PArrayStoreInfo& storeInfos, const PLockZ& unlockZ)  = 0;
	public: virtual void checkinStorage(const PArrayStoreInfo& storeInfos, const PLockZ& unlockZ, ::std::function< void (PArrayStoreInfo, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Insert deputy/substitute information.
	/// </summary>
	public: virtual void checkinSubs(const PArraySubsInfo& deps, const PLockZ& unlockZ)  = 0;
	public: virtual void checkinSubs(const PArraySubsInfo& deps, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Write (add) user profile options.
	/// </summary>
	public: virtual void checkinUserProfile(const PUserProfile& userProfile, const PLockZ& unlockZ)  = 0;
	public: virtual void checkinUserProfile(const PUserProfile& userProfile, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Writes or inserts users or groups.
	/// </summary>
	/// <remarks>
	/// <p>
	/// When inserting users or groups either <code>UserInfo.id=-1</code> should be
	/// set or the bit <code>CheckinUsersC.NEW_USER</code> in
	/// <code>checkinUsersC</code> should be used.
	/// The second case allows a complete user and group structure to be checked in with
	/// a single call of <code>checkinUsers</code>. Therefore the IDs in the submitted
	/// <code>UserInfo</code> objects must be unique and cannot be used by other users or groups in
	/// the archive database.
	/// </p><p>
	/// If only the user data is to be unlocked then the method should be called with
	/// <code>userInfos=null</code> and <code>lockZ=lockZ.YES</code>.
	/// </p><p>
	/// If the user of the current session is a sub-administrator (has right AccessC.FLAG_SUBADMIN)
	/// the <code>UserInfo.parent</code> members of the users in <code>userInfos</code>
	/// are internally set to the current users ID. In other words: sub-administrators
	/// are not free to define the parent of the users or groups.
	/// </p><p>
	/// The method checks whether the users or groups to be checked-in have
	/// more rights than their parents (administrators).
	/// </p><p>
	/// Since the function requires an exclusive access to the user data, the data
	/// must be locked for the current user or must not be locked for anyone. To
	/// check in regardless of a lock  <code>lockZ.FORCE</code> must be supplied
	/// in <code>lockZ</code>.
	/// </p><p>
	/// The users password is only written for new users or if
	/// <code>CheckinUsersC.PASSWORD</code> for the parameter <code>checkinUsersZ</code>
	/// is supplied along with the password member <code>UserInfo.pwd!=null</code>.
	/// In this case, the userInfos array must be of length=1. The user does not
	/// need to have the right AccessC.FLAG_SUBADMIN, but must have the right AccessC.FLAG_CHANGEPW.
	/// Only the members UserInfo.id and UserInfo.pwd are taken into account. This is how to
	/// change a password:
	/// <code>UserInfo ui = new UserInfo();</code><br/>
	/// <code>ui.id = current user id;</code><br/>
	/// <code>ui.pwd = new password;</code><br/>
	/// <code>ix.checkinUsers(ci, new UserInfo[] {ui}, CheckinUsersC.PASSWORD, LockC.NO);</code>
	/// </p><p>
	/// Password rules are checked, if the user changes the password or if a new user is stored.
	/// The password rules are defined in the user profile value at key UserProfileC.KEY_PASSWORD_RULES.
	/// If the password violates the password rules, an exception is throw with message "[ELOIX:3007]...".
	/// The error number (3007) is defined in IXExceptionC.PASSWORD_DENIED.
	/// </p><p>
	/// The password expiring date is handled. If the password is changed, the expiring date in the
	/// user data is updated: UserInfo.userProps[UserInfoC.PROP_ACTION] = "EX{iso-date-without-time}".
	/// Interactive client applications should check the action field in order display a dialog, if the
	/// password has to be changed. They do not need to check the "EX<iso-date>", because it is replaced
	/// by "PWf" (must change password) for the UserInfo object in the LoginResult object return by the
	/// login() functions, resp. the create() functions of IXConnFactory.
	/// The following code is recommended:
	/// <code>IXConnection conn = ...</code><br/>
	/// <code>String action = conn.getLoginResult().getUser().userProps[UserInfoC.PROP_ACTION];</code><br/>
	/// <code>boolean userShouldChangePassword = action.indexOf(UserInfoC.PROP_ACTION_USER_SHOULD_CHANGE_PASSWORD) >= 0;</code><br/>
	/// <code>boolean userMustChangePassword = action.indexOf(UserInfoC.PROP_ACTION_USER_MUST_CHANGE_PASSWORD) >= 0;</code>
	/// </p>
	/// </remarks>
	public: virtual PArrayInt checkinUsers(const PArrayUserInfo& userInfos, const PCheckinUsersZ& checkinUsersZ, const PLockZ& unlockZ)  = 0;
	public: virtual void checkinUsers(const PArrayUserInfo& userInfos, const PCheckinUsersZ& checkinUsersZ, const PLockZ& unlockZ, ::std::function< void (PArrayInt, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Inserts or updates organizational units.
	/// </summary>
	/// <remarks>
	/// <p>
	/// When inserting a new OU, <code>OrgUnitInfo.id=-1</code> has to be set.
	/// More than one OU can be checked in with a single call of
	/// <code>checkinOrgUnit</code>. Therefore the names, IDs and GUIDs in the
	/// submitted <code>OrgUnitInfo</code> objects must be unique and cannot be
	/// used by other OUs in the archive database.
	/// </p><p>
	/// If only the user and OU data is to be unlocked then the method should be
	/// called with <code>orgUnitInfos=null</code> and <code>lockZ=lockZ.YES</code>.
	/// </p>
	/// </remarks>
	public: virtual PMapIntegerOrgUnitInfo checkinOrgUnits(const PArrayOrgUnitInfo& orgUnitInfos, const PCheckinOrgUnitInfo& reserved, const PLockZ& unlockZ)  = 0;
	public: virtual void checkinOrgUnits(const PArrayOrgUnitInfo& orgUnitInfos, const PCheckinOrgUnitInfo& reserved, const PLockZ& unlockZ, ::std::function< void (PMapIntegerOrgUnitInfo, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Delete OUs.
	/// </summary>
	public: virtual void deleteOrgUnits(const PArrayString& ids, const PLockZ& unlockZ)  = 0;
	public: virtual void deleteOrgUnits(const PArrayString& ids, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Read the data of all OUs.
	/// </summary>
	public: virtual PMapIntegerOrgUnitInfo checkoutOrgUnits(const PCheckoutOrgUnitInfo& reserved, const PLockZ& lockZ)  = 0;
	public: virtual void checkoutOrgUnits(const PCheckoutOrgUnitInfo& reserved, const PLockZ& lockZ, ::std::function< void (PMapIntegerOrgUnitInfo, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Write/create a workflow.
	/// </summary>
	/// <remarks>
	/// <p>In case of a new workflow object of type WFTypeC.ACTIVE, the workflow is
	/// immediately started after written into database. This requires a valid WFDiagram.getObjId().</p>
	/// </remarks>
	public: virtual int32_t checkinWorkFlow(const PWFDiagram& wf, const PWFDiagramZ& workFlowDiagramZ, const PLockZ& unlockZ)  = 0;
	public: virtual void checkinWorkFlow(const PWFDiagram& wf, const PWFDiagramZ& workFlowDiagramZ, const PLockZ& unlockZ, ::std::function< void (int32_t, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Checkout the markers definitions (colors of archive entries).
	/// </summary>
	public: virtual PArrayColorData checkoutColors(const PLockZ& lockZ)  = 0;
	public: virtual void checkoutColors(const PLockZ& lockZ, ::std::function< void (PArrayColorData, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Read config file names and file data.
	/// </summary>
	/// <remarks>
	/// <p>
	/// The <code>names</code> parameter selects the config files. Each element in
	/// this array contains the virtual path to a file. A path private to a user starts
	/// with the user s name. Paths may contain the wildcard <code>*</code> instead
	/// of a file name. In this case all files in the directory are returned.
	/// </p><p>
	/// <table border="2">
	/// <tr><td>Example</td><td>Description</td></tr>
	/// <tr><td><code>name[.]=peter/template/*</code></td>
	/// <td>Selects all private document templates of user peter (document templates are currently not supported!)</td></tr>
	/// <tr><td><code>name[.]=peter/postbox/*</code></td>
	/// <td>Selects peters server side postbox files</td></tr>
	/// <tr><td><code>name[.]=template/*</code></td>
	/// <td>Selects all document templates available for all users (document templates are currently not supported!)</td></tr>
	/// <tr><td><code>name[.]=eloscripts/*</code></td>
	/// <td>Selects all scripts</td></tr>
	/// </table>
	/// </p>
	/// </remarks>
	public: virtual PArrayConfigFile checkoutConfigFiles(const PArrayString& names, const PConfigFileZ& configFileZ, const PLockZ& lockZ)  = 0;
	public: virtual void checkoutConfigFiles(const PArrayString& names, const PConfigFileZ& configFileZ, const PLockZ& lockZ, ::std::function< void (PArrayConfigFile, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Get counter information.
	/// </summary>
	public: virtual PArrayCounterInfo checkoutCounters(const PArrayString& counterNames, bool incrementCounters, const PLockZ& lockZ)  = 0;
	public: virtual void checkoutCounters(const PArrayString& counterNames, bool incrementCounters, const PLockZ& lockZ, ::std::function< void (PArrayCounterInfo, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Reads the indexing information and the download URL of a document.
	/// </summary>
	/// <remarks>
	/// </p><p>
	/// At least one of the parameters <code>objId</code> and <code>docId</code> must
	/// be supplied.
	/// If only <code>objId</code> is supplied, the function reads the information
	/// for the current work version of the document. If <code>docId</code> is supplied,
	/// the function reads the information for a specific document or attachment version.
	/// All versions are returned if <code>docId="-1"</code> is supplied.
	/// </p><p>
	/// The document member of the returned object contains the URL from where the
	/// document file can be read. Use raw HTTP functions to download the file.
	/// </p>
	/// <p>
	/// If the document is only to be unlocked, see <code>checkinSord</code>.
	/// </p>
	/// </remarks>
	public: virtual PEditInfo checkoutDoc(const ::std::wstring& objId, const ::std::wstring& docId, const PEditInfoZ& editInfoZ, const PLockZ& lockZ)  = 0;
	public: virtual void checkoutDoc(const ::std::wstring& objId, const ::std::wstring& docId, const PEditInfoZ& editInfoZ, const PLockZ& lockZ, ::std::function< void (PEditInfo, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Reads a storage mask from the database.
	/// </summary>
	public: virtual PDocMask checkoutDocMask(const ::std::wstring& maskId, const PDocMaskZ& docMaskZ, const PLockZ& lockZ)  = 0;
	public: virtual void checkoutDocMask(const ::std::wstring& maskId, const PDocMaskZ& docMaskZ, const PLockZ& lockZ, ::std::function< void (PDocMask, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Reads a list of key objects.
	/// </summary>
	public: virtual PArrayKeyInfo checkoutKeys(const PArrayString& ids, const PLockZ& lockZ)  = 0;
	public: virtual void checkoutKeys(const PArrayString& ids, const PLockZ& lockZ, ::std::function< void (PArrayKeyInfo, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Collects keywords and their children.
	/// </summary>
	/// <remarks>
	/// <p>The keyword objects with the given <code>kwids[.]</code> will be read.
	/// <table border="2">
	/// <tr><td rowspan=4><code>kwids[.]=</code></td><td><code>KeywordC.KWID_*</code>,</td></tr>
	/// <tr><td>an index row name,</td></tr>
	/// <tr><td>an ID of a previously read keyword.</td></tr>
	/// <tr><td>null, to read all toplevel keyword lists. Parameter <code>max</code> is ignored.</td></tr>
	/// </table>
	/// </p>
	/// <p>The parameter <code>max</code> controls how many keywords will be read.
	/// <table border="2">
	/// <tr><td>max = 0</td><td>Only the first level directly below the given
	/// <code>kwids[.]</code> is read (up to 676 keywords). The children of the
	/// returned keywords are <code>null</code></td></tr>
	/// <tr><td><code>max</code> = -1</td><td>Entire tree below <code>kwid</code> is read.</td></tr>
	/// <tr><td><code>max</code> &gt; 0</td><td>Approximately up to this number of keywords are read.
	/// The children of a keyword are always read completely or they are <code>null</code>.
	/// Thus up to <code>max</code>+675 keywords could be returned.</td></tr>
	/// </table>
	/// </p>
	/// <p>
	/// Hint: if <code>max</code> &gt;= 0 and the <code>Keyword.children</code>
	/// of a keyword is an empty array (not <code>null</code>), the keyword has definitely no children.
	/// If <code>Keyword.children = null</code>, query the children with a further
	/// call to <code>collectKeywords</code>.
	/// </p>
	/// <p>
	/// Before one of the returned keywords can be used as an index value the
	/// members <code>Keyword.enabled</code> and <code>Keyword.raw</code> must be
	/// analyzed, see <code>Keyword</code> documentation.</p>
	/// <p>You need the access right <code>AccessC.FLAG_EDITCONFIG</code> to lock keywords against concurrent modification.<p>
	/// </remarks>
	public: virtual PArrayKeyword checkoutKeywords(const PArrayString& kwids, const PKeywordZ& keywordZ, int32_t max, const PLockZ& lockZ)  = 0;
	public: virtual void checkoutKeywords(const PArrayString& kwids, const PKeywordZ& keywordZ, int32_t max, const PLockZ& lockZ, ::std::function< void (PArrayKeyword, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Read notes of a given Sord.
	/// </summary>
	public: virtual PArrayNote checkoutNotes(const ::std::wstring& objId, const PArrayString& noteIds, const PNoteZ& noteZ, const PLockZ& lockZ)  = 0;
	public: virtual void checkoutNotes(const ::std::wstring& objId, const PArrayString& noteIds, const PNoteZ& noteZ, const PLockZ& lockZ, ::std::function< void (PArrayNote, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Reads Notification for a watchGuid / userGuid combination
	/// 
	/// if userGuid is null, the own Guid will be taken
	/// if userGuid is not the own Guid, admin rights are needed
	/// </summary>
	public: virtual PNotification checkoutNotification(const ::std::wstring& watchGuid, const ::std::wstring& userGuid)  = 0;
	public: virtual void checkoutNotification(const ::std::wstring& watchGuid, const ::std::wstring& userGuid, ::std::function< void (PNotification, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Reads and locks a reminder object.
	/// </summary>
	public: virtual PArrayReminder checkoutReminders(const PArrayInt& reminderIds, const PLockZ& lockZ)  = 0;
	public: virtual void checkoutReminders(const PArrayInt& reminderIds, const PLockZ& lockZ, ::std::function< void (PArrayReminder, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Reads replication set names.
	/// </summary>
	public: virtual PArrayReplSetName checkoutReplNames(const PLockZ& lockZ)  = 0;
	public: virtual void checkoutReplNames(const PLockZ& lockZ, ::std::function< void (PArrayReplSetName, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Reads the report options.
	/// </summary>
	public: virtual PReportOptions checkoutReportOptions(const PLockZ& lockZ)  = 0;
	public: virtual void checkoutReportOptions(const PLockZ& lockZ, ::std::function< void (PReportOptions, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Reads the data needed to edit an existing archive entry.
	/// </summary>
	/// <remarks>
	/// <table border="2">
	/// <tr>
	/// <td>Possible object identifiers (parameter objId)</td>
	/// <td>Usage</td>
	/// </tr><tr>
	/// <td>ID</td>
	/// <td>A numeric object number corresponding to Sord.getId() converted to string</td>
	/// </tr><tr>
	/// <td>GUID</td>
	/// <td>A GUID corresponding to Sord.getGuid()</td>
	/// </tr><tr>
	/// <td>Index value</td>
	/// <td>Use "OKEY:&lt;index-group-name&gt;=&lt;index-value&gt;" to select an object by an index value, example: "OKEY:SAPPATH=123124109824123/data".
	/// The wildcards &quot;%&quot; or &quot;*&quot; can be used in &lt;index-group-name&gt; or &lt;index-value&gt; to return all or any data that matches.
	/// </td>
	/// </tr><tr>
	/// <td>Index match value</td>
	/// <td>Use "LMATCH:&lt;index-group-name&gt;=&lt;fix-value&gt;%&lt;match-value&gt;"
	/// to select an object by an index value that starts with &lt;fix-value&gt; and
	/// might be followed by &lt;match-value&gt;. The object that fits most characters
	/// in &lt;match-value&gt; is selected.
	/// Example: "LMATCH:ELOINDEX=S%CH".
	/// The wildcards &quot;%&quot; or &quot;*&quot; can be used in &lt;index-group-name&gt; or &lt;match-value&gt; to return all or any data that matches.
	/// This selection mode only be utilized on non-deleted Sords.
	/// </td>
	/// </tr><tr>
	/// <td>Archive path</td>
	/// <td>Use "ARCPATH:&lt;delim-char&gt;&lt;SordName1&gt;&lt;delim-char&gt;&lt;SordName2&gt;..."
	/// to select an object by an archive path.
	/// This selection mode only be utilized on non-deleted Sords.
	/// </td>
	/// </tr><tr>
	/// <td>Archive path with base ID</td>
	/// <td>Use "ARCPATH[&lt;ID&gt;]:&lt;delim-char&gt;&lt;SordName1&gt;&lt;delim-char&gt;&lt;SordName2&gt;..." to select an object by an archive path</td>
	/// </tr>
	/// </tr><tr>
	/// <td>MD5 hash</td>
	/// <td>Use "MD5:&lt;MD5-hash-hex-string&gt;" to select an object by an MD5 hash. Use upper case letters for hexadecimal characters for the hash value.</td>
	/// </tr>
	/// </table>
	/// <p>
	/// The object can be locked against concurrent modification if <code>lockZ</code>
	/// is set to <code>lockZ.YES</code>.
	/// </remarks>
	public: virtual PEditInfo checkoutSord(const ::std::wstring& objId, const PEditInfoZ& editInfoZ, const PLockZ& lockZ)  = 0;
	public: virtual void checkoutSord(const ::std::wstring& objId, const PEditInfoZ& editInfoZ, const PLockZ& lockZ, ::std::function< void (PEditInfo, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// <code>checkoutSordHistory</code> retrieves all history entries related to a given object.
	/// </summary>
	public: virtual PArraySordHist checkoutSordHistory(const ::std::wstring& objId)  = 0;
	public: virtual void checkoutSordHistory(const ::std::wstring& objId, ::std::function< void (PArraySordHist, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Get sord type information.
	/// </summary>
	/// <remarks>
	/// <p>SordType objects give access to labels,
	/// icons and extensions corresponding to <code>Sord.type.</code></p>
	/// <p>Parameter <code>sordTypes</code> can be:
	/// <table border="2">
	/// <tr><th>sordType</th><th>return</th></tr>
	/// <tr><td>Array of type numbers or names</td><td>Returns for each type number (resp. name) the associated SordType information</td></tr>
	/// <tr><td>null</td><td>Returns SordType information for all types</td></tr>
	/// </table>
	/// </p><p>
	/// Parameter <code>sordTypeZ</code> specifies which members of the returned objects should be filled.
	/// It also contains the content type of the image data to be returned. This content type correspond
	/// to directories named "jpg", "ico" resp. "bmp" below ".../am-eloam/configuration/initdata/images/sordtypes/".
	/// Use ELO CLIENT to fill the directories with images of the required type.
	/// </p>
	/// </remarks>
	public: virtual PArraySordType checkoutSordTypes(const PArrayInt& sordTypeIds, const PSordTypeZ& sordTypeZ, const PLockZ& lockZ)  = 0;
	public: virtual void checkoutSordTypes(const PArrayInt& sordTypeIds, const PSordTypeZ& sordTypeZ, const PLockZ& lockZ, ::std::function< void (PArraySordType, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// checkoutStorage retrieves an array of configured paths from the Document
	/// Manager.
	/// </summary>
	/// <remarks>
	/// The contents matches the table &lt;elodmpath&gt;.
	/// </remarks>
	public: virtual PArrayStoreInfo checkoutStorage(const PArrayString& ids, const PLockZ& lockZ)  = 0;
	public: virtual void checkoutStorage(const PArrayString& ids, const PLockZ& lockZ, ::std::function< void (PArrayStoreInfo, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Read the substitute information for the given user.
	/// </summary>
	/// <remarks>
	/// <p>The returned array
	/// contains the relations/users for which the given user is the substituted person
	/// or the substitute.</p>
	/// </remarks>
	public: virtual PArraySubsInfo checkoutSubs(const ::std::wstring& userId, const PLockZ& lockZ)  = 0;
	public: virtual void checkoutSubs(const ::std::wstring& userId, const PLockZ& lockZ, ::std::function< void (PArraySubsInfo, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Read user profile options.
	/// </summary>
	/// <remarks>
	/// <p>
	/// Set <code>userProfile.userId</code> to the current user, to read her or his entire option set.
	/// This means that the default values for all users and the options inherited from the users groups are included too.
	/// </p>
	/// <p>
	/// In order to read the user specific options without defaults and group options, set <code>userProfile.excludeDefaultValues=true</code>
	/// and <code>userProfile.excludeGroupValues=true</code>.
	/// </p>
	/// </remarks>
	public: virtual PUserProfile checkoutUserProfile(const PUserProfile& userProfile, const PLockZ& lockZ)  = 0;
	public: virtual void checkoutUserProfile(const PUserProfile& userProfile, const PLockZ& lockZ, ::std::function< void (PUserProfile, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Reads the user data for users or groups.
	/// </summary>
	/// <remarks>
	/// <p>
	/// The function has various options for specifying which users are to read, e. g. all users,
	/// users of a specific group or groups of a specific user. The options are controlled
	/// with the bit-mask parameter <code>checkoutUsersC</code>. Possible values are
	/// combinations of <code>CheckoutUsersC</code> values.
	/// </p><p>
	/// Supplying <code>lockZ.YES</code> or <code>lockZ.FORCE</code> for the parameter
	/// <code>lockZ</code> locks the user data against concurrent modification.
	/// The lock can be released with <code>checkinUsers</code> or <code>deleteUsers</code>.
	/// </p><p>
	/// All returned <code>UserInfo</code> objects have empty passwords because the
	/// passwords cannot be read from the archive database.
	/// </p>
	/// </remarks>
	public: virtual PArrayUserInfo checkoutUsers(const PArrayString& ids, const PCheckoutUsersZ& checkoutUsersZ, const PLockZ& lockZ)  = 0;
	public: virtual void checkoutUsers(const PArrayString& ids, const PCheckoutUsersZ& checkoutUsersZ, const PLockZ& lockZ, ::std::function< void (PArrayUserInfo, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Reads a workflow definition.
	/// </summary>
	public: virtual PWFDiagram checkoutWorkFlow(const ::std::wstring& flowId, const PWFTypeZ& typeZ, const PWFDiagramZ& workFlowDiagramZ, const PLockZ& lockZ)  = 0;
	public: virtual void checkoutWorkFlow(const ::std::wstring& flowId, const PWFTypeZ& typeZ, const PWFDiagramZ& workFlowDiagramZ, const PLockZ& lockZ, ::std::function< void (PWFDiagram, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// <code>cleanupStart(ClientInfo ci)</code> removes all deleted objects and related
	/// entries from the archive database.
	/// </summary>
	/// <remarks>
	/// <p>Once started the call returns immediately,
	/// while the unique background thread cleans the archive until it finishes or
	/// <code>cleanupStart(ClientInfo ci)</code> is called. Only users owning main administrator
	/// rights may clean up archives.</p>
	/// </remarks>
	public: virtual bool cleanupStart(const PDeleteOptions& deleteOptions)  = 0;
	public: virtual void cleanupStart(const PDeleteOptions& deleteOptions, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// <code>cleanupState(ClientInfo ci)</code> returns state information in
	/// a <code>BackgroundThreadInfo</code>.
	/// </summary>
	/// <remarks>
	/// <p>
	/// <table>
	/// <tr><td>IsRunning       </td><td>true/false;</td></tr>
	/// <tr><td>ThreadStart     </td><td>ISO date containing the cleaner s start;</td></tr>
	/// <tr><td>CountProcessed  </td><td>visited archive entries</td></tr>
	/// <tr><td>CountErrors     </td><td>erroneous entries</td></tr>
	/// <tr><td>LastID          </td><td>object ID of the last visited entry</td></tr>
	/// <tr><td>LastGUID        </td><td>object GUID of the last visited entry</td></tr>
	/// </table>
	/// </p>
	/// </remarks>
	public: virtual PJobState cleanupState()  = 0;
	public: virtual void cleanupState(::std::function< void (PJobState, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// <code>cleanupStop(ClientInfo ci)</code> stops the cleaning as soon as possible
	/// finishing open transactions first.
	/// </summary>
	/// <remarks>
	/// <p>The call returns, when the background cleaner has
	/// been stopped. Only users owning main administrative rights may clean up archives.</p>
	/// </remarks>
	public: virtual bool cleanupStop()  = 0;
	public: virtual void cleanupStop(::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// <code>collectJobStates</code> lists all the states of currently existing jobs from the IX backround job pool
	/// running or finished, but still listed.
	/// </summary>
	public: virtual PArrayJobState collectJobStates(bool activeJobs, bool finishedJobs, bool fullInfo)  = 0;
	public: virtual void collectJobStates(bool activeJobs, bool finishedJobs, bool fullInfo, ::std::function< void (PArrayJobState, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Collect workflow nodes.
	/// </summary>
	public: virtual PArrayWFCollectNode collectWorkFlowNodes(const ::std::wstring& flowName, const PWFTypeZ& wfTypeZ, const ::std::wstring& nodeName, int32_t nodeType, const ::std::wstring& objId, const ::std::wstring& enterDateIso, const ::std::wstring& exitDateIso, const PArrayString& userIds, bool onlyActive, bool onlyStartNodes)  = 0;
	public: virtual void collectWorkFlowNodes(const ::std::wstring& flowName, const PWFTypeZ& wfTypeZ, const ::std::wstring& nodeName, int32_t nodeType, const ::std::wstring& objId, const ::std::wstring& enterDateIso, const ::std::wstring& exitDateIso, const PArrayString& userIds, bool onlyActive, bool onlyStartNodes, ::std::function< void (PArrayWFCollectNode, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Collects workflow names.
	/// </summary>
	/// <remarks>
	/// <p><b>This method will be deprecated in future versions of the ELO IndexServer</b>.
	/// It is recommended that the findFirstTasks() and findNextTasks() methods are used for retrieving
	/// workflow information from the IndexServer.</p>
	/// </remarks>
	public: virtual PArrayIdName collectWorkFlows(const PWFTypeZ& typeZ)  = 0;
	public: virtual void collectWorkFlows(const PWFTypeZ& typeZ, ::std::function< void (PArrayIdName, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Finds active workflows.
	/// </summary>
	/// <remarks>
	/// <p>This method returns all active workflows for the current user.</p>
	/// </remarks>
	public: virtual PFindResult findFirstWorkflows(const PFindWorkflowInfo& findInfo, int32_t max, const PWFDiagramZ& wfDiagramZ)  = 0;
	public: virtual void findFirstWorkflows(const PFindWorkflowInfo& findInfo, int32_t max, const PWFDiagramZ& wfDiagramZ, ::std::function< void (PFindResult, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Finds more active workflows.
	/// </summary>
	/// <remarks>
	/// <p>This method returns all active workflows for the current user.</p>
	/// </remarks>
	public: virtual PFindResult findNextWorkflows(const ::std::wstring& searchId, int32_t index, int32_t maxResults)  = 0;
	public: virtual void findNextWorkflows(const ::std::wstring& searchId, int32_t index, int32_t maxResults, ::std::function< void (PFindResult, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Replaces control sequences in the text of a keyword.
	/// </summary>
	public: virtual ::std::wstring cookKeyword(const ::std::wstring& kwid)  = 0;
	public: virtual void cookKeyword(const ::std::wstring& kwid, ::std::function< void (::std::wstring, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Moves an archive entry or creates a relation (logical copy).
	/// </summary>
	/// <remarks>
	/// <p>
	/// <b>1. Move</b><br/>
	/// To move an archive entry into another parent set bit <code>CopySordC.MOVE</code>
	/// in <code>copySordC</code>. Put the ID or GUID of the new parent into <code>newParentId</code>.
	/// If a reference shold be moved instead of an original, parameter <code>copyInfo</code> has to be passed with
	/// {@link CopyInfo#oldParentId} set to the current parent ID of the relation.
	/// In order to control the manual sort order, supply a <code>copyInfo</code> object with {@link CopyInfo#manSortIdx}.
	/// </p><p>
	/// <b>2. Relation</b><br/>
	/// Bit <code>CopySordC.REFERENCE</code> in <code>copySordC</code> should be used to
	/// create a logical copy of the archive entry in <code>newParentId</code>. <br/>
	/// Set <code>copyInfo=null</code> or supply an object and set the <code>CopyInfo.manSortIdx</code>
	/// to control the manual sort order. <br/>
	/// <p>References can be deleted with <code>deleteSord</code></p>
	/// </remarks>
	public: virtual int32_t copySord(const ::std::wstring& newParentId, const ::std::wstring& objId, const PCopyInfo& copyInfo, const PCopySordZ& copySordZ)  = 0;
	public: virtual void copySord(const ::std::wstring& newParentId, const ::std::wstring& objId, const PCopyInfo& copyInfo, const PCopySordZ& copySordZ, ::std::function< void (int32_t, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Creates a new document with indexing information.
	/// </summary>
	/// <remarks>
	/// </p><p>
	/// Currently the same as <code>createSord</code> but the type member of the
	/// returned indexing information (if any) is set to <code>SordC.LBT_DOCUMENT</code>.
	/// </p><p>
	/// If <code>maskId</code> is null or empty, the function tries to assign the
	/// mask defined in the configuration options of the Windows CLIENT.
	/// If this mask cannot be found, the behavior is unpredictable and
	/// -1 might be returned in sord.mask.
	/// </p>
	/// </remarks>
	public: virtual PEditInfo createDoc(const ::std::wstring& parentId, const ::std::wstring& maskId, const ::std::wstring& docTemplate, const PEditInfoZ& editInfoZ)  = 0;
	public: virtual void createDoc(const ::std::wstring& parentId, const ::std::wstring& maskId, const ::std::wstring& docTemplate, const PEditInfoZ& editInfoZ, ::std::function< void (PEditInfo, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Creates a storage mask object and assigns default values.
	/// </summary>
	/// <remarks>
	/// <p>
	/// This function does not insert the mask object into the database. Initial
	/// values can be copied from the mask specified with <code>maskId</code>.<p>
	/// </remarks>
	public: virtual PDocMask createDocMask(const ::std::wstring& maskId)  = 0;
	public: virtual void createDocMask(const ::std::wstring& maskId, ::std::function< void (PDocMask, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Creates and initializes a key object.
	/// </summary>
	public: virtual PKeyInfo createKey()  = 0;
	public: virtual void createKey(::std::function< void (PKeyInfo, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Returns an initialized, temporary Note object.
	/// </summary>
	public: virtual PNote createNote(const ::std::wstring& objId)  = 0;
	public: virtual void createNote(const ::std::wstring& objId, ::std::function< void (PNote, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Returns an initialized, temporary Note object.
	/// </summary>
	/// <remarks>
	/// <p>The object is initialized by the given note template. Placeholders are
	/// replaced by the current values.</p>
	/// </remarks>
	public: virtual PNote createNote2(const ::std::wstring& objId, int32_t noteType, const ::std::wstring& templId)  = 0;
	public: virtual void createNote2(const ::std::wstring& objId, int32_t noteType, const ::std::wstring& templId, ::std::function< void (PNote, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Creates a reminder for the Sord specified by objId.
	/// </summary>
	public: virtual PReminder createReminder(const ::std::wstring& objId)  = 0;
	public: virtual void createReminder(const ::std::wstring& objId, ::std::function< void (PReminder, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Creates an object containing all the data needed to edit the
	/// indexing information of a new archive entry.
	/// </summary>
	/// <remarks>
	/// <p>
	/// The function does not insert
	/// the new object into the database. <code>checkinSord</code> is used to insert a
	/// new object in the database.</p>
	/// <p>
	/// This function can also be used to retrieve the lists of storage masks, markers (colours)
	/// etc. For this purpose parameter <code>parentId=null</code> must be set along with
	/// <code>maskId=null</code> and supply <code>EditInfoC.mbBasicData</code> for <code>editInfoZ</code>.
	/// </p><p>
	/// To create and initialize an object for indexing information, parameter
	/// <code>editInfoZ</code> must include bit <code>EditInfoZ.mbSordMembers</code>, e. g. <code>EditInfoZ.mbSord</code>.
	/// Parameter <code>parentId</code> can specify the ID or GUID of the parent entry
	/// in the archive hierarchy. Access rights and replication information
	/// are initialized from the parent.
	/// </p><p>The <code>maskId</code> parameter
	/// is the name or ID of a storage mask that defines a template for the indexing
	/// information. If <code>maskId</code> is null or empty, the function tries to assign the
	/// mask with GUID <code>DocMaskC.GUID_FOLDER</code>. If this mask cannot be found, the
	/// default folder mask defined in the configuration options of the Windows CLIENT is used.
	/// If this mask is also not found, the behavior is unpredictable and a -1 might be returned in sord.mask.
	/// </p><p>
	/// The parameters <code>parentId</code> and <code>maskId</code> are unchecked if an event script
	/// {@link IXServerEvents#onCreateSord(IXServerEventsContext, String, String, EditInfoZ)} is configured.
	/// In this case, both can have arbitrary values.
	/// </p>
	/// </remarks>
	public: virtual PEditInfo createSord(const ::std::wstring& parentId, const ::std::wstring& maskId, const PEditInfoZ& editInfoZ)  = 0;
	public: virtual void createSord(const ::std::wstring& parentId, const ::std::wstring& maskId, const PEditInfoZ& editInfoZ, ::std::function< void (PEditInfo, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Creates an object for user data.
	/// </summary>
	/// <remarks>
	/// <p>
	/// The returned <code>UserInfo</code> object is initialized with default values.
	/// User rights and keys are copied from the user <code>rightsAsUserId</code>.</p>
	/// 
	/// <p>This function does not create a new user in the archive database. To insert a new
	/// user into the database the function <code>checkinUsers</code> must be used after the user has been
	/// created with<code>createUser</code>.</p>
	/// 
	/// <p>If the user calling this function is a main administrator (has right
	/// AccessC.FLAG_ADMIN), the created user will have the same <code>UserInfo.parent</code>
	/// as the user specified in <code>rightsAsUserId</code>. If the user calling
	/// this function is a sub-administrator (has right AccessC.FLAG_SUBADMIN), the
	/// parent of the created user is the id of the calling user.</p>
	/// </remarks>
	public: virtual PUserInfo createUser(const ::std::wstring& rightsAsUserId)  = 0;
	public: virtual void createUser(const ::std::wstring& rightsAsUserId, ::std::function< void (PUserInfo, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Initalizes a WFNode object.
	/// </summary>
	/// <remarks>
	/// <p>WFNode.userId is set to WFNodeC.USERID_OWNER if the supplied type is a person node.</p>
	/// </remarks>
	public: virtual PWFNode createWFNode(int32_t nodeId, int32_t nodeTypeC)  = 0;
	public: virtual void createWFNode(int32_t nodeId, int32_t nodeTypeC, ::std::function< void (PWFNode, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Prepares a WFDiagram structure.
	/// </summary>
	public: virtual PWFDiagram createWorkFlow(const ::std::wstring& wfName, const PWFTypeZ& typeZ)  = 0;
	public: virtual void createWorkFlow(const ::std::wstring& wfName, const PWFTypeZ& typeZ, ::std::function< void (PWFDiagram, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Deletes configuration files.
	/// </summary>
	public: virtual void deleteConfigFiles(const PArrayString& names, const PLockZ& unlockZ)  = 0;
	public: virtual void deleteConfigFiles(const PArrayString& names, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Delete counters.
	/// </summary>
	/// <remarks>
	/// <p>This function is currently not implemented and always throws
	/// an exception. Counters cannot be deleted.</p>
	/// </remarks>
	public: virtual void deleteCounters(const PArrayString& counterNames, const PLockZ& unlockZ)  = 0;
	public: virtual void deleteCounters(const PArrayString& counterNames, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Deletes a storage mask.
	/// </summary>
	/// <remarks>
	/// </p><p>
	/// If archive entries connected to the mask still exist in the database, another
	/// mask <code>assignMaskId</code> can be assigned to them.
	/// </p><p>
	/// If <code>assignMaskId</code> is not defined and there are objects connected
	/// to the mask in the database the method throws an exception.
	/// </p><p>
	/// </remarks>
	public: virtual bool deleteDocMask(const ::std::wstring& maskId, const ::std::wstring& assignMaskId, const PLockZ& unlockZ)  = 0;
	public: virtual void deleteDocMask(const ::std::wstring& maskId, const ::std::wstring& assignMaskId, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Deletes keys.
	/// </summary>
	/// <remarks>
	/// <p>
	/// Since the function requires an exclusive access to the user data, the data
	/// must be locked for the current user or must not be locked for anyone. To
	/// check in regardless of a lock supply <code>lockZ.FORCE</code>
	/// in <code>lockZ</code>.
	/// </remarks>
	public: virtual void deleteKeys(const PArrayString& ids, const PLockZ& unlockZ)  = 0;
	public: virtual void deleteKeys(const PArrayString& ids, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Deletes the keywords with the given IDs.
	/// </summary>
	/// <remarks>
	/// <p><b>IMPORTANT: This function assigns new IDs to all branches of the
	/// keyword trees below the parent keywords of the given IDs.
	/// The client program should read the parent keyword and all children below
	/// again to receive the new IDs. </b></p>
	/// <p>The access rights <code>AccessC.FLAG_EDITCONFIG</code> and
	/// <code>AccessC.FLAG_EDITSWL</code> are required to delete keywords.<p>
	/// </remarks>
	public: virtual void deleteKeywords(const PArrayString& kwids, const PLockZ& unlockZ)  = 0;
	public: virtual void deleteKeywords(const PArrayString& kwids, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Deletes notes.
	/// </summary>
	/// <remarks>
	/// <p>After a note or annotation has been deleted it should not be checked in again with MbAll. In
	/// this case the isDeleted() value is overwritten and the note or annotation will no longer be
	/// deleted. In this case MbOnlyLock should be used to remove the lock on the notes.</p>
	/// </remarks>
	public: virtual void deleteNotes(const PArrayString& noteIds, const PLockZ& unlockZ)  = 0;
	public: virtual void deleteNotes(const PArrayString& noteIds, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Deleting the Notification identified by objGuid / userGuid combination
	/// if the Notification has child Notifications, they will be deleted as well.
	/// </summary>
	public: virtual int32_t deleteNotification(const ::std::wstring& objGuid, const ::std::wstring& userGuid)  = 0;
	public: virtual void deleteNotification(const ::std::wstring& objGuid, const ::std::wstring& userGuid, ::std::function< void (int32_t, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Deletes the reminders (logically) with the the given IDs.
	/// </summary>
	public: virtual void deleteReminders(const PArrayInt& reminderIds, const PLockZ& unlockZ)  = 0;
	public: virtual void deleteReminders(const PArrayInt& reminderIds, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Deletes report entries until <code>endDateISO</code>.
	/// </summary>
	public: virtual void deleteReport(const ::std::wstring& endDateISO)  = 0;
	public: virtual void deleteReport(const ::std::wstring& endDateISO, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Deletes an archive entry and all child entries or deletes a relation (logical copy).
	/// </summary>
	/// <remarks>
	/// </p><p>
	/// A reference is deleted if <code>parentId</code> specifies an entry which is
	/// not the main parent of <code>objId</code>. The main parent can be found
	/// in <code>Sord.parent</code> after reading the indexing information for
	/// <code>objId</code> using <code>checkoutSord</code>. References are never deleted physically.
	/// </p><p>
	/// A archive entry is deleted if <code>parentId</code> is set to <code>null</code>
	/// or the id of its main parent.
	/// </p><p>
	/// If <code>deleteFinally=true</code>, all already logically deleted objects in the subtree of objId will be deleted physically.
	/// All related data (document versions, attachments, workflows, etc.) will also be physically deleted. Use this parameter with caution,
	/// since a reverse operation does not exist.
	/// </p><p>
	/// To delete logically set <code>deleteFinally=false</code>, which only sets the the delete flag within the database.
	/// </p><p>
	/// </remarks>
	public: virtual bool deleteSord(const ::std::wstring& parentId, const ::std::wstring& objId, const PLockZ& unlockZ, const PDeleteOptions& deleteOptions)  = 0;
	public: virtual void deleteSord(const ::std::wstring& parentId, const ::std::wstring& objId, const PLockZ& unlockZ, const PDeleteOptions& deleteOptions, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Write or insert sord type information.
	/// </summary>
	public: virtual void deleteSordTypes(const PArrayInt& sordTypeIds, const PLockZ& unlockZ)  = 0;
	public: virtual void deleteSordTypes(const PArrayInt& sordTypeIds, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Delete deputy information.
	/// </summary>
	public: virtual void deleteSubs(const PArraySubsInfo& deps, const PLockZ& unlockZ)  = 0;
	public: virtual void deleteSubs(const PArraySubsInfo& deps, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Deletes profile options.
	/// </summary>
	public: virtual void deleteUserProfile(const PUserProfile& userProfile, const PLockZ& unlockZ)  = 0;
	public: virtual void deleteUserProfile(const PUserProfile& userProfile, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Deletes users or groups.
	/// </summary>
	/// <remarks>
	/// </p><p>
	/// Since this function requires exclusive access to the user data, the data
	/// must be locked for the current user or must not be locked for anyone. To
	/// check in regardless of a lock  <code>lockZ.FORCE</code>
	/// in <code>lockZ</code> must be supplied.
	/// </remarks>
	public: virtual void deleteUsers(const PArrayString& ids, const PLockZ& unlockZ)  = 0;
	public: virtual void deleteUsers(const PArrayString& ids, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Deletes a workflow.
	/// </summary>
	/// <remarks>
	/// <p> WOrkflows that are deleted are not physically deleted and can be retrieved using checkoutWorkFlow().
	/// Deleted workflows return true when the WFDiagram.isDeleted() method is called.</p>
	/// </remarks>
	public: virtual void deleteWorkFlow(const ::std::wstring& flowId, const PWFTypeZ& typeZ, const PLockZ& unlockZ)  = 0;
	public: virtual void deleteWorkFlow(const ::std::wstring& flowId, const PWFTypeZ& typeZ, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Stores an edited person node of an active workflow into the database and unlocks the workflow.
	/// </summary>
	/// <remarks>
	/// <p>The workflow is forwarded to the successor nodes as passed in parameter <code>arrEnterNodesIds</code>.</p>
	/// </remarks>
	public: virtual void endEditWorkFlowNode(int32_t nFlowId, int32_t nNodeId, bool bTerminate, bool bCancel, const ::std::wstring& sName, const ::std::wstring& sComment, const PArrayInt& arrEnterNodesIds)  = 0;
	public: virtual void endEditWorkFlowNode(int32_t nFlowId, int32_t nNodeId, bool bTerminate, bool bCancel, const ::std::wstring& sName, const ::std::wstring& sComment, const PArrayInt& arrEnterNodesIds, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Deletes the search results explicitly in the IndexServer process to save memory.
	/// </summary>
	public: virtual void findClose(const ::std::wstring& searchId)  = 0;
	public: virtual void findClose(const ::std::wstring& searchId, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Finds configuration or postbox files.
	/// </summary>
	public: virtual PFindResult findFirstConfigFiles(const PFindConfigFileInfo& findInfo, int32_t max, const PConfigFileZ& configFileZ)  = 0;
	public: virtual void findFirstConfigFiles(const PFindConfigFileInfo& findInfo, int32_t max, const PConfigFileZ& configFileZ, ::std::function< void (PFindResult, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Finds report entries.
	/// </summary>
	public: virtual PFindResult findFirstReportInfos(const PFindReportInfo& opts, int32_t max)  = 0;
	public: virtual void findFirstReportInfos(const PFindReportInfo& opts, int32_t max, ::std::function< void (PFindResult, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Find archive entries and retrieve  the first <code>max</code> objects.
	/// </summary>
	/// <remarks>
	/// <p>
	/// This function performs a search over indexing information, full text,
	/// or hierarchy (child lists).
	/// </p><p>
	/// It returns either an ID array or a <code>Sord</code> object array. The maximum
	/// array length is restricted to the value of the <code>max</code> parameter.
	/// Further results can be read with <code>findNextSords</code> using the search ID
	/// <code>FindResult.searchId</code> returned by this function. The search ID has
	/// a limited lifetime which can be configured. The default value is 5 minutes.
	/// The search results can be explicitly deleted with <code>findClose</code> to
	/// save memory on the server side.
	/// </p>
	/// <p>
	/// This function does not write report entries ReportInfoC.ACT_IX_CHECKOUT_SORD for
	/// the results although it can return as much indexing information as checkoutSord does.
	/// </p>
	/// </remarks>
	public: virtual PFindResult findFirstSords(const PFindInfo& findInfo, int32_t max, const PSordZ& sordZ)  = 0;
	public: virtual void findFirstSords(const PFindInfo& findInfo, int32_t max, const PSordZ& sordZ, ::std::function< void (PFindResult, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Finds reminders, activities and active workflow nodes.
	/// </summary>
	public: virtual PFindResult findFirstTasks(const PFindTasksInfo& findInfo, int32_t max)  = 0;
	public: virtual void findFirstTasks(const PFindTasksInfo& findInfo, int32_t max, ::std::function< void (PFindResult, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Finds next configuration files.
	/// </summary>
	public: virtual PFindResult findNextConfigFiles(const ::std::wstring& searchId, int32_t idx, int32_t max, const PConfigFileZ& configFileZ)  = 0;
	public: virtual void findNextConfigFiles(const ::std::wstring& searchId, int32_t idx, int32_t max, const PConfigFileZ& configFileZ, ::std::function< void (PFindResult, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Finds report entries.
	/// </summary>
	public: virtual PFindResult findNextReportInfos(const ::std::wstring& searchId, int32_t idx, int32_t max)  = 0;
	public: virtual void findNextReportInfos(const ::std::wstring& searchId, int32_t idx, int32_t max, ::std::function< void (PFindResult, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Retrieves further results of a previous search with <code>findFirstSords</code>.
	/// </summary>
	public: virtual PFindResult findNextSords(const ::std::wstring& searchId, int32_t idx, int32_t max, const PSordZ& sordZ)  = 0;
	public: virtual void findNextSords(const ::std::wstring& searchId, int32_t idx, int32_t max, const PSordZ& sordZ, ::std::function< void (PFindResult, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Continues the find process started with findFirstTasks.
	/// </summary>
	public: virtual PFindResult findNextTasks(const ::std::wstring& searchId, int32_t idx, int32_t max)  = 0;
	public: virtual void findNextTasks(const ::std::wstring& searchId, int32_t idx, int32_t max, ::std::function< void (PFindResult, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Removes temp-files after an export.
	/// </summary>
	/// <remarks>
	/// <p>This method should be called, after the generated
	/// ZIP-archive has been successfully downloaded.</p>
	/// </remarks>
	public: virtual void finishExport(const ::std::wstring& exportId)  = 0;
	public: virtual void finishExport(const ::std::wstring& exportId, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Retrieves the constants.
	/// </summary>
	/// <remarks>
	/// <p>Constants are provided as objects to provide the advantage of type checking.
	/// (Java 1.4 does not support enumeration types).</p>
	/// </remarks>
	public: virtual PIXServicePortC getConstants()  = 0;
	public: virtual void getConstants(::std::function< void (PIXServicePortC, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Gets the URL for downloading the generated ZIP-archive of this export.
	/// </summary>
	public: virtual ::std::wstring getExportZipUrl(const ::std::wstring& exportId)  = 0;
	public: virtual void getExportZipUrl(const ::std::wstring& exportId, ::std::function< void (::std::wstring, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Retrieves the URL for uploading the ZIP-archive for this import.
	/// </summary>
	public: virtual ::std::wstring getImportZipUrl(const ::std::wstring& importId)  = 0;
	public: virtual void getImportZipUrl(const ::std::wstring& importId, ::std::function< void (::std::wstring, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Retrieves configurational information, e.g. license key, additional IndexServers, etc
	/// </summary>
	public: virtual PServerInfo getServerInfo()  = 0;
	public: virtual void getServerInfo(::std::function< void (PServerInfo, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Sets the writable members of ServerInfo.
	/// </summary>
	public: virtual void setServerInfo(const PServerInfo& serverInfo)  = 0;
	public: virtual void setServerInfo(const PServerInfo& serverInfo, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Gets DM configuration information.
	/// </summary>
	public: virtual PServerInfoDM getServerInfoDM()  = 0;
	public: virtual void getServerInfoDM(::std::function< void (PServerInfoDM, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Sets the writable members of the DM configuration.
	/// </summary>
	public: virtual void setServerInfoDM(const PServerInfoDM& serverInfo)  = 0;
	public: virtual void setServerInfoDM(const PServerInfoDM& serverInfo, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Retrieve the current session options.
	/// </summary>
	public: virtual PSessionOptions getSessionOptions()  = 0;
	public: virtual void getSessionOptions(::std::function< void (PSessionOptions, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Reads user or group names and IDs.
	/// </summary>
	/// <remarks>
	/// <p>
	/// The method performs an internal call to <code>checkoutUsers</code>. <b>Note:</b> Only
	/// the names and IDs are returned and not the complete user data.
	/// </p><p>
	/// If the current user is assigned to organisation units, the function returns only
	/// users and groups assigned to at least one of the users organisation units.
	/// </p>
	/// </remarks>
	public: virtual PArrayUserName getUserNames(const PArrayString& ids, const PCheckoutUsersZ& checkoutUsersZ)  = 0;
	public: virtual void getUserNames(const PArrayString& ids, const PCheckoutUsersZ& checkoutUsersZ, ::std::function< void (PArrayUserName, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Imports a workflow template from a file.
	/// </summary>
	/// <remarks>
	/// <p>To export a workflow template
	/// into a file, use the workflow design dialogue in ELO-CLIENT.</p>
	/// </remarks>
	public: virtual int32_t importWorkFlow(const ::std::wstring& flowName, const PBytes& fileData)  = 0;
	public: virtual void importWorkFlow(const ::std::wstring& flowName, const PBytes& fileData, ::std::function< void (int32_t, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Imports a workflow template from a file.
	/// </summary>
	/// <remarks>
	/// <p>To export a workflow template
	/// into a file, use the workflow design dialogue in ELO-CLIENT.</p>
	/// </remarks>
	public: virtual int32_t importWorkFlow2(const ::std::wstring& flowName, const PBytes& fileData, const PWorkflowImportOptions& importOptions)  = 0;
	public: virtual void importWorkFlow2(const ::std::wstring& flowName, const PBytes& fileData, const PWorkflowImportOptions& importOptions, ::std::function< void (int32_t, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Links archive entries.
	/// </summary>
	/// <remarks>
	/// <p>Links are associations between archive entries and are
	/// independent from the archive hierarchy.
	/// </p><p>
	/// The links to or from an archive entry are listed in <code>Sord.linksGoOut</code>
	/// and <code>Sord.linksComeIn</code>. In the database structure and in the Indexserver API,
	/// links are vectors that point from one Sord to one or more other Sords. But the client applications
	/// usually do not take care of the direction. They add the links found in Sord.linksGoOut and
	/// Sord.linksComeIn in order to show the liked objects.
	/// </p><p>
	/// There are two different types of links: pairs and cross-links. A pair connects exactly two
	/// Sord objects. Each pair has its own link-ID in the database. A cross-link connects a group of objects
	/// under the same link-ID. At the first glance it seems, that each object has a pair-link to each other object.
	/// But there is a significant difference when deleting links.
	/// E.g. if the Sord objects sord1, sord2, sord3 are connected with a cross-link, function checkoutSord will return
	/// for sord1: {sord2, sord3}, sord2: {sord1, sord3} and sord3: {sord1, sord2}. If function unlinkSords
	/// is called for the link sord1-sord2 (fromSord=sord1, toSords=[sord2]), the next calls to checkoutSord will return
	/// for sord1: {sord3}, sord2: {}, sord3: {sord1}. If the objects were connected by pair-links, the result would
	/// be sord1: {sord3}, sord2: {sord3}, sord3: {sord1, sord2}.
	/// </p>
	/// </remarks>
	public: virtual void linkSords(const ::std::wstring& fromId, const PArrayString& toIds, const PLinkSordZ& linkZ)  = 0;
	public: virtual void linkSords(const ::std::wstring& fromId, const PArrayString& toIds, const PLinkSordZ& linkZ, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Locks the archive with the specified key or retrieves the lock on the archive.
	/// </summary>
	/// <remarks>
	/// <p>If no key is specified (null or empty string), the current archive key is returned.
	/// To unlock the archive, call this function with <code>keyId="0"</code>.</p>
	/// </remarks>
	public: virtual int32_t lockArchive(const ::std::wstring& keyId)  = 0;
	public: virtual void lockArchive(const ::std::wstring& keyId, ::std::function< void (int32_t, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Log on to IndexServer.
	/// </summary>
	/// <remarks>
	/// <p>If the function succeeds, the return value is an object containing a ticket
	/// that allows access to all the other interface functions.
	/// </p><p>This ticket has a limited lifetime as returned in <code>LoginResult.ticketDuration</code>.
	/// The life time can be extended by calling <code>alive</code>.
	/// </p><p>The <code>runAsUser</code> parameter is used in Single-Sign-On environments.
	/// The login is performed for every user with the same SSO account specific to the application
	/// and the <runAsUser> parameter specifies the security context for the IndexServer
	/// connection. The SSO account must have administrator privileges.
	/// </p><p>
	/// <p><b>Examples:</b></p>
	/// <p>
	/// <code>// Initialize ClientInfo with language specific data </code><br/>
	/// <code>ClientInfo ci = new ClientInfo();</code><br/>
	/// <code>ci.setLanguage("de");</code><br/>
	/// <code>ci.setCountry("DE");</code><br/>
	/// <br/>
	/// <code>// Fritz logs on to IndexServer </code><br/>
	/// <code>LoginResult lr = eloix.login(ci, "Fritz", "fritzchen", "Fritz computer", null);</code><br/>
	/// <br/>
	/// <code>// The returned object contains a second ClientInfo object including the ticket. </code><br/>
	/// <code>// This ClientInfo should be used for all subsequent calls .</code><br/>
	/// <code>ci = lr.ci;</code><br/>
	/// <br/>
	/// <code>// Dump ticket and lifetime. </code><br/>
	/// <code>System.out.println("Ticket=" + ci.getTicket());</code><br/>
	/// <code>System.out.println("Lifetime=" + lr.getTicketLifetime());</code><br/>
	/// <br/>
	/// <code>// Logout </code><br/>
	/// <code>eloix.logout(ci);</code><br/>
	/// </p>
	/// 
	/// <p><b>Example for Single-Sign-On:</b></p>
	/// <p>
	/// <code>// Initialize ClientInfo with language specific data.</code><br/>
	/// <code>ClientInfo ci = new ClientInfo();</code><br/>
	/// <code>ci.setLanguage("de");</code><br/>
	/// <code>ci.setCountry("DE");</code><br/>
	/// <br/>
	/// <code>// Fritz logs on to IndexServer with SSO account "MyApp" </code><br/>
	/// <code>LoginResult lr = eloix.login(ci, "MyApp", "myapp", "Fritz computer", "Fritz");</code><br/>
	/// <br/>
	/// <code>// The returned object contains a second ClientInfo object including the ticket. </code><br/>
	/// <code>// Use for all subsequent calls this ClientInfo.</code><br/>
	/// <code>ci = lr.ci;</code><br/>
	/// <br/>
	/// <code>// Dump ticket and lifetime. </code><br/>
	/// <code>System.out.println("Ticket=" + ci.getTicket());</code><br/>
	/// <code>System.out.println("Lifetime=" + lr.getTicketLifetime());</code><br/>
	/// <code>System.out.println("user=" + lr.getUser().getName()); // =Fritz </code><br/>
	/// <br/>
	/// <code>// Logout </code><br/>
	/// <code>eloix.logout(ci);</code><br/>
	/// </p>
	/// </remarks>
	public: virtual PLoginResult login(const ::std::wstring& userName, const ::std::wstring& userPwd, const ::std::wstring& clientComputer, const ::std::wstring& runAsUser)  = 0;
	public: virtual void login(const ::std::wstring& userName, const ::std::wstring& userPwd, const ::std::wstring& clientComputer, const ::std::wstring& runAsUser, ::std::function< void (PLoginResult, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Login any user as an administrator.
	/// </summary>
	/// <remarks>
	/// <p>This function logs on the user given in <code>reportAsUser</code> as an
	/// administrator. The effective rights of the resulting session are not constrained
	/// to the rights of the given user.
	/// The client application is responsible for access checking.</p>
	/// </remarks>
	public: virtual PLoginResult loginAdmin(const ::std::wstring& userName, const ::std::wstring& userPwd, const ::std::wstring& clientComputer, const ::std::wstring& reportAsUser)  = 0;
	public: virtual void loginAdmin(const ::std::wstring& userName, const ::std::wstring& userPwd, const ::std::wstring& clientComputer, const ::std::wstring& reportAsUser, ::std::function< void (PLoginResult, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// This login is used by ELOprofessional applications if the IndexServer is used to
	/// forward workflows (WorkflowServer).
	/// </summary>
	/// <remarks>
	/// <p>This login returns a limited connection to the
	/// IndexServer. It is not possible to access documents or user data.</p>
	/// </remarks>
	public: virtual PLoginResult loginEloProf(int32_t userId, const ::std::wstring& certificate, const ::std::wstring& clientComputer)  = 0;
	public: virtual void loginEloProf(int32_t userId, const ::std::wstring& certificate, const ::std::wstring& clientComputer, ::std::function< void (PLoginResult, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Login method fÃ¼r Kerberos.
	/// </summary>
	public: virtual PLoginResult loginKerberos(const PBytes& ticket, const ::std::wstring& clientComputer)  = 0;
	public: virtual void loginKerberos(const PBytes& ticket, const ::std::wstring& clientComputer, ::std::function< void (PLoginResult, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Log out user.
	/// </summary>
	/// <remarks>
	/// <p>The ticket contained in <code>ci</code> becomes invalid.</p>
	/// </remarks>
	public: virtual void logout()  = 0;
	public: virtual void logout(::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Parses the given string of an exception into a structured IXExceptionData object.
	/// </summary>
	/// <remarks>
	/// <p>If the given string does not represent an IXException, the exceptionType NOT_IX
	/// is returned (value -1) and the given exception string can be found in "message".
	/// </remarks>
	public: virtual PIXExceptionData parseException(const ::std::wstring& exceptionString)  = 0;
	public: virtual void parseException(const ::std::wstring& exceptionString, ::std::function< void (PIXExceptionData, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Executes the processing information given by <code>processInfo</code> for all objects
	/// found by a <code>findFirstSords</code> call.
	/// </summary>
	public: virtual PJobState processFindResult(const ::std::wstring& searchId, const PProcessInfo& procInfo)  = 0;
	public: virtual void processFindResult(const ::std::wstring& searchId, const PProcessInfo& procInfo, ::std::function< void (PJobState, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// <code>processTrees</code> extends ValueClass implements a generic tree walk for all subtrees specified in
	/// <code>navInfo</code>.
	/// </summary>
	/// <remarks>
	/// <p>Specific operations for each node are queued in <code>procInfo</code>
	/// and will be applied in order of appearance.</p>
	/// </remarks>
	public: virtual PJobState processTrees(const PNavigationInfo& navigationInfo, const PProcessInfo& procInfo)  = 0;
	public: virtual void processTrees(const PNavigationInfo& navigationInfo, const PProcessInfo& procInfo, ::std::function< void (PJobState, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Returns the job state for a given job GUID.
	/// </summary>
	public: virtual PJobState queryJobState(const ::std::wstring& jobGuid, bool activeJobs, bool finishedJobs, bool fullInfo)  = 0;
	public: virtual void queryJobState(const ::std::wstring& jobGuid, bool activeJobs, bool finishedJobs, bool fullInfo, ::std::function< void (PJobState, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Creates a new object relationship.
	/// </summary>
	public: virtual void refSord(const ::std::wstring& oldParentId, const ::std::wstring& newParentId, const ::std::wstring& objId, int32_t manSortIdx)  = 0;
	public: virtual void refSord(const ::std::wstring& oldParentId, const ::std::wstring& newParentId, const ::std::wstring& objId, int32_t manSortIdx, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Restores an archive entry, its references and notes.
	/// </summary>
	/// <remarks>
	/// <p>
	/// Passing true for <code>singleObject</code> restores only the object represented by
	/// <code>objId</code>.<br/> Otherwise, the complete subtree beginning at <code>objId</code> will be restored.
	/// </p><p>
	/// </remarks>
	public: virtual bool restoreSord(const ::std::wstring& objId, const PRestoreOptions& restoreOptions)  = 0;
	public: virtual void restoreSord(const ::std::wstring& objId, const PRestoreOptions& restoreOptions, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// This function sets options related to the session identified by the given
	/// ticket.
	/// </summary>
	public: virtual void setSessionOptions(const PSessionOptions& opts)  = 0;
	public: virtual void setSessionOptions(const PSessionOptions& opts, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Starts an Ad Hoc Workflow.
	/// </summary>
	public: virtual int32_t startAdHocWorkFlow(const ::std::wstring& name, const ::std::wstring& objId, const PArrayString& arrUserIds, const ::std::wstring& nodeName, bool forValidation, bool serialFlow, const ::std::wstring& cancelUserId, const ::std::wstring& cancelMessage, const ::std::wstring& finishedUserId, const ::std::wstring& finishedMessage, const ::std::wstring& finishedScript)  = 0;
	public: virtual void startAdHocWorkFlow(const ::std::wstring& name, const ::std::wstring& objId, const PArrayString& arrUserIds, const ::std::wstring& nodeName, bool forValidation, bool serialFlow, const ::std::wstring& cancelUserId, const ::std::wstring& cancelMessage, const ::std::wstring& finishedUserId, const ::std::wstring& finishedMessage, const ::std::wstring& finishedScript, ::std::function< void (int32_t, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Starts an export-job.
	/// </summary>
	/// <remarks>
	/// <p>The given IDs and their children will be exported as specified in the
	/// options.</p>
	/// </remarks>
	public: virtual ::std::wstring startExport(const PArrayString& topLevelIDs, int64_t options)  = 0;
	public: virtual void startExport(const PArrayString& topLevelIDs, int64_t options, ::std::function< void (::std::wstring, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Starts an export-job.
	/// </summary>
	/// <remarks>
	/// <p>This is an enhanced version which works with the
	/// same options as the ones in Windows Client</p>
	/// </remarks>
	public: virtual ::std::wstring startExportExt(const PExportExtOptions& options)  = 0;
	public: virtual void startExportExt(const PExportExtOptions& options, ::std::function< void (::std::wstring, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Starts an import-job.
	/// </summary>
	/// <remarks>
	/// <p>The given IDs and their children will be imported as specified in the
	/// options.</p>
	/// </remarks>
	public: virtual ::std::wstring startImport(const ::std::wstring& filingPath, int32_t guidMethod, int64_t options)  = 0;
	public: virtual void startImport(const ::std::wstring& filingPath, int32_t guidMethod, int64_t options, ::std::function< void (::std::wstring, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Starts a workflow from a workflow template.
	/// </summary>
	public: virtual int32_t startWorkFlow(const ::std::wstring& templFlowId, const ::std::wstring& flowName, const ::std::wstring& objId)  = 0;
	public: virtual void startWorkFlow(const ::std::wstring& templFlowId, const ::std::wstring& flowName, const ::std::wstring& objId, ::std::function< void (int32_t, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Assign a node to a user.
	/// </summary>
	/// <remarks>
	/// <p>This function is useful in two situations:<br/>
	/// 1. A user calls this function to assume a task for exclusive use.
	/// The task must be assigned to one of the user s groups or to a user
	/// substituted by the current user. Supply an empty <code>sUserId</code>.<br/>
	/// 2. A user calls this function to pass the task to another user. The task
	/// must be assigned to the current user. Supply any user name or ID in sUserId.
	/// </p>
	/// The function assigns in addition to the given node all nodes with the same {@link WFNode#departmentGroup}.
	/// </remarks>
	public: virtual void takeWorkFlowNode(int32_t nFlowId, int32_t nNodeId, const ::std::wstring& sUserId, int32_t nFlags, const PLockZ& lockZ)  = 0;
	public: virtual void takeWorkFlowNode(int32_t nFlowId, int32_t nNodeId, const ::std::wstring& sUserId, int32_t nFlags, const PLockZ& lockZ, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Terminates a workflow.
	/// </summary>
	public: virtual int32_t terminateWorkFlow(const ::std::wstring& flowId, const PLockZ& unlockZ)  = 0;
	public: virtual void terminateWorkFlow(const ::std::wstring& flowId, const PLockZ& unlockZ, ::std::function< void (int32_t, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Delegates the specified workflow node to another user.
	/// </summary>
	/// <remarks>
	/// <p>An additional person node is inserted into the workflow for the given user and the
	/// workflow is forwarded to this node. If {@link WFDelegateNodeInfo#backNodeName} is set,
	/// a further node is added after the delegation node for the current user.</p>
	/// </remarks>
	public: virtual void delegateWorkFlowNode(const PWFDelegateNodeInfo& delegateNodeInfo, const PLockZ& lockZ)  = 0;
	public: virtual void delegateWorkFlowNode(const PWFDelegateNodeInfo& delegateNodeInfo, const PLockZ& lockZ, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// <p>Sets the value userDelayDateIso of the given node.
	/// </summary>
	/// <remarks>
	/// </p>
	/// </remarks>
	public: virtual void deferWorkFlowNode(const ::std::wstring& flowId, int32_t nodeId, const ::std::wstring& userDelayDateIso, const PLockZ& lockZ)  = 0;
	public: virtual void deferWorkFlowNode(const ::std::wstring& flowId, int32_t nodeId, const ::std::wstring& userDelayDateIso, const PLockZ& lockZ, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// This function is used for testing.
	/// </summary>
	/// <remarks>
	/// <p>In productive environments it always throws
	/// an exception.</p>
	/// </remarks>
	public: virtual PArrayString testAdapter(const ::std::wstring& fn, const PArrayString& params)  = 0;
	public: virtual void testAdapter(const ::std::wstring& fn, const PArrayString& params, ::std::function< void (PArrayString, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Remove links between archive entries.
	/// </summary>
	public: virtual void unlinkSords(const ::std::wstring& fromId, const PArrayString& toIds, const PLinkSordZ& linkZ)  = 0;
	public: virtual void unlinkSords(const ::std::wstring& fromId, const PArrayString& toIds, const PLinkSordZ& linkZ, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Read and optionally lock the password information for document encryption.
	/// </summary>
	public: virtual PArrayCryptInfo checkoutCryptInfos(const PArrayString& ids, const PLockZ& lockZ)  = 0;
	public: virtual void checkoutCryptInfos(const PArrayString& ids, const PLockZ& lockZ, ::std::function< void (PArrayCryptInfo, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Write and optionally unlock encryption information.
	/// </summary>
	/// <remarks>
	/// <p>
	/// The passwords supplied in cryptInfos must be encrypted with the
	/// IXClient.encryptPassword function.
	/// </p><p>
	/// Administrators are allowed to alter internal keys and encryption set names.
	/// <table border="2">
	/// <tr><td>cryptInfos[.].keyInfo</td><td>Description</td></tr>
	/// <tr><td>*</td><td>Generate new internal keys and set cryptInfos[.].pwd as external password.</td></tr>
	/// <tr><td>Value from another ELO system</td><td>Set this value as internal and external key pair. cryptInfos[.].pwd is ignored.</td></tr>
	/// </table>
	/// </p>
	/// </remarks>
	public: virtual void checkinCryptInfos(const PArrayCryptInfo& cryptInfos, const PLockZ& unlockZ)  = 0;
	public: virtual void checkinCryptInfos(const PArrayCryptInfo& cryptInfos, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Provide a password to be used in the current session for encrypting and
	/// decrypting of documents.
	/// </summary>
	/// <remarks>
	/// <p>The given password must be encrypted with the IXClient.encryptPassword
	/// function to hide it from administrators. An unencrypted password will cause
	/// an exception.
	/// </p><p>
	/// To use the encryption/decryption functionality of IndexServer, the
	/// session option &lt;ix.encryptDocuments&gt; resp. &lt;ix.decryptDocuments&gt;
	/// has to be &lt;true&gt;.
	/// Then, IndexServer generates special URLs that cause it to encrypt documents on
	/// upload and decrypt documents on download.
	/// </p>
	/// Be aware of the fact that encryption/decryption happens between IndexServer
	/// and Document Manager communication and not between IndexServer and the client
	/// application. Thus it is strongly recommended to use HTTPS between the client
	/// application and IndexServer. The IndexServer configuration option
	/// &quot;ixUrlBase&quot; can be helpful to achieve this.
	/// </remarks>
	public: virtual void provideCryptPassword(const ::std::wstring& encryptionSet, const ::std::wstring& pwd)  = 0;
	public: virtual void provideCryptPassword(const ::std::wstring& encryptionSet, const ::std::wstring& pwd, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Invalidate the internally used caches for users, storage masks, etc.
	/// </summary>
	public: virtual void invalidateCache(int32_t flags)  = 0;
	public: virtual void invalidateCache(int32_t flags, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Invalidate the internally used caches.
	/// </summary>
	public: virtual PInvalidateCacheResult invalidateCache2(const PInvalidateCacheInfo& info)  = 0;
	public: virtual void invalidateCache2(const PInvalidateCacheInfo& info, ::std::function< void (PInvalidateCacheResult, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Find terms for which a translation is available.
	/// </summary>
	/// <remarks>
	/// <p>Close the search results with a call to findClose.</p>
	/// </remarks>
	public: virtual PFindResult findFirstTranslateTerms(const PFindTranslateTermInfo& findInfo, int32_t max)  = 0;
	public: virtual void findFirstTranslateTerms(const PFindTranslateTermInfo& findInfo, int32_t max, ::std::function< void (PFindResult, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Find next terms.
	/// </summary>
	public: virtual PFindResult findNextTranslateTerms(const ::std::wstring& searchId, int32_t idx, int32_t max)  = 0;
	public: virtual void findNextTranslateTerms(const ::std::wstring& searchId, int32_t idx, int32_t max, ::std::function< void (PFindResult, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Read terms from translation table for viewing or editing.
	/// </summary>
	/// <remarks>
	/// <p>
	/// It can also be used to retrieve the supported languages.
	/// Use this function, if only a few terms should be returned.
	/// Otherwise call <code>findFirstTranslateTerms</code>.
	/// </p>
	/// </remarks>
	public: virtual PArrayTranslateTerm checkoutTranslateTerms(const PArrayString& termIds, const PLockZ& lockZ)  = 0;
	public: virtual void checkoutTranslateTerms(const PArrayString& termIds, const PLockZ& lockZ, ::std::function< void (PArrayTranslateTerm, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Write or insert terms into the translation table.
	/// </summary>
	/// <remarks>
	/// <p>
	/// This function should not be called frequently, because it causes the translation cache to be reloaded.
	/// </p>
	/// </remarks>
	public: virtual PArrayString checkinTranslateTerms(const PArrayTranslateTerm& tterms, const PLockZ& unlockZ)  = 0;
	public: virtual void checkinTranslateTerms(const PArrayTranslateTerm& tterms, const PLockZ& unlockZ, ::std::function< void (PArrayString, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Delete terms from the translation table.
	/// </summary>
	/// <remarks>
	/// <p>
	/// This function should not be called frequently, because it causes the translation cache to be reloaded.
	/// </p>
	/// </remarks>
	public: virtual void deleteTranslateTerms(const PArrayString& termIds, const PLockZ& unlockZ)  = 0;
	public: virtual void deleteTranslateTerms(const PArrayString& termIds, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Reads the version information of all versions of the given workflow.
	/// </summary>
	public: virtual PArrayWFVersion getWorkflowTemplateVersions(const ::std::wstring& flowId, bool onlyDeleted)  = 0;
	public: virtual void getWorkflowTemplateVersions(const ::std::wstring& flowId, bool onlyDeleted, ::std::function< void (PArrayWFVersion, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Check out versions of a workflow template.
	/// </summary>
	public: virtual PWFDiagram checkoutWorkflowTemplate(const ::std::wstring& flowId, const ::std::wstring& versionId, const PWFDiagramZ& wfZ, const PLockZ& lockZ)  = 0;
	public: virtual void checkoutWorkflowTemplate(const ::std::wstring& flowId, const ::std::wstring& versionId, const PWFDiagramZ& wfZ, const PLockZ& lockZ, ::std::function< void (PWFDiagram, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Check in a workflow template as a new version or overwrite an existing version.
	/// </summary>
	public: virtual PArrayInt checkinWorkflowTemplate(const PWFDiagram& wf, const PWFDiagramZ& wfZ, const PLockZ& unlockZ)  = 0;
	public: virtual void checkinWorkflowTemplate(const PWFDiagram& wf, const PWFDiagramZ& wfZ, const PLockZ& unlockZ, ::std::function< void (PArrayInt, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Deletes a workflow template version.
	/// </summary>
	public: virtual void deleteWorkflowTemplate(const ::std::wstring& flowId, const ::std::wstring& versionId, const PLockZ& unlockZ)  = 0;
	public: virtual void deleteWorkflowTemplate(const ::std::wstring& flowId, const ::std::wstring& versionId, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Read the stamp definitions from the users options.
	/// </summary>
	public: virtual PArrayNoteTemplate checkoutNoteTemplates(const ::std::wstring& userId, const PArrayString& ids, const PNoteTemplateZ& ntemplZ, const PLockZ& lockZ)  = 0;
	public: virtual void checkoutNoteTemplates(const ::std::wstring& userId, const PArrayString& ids, const PNoteTemplateZ& ntemplZ, const PLockZ& lockZ, ::std::function< void (PArrayNoteTemplate, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Initializes a new NoteTemplate object.
	/// </summary>
	public: virtual PNoteTemplate createNoteTemplate(const ::std::wstring& userId)  = 0;
	public: virtual void createNoteTemplate(const ::std::wstring& userId, ::std::function< void (PNoteTemplate, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Delete the stamp definition with the given ID.
	/// </summary>
	public: virtual void deleteNoteTemplates(const ::std::wstring& userId, const PArrayString& ids, const PLockZ& unlockZ)  = 0;
	public: virtual void deleteNoteTemplates(const ::std::wstring& userId, const PArrayString& ids, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Writes the given stamp definition into the database.
	/// </summary>
	public: virtual PArrayInt checkinNoteTemplates(const PArrayNoteTemplate& noteTemplates, const PNoteTemplateZ& ntemplZ, const PLockZ& unlockZ)  = 0;
	public: virtual void checkinNoteTemplates(const PArrayNoteTemplate& noteTemplates, const PNoteTemplateZ& ntemplZ, const PLockZ& unlockZ, ::std::function< void (PArrayInt, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// This function reloads all internal objects.
	/// </summary>
	/// <remarks>
	/// <p>
	/// Call this function with administrator privileges,
	/// if configuration options,
	/// scripts or configuration files are modified.
	/// Current sessions and processes are tried to be kept alive.
	/// But under some conditions, sessions get lost and running
	/// processes terminate with an exception!
	/// </p>
	/// </remarks>
	public: virtual void reload()  = 0;
	public: virtual void reload(::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// This function reloads all scripts.
	/// </summary>
	/// <remarks>
	/// <p>
	/// Call this function with administrator privileges,
	/// </p>
	/// if some scripts are modified.
	/// </remarks>
	public: virtual void reloadScripts()  = 0;
	public: virtual void reloadScripts(::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// This function returns a map containing information of all compiled scripts.
	/// </summary>
	public: virtual byps::PMapIntegerString getCompiledScripts()  = 0;
	public: virtual void getCompiledScripts(::std::function< void (byps::PMapIntegerString, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// This function returns the list of the scripts which are currently debugged,
	/// i.e. the property "scriptsToDebug".
	/// </summary>
	public: virtual ::std::wstring getScriptsToDebug()  = 0;
	public: virtual void getScriptsToDebug(::std::function< void (::std::wstring, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// This function allows to set the the property "scriptsToDebug".
	/// </summary>
	public: virtual void setScriptsToDebug(const ::std::wstring& scriptsToDebug)  = 0;
	public: virtual void setScriptsToDebug(const ::std::wstring& scriptsToDebug, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// This function returns debugger's port.
	/// </summary>
	public: virtual int32_t getDebuggerPort()  = 0;
	public: virtual void getDebuggerPort(::std::function< void (int32_t, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Deletes a keyword list.
	/// </summary>
	public: virtual void deleteKeywordList(const ::std::wstring& kwid, const PLockZ& unlockZ)  = 0;
	public: virtual void deleteKeywordList(const ::std::wstring& kwid, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Reads a keyword list.
	/// </summary>
	/// <remarks>
	/// <p>
	/// This function internally calls checkoutKeywords.
	/// </p>
	/// </remarks>
	public: virtual PKeywordList checkoutKeywordList(const ::std::wstring& kwid, const PKeywordZ& keywordZ, int32_t max, const PLockZ& lockZ)  = 0;
	public: virtual void checkoutKeywordList(const ::std::wstring& kwid, const PKeywordZ& keywordZ, int32_t max, const PLockZ& lockZ, ::std::function< void (PKeywordList, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Write or insert a keyword list.
	/// </summary>
	/// <remarks>
	/// <p>
	/// This function internally calls checkinKeywords.
	/// </p>
	/// </remarks>
	public: virtual void checkinKeywordList(const PKeywordList& kwList, const PLockZ& unlockZ)  = 0;
	public: virtual void checkinKeywordList(const PKeywordList& kwList, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Compares the given ACLs and computes the sum, difference and intersection.
	/// </summary>
	/// <remarks>
	/// <p>
	/// To remove the duplicate entries in an ACL, call this function with a null value for the rhs parameter.
	/// The CombineAclResult.sum contains the ACL without duplicates.
	/// </p>
	/// </remarks>
	public: virtual PCombineAclResult combineAcl(const PArrayAclItem& lhs, const PArrayAclItem& rhs, const PCombineAclOptions& options)  = 0;
	public: virtual void combineAcl(const PArrayAclItem& lhs, const PArrayAclItem& rhs, const PCombineAclOptions& options, ::std::function< void (PCombineAclResult, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Returns the access of the given ACL.
	/// </summary>
	public: virtual PAclAccessResult getAclAccess(const PAclAccessInfo& aai)  = 0;
	public: virtual void getAclAccess(const PAclAccessInfo& aai, ::std::function< void (PAclAccessResult, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Returns the EditInfo-Objects from the FileData-Objects.
	/// </summary>
	/// <remarks>
	/// <p>
	/// The rows "IXDTEXT",
	/// "ISCRYPT", "ATTACHID" and "SIGID" in the esw-file are not supported in this version.
	/// </p>
	/// </remarks>
	public: virtual PArrayEditInfo getEditInfoFromESW(const PArrayFileData& fileDatas, const PEditInfoEswOptions& eswOptions)  = 0;
	public: virtual void getEditInfoFromESW(const PArrayFileData& fileDatas, const PEditInfoEswOptions& eswOptions, ::std::function< void (PArrayEditInfo, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Returns the FileData-Objects from the EditInfo-Objects.
	/// </summary>
	/// <remarks>
	/// <p>
	/// Caution: sord.XDateIso and sord.IDateIso have to contain a value related to the servers timezone.
	/// </p>
	/// </remarks>
	public: virtual PArrayFileData getESWFromEditInfo(const PArrayEditInfo& editInfos, const PEditInfoEswOptions& eswOptions)  = 0;
	public: virtual void getESWFromEditInfo(const PArrayEditInfo& editInfos, const PEditInfoEswOptions& eswOptions, ::std::function< void (PArrayFileData, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Returns the LoginResult object that represents the session of the ticket contained in the given ClientInfo object.
	/// </summary>
	public: virtual PLoginResult getSessionFromTicket(int32_t options)  = 0;
	public: virtual void getSessionFromTicket(int32_t options, ::std::function< void (PLoginResult, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Returns the SessionInfo-Objects about all the active connections.
	/// </summary>
	public: virtual PArraySessionInfo getSessionInfos(const PSessionInfoParams& params)  = 0;
	public: virtual void getSessionInfos(const PSessionInfoParams& params, ::std::function< void (PArraySessionInfo, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Execute a script.
	/// </summary>
	public: virtual PExecuteScriptResult executeScript(const PExecuteScriptParams& params)  = 0;
	public: virtual void executeScript(const PExecuteScriptParams& params, ::std::function< void (PExecuteScriptResult, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Exports the workflow-version.
	/// </summary>
	public: virtual PFileData exportWorkflow(const PWorkflowExportOptions& wfExportOptions)  = 0;
	public: virtual void exportWorkflow(const PWorkflowExportOptions& wfExportOptions, ::std::function< void (PFileData, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Read all distinct values from the database that are used for the given ObjKey
	/// name, potentionally causing an enormous database load.
	/// </summary>
	public: virtual PValuesOfObjKey getDistinctValuesOfObjKey(const ::std::wstring& okeyName, const PValuesOfObjKeyOptions& opts)  = 0;
	public: virtual void getDistinctValuesOfObjKey(const ::std::wstring& okeyName, const PValuesOfObjKeyOptions& opts, ::std::function< void (PValuesOfObjKey, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Read characteristical properties of the archive.
	/// </summary>
	public: virtual PArchiveStatistics getArchiveStatistics(int64_t opts)  = 0;
	public: virtual void getArchiveStatistics(int64_t opts, ::std::function< void (PArchiveStatistics, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Collects the existing map domains.
	/// </summary>
	/// <remarks>
	/// <p>
	/// This function does not return the special domain MapDomainC.DOMAIN_IX_OPTIONS.
	/// </p>
	/// </remarks>
	public: virtual PArrayMapDomain collectMapDomains()  = 0;
	public: virtual void collectMapDomains(::std::function< void (PArrayMapDomain, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Creates or updates a map domain.
	/// </summary>
	public: virtual void checkinMapDomain(const PMapDomain& mapDomain, const PLockZ& unlockZ)  = 0;
	public: virtual void checkinMapDomain(const PMapDomain& mapDomain, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Reads the data of a map domain.
	/// </summary>
	public: virtual PMapDomain checkoutMapDomain(const ::std::wstring& domainName, const PLockZ& lockZ)  = 0;
	public: virtual void checkoutMapDomain(const ::std::wstring& domainName, const PLockZ& lockZ, ::std::function< void (PMapDomain, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Deletes a map domain and removes the associated database tables.
	/// </summary>
	public: virtual void deleteMapDomain(const ::std::wstring& domainName, const PLockZ& unlockZ)  = 0;
	public: virtual void deleteMapDomain(const ::std::wstring& domainName, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Inserts or updates the given key-value-pairs in <code>data</code> in the map specified by <code>id</code>.
	/// </summary>
	/// <remarks>
	/// <p>
	/// The map can be associated to a Sord object by setting the parameter <code>objId</code> to a valid Sord ID.
	/// This implies, that the map is deleted, if the Sord object is finally deleted. Furthermore, the map can
	/// be copied with the Sord object. Therefore, the map ID must be equal to the Sord ID and the map domain
	/// must be prepared to copy items by setting <code>MapDomain.copy=true</code>.
	/// </p>
	/// <p>
	/// If domainName is set to MapDomainC.DOMAIN_IX_OPTIONS, the IndexServer configuration options from table
	/// eloixopt can be written. Therefore the key items in <code>data</code> must be formatted as
	/// data[.].key = &qt;[&qt; + ixid + &qt;]&qt; + optname. Whereby ixid is &qt;_ALL&qt; or the
	/// IndexServer ID specified in the web.xml or config.xml. The parameter <code>id</code> is ignored when
	/// reading IndexServer options. The <code>unlockZ</code> parameter is ignored too, because the options
	/// table does not support locking. Only Administrators are allowed to access the IndexServer options.
	/// </p>
	/// <p>
	/// Since ELO10: Map items can be of type {@link MapValue} which allows to store a BLOB.
	/// The maximum BLOB size should be at most {@link FileDataC#MAX_BLOB_LENGTH}.
	/// <pre><code>
	/// InputStream istream = new FileInputStream(new File("c:\test.txt")); // is closed in checkinMap
	/// FileData fileData = new FileData();
	/// fileData.setContentType("text/plain");
	/// fileData.setStream(istream);
	/// MapValue mapValue = new MapValue();
	/// mapValue.setKey("myfile");
	/// mapValue.setBlobValue(fileData);
	/// conn.ix().checkinMap( "MyMapDomain", "1", 0, new KeyValue[] { mapValue }, LockC.NO );
	/// </code></pre>
	/// </p>
	/// </remarks>
	public: virtual void checkinMap(const ::std::wstring& domainName, const ::std::wstring& id, int32_t objId, const PArrayKeyValue& data, const PLockZ& unlockZ)  = 0;
	public: virtual void checkinMap(const ::std::wstring& domainName, const ::std::wstring& id, int32_t objId, const PArrayKeyValue& data, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Reads a map or parts of a map.
	/// </summary>
	/// <remarks>
	/// <p>
	/// Since ELO10: In order to access BLOB values, lookup the value in the returned element {@link MapData#mapItems} or cast
	/// the related object in {@link MapData#items} to {@link MapValue}.
	/// <pre><code>
	/// MapData map = conn.ix().checkoutMap( mapDomainName, "1", new String[] {"myfile"}, LockC.NO );
	/// MapValue mapValue = map.getMapItems().get("myfile");
	/// InputStream istream = mapValueR.getBlobValue().getStream();
	/// try {
	/// ...
	/// } finally {
	/// istream.close();
	/// }
	/// </code></pre>
	/// </p>
	/// </remarks>
	public: virtual PMapData checkoutMap(const ::std::wstring& domainName, const ::std::wstring& id, const PArrayString& keyNames, const PLockZ& lockZ)  = 0;
	public: virtual void checkoutMap(const ::std::wstring& domainName, const ::std::wstring& id, const PArrayString& keyNames, const PLockZ& lockZ, ::std::function< void (PMapData, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Delete map items.
	/// </summary>
	public: virtual void deleteMap(const ::std::wstring& domainName, const ::std::wstring& id, const PArrayString& keyNames, const PLockZ& unlockZ)  = 0;
	public: virtual void deleteMap(const ::std::wstring& domainName, const ::std::wstring& id, const PArrayString& keyNames, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Find terms for faceted search.
	/// </summary>
	public: virtual PArrayContextTerm getContextTerms(const PFindInfo& findInfo, const ::std::wstring& field, int32_t max)  = 0;
	public: virtual void getContextTerms(const PFindInfo& findInfo, const ::std::wstring& field, int32_t max, ::std::function< void (PArrayContextTerm, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Execute a registered function defined in a JavaScript or in an event handler.
	/// </summary>
	public: virtual PAny executeRegisteredFunction(const ::std::wstring& functionName, const PAny& param)  = 0;
	public: virtual void executeRegisteredFunction(const ::std::wstring& functionName, const PAny& param, ::std::function< void (PAny, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Execute a registered function defined in a JavaScript or in an event handler.
	/// </summary>
	public: virtual ::std::wstring executeRegisteredFunctionString(const ::std::wstring& functionName, const ::std::wstring& param)  = 0;
	public: virtual void executeRegisteredFunctionString(const ::std::wstring& functionName, const ::std::wstring& param, ::std::function< void (::std::wstring, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Get alternative terms for an iSearch search.
	/// </summary>
	/// <remarks>
	/// <p>
	/// This function can be used to list all index values currently used for a given index group.
	/// To achieve this, pass termType=SearchTermsC.TERMS and set findInfo.findDirect.query = "LINE." + indexgroup + ":" + valueprefix.
	/// If more than 10 values shoud be returned, set findInfo.findOptions.totalCount to the maximum
	/// values to be returned.
	/// </p>
	/// </remarks>
	public: virtual PArrayString getSearchTerms(const PFindInfo& findInfo, int32_t termType)  = 0;
	public: virtual void getSearchTerms(const PFindInfo& findInfo, int32_t termType, ::std::function< void (PArrayString, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Queries, enters or leaves the administration mode.
	/// </summary>
	/// <remarks>
	/// <p>
	/// In administration mode, only main administrators can logon to the archive.
	/// </p>
	/// </remarks>
	public: virtual int32_t adminMode(int32_t mode)  = 0;
	public: virtual void adminMode(int32_t mode, ::std::function< void (int32_t, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Get or set the fulltext configuration.
	/// </summary>
	public: virtual PFulltextConfig configureFulltext(const ::std::wstring& userId, const PFulltextConfig& opts)  = 0;
	public: virtual void configureFulltext(const ::std::wstring& userId, const PFulltextConfig& opts, ::std::function< void (PFulltextConfig, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// This function notifies the IndexServer about an operation of the client program.
	/// </summary>
	/// <remarks>
	/// <p>
	/// Use this function in order to notify the license management, when a write access
	/// has been processed, e.g. scan a document or perform OCR analysis on a document.
	/// </p>
	/// </remarks>
	public: virtual PNotifyServerResult notifyServer(const PNotifyServerInfo& msg)  = 0;
	public: virtual void notifyServer(const PNotifyServerInfo& msg, ::std::function< void (PNotifyServerResult, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Query or send backup profile information of the ELOdm.
	/// </summary>
	/// <remarks>
	/// <p>
	/// The user calling this method must have the main administrator right
	/// (AccessC.FLAG_ADMIN).
	/// </p>
	/// </remarks>
	public: virtual PArrayBackupProfile configureBackup(const PArrayBackupProfile& backupProfiles)  = 0;
	public: virtual void configureBackup(const PArrayBackupProfile& backupProfiles, ::std::function< void (PArrayBackupProfile, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Query the status of the backup and purge tasks of the ELOdm.
	/// </summary>
	/// <remarks>
	/// <p>
	/// In addition, the backup and purge tasks can be started or stopped.
	/// The user calling this method must have the main administrator right
	/// (AccessC.FLAG_ADMIN).
	/// </p>
	/// </remarks>
	public: virtual PBackupPurgeStatus controlBackup(const PControlBackupInfo& controlBackupInfo)  = 0;
	public: virtual void controlBackup(const PControlBackupInfo& controlBackupInfo, ::std::function< void (PBackupPurgeStatus, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Query or send the purge task settings of the ELOdm.
	/// </summary>
	/// <remarks>
	/// <p>
	/// The user calling this method must have the main administrator right
	/// (AccessC.FLAG_ADMIN).
	/// </p>
	/// </remarks>
	public: virtual PPurgeSettings configurePurge(const PPurgeSettings& purgeSettings)  = 0;
	public: virtual void configurePurge(const PPurgeSettings& purgeSettings, ::std::function< void (PPurgeSettings, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Adds additional params to an upload or download URL.
	/// </summary>
	/// <remarks>
	/// <p>
	/// Currently, additional params are only available for download URLs.
	/// </p>
	/// </remarks>
	public: virtual ::std::wstring addUrlParams(const ::std::wstring& url, const PUrlParams& params)  = 0;
	public: virtual void addUrlParams(const ::std::wstring& url, const PUrlParams& params, ::std::function< void (::std::wstring, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Open a new event bus.
	/// </summary>
	/// <remarks>
	/// <p>
	/// Caution: the event bus API functions cannot be used with SOAP communication.
	/// </p><p>
	/// An event bus is like a communication channel between two or more subscribers. One subscriber sends an
	/// event and the bus dispatches it to the subscribers that are listening.
	/// </p><p>
	/// Before an application can send events, it has to call the function <code>createEventBusSubscriber</code>
	/// in order to create a subscriber ID. A subscriber can send events to an event bus or listen to events from an event bus.
	/// To send an event, the function <code>sendEvents</code> has to be called.<br>
	/// In order to revive events from event busses, event listeners have to be registered with the event busses first.
	/// An event listener specifies a list of <code>EventFilter</code> objects which describe the requested event types and busses from which to receive events.
	/// A subscriber can register any number of event listeners to potentially different event busses with a single call to <code>createEventBusListener</code>.
	/// Further event listeners can be added by this function or deleted with <code>deleteEventBusListener</code> at any time.
	/// </p><p>
	/// A helper object of <code>IXConnection</code>, which can be obtained by <code>IXConnection.getEventBusApi()</code>,
	/// listens for incoming events and forwards them to an object that implements the <code>IXEventBusHandler</code> interface.
	/// This object has to be provided by the client application and must be passed in a call to <code>IXConnection.getEventBusApi().setHandler(...)</code>.
	/// </p><p>
	/// Normally, client applications will use the predefined busses listed in <code>EventBusC</code>.
	/// This class defines a broadcast bus and busses related to users. Any subscriber can receive events from the broadcast
	/// bus. In difference to that, user busses can be listened only by the owner - a user bus acts somewhat like a mailbox.
	/// <p></p>
	/// There is no constraint to subscribers for sending events to busses. A subscriber can send any event to a bus, if it knows the bus ID.
	/// <p></p>
	/// In some circumstances, it is useful to work with a private channel between particular subscribers. This could be a channel used
	/// for chat messages between users. Another example is a channel between separated components of an application that share the same
	/// ticket an have to synchronize the user interfaces.
	/// <p></p>
	/// Use this function to open an event bus e.g. to establish a private communication channel between
	/// two or more applications. The returned bus ID is built upon the given information in <code>params</code>.
	/// Two applications, that supply equal params objects, will receive equal bus IDs.
	/// At least one of the applications has to close the bus with <code>closeEventBus</code> if it is needed no more.
	/// </p>
	/// </remarks>
	public: virtual int64_t openEventBus(const PEventBusParams& params)  = 0;
	public: virtual void openEventBus(const PEventBusParams& params, ::std::function< void (int64_t, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Close an event bus opened by <code>openEventBus</code>.
	/// </summary>
	/// <remarks>
	/// <p>
	/// Any subscriber that knows the bus ID can close this event bus.
	/// When a bus is closed, all outstanding events in the ELOix are deleted.
	/// After a bus is closed, neither listener will receive anymore events from this bus.
	/// This function ignores unknown or already closed bus IDs or bus IDs defined in <code>EventBusC</code>.
	/// </p>
	/// </remarks>
	public: virtual void closeEventBus(int64_t busId)  = 0;
	public: virtual void closeEventBus(int64_t busId, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Create an event bus subscriber.
	/// </summary>
	/// <remarks>
	/// <p>
	/// A subscriber sends events to an event bus or receives events from an event bus.
	/// An application resp. an <code>IXConnection</code> can open any number of subscribers.
	/// A subscriber has to be deleted with <code>deleteEventBusSubscriber</code> when it is no more needed.
	/// A bus is also deleted, if the last event listener is deleted. This might happen when <code>deleteEventBusSubscriber</code> or <code>deleteEventBusListener</code> is called.
	/// In this case, it is not necessary to call <code>deleteEventBusSubscriber</code>.
	/// </p>
	/// </remarks>
	public: virtual int64_t createEventBusSubscriber()  = 0;
	public: virtual void createEventBusSubscriber(::std::function< void (int64_t, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Deletes an event bus subscriber.
	/// </summary>
	/// <remarks>
	/// <p>
	/// This function deletes a subscriber an all its event listeners.
	/// </p>
	/// </remarks>
	public: virtual void deleteEventBusSubscriber(int64_t subsId)  = 0;
	public: virtual void deleteEventBusSubscriber(int64_t subsId, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Creates an event bus listener.
	/// </summary>
	/// <remarks>
	/// <p>
	/// This function creates an event bus listener that filters events from the event bus as described in the filter list of the <code>eventListener</code> parameter.
	/// Event bus listeners have to be deleted by either <code>deleteEventBusListener</code> or by deleting the subscriber with <code>deleteEventBusSubscriber</code>.
	/// </p>
	/// </remarks>
	public: virtual int64_t createEventBusListener(int64_t subsId, const PEventListener& eventListener)  = 0;
	public: virtual void createEventBusListener(int64_t subsId, const PEventListener& eventListener, ::std::function< void (int64_t, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Deletes an event bus listener.
	/// </summary>
	/// <remarks>
	/// <p>
	/// This function deletes an event bus listener that was created by a call to <code>createEventBusListener</code>.
	/// The function does not throw an exception, if the Listener ID does not exist.
	/// </p>
	/// </remarks>
	public: virtual void deleteEventBusListener(int64_t lsnId)  = 0;
	public: virtual void deleteEventBusListener(int64_t lsnId, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Read events from the server.
	/// </summary>
	/// <remarks>
	/// <p>
	/// This function should not be called directly. It is used internally by the event bus helper object of <code>IXConnection</code>.
	/// </p>
	/// </remarks>
	public: virtual PArrayEvent internalReceiveEvents(int64_t subsId, int64_t timeoutMillis)  = 0;
	public: virtual void internalReceiveEvents(int64_t subsId, int64_t timeoutMillis, ::std::function< void (PArrayEvent, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Send events to event busses.
	/// </summary>
	/// <remarks>
	/// <p>
	/// Call this function to send events to event busses.
	/// </p>
	/// </remarks>
	public: virtual void sendEvents(int64_t subsId, const PArrayEvent& events)  = 0;
	public: virtual void sendEvents(int64_t subsId, const PArrayEvent& events, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Helper function to create a RSA key pair.
	/// </summary>
	public: virtual PArrayString createRsaKeys()  = 0;
	public: virtual void createRsaKeys(::std::function< void (PArrayString, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Encrypt or decrypt a string using the RSA algorithm.
	/// </summary>
	/// <remarks>
	/// <p>
	/// This function encrypts or decrypts the string <code>data</code> using the RSA algorithm.
	/// The string must not be longer than 768 characters.
	/// Pass the public RSA key in <code>key</code>, if the string should be encrypted.
	/// In order to decrypt the string, the private key has to be passed.
	/// Both keys must be created with <code>createRsaKeys</code>.
	/// </p>
	/// </remarks>
	public: virtual ::std::wstring encryptStringRsa(const ::std::wstring& key, const ::std::wstring& data, bool encryptNotDecrypt)  = 0;
	public: virtual void encryptStringRsa(const ::std::wstring& key, const ::std::wstring& data, bool encryptNotDecrypt, ::std::function< void (::std::wstring, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// This function creates an activity project in memory.
	/// </summary>
	/// <remarks>
	/// <p>
	/// If projectName is not null and not empty, the function checks whether the name is already used.
	/// The current session must have the permission AccessC.FLAG_EDITACT in order to call this function.
	/// </p>
	/// </remarks>
	public: virtual PActivityProject createActivityProject(const ::std::wstring& projectName)  = 0;
	public: virtual void createActivityProject(const ::std::wstring& projectName, ::std::function< void (PActivityProject, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// This function writes an activity project into the database.
	/// </summary>
	/// <remarks>
	/// <p>
	/// The current session must have the permission AccessC.FLAG_EDITACT in order to call this function.
	/// </p>
	/// </remarks>
	public: virtual ::std::wstring checkinActivityProject(const PActivityProject& actProj, const PLockZ& unlockZ)  = 0;
	public: virtual void checkinActivityProject(const PActivityProject& actProj, const PLockZ& unlockZ, ::std::function< void (::std::wstring, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// This function reads and optionally locks an activity project.
	/// </summary>
	public: virtual PActivityProject checkoutActivityProject(const ::std::wstring& projectName, const PLockZ& lockZ)  = 0;
	public: virtual void checkoutActivityProject(const ::std::wstring& projectName, const PLockZ& lockZ, ::std::function< void (PActivityProject, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// This function deletes an activity project from the database.
	/// </summary>
	/// <remarks>
	/// <p>
	/// The current session must have the permission AccessC.FLAG_EDITACT in order to call this function.
	/// </p>
	/// </remarks>
	public: virtual void deleteActivityProject(const ::std::wstring& projectName, const PLockZ& unlockZ)  = 0;
	public: virtual void deleteActivityProject(const ::std::wstring& projectName, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// This function reads all activity projects.
	/// </summary>
	public: virtual PArrayActivityProject findActivityProjects(const PFindActivityProjectsInfo& findInfo)  = 0;
	public: virtual void findActivityProjects(const PFindActivityProjectsInfo& findInfo, ::std::function< void (PArrayActivityProject, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// This function creates an activity in memory based on the given project and assigned to the given object.
	/// </summary>
	/// <remarks>
	/// <p>
	/// The current session must have read access to the Sord, if parameter objId is specified.
	/// </p>
	/// </remarks>
	public: virtual PActivity createActivity(const ::std::wstring& projectName, const ::std::wstring& objId)  = 0;
	public: virtual void createActivity(const ::std::wstring& projectName, const ::std::wstring& objId, ::std::function< void (PActivity, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// This function inserts or updates an activity.
	/// </summary>
	/// <remarks>
	/// <p>
	/// The current session must have read access to the given Sord.
	/// In order to update an existing activity, the current session must be sender or receiver of the activity (Acitivty.senderId, Activity.receiverId).
	/// </p>
	/// </remarks>
	public: virtual ::std::wstring checkinActivity(const PActivity& act, const PLockZ& unlockZ)  = 0;
	public: virtual void checkinActivity(const PActivity& act, const PLockZ& unlockZ, ::std::function< void (::std::wstring, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// This function deletes an activity.
	/// </summary>
	/// <remarks>
	/// <p>
	/// The current session must be sender or receiver of the activity (Acitivty.senderId, Activity.receiverId).
	/// </p>
	/// </remarks>
	public: virtual void deleteActivity(const ::std::wstring& actGuid, const PDeleteActivityOptions& deleteOptions, const PLockZ& unlockZ)  = 0;
	public: virtual void deleteActivity(const ::std::wstring& actGuid, const PDeleteActivityOptions& deleteOptions, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// This function reads and optionally locks an activity.
	/// </summary>
	/// <remarks>
	/// <p>
	/// The current session must be sender or receiver of the activity (Acitivty.senderId, Activity.receiverId).
	/// </p>
	/// </remarks>
	public: virtual PActivity checkoutActivity(const ::std::wstring& actGuid, const PLockZ& lockZ)  = 0;
	public: virtual void checkoutActivity(const ::std::wstring& actGuid, const PLockZ& lockZ, ::std::function< void (PActivity, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// This function reads the activities of an object.
	/// </summary>
	public: virtual PFindResult findFirstActivities(const PFindActivityInfo& findInfo, int32_t max, const PActivityZ& activityZ)  = 0;
	public: virtual void findFirstActivities(const PFindActivityInfo& findInfo, int32_t max, const PActivityZ& activityZ, ::std::function< void (PFindResult, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// This function reads the next activites of an object.
	/// </summary>
	public: virtual PFindResult findNextActivities(const ::std::wstring& searchId, int32_t idx, int32_t max, const PActivityZ& activityZ)  = 0;
	public: virtual void findNextActivities(const ::std::wstring& searchId, int32_t idx, int32_t max, const PActivityZ& activityZ, ::std::function< void (PFindResult, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// This function is called from an OCR worker process to notify Indexserver about its state.
	/// </summary>
	/// <remarks>
	/// <p>
	/// The behavior of a OCR worker process is beyond the API documentation. Contact ELO support,
	/// if a different OCR has to be integrated.
	/// </p>
	/// </remarks>
	public: virtual POcrWorker registerOcrWorker(const POcrWorker& ocrWorker)  = 0;
	public: virtual void registerOcrWorker(const POcrWorker& ocrWorker, ::std::function< void (POcrWorker, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Compute OCR on the given image data or on an archived document.
	/// </summary>
	/// <remarks>
	/// <p>
	/// <i>In order to use this function, the ELO OCR Service 8.0 has to be installed somewhere on the network and
	/// has to be configured for Indexserver access.</i>
	/// </p><p>
	/// The request can be performed synchronously or asynchronously.
	/// In asynchronous processing, the result is sent via the Indexserver Event API.
	/// In order to receive the result, the client application has to register a listener for the event type
	/// EventBusC.EVENT_OCR_RESULT.
	/// </p><p>
	/// Use an empty OcrInfo object to check, whether OCR is available.
	/// </p><p>
	/// This is a simple example for synchronous OCR processing:
	/// <pre><code>
	/// IXConnection conn = ...
	/// String imageFile = ... // Input file in TIFF, etc. format
	/// String textFile = ... // Output file in text format
	/// <br/>
	/// // Is OCR via IX available? - Pass an empty OcrInfo object to processOcr in order to find it out.
	/// OcrInfo ocrInfo = new OcrInfo();
	/// bool isOcrAvail = conn.Ix.processOcr(ocrInfo) != null;
	/// if (!isOcrAvail) return;
	/// <br/>
	/// // Query the languages supported by the OCR Engine
	/// OcrInfo ocrInfoLangs = new OcrInfo();
	/// ocrInfoLangs.queryLanguages = new OcrInfoQueryLanguages();
	/// OcrResult ocrResultLangs = conn.Ix.processOcr(ocrInfoLangs);
	/// <br/>
	/// // Anaylze file
	/// // Load entire image into memory
	/// OcrInfo ocrInfo = new OcrInfo();
	/// ocrInfo.recognizeFile = new OcrInfoRecognizeFile();
	/// ocrInfo.recognizeFile.imageData = new FileData();
	/// ocrInfo.recognizeFile.imageData.data = File.ReadAllBytes(imageFile);
	/// ocrInfo.recognizeFile.imageData.contentType = Path.GetExtension(imageFile);
	/// ocrInfo.recognizeFile.pageNo = -1; // analyze all pages
	/// ocrInfo.recognizeFile.outputFormat = OcrInfoC.TEXT; // return result as String
	/// ocrInfo.recognizeFile.recognizeLangs = new String[] {"German", "Czech"}; // Choosen from ocrResultLangs.internalLangs
	/// <br/>
	/// // Process OCR
	/// OcrResult ocrResult = conn.Ix.processOcr(ocrInfo);
	/// <br/>
	/// // Write text output to file
	/// File.WriteAllText(textFile, ocrResult.recognizeFile.text, Encoding.UTF8);
	/// </code></pre>
	/// </p>
	/// </remarks>
	public: virtual POcrResult processOcr(const POcrInfo& ocrInfo)  = 0;
	public: virtual void processOcr(const POcrInfo& ocrInfo, ::std::function< void (POcrResult, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Evaluate the destination archive path based on filing definitions of a keywording from.
	/// </summary>
	/// <remarks>
	/// <p>
	/// This function evaluates the parent folder of a Sord object based on the filing
	/// definition of a keywording form WITHOUT storing the Sord object.
	/// This is in contrast to the checkinSord and checkinDocEnd functions which store the Sord object
	/// in the resulting parent.
	/// </p>
	/// </remarks>
	public: virtual PAutoFilingResult evalAutoFiling(const ::std::wstring& maskId, const PSord& sord, const PAutoFilingOptions& opts)  = 0;
	public: virtual void evalAutoFiling(const ::std::wstring& maskId, const PSord& sord, const PAutoFilingOptions& opts, ::std::function< void (PAutoFilingResult, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Reads the history entries for the given map.
	/// </summary>
	/// <remarks>
	/// <p>
	/// History entries are only written for MapDomain objects with {@link MapDomain#history}=true.
	/// For MapDomain objects with {@link MapDomain#history}=false, an empty array is returned.
	/// If no history entries exist for the given domainName and mapId, an empty array is returned.
	/// </p>
	/// </remarks>
	public: virtual PArrayMapHist checkoutMapHistory(const ::std::wstring& domainName, const ::std::wstring& mapId, const PMapHistZ& membersZ)  = 0;
	public: virtual void checkoutMapHistory(const ::std::wstring& domainName, const ::std::wstring& mapId, const PMapHistZ& membersZ, ::std::function< void (PArrayMapHist, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Prepares the IndexServer to enable a document to be checked in.
	/// </summary>
	/// <remarks>
	/// <p>
	/// Retrieves path id and encryption set from the sord object and sets these values in document versions
	/// of this document.
	/// In case of limited release document, work version is set to false.
	/// Document id will not be set to 0, if "keepIds" is true in option "opts" (when no new document but
	/// only signature should be added for a version controlled document, up to this version clients had
	/// to reset the actual document id after running method checkinDocBegin)
	/// </p>
	/// </remarks>
	public: virtual PDocument checkinDocBegin2(const PSord& sord, const PDocument& document, const PCheckinDocOptions& opts)  = 0;
	public: virtual void checkinDocBegin2(const PSord& sord, const PDocument& document, const PCheckinDocOptions& opts, ::std::function< void (PDocument, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Query the status of the job and control its state.
	/// </summary>
	/// <remarks>
	/// <p>
	/// Using this method the job can be cancelled. The user calling this method
	/// must have started the job or must have the administrator right
	/// (AccessC.FLAG_ADMIN).
	/// </p>
	/// </remarks>
	public: virtual PJobState controlBackgroundThread(const PJobState& jobState)  = 0;
	public: virtual void controlBackgroundThread(const PJobState& jobState, ::std::function< void (PJobState, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Query all jobs executed in the background.
	/// </summary>
	/// <remarks>
	/// <p>
	/// The method returns all jobs started by the calling user. If the user has
	/// the administrator right (AccessC.FLAG_ADMIN) the
	/// findBackgroundThreadOptions parameter can filter for users.
	/// </p>
	/// </remarks>
	public: virtual PFindResult findBackgroundThreads(const PFindBackgroundThreadOptions& findBackgroundThreadOptions)  = 0;
	public: virtual void findBackgroundThreads(const PFindBackgroundThreadOptions& findBackgroundThreadOptions, ::std::function< void (PFindResult, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Query the protocol of a background thread.
	/// </summary>
	/// <remarks>
	/// <p>
	/// The method returns all log messages that matches the restrictions given by
	/// the parameter queryJobProtocolInfo, and that are cached at the IndexServer.
	/// The amount of cached entries is configurable at the log4j configuration
	/// file.
	/// </p>
	/// </remarks>
	public: virtual PQueryJobProtocolResult queryJobProtocol(const PQueryJobProtocolInfo& queryJobProtocolInfo)  = 0;
	public: virtual void queryJobProtocol(const PQueryJobProtocolInfo& queryJobProtocolInfo, ::std::function< void (PQueryJobProtocolResult, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Queries dynamic keyword lists.
	/// </summary>
	/// <remarks>
	/// <p>
	/// A server script generates the data of dynamic keyword lists from external
	/// resources. Such resources may be databases of CRMs, webservices like
	/// twitter, an e-M@il provider, etc. The default installation does not provide
	/// any server scripts. They must be implemented by the end-user.
	/// </p>
	/// </remarks>
	public: virtual PKeywordsDynamicResult checkoutKeywordsDynamic(const PKeywordsDynamicInfo& keywordsDynamicInfo)  = 0;
	public: virtual void checkoutKeywordsDynamic(const PKeywordsDynamicInfo& keywordsDynamicInfo, ::std::function< void (PKeywordsDynamicResult, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Gets the list of Sord object which are the predecessors of the sord given by the objId.
	/// </summary>
	/// <remarks>
	/// <p>
	/// If csi.inclRefPaths is set, all the sord of the referenced paths are also returned.
	/// </p>
	/// </remarks>
	public: virtual PSordPaths checkoutSordPath(const ::std::wstring& objId, const PSordZ& sordZ, const PCheckoutSordPathInfo& csi)  = 0;
	public: virtual void checkoutSordPath(const ::std::wstring& objId, const PSordZ& sordZ, const PCheckoutSordPathInfo& csi, ::std::function< void (PSordPaths, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Generates URLs for preview images of documents.
	/// </summary>
	public: virtual PPreviewImageResult checkoutPreviewImageURLs(const PPreviewImageInfo& previewImageInfo)  = 0;
	public: virtual void checkoutPreviewImageURLs(const PPreviewImageInfo& previewImageInfo, ::std::function< void (PPreviewImageResult, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Specify, which notifications should be sent by the server.
	/// </summary>
	public: virtual PApplyForNotificationsInfo applyForNotifications(const PApplyForNotificationsInfo& info)  = 0;
	public: virtual void applyForNotifications(const PApplyForNotificationsInfo& info, ::std::function< void (PApplyForNotificationsInfo, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Gets the public downloads.
	/// </summary>
	public: virtual PVectorPublicDownload getPublicDownloads(const PPublicDownloadOptions& opts)  = 0;
	public: virtual void getPublicDownloads(const PPublicDownloadOptions& opts, ::std::function< void (PVectorPublicDownload, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Deletes the public downloads
	/// </summary>
	public: virtual void terminatePublicDownloadUrls(const PPublicDownloadOptions& opts)  = 0;
	public: virtual void terminatePublicDownloadUrls(const PPublicDownloadOptions& opts, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Edits the public downloads
	/// </summary>
	public: virtual void editPublicDownloadUrls(const PPublicDownloadOptions& opts)  = 0;
	public: virtual void editPublicDownloadUrls(const PPublicDownloadOptions& opts, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Resolves the rights of a user.
	/// </summary>
	/// <remarks>
	/// <p>
	/// This function calculates the effective rights of a given user. Hereby, the
	/// given parameter userInfo will not be checked in. This way it is possible to
	/// set hypothetical groups for the user and retrieve the results of the change
	/// without applying them. The effective rights always are calculated for every
	/// right.
	/// </p>
	/// <p>
	/// The groups of the given users will be combined with the groups he already
	/// is a member of. This combination works like the logical "or" function. If
	/// you want the result without a specific group, ignore the corresponding
	/// {@link ResolveRightsResult} which has set {@link ResolveRightsResult#type}=
	/// {@link ResolveRightsResultC#DIRECT}.
	/// </p>
	/// </remarks>
	public: virtual PVectorResolveRightsResult resolveRights(const PUserInfo& ui, const PResolveRightsInfo& info)  = 0;
	public: virtual void resolveRights(const PUserInfo& ui, const PResolveRightsInfo& info, ::std::function< void (PVectorResolveRightsResult, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Starts an Ad Hoc Workflow.
	/// </summary>
	public: virtual int32_t startAdHocWorkFlow2(const ::std::wstring& name, const ::std::wstring& objId, const PArrayUserNodeInfo& userNodeInfo, const PStartAdHocWorkflowInfo& startWfInfo)  = 0;
	public: virtual void startAdHocWorkFlow2(const ::std::wstring& name, const ::std::wstring& objId, const PArrayUserNodeInfo& userNodeInfo, const PStartAdHocWorkflowInfo& startWfInfo, ::std::function< void (int32_t, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Starts an Ad Hoc Workflow.
	/// </summary>
	public: virtual int32_t startAdHocWorkFlow3(const ::std::wstring& name, const ::std::wstring& objId, const PStartAdHocWorkflowInfo& startWfInfo)  = 0;
	public: virtual void startAdHocWorkFlow3(const ::std::wstring& name, const ::std::wstring& objId, const PStartAdHocWorkflowInfo& startWfInfo, ::std::function< void (int32_t, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Creates and inserts a new public download
	/// </summary>
	public: virtual PPublicDownload insertPublicDownload(const PPublicDownloadOptions& opts)  = 0;
	public: virtual void insertPublicDownload(const PPublicDownloadOptions& opts, ::std::function< void (PPublicDownload, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Initialize a subscription object.
	/// </summary>
	public: virtual PSubscription createSubscription(const ::std::wstring& watchGuid)  = 0;
	public: virtual void createSubscription(const ::std::wstring& watchGuid, ::std::function< void (PSubscription, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Add a subscription.
	/// </summary>
	public: virtual PSubscription checkinSubscription(const PSubscription& subs, const PSubscriptionZ& subsZ)  = 0;
	public: virtual void checkinSubscription(const PSubscription& subs, const PSubscriptionZ& subsZ, ::std::function< void (PSubscription, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Delete a subscription.
	/// </summary>
	public: virtual void deleteSubscription(const PSubscription& subs)  = 0;
	public: virtual void deleteSubscription(const PSubscription& subs, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Find first max subscriptions.
	/// </summary>
	/// <remarks>
	/// This function finds the subscriptions of the current user.
	/// </remarks>
	public: virtual PFindResult findFirstSubscriptions(const PFindSubscriptionInfo& findInfo, int32_t max, const PSubscriptionZ& subsZ)  = 0;
	public: virtual void findFirstSubscriptions(const PFindSubscriptionInfo& findInfo, int32_t max, const PSubscriptionZ& subsZ, ::std::function< void (PFindResult, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Find next max subscriptions beginning at index idx.
	/// </summary>
	public: virtual PFindResult findNextSubscriptions(const ::std::wstring& searchId, int32_t idx, int32_t max, const PSubscriptionZ& subsZ)  = 0;
	public: virtual void findNextSubscriptions(const ::std::wstring& searchId, int32_t idx, int32_t max, const PSubscriptionZ& subsZ, ::std::function< void (PFindResult, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Find first notes.
	/// </summary>
	/// <remarks>
	/// This function starts a search for Note object and returns the first objects found in {@link FindResult#notes}.
	/// At least {@link FindInfo#findByNotes} must be set. The member {@link FindInfo#findChildren} optionally
	/// constrain the results to a folder.
	/// The search must be closed with {@link #findClose(ClientInfo, String)} in order to release internally cached data.
	/// </remarks>
	public: virtual PFindResult findFirstNotes(const PFindInfo& findInfo, int32_t max, const PNoteZ& noteZ)  = 0;
	public: virtual void findFirstNotes(const PFindInfo& findInfo, int32_t max, const PNoteZ& noteZ, ::std::function< void (PFindResult, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Find next notes.
	/// </summary>
	/// <remarks>
	/// This function continues a search for Note objects startet with function {@link #findFirstNotes(ClientInfo, FindInfo, int, NoteZ)}.
	/// </remarks>
	public: virtual PFindResult findNextNotes(const ::std::wstring& searchId, int32_t idx, int32_t max, const PNoteZ& noteZ)  = 0;
	public: virtual void findNextNotes(const ::std::wstring& searchId, int32_t idx, int32_t max, const PNoteZ& noteZ, ::std::function< void (PFindResult, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Inserts custom report entries.
	/// </summary>
	/// <remarks>
	/// <p>
	/// This function writes new entries into the report table. These entries always
	/// are appended to the report table. Once in the report table, no data will be
	/// overwritten by this function. The ReportInfo element must provide an action
	/// number {@link ReportInfo#actionNo} at least. The action number has to be
	/// within the range {@link ReportInfoC#ACT_CUSTOM_FIRST} and
	/// {@link ReportInfoC#ACT_CUSTOM_LAST}. Besides the action number, the report
	/// entry can hold custom data in the fields objId, extra1, extra2, text and
	/// extraInfo. If specified, the object in extraInfo must be Serializable.
	/// If the report entry to insert does not belong to a {@link Sord}, set the
	/// objId value to 0.
	/// </p>
	/// </remarks>
	public: virtual void checkinReport(const PReportInfo& report, const PCheckinReportInfo& reserved, const PLockZ& lockZ)  = 0;
	public: virtual void checkinReport(const PReportInfo& report, const PCheckinReportInfo& reserved, const PLockZ& lockZ, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Links archive entries like {@link #linkSords}.
	/// </summary>
	/// <remarks>
	/// <p>This method provides the additional parameter {@link LinkSordInfo} to
	/// specify more options for linking sords together.</p>
	/// </remarks>
	public: virtual void linkSords2(const ::std::wstring& fromId, const PArrayString& toIds, const PLinkSordZ& linkSordZ, const PLinkSordInfo& linkSordInfo)  = 0;
	public: virtual void linkSords2(const ::std::wstring& fromId, const PArrayString& toIds, const PLinkSordZ& linkSordZ, const PLinkSordInfo& linkSordInfo, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Returns the WebDAV path from an Object ID.
	/// </summary>
	public: virtual ::std::wstring getWebDAVPathFromObjID(const ::std::wstring& objId)  = 0;
	public: virtual void getWebDAVPathFromObjID(const ::std::wstring& objId, ::std::function< void (::std::wstring, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Returns the WebDAV path from an Object ID.
	/// </summary>
	public: virtual PGetWebDAVPathResult getWebDAVPathFromObjID2(const PGetWebDAVPathOptions& options)  = 0;
	public: virtual void getWebDAVPathFromObjID2(const PGetWebDAVPathOptions& options, ::std::function< void (PGetWebDAVPathResult, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Reads the histories of a node or a whole workflow.
	/// </summary>
	public: virtual PCheckoutWorkflowHistoryResult checkoutWorkflowHistory(const PCheckoutWorkflowHistoryParams& checkoutWorkflowHistoryParams)  = 0;
	public: virtual void checkoutWorkflowHistory(const PCheckoutWorkflowHistoryParams& checkoutWorkflowHistoryParams, ::std::function< void (PCheckoutWorkflowHistoryResult, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Writes a keyword template into the database.
	/// </summary>
	/// <remarks>
	/// If this keyword template is already used in keywording forms, these keywording forms will be updated.
	/// This function requires ELO 10 license.
	/// </remarks>
	public: virtual int32_t checkinDocMaskLineTemplate(const PDocMaskLineTemplate& dmlt, const PDocMaskLineTemplateZ& dmltZ, const PCheckInDocMaskLineTemplateOptions& options, const PLockZ& lockZ)  = 0;
	public: virtual void checkinDocMaskLineTemplate(const PDocMaskLineTemplate& dmlt, const PDocMaskLineTemplateZ& dmltZ, const PCheckInDocMaskLineTemplateOptions& options, const PLockZ& lockZ, ::std::function< void (int32_t, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Check out keyword templates.
	/// </summary>
	/// <remarks>
	/// This function requires ELO 10 license.
	/// </remarks>
	public: virtual PArrayDocMaskLineTemplate checkoutDocMaskLineTemplates(const PArrayString& groups, const PDocMaskLineTemplateZ& dmltZ, const PLockZ& lockZ)  = 0;
	public: virtual void checkoutDocMaskLineTemplates(const PArrayString& groups, const PDocMaskLineTemplateZ& dmltZ, const PLockZ& lockZ, ::std::function< void (PArrayDocMaskLineTemplate, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Delete keyword templates
	/// This function requires ELO 10 license.
	/// </summary>
	public: virtual void deleteDocMaskLineTemplates(const PArrayString& groups, const PLockZ& unlockZ)  = 0;
	public: virtual void deleteDocMaskLineTemplates(const PArrayString& groups, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Prepare forwarding of a workflow node.
	/// </summary>
	/// <remarks>
	/// Use this function to lock a workflow and get the data required for forwarding a node.
	/// </remarks>
	public: virtual PWFEditNode beginForwardWorkflowNode(int32_t flowId, int32_t nodeId, const PBeginForwardWorkflowNodeInfo& fwdInfo, const PLockZ& lockZ)  = 0;
	public: virtual void beginForwardWorkflowNode(int32_t flowId, int32_t nodeId, const PBeginForwardWorkflowNodeInfo& fwdInfo, const PLockZ& lockZ, ::std::function< void (PWFEditNode, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Forward a workflow node, terminate a workflow or modify node data.
	/// </summary>
	/// <remarks>
	/// <h2>Example 1: Forward a workflow node:</h2>
	/// <p>
	/// <pre><code>
	/// // Lock workflow and read node data
	/// WFEditNode editNode = conn.ix().beginForwardWorkflowNode(flowId, nodeId, null, LockC.IF_FREE);
	/// // Select successor nodes to be activated
	/// // Make sure to select only one successor if: (editNode.getNode().getFlags() & WFNodeC.FLAG_ONE_SUCCESSOR) != 0
	/// List<Integer> succNodes = Arrays.asList(editNode.getSuccNodes()[0].getId());
	/// // Optionally: change node name and comment
	/// WFNode activeNode = editNode.getNode();
	/// activeNode.setName("new name");
	/// activeNode.setComment("new comment");
	/// // Forward
	/// ForwardWorkflowNodeInfo fwdInfo = new ForwardWorkflowNodeInfo();
	/// fwdInfo.setNode(activeNode);
	/// fwdInfo.setSuccessorNodesToActivate(succNodes);
	/// connU.ix().forwardWorkflowNode(flowId, nodeId, fwdInfo, LockC.YES);
	/// </code></pre>
	/// </p>
	/// <h2>Example 2: Cancel forwarding after beginForwardWorkflowNode has locked the workflow</h2>
	/// <p>
	/// <pre><code>
	/// // Lock workflow and read node data
	/// WFEditNode editNode = conn.ix().beginForwardWorkflowNode(flowId, nodeId, null, LockC.IF_FREE);
	/// // Cancel forward
	/// ForwardWorkflowNodeInfo fwdInfo = null;
	/// connU.ix().forwardWorkflowNode(flowId, nodeId, fwdInfo, LockC.YES);
	/// </code></pre>
	/// </p>
	/// <h2>Example 3: Change node priority, name and comment</h2>
	/// <p>
	/// <pre><code>
	/// </p>
	/// // Lock workflow
	/// WFEditNode editNode = conn.ix().beginForwardWorkflowNode(flowId, nodeId, null, LockC.IF_FREE);
	/// // Change node priority, name and comment
	/// WFNode activeNode = editNode.getNode();
	/// activeNode.setPrio(UserTaskPriorityC.HIGHEST);
	/// activeNode.setName("new name");
	/// activeNode.setComment("new comment");
	/// // Update node and unlock
	/// ForwardWorkflowNodeInfo fwdInfo = new ForwardWorkflowNodeInfo();
	/// fwdInfo.setNode(activeNode);
	/// connU.ix().forwardWorkflowNode(flowId, nodeId, fwdInfo, LockC.YES);
	/// </code></pre>
	/// </p>
	/// </remarks>
	public: virtual PForwardWorkflowNodeResult forwardWorkflowNode(int32_t flowId, int32_t nodeId, const PForwardWorkflowNodeInfo& fwdInfo, const PLockZ& unlockZ)  = 0;
	public: virtual void forwardWorkflowNode(int32_t flowId, int32_t nodeId, const PForwardWorkflowNodeInfo& fwdInfo, const PLockZ& unlockZ, ::std::function< void (PForwardWorkflowNodeResult, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Find user data.
	/// </summary>
	/// <remarks>
	/// This function allows to find users by their name, description, or one of their properties.
	/// Wildcards can be used as defined in the session options, see {@link SessionOptionsC#DB_WILDCARDS}.
	/// <p>
	/// Example:
	/// <pre><code class="example">
	/// FindUserInfo findUserInfo = new FindUserInfo();
	/// findUserInfo.setName("testFind?sers-*");
	/// int idx = 0, max = 100;
	/// FindResult fr = conn.ix().findFirstUsers(findUserInfo, max);
	/// try {
	/// while (true) {
	/// for (UserName userName : fr.getUserNames().values()) {
	/// // process userName object
	/// }
	/// 
	/// if (!fr.isMoreResults()) break;
	/// 
	/// idx += fr.getUserNames().length;
	/// fr = conn.ix().findNextUsers(fr.getSearchId(), idx, max);
	/// }
	/// }
	/// catch (RemoteException e) {
	/// // process exception
	/// throw e;
	/// }
	/// finally {
	/// conn.ix().findClose(fr.getSearchId());
	/// }
	/// </code></pre>
	/// </p>
	/// </remarks>
	public: virtual PFindResult findFirstUsers(const PFindUserInfo& findUserInfo, int32_t max)  = 0;
	public: virtual void findFirstUsers(const PFindUserInfo& findUserInfo, int32_t max, ::std::function< void (PFindResult, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Find next user data.
	/// </summary>
	public: virtual PFindResult findNextUsers(const ::std::wstring& searchId, int32_t idx, int32_t max)  = 0;
	public: virtual void findNextUsers(const ::std::wstring& searchId, int32_t idx, int32_t max, ::std::function< void (PFindResult, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Check licensing information.
	/// </summary>
	/// <remarks>
	/// This function checks the given license information using proprietary algorithms.
	/// </remarks>
	public: virtual PLicenseResult checkLicense(const PLicenseInfo& licenseInfo)  = 0;
	public: virtual void checkLicense(const PLicenseInfo& licenseInfo, ::std::function< void (PLicenseResult, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Move documents from one storage path to another storage path.
	/// </summary>
	public: virtual PJobState moveDocuments(const PMoveDocumentsInfo& moveDocumentsInfo)  = 0;
	public: virtual void moveDocuments(const PMoveDocumentsInfo& moveDocumentsInfo, ::std::function< void (PJobState, BException ex) > asyncResult)  = 0;
	
	
};

}}}}
//-------------------------------------------------
// Stub class BStub_IXServicePortIF

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

class BStub_IXServicePortIF;
typedef byps_ptr<BStub_IXServicePortIF> PStub_IXServicePortIF;

class BStub_IXServicePortIF : public BStub, public virtual IXServicePortIFAuth {
	
	public: BStub_IXServicePortIF(PTransport transport);	
	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: virtual void alive() ;
	public: virtual void alive(::std::function< void (bool, BException ex) > asyncResult) ;
	public: virtual PWFEditNode beginEditWorkFlowNode(int32_t nFlowId, int32_t nNodeId, const PLockZ& lockZ) ;
	public: virtual void beginEditWorkFlowNode(int32_t nFlowId, int32_t nNodeId, const PLockZ& lockZ, ::std::function< void (PWFEditNode, BException ex) > asyncResult) ;
	public: virtual PEditInfo changeSordMask(const PSord& sord, const ::std::wstring& maskId, const PEditInfoZ& editInfoZ) ;
	public: virtual void changeSordMask(const PSord& sord, const ::std::wstring& maskId, const PEditInfoZ& editInfoZ, ::std::function< void (PEditInfo, BException ex) > asyncResult) ;
	public: virtual void checkinColors(const PArrayColorData& colors, const PLockZ& unlockZ) ;
	public: virtual void checkinColors(const PArrayColorData& colors, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult) ;
	public: virtual void checkinConfigFiles(const PArrayConfigFile& configFiles, const PLockZ& unlockZ) ;
	public: virtual void checkinConfigFiles(const PArrayConfigFile& configFiles, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult) ;
	public: virtual PArrayConfigFile checkinConfigFilesBegin(const PArrayString& names) ;
	public: virtual void checkinConfigFilesBegin(const PArrayString& names, ::std::function< void (PArrayConfigFile, BException ex) > asyncResult) ;
	public: virtual PArrayConfigFile checkinConfigFilesEnd(const PArrayConfigFile& configFiles, const PLockZ& unlockZ) ;
	public: virtual void checkinConfigFilesEnd(const PArrayConfigFile& configFiles, const PLockZ& unlockZ, ::std::function< void (PArrayConfigFile, BException ex) > asyncResult) ;
	public: virtual void checkinCounters(const PArrayCounterInfo& counterInfos, const PLockZ& unlockZ) ;
	public: virtual void checkinCounters(const PArrayCounterInfo& counterInfos, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult) ;
	public: virtual PDocument checkinDocBegin(const PDocument& document) ;
	public: virtual void checkinDocBegin(const PDocument& document, ::std::function< void (PDocument, BException ex) > asyncResult) ;
	public: virtual PDocument checkinDocDupl(const PSord& sord, const PSordZ& sordZ, const PDocument& document, const PLockZ& unlockZ) ;
	public: virtual void checkinDocDupl(const PSord& sord, const PSordZ& sordZ, const PDocument& document, const PLockZ& unlockZ, ::std::function< void (PDocument, BException ex) > asyncResult) ;
	public: virtual PDocument checkinDocEnd(const PSord& sord, const PSordZ& sordZ, const PDocument& document, const PLockZ& unlockZ) ;
	public: virtual void checkinDocEnd(const PSord& sord, const PSordZ& sordZ, const PDocument& document, const PLockZ& unlockZ, ::std::function< void (PDocument, BException ex) > asyncResult) ;
	public: virtual int32_t checkinDocMask(const PDocMask& docMask, const PDocMaskZ& docMaskZ, const PLockZ& unlockZ) ;
	public: virtual void checkinDocMask(const PDocMask& docMask, const PDocMaskZ& docMaskZ, const PLockZ& unlockZ, ::std::function< void (int32_t, BException ex) > asyncResult) ;
	public: virtual PArrayDocument checkinDocsBegin(const PArrayDocument& documents) ;
	public: virtual void checkinDocsBegin(const PArrayDocument& documents, ::std::function< void (PArrayDocument, BException ex) > asyncResult) ;
	public: virtual PArrayDocument checkinDocsEnd(const PArraySord& sords, const PArraySordZ& sordZs, const PArrayDocument& documents, const PLockZ& unlockZ) ;
	public: virtual void checkinDocsEnd(const PArraySord& sords, const PArraySordZ& sordZs, const PArrayDocument& documents, const PLockZ& unlockZ, ::std::function< void (PArrayDocument, BException ex) > asyncResult) ;
	public: virtual PArrayInt checkinKeys(const PArrayKeyInfo& keyInfos, const PLockZ& unlockZ) ;
	public: virtual void checkinKeys(const PArrayKeyInfo& keyInfos, const PLockZ& unlockZ, ::std::function< void (PArrayInt, BException ex) > asyncResult) ;
	public: virtual void checkinKeywords(const PArrayKeyword& kws, const PLockZ& unlockZ) ;
	public: virtual void checkinKeywords(const PArrayKeyword& kws, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult) ;
	public: virtual PArrayInt checkinNotes(const ::std::wstring& objId, const PArrayNote& notes, const PNoteZ& noteZ, const PLockZ& unlockZ) ;
	public: virtual void checkinNotes(const ::std::wstring& objId, const PArrayNote& notes, const PNoteZ& noteZ, const PLockZ& unlockZ, ::std::function< void (PArrayInt, BException ex) > asyncResult) ;
	public: virtual PNotification checkinNotification(const PNotification& notif, const PNotificationZ& notiZ) ;
	public: virtual void checkinNotification(const PNotification& notif, const PNotificationZ& notiZ, ::std::function< void (PNotification, BException ex) > asyncResult) ;
	public: virtual PArrayInt checkinReminder(const PReminder& remi, const PArrayString& receiverIds, bool expandGroups, const PLockZ& unlockZ) ;
	public: virtual void checkinReminder(const PReminder& remi, const PArrayString& receiverIds, bool expandGroups, const PLockZ& unlockZ, ::std::function< void (PArrayInt, BException ex) > asyncResult) ;
	public: virtual void checkinReplNames(const PArrayReplSetName& replNames, const PLockZ& unlockZ) ;
	public: virtual void checkinReplNames(const PArrayReplSetName& replNames, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult) ;
	public: virtual void checkinReportOptions(const PReportOptions& options, const PLockZ& unlockZ) ;
	public: virtual void checkinReportOptions(const PReportOptions& options, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult) ;
	public: virtual int32_t checkinSord(const PSord& sord, const PSordZ& sordZ, const PLockZ& unlockZ) ;
	public: virtual void checkinSord(const PSord& sord, const PSordZ& sordZ, const PLockZ& unlockZ, ::std::function< void (int32_t, BException ex) > asyncResult) ;
	public: virtual PArrayInt checkinSordPath(const ::std::wstring& parentId, const PArraySord& sords, const PSordZ& sordZ) ;
	public: virtual void checkinSordPath(const ::std::wstring& parentId, const PArraySord& sords, const PSordZ& sordZ, ::std::function< void (PArrayInt, BException ex) > asyncResult) ;
	public: virtual void checkinSordTypes(const PArraySordType& sordTypes, const PLockZ& unlockZ) ;
	public: virtual void checkinSordTypes(const PArraySordType& sordTypes, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult) ;
	public: virtual PArrayStoreInfo checkinStorage(const PArrayStoreInfo& storeInfos, const PLockZ& unlockZ) ;
	public: virtual void checkinStorage(const PArrayStoreInfo& storeInfos, const PLockZ& unlockZ, ::std::function< void (PArrayStoreInfo, BException ex) > asyncResult) ;
	public: virtual void checkinSubs(const PArraySubsInfo& deps, const PLockZ& unlockZ) ;
	public: virtual void checkinSubs(const PArraySubsInfo& deps, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult) ;
	public: virtual void checkinUserProfile(const PUserProfile& userProfile, const PLockZ& unlockZ) ;
	public: virtual void checkinUserProfile(const PUserProfile& userProfile, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult) ;
	public: virtual PArrayInt checkinUsers(const PArrayUserInfo& userInfos, const PCheckinUsersZ& checkinUsersZ, const PLockZ& unlockZ) ;
	public: virtual void checkinUsers(const PArrayUserInfo& userInfos, const PCheckinUsersZ& checkinUsersZ, const PLockZ& unlockZ, ::std::function< void (PArrayInt, BException ex) > asyncResult) ;
	public: virtual PMapIntegerOrgUnitInfo checkinOrgUnits(const PArrayOrgUnitInfo& orgUnitInfos, const PCheckinOrgUnitInfo& reserved, const PLockZ& unlockZ) ;
	public: virtual void checkinOrgUnits(const PArrayOrgUnitInfo& orgUnitInfos, const PCheckinOrgUnitInfo& reserved, const PLockZ& unlockZ, ::std::function< void (PMapIntegerOrgUnitInfo, BException ex) > asyncResult) ;
	public: virtual void deleteOrgUnits(const PArrayString& ids, const PLockZ& unlockZ) ;
	public: virtual void deleteOrgUnits(const PArrayString& ids, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult) ;
	public: virtual PMapIntegerOrgUnitInfo checkoutOrgUnits(const PCheckoutOrgUnitInfo& reserved, const PLockZ& lockZ) ;
	public: virtual void checkoutOrgUnits(const PCheckoutOrgUnitInfo& reserved, const PLockZ& lockZ, ::std::function< void (PMapIntegerOrgUnitInfo, BException ex) > asyncResult) ;
	public: virtual int32_t checkinWorkFlow(const PWFDiagram& wf, const PWFDiagramZ& workFlowDiagramZ, const PLockZ& unlockZ) ;
	public: virtual void checkinWorkFlow(const PWFDiagram& wf, const PWFDiagramZ& workFlowDiagramZ, const PLockZ& unlockZ, ::std::function< void (int32_t, BException ex) > asyncResult) ;
	public: virtual PArrayColorData checkoutColors(const PLockZ& lockZ) ;
	public: virtual void checkoutColors(const PLockZ& lockZ, ::std::function< void (PArrayColorData, BException ex) > asyncResult) ;
	public: virtual PArrayConfigFile checkoutConfigFiles(const PArrayString& names, const PConfigFileZ& configFileZ, const PLockZ& lockZ) ;
	public: virtual void checkoutConfigFiles(const PArrayString& names, const PConfigFileZ& configFileZ, const PLockZ& lockZ, ::std::function< void (PArrayConfigFile, BException ex) > asyncResult) ;
	public: virtual PArrayCounterInfo checkoutCounters(const PArrayString& counterNames, bool incrementCounters, const PLockZ& lockZ) ;
	public: virtual void checkoutCounters(const PArrayString& counterNames, bool incrementCounters, const PLockZ& lockZ, ::std::function< void (PArrayCounterInfo, BException ex) > asyncResult) ;
	public: virtual PEditInfo checkoutDoc(const ::std::wstring& objId, const ::std::wstring& docId, const PEditInfoZ& editInfoZ, const PLockZ& lockZ) ;
	public: virtual void checkoutDoc(const ::std::wstring& objId, const ::std::wstring& docId, const PEditInfoZ& editInfoZ, const PLockZ& lockZ, ::std::function< void (PEditInfo, BException ex) > asyncResult) ;
	public: virtual PDocMask checkoutDocMask(const ::std::wstring& maskId, const PDocMaskZ& docMaskZ, const PLockZ& lockZ) ;
	public: virtual void checkoutDocMask(const ::std::wstring& maskId, const PDocMaskZ& docMaskZ, const PLockZ& lockZ, ::std::function< void (PDocMask, BException ex) > asyncResult) ;
	public: virtual PArrayKeyInfo checkoutKeys(const PArrayString& ids, const PLockZ& lockZ) ;
	public: virtual void checkoutKeys(const PArrayString& ids, const PLockZ& lockZ, ::std::function< void (PArrayKeyInfo, BException ex) > asyncResult) ;
	public: virtual PArrayKeyword checkoutKeywords(const PArrayString& kwids, const PKeywordZ& keywordZ, int32_t max, const PLockZ& lockZ) ;
	public: virtual void checkoutKeywords(const PArrayString& kwids, const PKeywordZ& keywordZ, int32_t max, const PLockZ& lockZ, ::std::function< void (PArrayKeyword, BException ex) > asyncResult) ;
	public: virtual PArrayNote checkoutNotes(const ::std::wstring& objId, const PArrayString& noteIds, const PNoteZ& noteZ, const PLockZ& lockZ) ;
	public: virtual void checkoutNotes(const ::std::wstring& objId, const PArrayString& noteIds, const PNoteZ& noteZ, const PLockZ& lockZ, ::std::function< void (PArrayNote, BException ex) > asyncResult) ;
	public: virtual PNotification checkoutNotification(const ::std::wstring& watchGuid, const ::std::wstring& userGuid) ;
	public: virtual void checkoutNotification(const ::std::wstring& watchGuid, const ::std::wstring& userGuid, ::std::function< void (PNotification, BException ex) > asyncResult) ;
	public: virtual PArrayReminder checkoutReminders(const PArrayInt& reminderIds, const PLockZ& lockZ) ;
	public: virtual void checkoutReminders(const PArrayInt& reminderIds, const PLockZ& lockZ, ::std::function< void (PArrayReminder, BException ex) > asyncResult) ;
	public: virtual PArrayReplSetName checkoutReplNames(const PLockZ& lockZ) ;
	public: virtual void checkoutReplNames(const PLockZ& lockZ, ::std::function< void (PArrayReplSetName, BException ex) > asyncResult) ;
	public: virtual PReportOptions checkoutReportOptions(const PLockZ& lockZ) ;
	public: virtual void checkoutReportOptions(const PLockZ& lockZ, ::std::function< void (PReportOptions, BException ex) > asyncResult) ;
	public: virtual PEditInfo checkoutSord(const ::std::wstring& objId, const PEditInfoZ& editInfoZ, const PLockZ& lockZ) ;
	public: virtual void checkoutSord(const ::std::wstring& objId, const PEditInfoZ& editInfoZ, const PLockZ& lockZ, ::std::function< void (PEditInfo, BException ex) > asyncResult) ;
	public: virtual PArraySordHist checkoutSordHistory(const ::std::wstring& objId) ;
	public: virtual void checkoutSordHistory(const ::std::wstring& objId, ::std::function< void (PArraySordHist, BException ex) > asyncResult) ;
	public: virtual PArraySordType checkoutSordTypes(const PArrayInt& sordTypeIds, const PSordTypeZ& sordTypeZ, const PLockZ& lockZ) ;
	public: virtual void checkoutSordTypes(const PArrayInt& sordTypeIds, const PSordTypeZ& sordTypeZ, const PLockZ& lockZ, ::std::function< void (PArraySordType, BException ex) > asyncResult) ;
	public: virtual PArrayStoreInfo checkoutStorage(const PArrayString& ids, const PLockZ& lockZ) ;
	public: virtual void checkoutStorage(const PArrayString& ids, const PLockZ& lockZ, ::std::function< void (PArrayStoreInfo, BException ex) > asyncResult) ;
	public: virtual PArraySubsInfo checkoutSubs(const ::std::wstring& userId, const PLockZ& lockZ) ;
	public: virtual void checkoutSubs(const ::std::wstring& userId, const PLockZ& lockZ, ::std::function< void (PArraySubsInfo, BException ex) > asyncResult) ;
	public: virtual PUserProfile checkoutUserProfile(const PUserProfile& userProfile, const PLockZ& lockZ) ;
	public: virtual void checkoutUserProfile(const PUserProfile& userProfile, const PLockZ& lockZ, ::std::function< void (PUserProfile, BException ex) > asyncResult) ;
	public: virtual PArrayUserInfo checkoutUsers(const PArrayString& ids, const PCheckoutUsersZ& checkoutUsersZ, const PLockZ& lockZ) ;
	public: virtual void checkoutUsers(const PArrayString& ids, const PCheckoutUsersZ& checkoutUsersZ, const PLockZ& lockZ, ::std::function< void (PArrayUserInfo, BException ex) > asyncResult) ;
	public: virtual PWFDiagram checkoutWorkFlow(const ::std::wstring& flowId, const PWFTypeZ& typeZ, const PWFDiagramZ& workFlowDiagramZ, const PLockZ& lockZ) ;
	public: virtual void checkoutWorkFlow(const ::std::wstring& flowId, const PWFTypeZ& typeZ, const PWFDiagramZ& workFlowDiagramZ, const PLockZ& lockZ, ::std::function< void (PWFDiagram, BException ex) > asyncResult) ;
	public: virtual bool cleanupStart(const PDeleteOptions& deleteOptions) ;
	public: virtual void cleanupStart(const PDeleteOptions& deleteOptions, ::std::function< void (bool, BException ex) > asyncResult) ;
	public: virtual PJobState cleanupState() ;
	public: virtual void cleanupState(::std::function< void (PJobState, BException ex) > asyncResult) ;
	public: virtual bool cleanupStop() ;
	public: virtual void cleanupStop(::std::function< void (bool, BException ex) > asyncResult) ;
	public: virtual PArrayJobState collectJobStates(bool activeJobs, bool finishedJobs, bool fullInfo) ;
	public: virtual void collectJobStates(bool activeJobs, bool finishedJobs, bool fullInfo, ::std::function< void (PArrayJobState, BException ex) > asyncResult) ;
	public: virtual PArrayWFCollectNode collectWorkFlowNodes(const ::std::wstring& flowName, const PWFTypeZ& wfTypeZ, const ::std::wstring& nodeName, int32_t nodeType, const ::std::wstring& objId, const ::std::wstring& enterDateIso, const ::std::wstring& exitDateIso, const PArrayString& userIds, bool onlyActive, bool onlyStartNodes) ;
	public: virtual void collectWorkFlowNodes(const ::std::wstring& flowName, const PWFTypeZ& wfTypeZ, const ::std::wstring& nodeName, int32_t nodeType, const ::std::wstring& objId, const ::std::wstring& enterDateIso, const ::std::wstring& exitDateIso, const PArrayString& userIds, bool onlyActive, bool onlyStartNodes, ::std::function< void (PArrayWFCollectNode, BException ex) > asyncResult) ;
	public: virtual PArrayIdName collectWorkFlows(const PWFTypeZ& typeZ) ;
	public: virtual void collectWorkFlows(const PWFTypeZ& typeZ, ::std::function< void (PArrayIdName, BException ex) > asyncResult) ;
	public: virtual PFindResult findFirstWorkflows(const PFindWorkflowInfo& findInfo, int32_t max, const PWFDiagramZ& wfDiagramZ) ;
	public: virtual void findFirstWorkflows(const PFindWorkflowInfo& findInfo, int32_t max, const PWFDiagramZ& wfDiagramZ, ::std::function< void (PFindResult, BException ex) > asyncResult) ;
	public: virtual PFindResult findNextWorkflows(const ::std::wstring& searchId, int32_t index, int32_t maxResults) ;
	public: virtual void findNextWorkflows(const ::std::wstring& searchId, int32_t index, int32_t maxResults, ::std::function< void (PFindResult, BException ex) > asyncResult) ;
	public: virtual ::std::wstring cookKeyword(const ::std::wstring& kwid) ;
	public: virtual void cookKeyword(const ::std::wstring& kwid, ::std::function< void (::std::wstring, BException ex) > asyncResult) ;
	public: virtual int32_t copySord(const ::std::wstring& newParentId, const ::std::wstring& objId, const PCopyInfo& copyInfo, const PCopySordZ& copySordZ) ;
	public: virtual void copySord(const ::std::wstring& newParentId, const ::std::wstring& objId, const PCopyInfo& copyInfo, const PCopySordZ& copySordZ, ::std::function< void (int32_t, BException ex) > asyncResult) ;
	public: virtual PEditInfo createDoc(const ::std::wstring& parentId, const ::std::wstring& maskId, const ::std::wstring& docTemplate, const PEditInfoZ& editInfoZ) ;
	public: virtual void createDoc(const ::std::wstring& parentId, const ::std::wstring& maskId, const ::std::wstring& docTemplate, const PEditInfoZ& editInfoZ, ::std::function< void (PEditInfo, BException ex) > asyncResult) ;
	public: virtual PDocMask createDocMask(const ::std::wstring& maskId) ;
	public: virtual void createDocMask(const ::std::wstring& maskId, ::std::function< void (PDocMask, BException ex) > asyncResult) ;
	public: virtual PKeyInfo createKey() ;
	public: virtual void createKey(::std::function< void (PKeyInfo, BException ex) > asyncResult) ;
	public: virtual PNote createNote(const ::std::wstring& objId) ;
	public: virtual void createNote(const ::std::wstring& objId, ::std::function< void (PNote, BException ex) > asyncResult) ;
	public: virtual PNote createNote2(const ::std::wstring& objId, int32_t noteType, const ::std::wstring& templId) ;
	public: virtual void createNote2(const ::std::wstring& objId, int32_t noteType, const ::std::wstring& templId, ::std::function< void (PNote, BException ex) > asyncResult) ;
	public: virtual PReminder createReminder(const ::std::wstring& objId) ;
	public: virtual void createReminder(const ::std::wstring& objId, ::std::function< void (PReminder, BException ex) > asyncResult) ;
	public: virtual PEditInfo createSord(const ::std::wstring& parentId, const ::std::wstring& maskId, const PEditInfoZ& editInfoZ) ;
	public: virtual void createSord(const ::std::wstring& parentId, const ::std::wstring& maskId, const PEditInfoZ& editInfoZ, ::std::function< void (PEditInfo, BException ex) > asyncResult) ;
	public: virtual PUserInfo createUser(const ::std::wstring& rightsAsUserId) ;
	public: virtual void createUser(const ::std::wstring& rightsAsUserId, ::std::function< void (PUserInfo, BException ex) > asyncResult) ;
	public: virtual PWFNode createWFNode(int32_t nodeId, int32_t nodeTypeC) ;
	public: virtual void createWFNode(int32_t nodeId, int32_t nodeTypeC, ::std::function< void (PWFNode, BException ex) > asyncResult) ;
	public: virtual PWFDiagram createWorkFlow(const ::std::wstring& wfName, const PWFTypeZ& typeZ) ;
	public: virtual void createWorkFlow(const ::std::wstring& wfName, const PWFTypeZ& typeZ, ::std::function< void (PWFDiagram, BException ex) > asyncResult) ;
	public: virtual void deleteConfigFiles(const PArrayString& names, const PLockZ& unlockZ) ;
	public: virtual void deleteConfigFiles(const PArrayString& names, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult) ;
	public: virtual void deleteCounters(const PArrayString& counterNames, const PLockZ& unlockZ) ;
	public: virtual void deleteCounters(const PArrayString& counterNames, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult) ;
	public: virtual bool deleteDocMask(const ::std::wstring& maskId, const ::std::wstring& assignMaskId, const PLockZ& unlockZ) ;
	public: virtual void deleteDocMask(const ::std::wstring& maskId, const ::std::wstring& assignMaskId, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult) ;
	public: virtual void deleteKeys(const PArrayString& ids, const PLockZ& unlockZ) ;
	public: virtual void deleteKeys(const PArrayString& ids, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult) ;
	public: virtual void deleteKeywords(const PArrayString& kwids, const PLockZ& unlockZ) ;
	public: virtual void deleteKeywords(const PArrayString& kwids, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult) ;
	public: virtual void deleteNotes(const PArrayString& noteIds, const PLockZ& unlockZ) ;
	public: virtual void deleteNotes(const PArrayString& noteIds, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult) ;
	public: virtual int32_t deleteNotification(const ::std::wstring& objGuid, const ::std::wstring& userGuid) ;
	public: virtual void deleteNotification(const ::std::wstring& objGuid, const ::std::wstring& userGuid, ::std::function< void (int32_t, BException ex) > asyncResult) ;
	public: virtual void deleteReminders(const PArrayInt& reminderIds, const PLockZ& unlockZ) ;
	public: virtual void deleteReminders(const PArrayInt& reminderIds, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult) ;
	public: virtual void deleteReport(const ::std::wstring& endDateISO) ;
	public: virtual void deleteReport(const ::std::wstring& endDateISO, ::std::function< void (bool, BException ex) > asyncResult) ;
	public: virtual bool deleteSord(const ::std::wstring& parentId, const ::std::wstring& objId, const PLockZ& unlockZ, const PDeleteOptions& deleteOptions) ;
	public: virtual void deleteSord(const ::std::wstring& parentId, const ::std::wstring& objId, const PLockZ& unlockZ, const PDeleteOptions& deleteOptions, ::std::function< void (bool, BException ex) > asyncResult) ;
	public: virtual void deleteSordTypes(const PArrayInt& sordTypeIds, const PLockZ& unlockZ) ;
	public: virtual void deleteSordTypes(const PArrayInt& sordTypeIds, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult) ;
	public: virtual void deleteSubs(const PArraySubsInfo& deps, const PLockZ& unlockZ) ;
	public: virtual void deleteSubs(const PArraySubsInfo& deps, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult) ;
	public: virtual void deleteUserProfile(const PUserProfile& userProfile, const PLockZ& unlockZ) ;
	public: virtual void deleteUserProfile(const PUserProfile& userProfile, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult) ;
	public: virtual void deleteUsers(const PArrayString& ids, const PLockZ& unlockZ) ;
	public: virtual void deleteUsers(const PArrayString& ids, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult) ;
	public: virtual void deleteWorkFlow(const ::std::wstring& flowId, const PWFTypeZ& typeZ, const PLockZ& unlockZ) ;
	public: virtual void deleteWorkFlow(const ::std::wstring& flowId, const PWFTypeZ& typeZ, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult) ;
	public: virtual void endEditWorkFlowNode(int32_t nFlowId, int32_t nNodeId, bool bTerminate, bool bCancel, const ::std::wstring& sName, const ::std::wstring& sComment, const PArrayInt& arrEnterNodesIds) ;
	public: virtual void endEditWorkFlowNode(int32_t nFlowId, int32_t nNodeId, bool bTerminate, bool bCancel, const ::std::wstring& sName, const ::std::wstring& sComment, const PArrayInt& arrEnterNodesIds, ::std::function< void (bool, BException ex) > asyncResult) ;
	public: virtual void findClose(const ::std::wstring& searchId) ;
	public: virtual void findClose(const ::std::wstring& searchId, ::std::function< void (bool, BException ex) > asyncResult) ;
	public: virtual PFindResult findFirstConfigFiles(const PFindConfigFileInfo& findInfo, int32_t max, const PConfigFileZ& configFileZ) ;
	public: virtual void findFirstConfigFiles(const PFindConfigFileInfo& findInfo, int32_t max, const PConfigFileZ& configFileZ, ::std::function< void (PFindResult, BException ex) > asyncResult) ;
	public: virtual PFindResult findFirstReportInfos(const PFindReportInfo& opts, int32_t max) ;
	public: virtual void findFirstReportInfos(const PFindReportInfo& opts, int32_t max, ::std::function< void (PFindResult, BException ex) > asyncResult) ;
	public: virtual PFindResult findFirstSords(const PFindInfo& findInfo, int32_t max, const PSordZ& sordZ) ;
	public: virtual void findFirstSords(const PFindInfo& findInfo, int32_t max, const PSordZ& sordZ, ::std::function< void (PFindResult, BException ex) > asyncResult) ;
	public: virtual PFindResult findFirstTasks(const PFindTasksInfo& findInfo, int32_t max) ;
	public: virtual void findFirstTasks(const PFindTasksInfo& findInfo, int32_t max, ::std::function< void (PFindResult, BException ex) > asyncResult) ;
	public: virtual PFindResult findNextConfigFiles(const ::std::wstring& searchId, int32_t idx, int32_t max, const PConfigFileZ& configFileZ) ;
	public: virtual void findNextConfigFiles(const ::std::wstring& searchId, int32_t idx, int32_t max, const PConfigFileZ& configFileZ, ::std::function< void (PFindResult, BException ex) > asyncResult) ;
	public: virtual PFindResult findNextReportInfos(const ::std::wstring& searchId, int32_t idx, int32_t max) ;
	public: virtual void findNextReportInfos(const ::std::wstring& searchId, int32_t idx, int32_t max, ::std::function< void (PFindResult, BException ex) > asyncResult) ;
	public: virtual PFindResult findNextSords(const ::std::wstring& searchId, int32_t idx, int32_t max, const PSordZ& sordZ) ;
	public: virtual void findNextSords(const ::std::wstring& searchId, int32_t idx, int32_t max, const PSordZ& sordZ, ::std::function< void (PFindResult, BException ex) > asyncResult) ;
	public: virtual PFindResult findNextTasks(const ::std::wstring& searchId, int32_t idx, int32_t max) ;
	public: virtual void findNextTasks(const ::std::wstring& searchId, int32_t idx, int32_t max, ::std::function< void (PFindResult, BException ex) > asyncResult) ;
	public: virtual void finishExport(const ::std::wstring& exportId) ;
	public: virtual void finishExport(const ::std::wstring& exportId, ::std::function< void (bool, BException ex) > asyncResult) ;
	public: virtual PIXServicePortC getConstants() ;
	public: virtual void getConstants(::std::function< void (PIXServicePortC, BException ex) > asyncResult) ;
	public: virtual ::std::wstring getExportZipUrl(const ::std::wstring& exportId) ;
	public: virtual void getExportZipUrl(const ::std::wstring& exportId, ::std::function< void (::std::wstring, BException ex) > asyncResult) ;
	public: virtual ::std::wstring getImportZipUrl(const ::std::wstring& importId) ;
	public: virtual void getImportZipUrl(const ::std::wstring& importId, ::std::function< void (::std::wstring, BException ex) > asyncResult) ;
	public: virtual PServerInfo getServerInfo() ;
	public: virtual void getServerInfo(::std::function< void (PServerInfo, BException ex) > asyncResult) ;
	public: virtual void setServerInfo(const PServerInfo& serverInfo) ;
	public: virtual void setServerInfo(const PServerInfo& serverInfo, ::std::function< void (bool, BException ex) > asyncResult) ;
	public: virtual PServerInfoDM getServerInfoDM() ;
	public: virtual void getServerInfoDM(::std::function< void (PServerInfoDM, BException ex) > asyncResult) ;
	public: virtual void setServerInfoDM(const PServerInfoDM& serverInfo) ;
	public: virtual void setServerInfoDM(const PServerInfoDM& serverInfo, ::std::function< void (bool, BException ex) > asyncResult) ;
	public: virtual PSessionOptions getSessionOptions() ;
	public: virtual void getSessionOptions(::std::function< void (PSessionOptions, BException ex) > asyncResult) ;
	public: virtual PArrayUserName getUserNames(const PArrayString& ids, const PCheckoutUsersZ& checkoutUsersZ) ;
	public: virtual void getUserNames(const PArrayString& ids, const PCheckoutUsersZ& checkoutUsersZ, ::std::function< void (PArrayUserName, BException ex) > asyncResult) ;
	public: virtual int32_t importWorkFlow(const ::std::wstring& flowName, const PBytes& fileData) ;
	public: virtual void importWorkFlow(const ::std::wstring& flowName, const PBytes& fileData, ::std::function< void (int32_t, BException ex) > asyncResult) ;
	public: virtual int32_t importWorkFlow2(const ::std::wstring& flowName, const PBytes& fileData, const PWorkflowImportOptions& importOptions) ;
	public: virtual void importWorkFlow2(const ::std::wstring& flowName, const PBytes& fileData, const PWorkflowImportOptions& importOptions, ::std::function< void (int32_t, BException ex) > asyncResult) ;
	public: virtual void linkSords(const ::std::wstring& fromId, const PArrayString& toIds, const PLinkSordZ& linkZ) ;
	public: virtual void linkSords(const ::std::wstring& fromId, const PArrayString& toIds, const PLinkSordZ& linkZ, ::std::function< void (bool, BException ex) > asyncResult) ;
	public: virtual int32_t lockArchive(const ::std::wstring& keyId) ;
	public: virtual void lockArchive(const ::std::wstring& keyId, ::std::function< void (int32_t, BException ex) > asyncResult) ;
	public: virtual PLoginResult login(const ::std::wstring& userName, const ::std::wstring& userPwd, const ::std::wstring& clientComputer, const ::std::wstring& runAsUser) ;
	public: virtual void login(const ::std::wstring& userName, const ::std::wstring& userPwd, const ::std::wstring& clientComputer, const ::std::wstring& runAsUser, ::std::function< void (PLoginResult, BException ex) > asyncResult) ;
	public: virtual PLoginResult loginAdmin(const ::std::wstring& userName, const ::std::wstring& userPwd, const ::std::wstring& clientComputer, const ::std::wstring& reportAsUser) ;
	public: virtual void loginAdmin(const ::std::wstring& userName, const ::std::wstring& userPwd, const ::std::wstring& clientComputer, const ::std::wstring& reportAsUser, ::std::function< void (PLoginResult, BException ex) > asyncResult) ;
	public: virtual PLoginResult loginEloProf(int32_t userId, const ::std::wstring& certificate, const ::std::wstring& clientComputer) ;
	public: virtual void loginEloProf(int32_t userId, const ::std::wstring& certificate, const ::std::wstring& clientComputer, ::std::function< void (PLoginResult, BException ex) > asyncResult) ;
	public: virtual PLoginResult loginKerberos(const PBytes& ticket, const ::std::wstring& clientComputer) ;
	public: virtual void loginKerberos(const PBytes& ticket, const ::std::wstring& clientComputer, ::std::function< void (PLoginResult, BException ex) > asyncResult) ;
	public: virtual void logout() ;
	public: virtual void logout(::std::function< void (bool, BException ex) > asyncResult) ;
	public: virtual PIXExceptionData parseException(const ::std::wstring& exceptionString) ;
	public: virtual void parseException(const ::std::wstring& exceptionString, ::std::function< void (PIXExceptionData, BException ex) > asyncResult) ;
	public: virtual PJobState processFindResult(const ::std::wstring& searchId, const PProcessInfo& procInfo) ;
	public: virtual void processFindResult(const ::std::wstring& searchId, const PProcessInfo& procInfo, ::std::function< void (PJobState, BException ex) > asyncResult) ;
	public: virtual PJobState processTrees(const PNavigationInfo& navigationInfo, const PProcessInfo& procInfo) ;
	public: virtual void processTrees(const PNavigationInfo& navigationInfo, const PProcessInfo& procInfo, ::std::function< void (PJobState, BException ex) > asyncResult) ;
	public: virtual PJobState queryJobState(const ::std::wstring& jobGuid, bool activeJobs, bool finishedJobs, bool fullInfo) ;
	public: virtual void queryJobState(const ::std::wstring& jobGuid, bool activeJobs, bool finishedJobs, bool fullInfo, ::std::function< void (PJobState, BException ex) > asyncResult) ;
	public: virtual void refSord(const ::std::wstring& oldParentId, const ::std::wstring& newParentId, const ::std::wstring& objId, int32_t manSortIdx) ;
	public: virtual void refSord(const ::std::wstring& oldParentId, const ::std::wstring& newParentId, const ::std::wstring& objId, int32_t manSortIdx, ::std::function< void (bool, BException ex) > asyncResult) ;
	public: virtual bool restoreSord(const ::std::wstring& objId, const PRestoreOptions& restoreOptions) ;
	public: virtual void restoreSord(const ::std::wstring& objId, const PRestoreOptions& restoreOptions, ::std::function< void (bool, BException ex) > asyncResult) ;
	public: virtual void setSessionOptions(const PSessionOptions& opts) ;
	public: virtual void setSessionOptions(const PSessionOptions& opts, ::std::function< void (bool, BException ex) > asyncResult) ;
	public: virtual int32_t startAdHocWorkFlow(const ::std::wstring& name, const ::std::wstring& objId, const PArrayString& arrUserIds, const ::std::wstring& nodeName, bool forValidation, bool serialFlow, const ::std::wstring& cancelUserId, const ::std::wstring& cancelMessage, const ::std::wstring& finishedUserId, const ::std::wstring& finishedMessage, const ::std::wstring& finishedScript) ;
	public: virtual void startAdHocWorkFlow(const ::std::wstring& name, const ::std::wstring& objId, const PArrayString& arrUserIds, const ::std::wstring& nodeName, bool forValidation, bool serialFlow, const ::std::wstring& cancelUserId, const ::std::wstring& cancelMessage, const ::std::wstring& finishedUserId, const ::std::wstring& finishedMessage, const ::std::wstring& finishedScript, ::std::function< void (int32_t, BException ex) > asyncResult) ;
	public: virtual ::std::wstring startExport(const PArrayString& topLevelIDs, int64_t options) ;
	public: virtual void startExport(const PArrayString& topLevelIDs, int64_t options, ::std::function< void (::std::wstring, BException ex) > asyncResult) ;
	public: virtual ::std::wstring startExportExt(const PExportExtOptions& options) ;
	public: virtual void startExportExt(const PExportExtOptions& options, ::std::function< void (::std::wstring, BException ex) > asyncResult) ;
	public: virtual ::std::wstring startImport(const ::std::wstring& filingPath, int32_t guidMethod, int64_t options) ;
	public: virtual void startImport(const ::std::wstring& filingPath, int32_t guidMethod, int64_t options, ::std::function< void (::std::wstring, BException ex) > asyncResult) ;
	public: virtual int32_t startWorkFlow(const ::std::wstring& templFlowId, const ::std::wstring& flowName, const ::std::wstring& objId) ;
	public: virtual void startWorkFlow(const ::std::wstring& templFlowId, const ::std::wstring& flowName, const ::std::wstring& objId, ::std::function< void (int32_t, BException ex) > asyncResult) ;
	public: virtual void takeWorkFlowNode(int32_t nFlowId, int32_t nNodeId, const ::std::wstring& sUserId, int32_t nFlags, const PLockZ& lockZ) ;
	public: virtual void takeWorkFlowNode(int32_t nFlowId, int32_t nNodeId, const ::std::wstring& sUserId, int32_t nFlags, const PLockZ& lockZ, ::std::function< void (bool, BException ex) > asyncResult) ;
	public: virtual int32_t terminateWorkFlow(const ::std::wstring& flowId, const PLockZ& unlockZ) ;
	public: virtual void terminateWorkFlow(const ::std::wstring& flowId, const PLockZ& unlockZ, ::std::function< void (int32_t, BException ex) > asyncResult) ;
	public: virtual void delegateWorkFlowNode(const PWFDelegateNodeInfo& delegateNodeInfo, const PLockZ& lockZ) ;
	public: virtual void delegateWorkFlowNode(const PWFDelegateNodeInfo& delegateNodeInfo, const PLockZ& lockZ, ::std::function< void (bool, BException ex) > asyncResult) ;
	public: virtual void deferWorkFlowNode(const ::std::wstring& flowId, int32_t nodeId, const ::std::wstring& userDelayDateIso, const PLockZ& lockZ) ;
	public: virtual void deferWorkFlowNode(const ::std::wstring& flowId, int32_t nodeId, const ::std::wstring& userDelayDateIso, const PLockZ& lockZ, ::std::function< void (bool, BException ex) > asyncResult) ;
	public: virtual PArrayString testAdapter(const ::std::wstring& fn, const PArrayString& params) ;
	public: virtual void testAdapter(const ::std::wstring& fn, const PArrayString& params, ::std::function< void (PArrayString, BException ex) > asyncResult) ;
	public: virtual void unlinkSords(const ::std::wstring& fromId, const PArrayString& toIds, const PLinkSordZ& linkZ) ;
	public: virtual void unlinkSords(const ::std::wstring& fromId, const PArrayString& toIds, const PLinkSordZ& linkZ, ::std::function< void (bool, BException ex) > asyncResult) ;
	public: virtual PArrayCryptInfo checkoutCryptInfos(const PArrayString& ids, const PLockZ& lockZ) ;
	public: virtual void checkoutCryptInfos(const PArrayString& ids, const PLockZ& lockZ, ::std::function< void (PArrayCryptInfo, BException ex) > asyncResult) ;
	public: virtual void checkinCryptInfos(const PArrayCryptInfo& cryptInfos, const PLockZ& unlockZ) ;
	public: virtual void checkinCryptInfos(const PArrayCryptInfo& cryptInfos, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult) ;
	public: virtual void provideCryptPassword(const ::std::wstring& encryptionSet, const ::std::wstring& pwd) ;
	public: virtual void provideCryptPassword(const ::std::wstring& encryptionSet, const ::std::wstring& pwd, ::std::function< void (bool, BException ex) > asyncResult) ;
	public: virtual void invalidateCache(int32_t flags) ;
	public: virtual void invalidateCache(int32_t flags, ::std::function< void (bool, BException ex) > asyncResult) ;
	public: virtual PInvalidateCacheResult invalidateCache2(const PInvalidateCacheInfo& info) ;
	public: virtual void invalidateCache2(const PInvalidateCacheInfo& info, ::std::function< void (PInvalidateCacheResult, BException ex) > asyncResult) ;
	public: virtual PFindResult findFirstTranslateTerms(const PFindTranslateTermInfo& findInfo, int32_t max) ;
	public: virtual void findFirstTranslateTerms(const PFindTranslateTermInfo& findInfo, int32_t max, ::std::function< void (PFindResult, BException ex) > asyncResult) ;
	public: virtual PFindResult findNextTranslateTerms(const ::std::wstring& searchId, int32_t idx, int32_t max) ;
	public: virtual void findNextTranslateTerms(const ::std::wstring& searchId, int32_t idx, int32_t max, ::std::function< void (PFindResult, BException ex) > asyncResult) ;
	public: virtual PArrayTranslateTerm checkoutTranslateTerms(const PArrayString& termIds, const PLockZ& lockZ) ;
	public: virtual void checkoutTranslateTerms(const PArrayString& termIds, const PLockZ& lockZ, ::std::function< void (PArrayTranslateTerm, BException ex) > asyncResult) ;
	public: virtual PArrayString checkinTranslateTerms(const PArrayTranslateTerm& tterms, const PLockZ& unlockZ) ;
	public: virtual void checkinTranslateTerms(const PArrayTranslateTerm& tterms, const PLockZ& unlockZ, ::std::function< void (PArrayString, BException ex) > asyncResult) ;
	public: virtual void deleteTranslateTerms(const PArrayString& termIds, const PLockZ& unlockZ) ;
	public: virtual void deleteTranslateTerms(const PArrayString& termIds, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult) ;
	public: virtual PArrayWFVersion getWorkflowTemplateVersions(const ::std::wstring& flowId, bool onlyDeleted) ;
	public: virtual void getWorkflowTemplateVersions(const ::std::wstring& flowId, bool onlyDeleted, ::std::function< void (PArrayWFVersion, BException ex) > asyncResult) ;
	public: virtual PWFDiagram checkoutWorkflowTemplate(const ::std::wstring& flowId, const ::std::wstring& versionId, const PWFDiagramZ& wfZ, const PLockZ& lockZ) ;
	public: virtual void checkoutWorkflowTemplate(const ::std::wstring& flowId, const ::std::wstring& versionId, const PWFDiagramZ& wfZ, const PLockZ& lockZ, ::std::function< void (PWFDiagram, BException ex) > asyncResult) ;
	public: virtual PArrayInt checkinWorkflowTemplate(const PWFDiagram& wf, const PWFDiagramZ& wfZ, const PLockZ& unlockZ) ;
	public: virtual void checkinWorkflowTemplate(const PWFDiagram& wf, const PWFDiagramZ& wfZ, const PLockZ& unlockZ, ::std::function< void (PArrayInt, BException ex) > asyncResult) ;
	public: virtual void deleteWorkflowTemplate(const ::std::wstring& flowId, const ::std::wstring& versionId, const PLockZ& unlockZ) ;
	public: virtual void deleteWorkflowTemplate(const ::std::wstring& flowId, const ::std::wstring& versionId, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult) ;
	public: virtual PArrayNoteTemplate checkoutNoteTemplates(const ::std::wstring& userId, const PArrayString& ids, const PNoteTemplateZ& ntemplZ, const PLockZ& lockZ) ;
	public: virtual void checkoutNoteTemplates(const ::std::wstring& userId, const PArrayString& ids, const PNoteTemplateZ& ntemplZ, const PLockZ& lockZ, ::std::function< void (PArrayNoteTemplate, BException ex) > asyncResult) ;
	public: virtual PNoteTemplate createNoteTemplate(const ::std::wstring& userId) ;
	public: virtual void createNoteTemplate(const ::std::wstring& userId, ::std::function< void (PNoteTemplate, BException ex) > asyncResult) ;
	public: virtual void deleteNoteTemplates(const ::std::wstring& userId, const PArrayString& ids, const PLockZ& unlockZ) ;
	public: virtual void deleteNoteTemplates(const ::std::wstring& userId, const PArrayString& ids, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult) ;
	public: virtual PArrayInt checkinNoteTemplates(const PArrayNoteTemplate& noteTemplates, const PNoteTemplateZ& ntemplZ, const PLockZ& unlockZ) ;
	public: virtual void checkinNoteTemplates(const PArrayNoteTemplate& noteTemplates, const PNoteTemplateZ& ntemplZ, const PLockZ& unlockZ, ::std::function< void (PArrayInt, BException ex) > asyncResult) ;
	public: virtual void reload() ;
	public: virtual void reload(::std::function< void (bool, BException ex) > asyncResult) ;
	public: virtual void reloadScripts() ;
	public: virtual void reloadScripts(::std::function< void (bool, BException ex) > asyncResult) ;
	public: virtual byps::PMapIntegerString getCompiledScripts() ;
	public: virtual void getCompiledScripts(::std::function< void (byps::PMapIntegerString, BException ex) > asyncResult) ;
	public: virtual ::std::wstring getScriptsToDebug() ;
	public: virtual void getScriptsToDebug(::std::function< void (::std::wstring, BException ex) > asyncResult) ;
	public: virtual void setScriptsToDebug(const ::std::wstring& scriptsToDebug) ;
	public: virtual void setScriptsToDebug(const ::std::wstring& scriptsToDebug, ::std::function< void (bool, BException ex) > asyncResult) ;
	public: virtual int32_t getDebuggerPort() ;
	public: virtual void getDebuggerPort(::std::function< void (int32_t, BException ex) > asyncResult) ;
	public: virtual void deleteKeywordList(const ::std::wstring& kwid, const PLockZ& unlockZ) ;
	public: virtual void deleteKeywordList(const ::std::wstring& kwid, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult) ;
	public: virtual PKeywordList checkoutKeywordList(const ::std::wstring& kwid, const PKeywordZ& keywordZ, int32_t max, const PLockZ& lockZ) ;
	public: virtual void checkoutKeywordList(const ::std::wstring& kwid, const PKeywordZ& keywordZ, int32_t max, const PLockZ& lockZ, ::std::function< void (PKeywordList, BException ex) > asyncResult) ;
	public: virtual void checkinKeywordList(const PKeywordList& kwList, const PLockZ& unlockZ) ;
	public: virtual void checkinKeywordList(const PKeywordList& kwList, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult) ;
	public: virtual PCombineAclResult combineAcl(const PArrayAclItem& lhs, const PArrayAclItem& rhs, const PCombineAclOptions& options) ;
	public: virtual void combineAcl(const PArrayAclItem& lhs, const PArrayAclItem& rhs, const PCombineAclOptions& options, ::std::function< void (PCombineAclResult, BException ex) > asyncResult) ;
	public: virtual PAclAccessResult getAclAccess(const PAclAccessInfo& aai) ;
	public: virtual void getAclAccess(const PAclAccessInfo& aai, ::std::function< void (PAclAccessResult, BException ex) > asyncResult) ;
	public: virtual PArrayEditInfo getEditInfoFromESW(const PArrayFileData& fileDatas, const PEditInfoEswOptions& eswOptions) ;
	public: virtual void getEditInfoFromESW(const PArrayFileData& fileDatas, const PEditInfoEswOptions& eswOptions, ::std::function< void (PArrayEditInfo, BException ex) > asyncResult) ;
	public: virtual PArrayFileData getESWFromEditInfo(const PArrayEditInfo& editInfos, const PEditInfoEswOptions& eswOptions) ;
	public: virtual void getESWFromEditInfo(const PArrayEditInfo& editInfos, const PEditInfoEswOptions& eswOptions, ::std::function< void (PArrayFileData, BException ex) > asyncResult) ;
	public: virtual PLoginResult getSessionFromTicket(int32_t options) ;
	public: virtual void getSessionFromTicket(int32_t options, ::std::function< void (PLoginResult, BException ex) > asyncResult) ;
	public: virtual PArraySessionInfo getSessionInfos(const PSessionInfoParams& params) ;
	public: virtual void getSessionInfos(const PSessionInfoParams& params, ::std::function< void (PArraySessionInfo, BException ex) > asyncResult) ;
	public: virtual PExecuteScriptResult executeScript(const PExecuteScriptParams& params) ;
	public: virtual void executeScript(const PExecuteScriptParams& params, ::std::function< void (PExecuteScriptResult, BException ex) > asyncResult) ;
	public: virtual PFileData exportWorkflow(const PWorkflowExportOptions& wfExportOptions) ;
	public: virtual void exportWorkflow(const PWorkflowExportOptions& wfExportOptions, ::std::function< void (PFileData, BException ex) > asyncResult) ;
	public: virtual PValuesOfObjKey getDistinctValuesOfObjKey(const ::std::wstring& okeyName, const PValuesOfObjKeyOptions& opts) ;
	public: virtual void getDistinctValuesOfObjKey(const ::std::wstring& okeyName, const PValuesOfObjKeyOptions& opts, ::std::function< void (PValuesOfObjKey, BException ex) > asyncResult) ;
	public: virtual PArchiveStatistics getArchiveStatistics(int64_t opts) ;
	public: virtual void getArchiveStatistics(int64_t opts, ::std::function< void (PArchiveStatistics, BException ex) > asyncResult) ;
	public: virtual PArrayMapDomain collectMapDomains() ;
	public: virtual void collectMapDomains(::std::function< void (PArrayMapDomain, BException ex) > asyncResult) ;
	public: virtual void checkinMapDomain(const PMapDomain& mapDomain, const PLockZ& unlockZ) ;
	public: virtual void checkinMapDomain(const PMapDomain& mapDomain, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult) ;
	public: virtual PMapDomain checkoutMapDomain(const ::std::wstring& domainName, const PLockZ& lockZ) ;
	public: virtual void checkoutMapDomain(const ::std::wstring& domainName, const PLockZ& lockZ, ::std::function< void (PMapDomain, BException ex) > asyncResult) ;
	public: virtual void deleteMapDomain(const ::std::wstring& domainName, const PLockZ& unlockZ) ;
	public: virtual void deleteMapDomain(const ::std::wstring& domainName, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult) ;
	public: virtual void checkinMap(const ::std::wstring& domainName, const ::std::wstring& id, int32_t objId, const PArrayKeyValue& data, const PLockZ& unlockZ) ;
	public: virtual void checkinMap(const ::std::wstring& domainName, const ::std::wstring& id, int32_t objId, const PArrayKeyValue& data, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult) ;
	public: virtual PMapData checkoutMap(const ::std::wstring& domainName, const ::std::wstring& id, const PArrayString& keyNames, const PLockZ& lockZ) ;
	public: virtual void checkoutMap(const ::std::wstring& domainName, const ::std::wstring& id, const PArrayString& keyNames, const PLockZ& lockZ, ::std::function< void (PMapData, BException ex) > asyncResult) ;
	public: virtual void deleteMap(const ::std::wstring& domainName, const ::std::wstring& id, const PArrayString& keyNames, const PLockZ& unlockZ) ;
	public: virtual void deleteMap(const ::std::wstring& domainName, const ::std::wstring& id, const PArrayString& keyNames, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult) ;
	public: virtual PArrayContextTerm getContextTerms(const PFindInfo& findInfo, const ::std::wstring& field, int32_t max) ;
	public: virtual void getContextTerms(const PFindInfo& findInfo, const ::std::wstring& field, int32_t max, ::std::function< void (PArrayContextTerm, BException ex) > asyncResult) ;
	public: virtual PAny executeRegisteredFunction(const ::std::wstring& functionName, const PAny& param) ;
	public: virtual void executeRegisteredFunction(const ::std::wstring& functionName, const PAny& param, ::std::function< void (PAny, BException ex) > asyncResult) ;
	public: virtual ::std::wstring executeRegisteredFunctionString(const ::std::wstring& functionName, const ::std::wstring& param) ;
	public: virtual void executeRegisteredFunctionString(const ::std::wstring& functionName, const ::std::wstring& param, ::std::function< void (::std::wstring, BException ex) > asyncResult) ;
	public: virtual PArrayString getSearchTerms(const PFindInfo& findInfo, int32_t termType) ;
	public: virtual void getSearchTerms(const PFindInfo& findInfo, int32_t termType, ::std::function< void (PArrayString, BException ex) > asyncResult) ;
	public: virtual int32_t adminMode(int32_t mode) ;
	public: virtual void adminMode(int32_t mode, ::std::function< void (int32_t, BException ex) > asyncResult) ;
	public: virtual PFulltextConfig configureFulltext(const ::std::wstring& userId, const PFulltextConfig& opts) ;
	public: virtual void configureFulltext(const ::std::wstring& userId, const PFulltextConfig& opts, ::std::function< void (PFulltextConfig, BException ex) > asyncResult) ;
	public: virtual PNotifyServerResult notifyServer(const PNotifyServerInfo& msg) ;
	public: virtual void notifyServer(const PNotifyServerInfo& msg, ::std::function< void (PNotifyServerResult, BException ex) > asyncResult) ;
	public: virtual PArrayBackupProfile configureBackup(const PArrayBackupProfile& backupProfiles) ;
	public: virtual void configureBackup(const PArrayBackupProfile& backupProfiles, ::std::function< void (PArrayBackupProfile, BException ex) > asyncResult) ;
	public: virtual PBackupPurgeStatus controlBackup(const PControlBackupInfo& controlBackupInfo) ;
	public: virtual void controlBackup(const PControlBackupInfo& controlBackupInfo, ::std::function< void (PBackupPurgeStatus, BException ex) > asyncResult) ;
	public: virtual PPurgeSettings configurePurge(const PPurgeSettings& purgeSettings) ;
	public: virtual void configurePurge(const PPurgeSettings& purgeSettings, ::std::function< void (PPurgeSettings, BException ex) > asyncResult) ;
	public: virtual ::std::wstring addUrlParams(const ::std::wstring& url, const PUrlParams& params) ;
	public: virtual void addUrlParams(const ::std::wstring& url, const PUrlParams& params, ::std::function< void (::std::wstring, BException ex) > asyncResult) ;
	public: virtual int64_t openEventBus(const PEventBusParams& params) ;
	public: virtual void openEventBus(const PEventBusParams& params, ::std::function< void (int64_t, BException ex) > asyncResult) ;
	public: virtual void closeEventBus(int64_t busId) ;
	public: virtual void closeEventBus(int64_t busId, ::std::function< void (bool, BException ex) > asyncResult) ;
	public: virtual int64_t createEventBusSubscriber() ;
	public: virtual void createEventBusSubscriber(::std::function< void (int64_t, BException ex) > asyncResult) ;
	public: virtual void deleteEventBusSubscriber(int64_t subsId) ;
	public: virtual void deleteEventBusSubscriber(int64_t subsId, ::std::function< void (bool, BException ex) > asyncResult) ;
	public: virtual int64_t createEventBusListener(int64_t subsId, const PEventListener& eventListener) ;
	public: virtual void createEventBusListener(int64_t subsId, const PEventListener& eventListener, ::std::function< void (int64_t, BException ex) > asyncResult) ;
	public: virtual void deleteEventBusListener(int64_t lsnId) ;
	public: virtual void deleteEventBusListener(int64_t lsnId, ::std::function< void (bool, BException ex) > asyncResult) ;
	public: virtual PArrayEvent internalReceiveEvents(int64_t subsId, int64_t timeoutMillis) ;
	public: virtual void internalReceiveEvents(int64_t subsId, int64_t timeoutMillis, ::std::function< void (PArrayEvent, BException ex) > asyncResult) ;
	public: virtual void sendEvents(int64_t subsId, const PArrayEvent& events) ;
	public: virtual void sendEvents(int64_t subsId, const PArrayEvent& events, ::std::function< void (bool, BException ex) > asyncResult) ;
	public: virtual PArrayString createRsaKeys() ;
	public: virtual void createRsaKeys(::std::function< void (PArrayString, BException ex) > asyncResult) ;
	public: virtual ::std::wstring encryptStringRsa(const ::std::wstring& key, const ::std::wstring& data, bool encryptNotDecrypt) ;
	public: virtual void encryptStringRsa(const ::std::wstring& key, const ::std::wstring& data, bool encryptNotDecrypt, ::std::function< void (::std::wstring, BException ex) > asyncResult) ;
	public: virtual PActivityProject createActivityProject(const ::std::wstring& projectName) ;
	public: virtual void createActivityProject(const ::std::wstring& projectName, ::std::function< void (PActivityProject, BException ex) > asyncResult) ;
	public: virtual ::std::wstring checkinActivityProject(const PActivityProject& actProj, const PLockZ& unlockZ) ;
	public: virtual void checkinActivityProject(const PActivityProject& actProj, const PLockZ& unlockZ, ::std::function< void (::std::wstring, BException ex) > asyncResult) ;
	public: virtual PActivityProject checkoutActivityProject(const ::std::wstring& projectName, const PLockZ& lockZ) ;
	public: virtual void checkoutActivityProject(const ::std::wstring& projectName, const PLockZ& lockZ, ::std::function< void (PActivityProject, BException ex) > asyncResult) ;
	public: virtual void deleteActivityProject(const ::std::wstring& projectName, const PLockZ& unlockZ) ;
	public: virtual void deleteActivityProject(const ::std::wstring& projectName, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult) ;
	public: virtual PArrayActivityProject findActivityProjects(const PFindActivityProjectsInfo& findInfo) ;
	public: virtual void findActivityProjects(const PFindActivityProjectsInfo& findInfo, ::std::function< void (PArrayActivityProject, BException ex) > asyncResult) ;
	public: virtual PActivity createActivity(const ::std::wstring& projectName, const ::std::wstring& objId) ;
	public: virtual void createActivity(const ::std::wstring& projectName, const ::std::wstring& objId, ::std::function< void (PActivity, BException ex) > asyncResult) ;
	public: virtual ::std::wstring checkinActivity(const PActivity& act, const PLockZ& unlockZ) ;
	public: virtual void checkinActivity(const PActivity& act, const PLockZ& unlockZ, ::std::function< void (::std::wstring, BException ex) > asyncResult) ;
	public: virtual void deleteActivity(const ::std::wstring& actGuid, const PDeleteActivityOptions& deleteOptions, const PLockZ& unlockZ) ;
	public: virtual void deleteActivity(const ::std::wstring& actGuid, const PDeleteActivityOptions& deleteOptions, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult) ;
	public: virtual PActivity checkoutActivity(const ::std::wstring& actGuid, const PLockZ& lockZ) ;
	public: virtual void checkoutActivity(const ::std::wstring& actGuid, const PLockZ& lockZ, ::std::function< void (PActivity, BException ex) > asyncResult) ;
	public: virtual PFindResult findFirstActivities(const PFindActivityInfo& findInfo, int32_t max, const PActivityZ& activityZ) ;
	public: virtual void findFirstActivities(const PFindActivityInfo& findInfo, int32_t max, const PActivityZ& activityZ, ::std::function< void (PFindResult, BException ex) > asyncResult) ;
	public: virtual PFindResult findNextActivities(const ::std::wstring& searchId, int32_t idx, int32_t max, const PActivityZ& activityZ) ;
	public: virtual void findNextActivities(const ::std::wstring& searchId, int32_t idx, int32_t max, const PActivityZ& activityZ, ::std::function< void (PFindResult, BException ex) > asyncResult) ;
	public: virtual POcrWorker registerOcrWorker(const POcrWorker& ocrWorker) ;
	public: virtual void registerOcrWorker(const POcrWorker& ocrWorker, ::std::function< void (POcrWorker, BException ex) > asyncResult) ;
	public: virtual POcrResult processOcr(const POcrInfo& ocrInfo) ;
	public: virtual void processOcr(const POcrInfo& ocrInfo, ::std::function< void (POcrResult, BException ex) > asyncResult) ;
	public: virtual PAutoFilingResult evalAutoFiling(const ::std::wstring& maskId, const PSord& sord, const PAutoFilingOptions& opts) ;
	public: virtual void evalAutoFiling(const ::std::wstring& maskId, const PSord& sord, const PAutoFilingOptions& opts, ::std::function< void (PAutoFilingResult, BException ex) > asyncResult) ;
	public: virtual PArrayMapHist checkoutMapHistory(const ::std::wstring& domainName, const ::std::wstring& mapId, const PMapHistZ& membersZ) ;
	public: virtual void checkoutMapHistory(const ::std::wstring& domainName, const ::std::wstring& mapId, const PMapHistZ& membersZ, ::std::function< void (PArrayMapHist, BException ex) > asyncResult) ;
	public: virtual PDocument checkinDocBegin2(const PSord& sord, const PDocument& document, const PCheckinDocOptions& opts) ;
	public: virtual void checkinDocBegin2(const PSord& sord, const PDocument& document, const PCheckinDocOptions& opts, ::std::function< void (PDocument, BException ex) > asyncResult) ;
	public: virtual PJobState controlBackgroundThread(const PJobState& jobState) ;
	public: virtual void controlBackgroundThread(const PJobState& jobState, ::std::function< void (PJobState, BException ex) > asyncResult) ;
	public: virtual PFindResult findBackgroundThreads(const PFindBackgroundThreadOptions& findBackgroundThreadOptions) ;
	public: virtual void findBackgroundThreads(const PFindBackgroundThreadOptions& findBackgroundThreadOptions, ::std::function< void (PFindResult, BException ex) > asyncResult) ;
	public: virtual PQueryJobProtocolResult queryJobProtocol(const PQueryJobProtocolInfo& queryJobProtocolInfo) ;
	public: virtual void queryJobProtocol(const PQueryJobProtocolInfo& queryJobProtocolInfo, ::std::function< void (PQueryJobProtocolResult, BException ex) > asyncResult) ;
	public: virtual PKeywordsDynamicResult checkoutKeywordsDynamic(const PKeywordsDynamicInfo& keywordsDynamicInfo) ;
	public: virtual void checkoutKeywordsDynamic(const PKeywordsDynamicInfo& keywordsDynamicInfo, ::std::function< void (PKeywordsDynamicResult, BException ex) > asyncResult) ;
	public: virtual PSordPaths checkoutSordPath(const ::std::wstring& objId, const PSordZ& sordZ, const PCheckoutSordPathInfo& csi) ;
	public: virtual void checkoutSordPath(const ::std::wstring& objId, const PSordZ& sordZ, const PCheckoutSordPathInfo& csi, ::std::function< void (PSordPaths, BException ex) > asyncResult) ;
	public: virtual PPreviewImageResult checkoutPreviewImageURLs(const PPreviewImageInfo& previewImageInfo) ;
	public: virtual void checkoutPreviewImageURLs(const PPreviewImageInfo& previewImageInfo, ::std::function< void (PPreviewImageResult, BException ex) > asyncResult) ;
	public: virtual PApplyForNotificationsInfo applyForNotifications(const PApplyForNotificationsInfo& info) ;
	public: virtual void applyForNotifications(const PApplyForNotificationsInfo& info, ::std::function< void (PApplyForNotificationsInfo, BException ex) > asyncResult) ;
	public: virtual PVectorPublicDownload getPublicDownloads(const PPublicDownloadOptions& opts) ;
	public: virtual void getPublicDownloads(const PPublicDownloadOptions& opts, ::std::function< void (PVectorPublicDownload, BException ex) > asyncResult) ;
	public: virtual void terminatePublicDownloadUrls(const PPublicDownloadOptions& opts) ;
	public: virtual void terminatePublicDownloadUrls(const PPublicDownloadOptions& opts, ::std::function< void (bool, BException ex) > asyncResult) ;
	public: virtual void editPublicDownloadUrls(const PPublicDownloadOptions& opts) ;
	public: virtual void editPublicDownloadUrls(const PPublicDownloadOptions& opts, ::std::function< void (bool, BException ex) > asyncResult) ;
	public: virtual PVectorResolveRightsResult resolveRights(const PUserInfo& ui, const PResolveRightsInfo& info) ;
	public: virtual void resolveRights(const PUserInfo& ui, const PResolveRightsInfo& info, ::std::function< void (PVectorResolveRightsResult, BException ex) > asyncResult) ;
	public: virtual int32_t startAdHocWorkFlow2(const ::std::wstring& name, const ::std::wstring& objId, const PArrayUserNodeInfo& userNodeInfo, const PStartAdHocWorkflowInfo& startWfInfo) ;
	public: virtual void startAdHocWorkFlow2(const ::std::wstring& name, const ::std::wstring& objId, const PArrayUserNodeInfo& userNodeInfo, const PStartAdHocWorkflowInfo& startWfInfo, ::std::function< void (int32_t, BException ex) > asyncResult) ;
	public: virtual int32_t startAdHocWorkFlow3(const ::std::wstring& name, const ::std::wstring& objId, const PStartAdHocWorkflowInfo& startWfInfo) ;
	public: virtual void startAdHocWorkFlow3(const ::std::wstring& name, const ::std::wstring& objId, const PStartAdHocWorkflowInfo& startWfInfo, ::std::function< void (int32_t, BException ex) > asyncResult) ;
	public: virtual PPublicDownload insertPublicDownload(const PPublicDownloadOptions& opts) ;
	public: virtual void insertPublicDownload(const PPublicDownloadOptions& opts, ::std::function< void (PPublicDownload, BException ex) > asyncResult) ;
	public: virtual PSubscription createSubscription(const ::std::wstring& watchGuid) ;
	public: virtual void createSubscription(const ::std::wstring& watchGuid, ::std::function< void (PSubscription, BException ex) > asyncResult) ;
	public: virtual PSubscription checkinSubscription(const PSubscription& subs, const PSubscriptionZ& subsZ) ;
	public: virtual void checkinSubscription(const PSubscription& subs, const PSubscriptionZ& subsZ, ::std::function< void (PSubscription, BException ex) > asyncResult) ;
	public: virtual void deleteSubscription(const PSubscription& subs) ;
	public: virtual void deleteSubscription(const PSubscription& subs, ::std::function< void (bool, BException ex) > asyncResult) ;
	public: virtual PFindResult findFirstSubscriptions(const PFindSubscriptionInfo& findInfo, int32_t max, const PSubscriptionZ& subsZ) ;
	public: virtual void findFirstSubscriptions(const PFindSubscriptionInfo& findInfo, int32_t max, const PSubscriptionZ& subsZ, ::std::function< void (PFindResult, BException ex) > asyncResult) ;
	public: virtual PFindResult findNextSubscriptions(const ::std::wstring& searchId, int32_t idx, int32_t max, const PSubscriptionZ& subsZ) ;
	public: virtual void findNextSubscriptions(const ::std::wstring& searchId, int32_t idx, int32_t max, const PSubscriptionZ& subsZ, ::std::function< void (PFindResult, BException ex) > asyncResult) ;
	public: virtual PFindResult findFirstNotes(const PFindInfo& findInfo, int32_t max, const PNoteZ& noteZ) ;
	public: virtual void findFirstNotes(const PFindInfo& findInfo, int32_t max, const PNoteZ& noteZ, ::std::function< void (PFindResult, BException ex) > asyncResult) ;
	public: virtual PFindResult findNextNotes(const ::std::wstring& searchId, int32_t idx, int32_t max, const PNoteZ& noteZ) ;
	public: virtual void findNextNotes(const ::std::wstring& searchId, int32_t idx, int32_t max, const PNoteZ& noteZ, ::std::function< void (PFindResult, BException ex) > asyncResult) ;
	public: virtual void checkinReport(const PReportInfo& report, const PCheckinReportInfo& reserved, const PLockZ& lockZ) ;
	public: virtual void checkinReport(const PReportInfo& report, const PCheckinReportInfo& reserved, const PLockZ& lockZ, ::std::function< void (bool, BException ex) > asyncResult) ;
	public: virtual void linkSords2(const ::std::wstring& fromId, const PArrayString& toIds, const PLinkSordZ& linkSordZ, const PLinkSordInfo& linkSordInfo) ;
	public: virtual void linkSords2(const ::std::wstring& fromId, const PArrayString& toIds, const PLinkSordZ& linkSordZ, const PLinkSordInfo& linkSordInfo, ::std::function< void (bool, BException ex) > asyncResult) ;
	public: virtual ::std::wstring getWebDAVPathFromObjID(const ::std::wstring& objId) ;
	public: virtual void getWebDAVPathFromObjID(const ::std::wstring& objId, ::std::function< void (::std::wstring, BException ex) > asyncResult) ;
	public: virtual PGetWebDAVPathResult getWebDAVPathFromObjID2(const PGetWebDAVPathOptions& options) ;
	public: virtual void getWebDAVPathFromObjID2(const PGetWebDAVPathOptions& options, ::std::function< void (PGetWebDAVPathResult, BException ex) > asyncResult) ;
	public: virtual PCheckoutWorkflowHistoryResult checkoutWorkflowHistory(const PCheckoutWorkflowHistoryParams& checkoutWorkflowHistoryParams) ;
	public: virtual void checkoutWorkflowHistory(const PCheckoutWorkflowHistoryParams& checkoutWorkflowHistoryParams, ::std::function< void (PCheckoutWorkflowHistoryResult, BException ex) > asyncResult) ;
	public: virtual int32_t checkinDocMaskLineTemplate(const PDocMaskLineTemplate& dmlt, const PDocMaskLineTemplateZ& dmltZ, const PCheckInDocMaskLineTemplateOptions& options, const PLockZ& lockZ) ;
	public: virtual void checkinDocMaskLineTemplate(const PDocMaskLineTemplate& dmlt, const PDocMaskLineTemplateZ& dmltZ, const PCheckInDocMaskLineTemplateOptions& options, const PLockZ& lockZ, ::std::function< void (int32_t, BException ex) > asyncResult) ;
	public: virtual PArrayDocMaskLineTemplate checkoutDocMaskLineTemplates(const PArrayString& groups, const PDocMaskLineTemplateZ& dmltZ, const PLockZ& lockZ) ;
	public: virtual void checkoutDocMaskLineTemplates(const PArrayString& groups, const PDocMaskLineTemplateZ& dmltZ, const PLockZ& lockZ, ::std::function< void (PArrayDocMaskLineTemplate, BException ex) > asyncResult) ;
	public: virtual void deleteDocMaskLineTemplates(const PArrayString& groups, const PLockZ& unlockZ) ;
	public: virtual void deleteDocMaskLineTemplates(const PArrayString& groups, const PLockZ& unlockZ, ::std::function< void (bool, BException ex) > asyncResult) ;
	public: virtual PWFEditNode beginForwardWorkflowNode(int32_t flowId, int32_t nodeId, const PBeginForwardWorkflowNodeInfo& fwdInfo, const PLockZ& lockZ) ;
	public: virtual void beginForwardWorkflowNode(int32_t flowId, int32_t nodeId, const PBeginForwardWorkflowNodeInfo& fwdInfo, const PLockZ& lockZ, ::std::function< void (PWFEditNode, BException ex) > asyncResult) ;
	public: virtual PForwardWorkflowNodeResult forwardWorkflowNode(int32_t flowId, int32_t nodeId, const PForwardWorkflowNodeInfo& fwdInfo, const PLockZ& unlockZ) ;
	public: virtual void forwardWorkflowNode(int32_t flowId, int32_t nodeId, const PForwardWorkflowNodeInfo& fwdInfo, const PLockZ& unlockZ, ::std::function< void (PForwardWorkflowNodeResult, BException ex) > asyncResult) ;
	public: virtual PFindResult findFirstUsers(const PFindUserInfo& findUserInfo, int32_t max) ;
	public: virtual void findFirstUsers(const PFindUserInfo& findUserInfo, int32_t max, ::std::function< void (PFindResult, BException ex) > asyncResult) ;
	public: virtual PFindResult findNextUsers(const ::std::wstring& searchId, int32_t idx, int32_t max) ;
	public: virtual void findNextUsers(const ::std::wstring& searchId, int32_t idx, int32_t max, ::std::function< void (PFindResult, BException ex) > asyncResult) ;
	public: virtual PLicenseResult checkLicense(const PLicenseInfo& licenseInfo) ;
	public: virtual void checkLicense(const PLicenseInfo& licenseInfo, ::std::function< void (PLicenseResult, BException ex) > asyncResult) ;
	public: virtual PJobState moveDocuments(const PMoveDocumentsInfo& moveDocumentsInfo) ;
	public: virtual void moveDocuments(const PMoveDocumentsInfo& moveDocumentsInfo, ::std::function< void (PJobState, BException ex) > asyncResult) ;
	
};
}}}}


//-------------------------------------------------
// RawStreamService

namespace de { namespace elo { namespace ix { namespace client { namespace compatibility { 

using namespace ::byps;

/// <summary>
/// This service helps to support the upload and download functions in IXConnection.
/// </summary>
class RawStreamService : public virtual BRemote {
	
	/// <summary>
	/// Upload a stream.
	/// </summary>
	public: virtual ::std::wstring upload(const de::elo::ix::client::PClientInfo& ci, const PArrayString& params, const PContentStream& is)  = 0;
	public: virtual void upload(const de::elo::ix::client::PClientInfo& ci, const PArrayString& params, const PContentStream& is, ::std::function< void (::std::wstring, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Download a stream
	/// </summary>
	public: virtual PContentStream download(const de::elo::ix::client::PClientInfo& ci, const PArrayString& params)  = 0;
	public: virtual void download(const de::elo::ix::client::PClientInfo& ci, const PArrayString& params, ::std::function< void (PContentStream, BException ex) > asyncResult)  = 0;
	
	
};

}}}}}

//-------------------------------------------------
// RawStreamServiceAuth

namespace de { namespace elo { namespace ix { namespace client { namespace compatibility { 

using namespace ::byps;

/// <summary>
/// This service helps to support the upload and download functions in IXConnection.
/// </summary>
class RawStreamServiceAuth : public virtual BRemote {
	
	/// <summary>
	/// Upload a stream.
	/// </summary>
	public: virtual ::std::wstring upload(const PArrayString& params, const PContentStream& is)  = 0;
	public: virtual void upload(const PArrayString& params, const PContentStream& is, ::std::function< void (::std::wstring, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Download a stream
	/// </summary>
	public: virtual PContentStream download(const PArrayString& params)  = 0;
	public: virtual void download(const PArrayString& params, ::std::function< void (PContentStream, BException ex) > asyncResult)  = 0;
	
	
};

}}}}}
//-------------------------------------------------
// Stub class BStub_RawStreamService

namespace de { namespace elo { namespace ix { namespace client { namespace compatibility { 

using namespace ::byps;

class BStub_RawStreamService;
typedef byps_ptr<BStub_RawStreamService> PStub_RawStreamService;

class BStub_RawStreamService : public BStub, public virtual RawStreamServiceAuth {
	
	public: BStub_RawStreamService(PTransport transport);	
	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: virtual ::std::wstring upload(const PArrayString& params, const PContentStream& is) ;
	public: virtual void upload(const PArrayString& params, const PContentStream& is, ::std::function< void (::std::wstring, BException ex) > asyncResult) ;
	public: virtual PContentStream download(const PArrayString& params) ;
	public: virtual void download(const PArrayString& params, ::std::function< void (PContentStream, BException ex) > asyncResult) ;
	
};
}}}}}


//-------------------------------------------------
// WClientService

namespace de { namespace elo { namespace ix { namespace client { namespace compatibility { 

using namespace ::byps;

class WClientService : public virtual BRemote {
	
	public: virtual void onAfterVersionChanged(const de::elo::ix::client::PClientInfo& ci, int32_t objId, int32_t docId, int32_t flags)  = 0;
	public: virtual void onAfterVersionChanged(const de::elo::ix::client::PClientInfo& ci, int32_t objId, int32_t docId, int32_t flags, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	
};

}}}}}

//-------------------------------------------------
// WClientServiceAuth

namespace de { namespace elo { namespace ix { namespace client { namespace compatibility { 

using namespace ::byps;

class WClientServiceAuth : public virtual BRemote {
	
	public: virtual void onAfterVersionChanged(int32_t objId, int32_t docId, int32_t flags)  = 0;
	public: virtual void onAfterVersionChanged(int32_t objId, int32_t docId, int32_t flags, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	
};

}}}}}
//-------------------------------------------------
// Stub class BStub_WClientService

namespace de { namespace elo { namespace ix { namespace client { namespace compatibility { 

using namespace ::byps;

class BStub_WClientService;
typedef byps_ptr<BStub_WClientService> PStub_WClientService;

class BStub_WClientService : public BStub, public virtual WClientServiceAuth {
	
	public: BStub_WClientService(PTransport transport);	
	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: virtual void onAfterVersionChanged(int32_t objId, int32_t docId, int32_t flags) ;
	public: virtual void onAfterVersionChanged(int32_t objId, int32_t docId, int32_t flags, ::std::function< void (bool, BException ex) > asyncResult) ;
	
};
}}}}}


//-------------------------------------------------
// FeedNotification

namespace de { namespace elo { namespace ix { namespace client { namespace feed { 

using namespace ::byps;

/// <summary>
/// Callback interface for notifications about a document feed.
/// </summary>
/// <remarks>
/// The client application can register an implementation of this
/// interface in order to be notified if an action is created or modified.
/// </remarks>
class FeedNotification : public virtual BRemote {
	
	/// <summary>
	/// Called when an action is created or updated.
	/// </summary>
	public: virtual void updateAction(const PAction& action)  = 0;
	public: virtual void updateAction(const PAction& action, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	
};

}}}}}
//-------------------------------------------------
// Skeleton class BSkeleton_FeedNotification
// Your interface implementation class has to be derived from this skeleton.
// Either provide an asynchronous or a synchronous function in your subclass.

namespace de { namespace elo { namespace ix { namespace client { namespace feed { 

using namespace ::byps;

class BSkeleton_FeedNotification;
typedef byps_ptr<BSkeleton_FeedNotification> PSkeleton_FeedNotification;

class BSkeleton_FeedNotification : public BSkeleton, public virtual FeedNotification {
	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: virtual void updateAction(const PAction& action) ;
	public: virtual void updateAction(const PAction& action, ::std::function< void (bool, BException ex) > asyncResult) ;
	
	
};
}}}}}

//-------------------------------------------------
// Stub class BStub_FeedNotification

namespace de { namespace elo { namespace ix { namespace client { namespace feed { 

using namespace ::byps;

class BStub_FeedNotification;
typedef byps_ptr<BStub_FeedNotification> PStub_FeedNotification;

class BStub_FeedNotification : public BStub, public virtual FeedNotification {
	
	public: BStub_FeedNotification(PTransport transport);	
	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: virtual void updateAction(const PAction& action) ;
	public: virtual void updateAction(const PAction& action, ::std::function< void (bool, BException ex) > asyncResult) ;
	
};
}}}}}


//-------------------------------------------------
// FeedService

namespace de { namespace elo { namespace ix { namespace client { namespace feed { 

using namespace ::byps;

/// <summary>
/// This interface provides functions to access document feeds.
/// </summary>
class FeedService : public virtual BRemote {
	
	/// <summary>
	/// Find actions of document feeds.
	/// </summary>
	/// <remarks>
	/// <p>
	/// In order to receive all actions for a document feed, call this function with {@link FindActionsInfo#objId} set to a Sord ID, GUID, etc.
	/// The results are returned in {@link FindResult#getActions()}. The Feed object associated to the Sord is returned in {@link FindResult#getFeeds()}.
	/// </p><p>
	/// Call IXServicePortIF.findClose to release internal resources when finished.
	/// </p>
	/// </remarks>
	public: virtual de::elo::ix::client::PFindResult findFirstActions(const de::elo::ix::client::PClientInfo& ci, const PFindActionsInfo& findInfo, int32_t max, const PActionZ& actionZ)  = 0;
	public: virtual void findFirstActions(const de::elo::ix::client::PClientInfo& ci, const PFindActionsInfo& findInfo, int32_t max, const PActionZ& actionZ, ::std::function< void (de::elo::ix::client::PFindResult, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Continue reading results from a search started with findFirstActions.
	/// </summary>
	public: virtual de::elo::ix::client::PFindResult findNextActions(const de::elo::ix::client::PClientInfo& ci, const ::std::wstring& searchId, int32_t idx, int32_t max, const PActionZ& actionZ)  = 0;
	public: virtual void findNextActions(const de::elo::ix::client::PClientInfo& ci, const ::std::wstring& searchId, int32_t idx, int32_t max, const PActionZ& actionZ, ::std::function< void (de::elo::ix::client::PFindResult, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Initialize a document feed item object.
	/// </summary>
	/// <remarks>
	/// This function does not store the created action in the database. Use {@link #checkinAction(ClientInfo, Action, ActionZ)}
	/// to make an Action object persistent.
	/// The returned object allows read access for everyone.
	/// </remarks>
	public: virtual PAction createAction(const de::elo::ix::client::PClientInfo& ci, EActionType type, const ::std::wstring& parentGuid)  = 0;
	public: virtual void createAction(const de::elo::ix::client::PClientInfo& ci, EActionType type, const ::std::wstring& parentGuid, ::std::function< void (PAction, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Create or update a document feed entry.
	/// </summary>
	public: virtual ::std::wstring checkinAction(const de::elo::ix::client::PClientInfo& ci, const PAction& action, const PActionZ& actionZ)  = 0;
	public: virtual void checkinAction(const de::elo::ix::client::PClientInfo& ci, const PAction& action, const PActionZ& actionZ, ::std::function< void (::std::wstring, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Read a document feed entry.
	/// </summary>
	public: virtual PAction checkoutAction(const de::elo::ix::client::PClientInfo& ci, const ::std::wstring& actionGuid, const PActionZ& actionZ)  = 0;
	public: virtual void checkoutAction(const de::elo::ix::client::PClientInfo& ci, const ::std::wstring& actionGuid, const PActionZ& actionZ, ::std::function< void (PAction, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Register a callback interface.
	/// </summary>
	/// <remarks>
	/// The server calls functions of this interface if the document feed is modified.
	/// </remarks>
	public: virtual void registerNotify(const de::elo::ix::client::PClientInfo& ci, const ::std::wstring& feedGuid, const PFeedNotification& notify)  = 0;
	public: virtual void registerNotify(const de::elo::ix::client::PClientInfo& ci, const ::std::wstring& feedGuid, const PFeedNotification& notify, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Unregister a callback interface.
	/// </summary>
	/// <remarks>
	/// Remove callback interface from internal list.
	/// </remarks>
	public: virtual void unregisterNotify(const de::elo::ix::client::PClientInfo& ci, const ::std::wstring& feedGuid)  = 0;
	public: virtual void unregisterNotify(const de::elo::ix::client::PClientInfo& ci, const ::std::wstring& feedGuid, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Reserved.
	/// </summary>
	public: virtual PAction internalInsertSystemAction(const de::elo::ix::client::PClientInfo& ci, const PAction& action)  = 0;
	public: virtual void internalInsertSystemAction(const de::elo::ix::client::PClientInfo& ci, const PAction& action, ::std::function< void (PAction, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Read a HashTag Object from Database
	/// </summary>
	public: virtual PHashTag checkoutHashTag(const de::elo::ix::client::PClientInfo& ci, const ::std::wstring& hashtagGuidOrName, const PHashTagZ& hstgZ)  = 0;
	public: virtual void checkoutHashTag(const de::elo::ix::client::PClientInfo& ci, const ::std::wstring& hashtagGuidOrName, const PHashTagZ& hstgZ, ::std::function< void (PHashTag, BException ex) > asyncResult)  = 0;
	
	public: virtual de::elo::ix::client::PFindResult findFirstHashTagRelation(const de::elo::ix::client::PClientInfo& ci, const PFindHashTagInfo& findInfo, int32_t max, const PHashTagZ& hashTagZ)  = 0;
	public: virtual void findFirstHashTagRelation(const de::elo::ix::client::PClientInfo& ci, const PFindHashTagInfo& findInfo, int32_t max, const PHashTagZ& hashTagZ, ::std::function< void (de::elo::ix::client::PFindResult, BException ex) > asyncResult)  = 0;
	
	public: virtual de::elo::ix::client::PFindResult findNextHashTagRelation(const de::elo::ix::client::PClientInfo& ci, const ::std::wstring& searchId, int32_t idx, int32_t max, const PHashTagZ& hashTagZ)  = 0;
	public: virtual void findNextHashTagRelation(const de::elo::ix::client::PClientInfo& ci, const ::std::wstring& searchId, int32_t idx, int32_t max, const PHashTagZ& hashTagZ, ::std::function< void (de::elo::ix::client::PFindResult, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Returns all HashTags which occurs in a given Array of Actions
	/// </summary>
	public: virtual byps_ptr< ::std::set< PHashTag > > findHashTagByActions(const de::elo::ix::client::PClientInfo& ci, const PArrayString& actionGuids, const PHashTagZ& hashTagZ)  = 0;
	public: virtual void findHashTagByActions(const de::elo::ix::client::PClientInfo& ci, const PArrayString& actionGuids, const PHashTagZ& hashTagZ, ::std::function< void (byps_ptr< ::std::set< PHashTag > >, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Returns all HashTags.
	/// </summary>
	/// <remarks>
	/// FindHashTagInfo filter the result by, createDateIso, lastUsedIso and minCount
	/// </remarks>
	public: virtual PMapStringHashTag findHashTags(const de::elo::ix::client::PClientInfo& ci, const PFindHashTagInfo& findInfo)  = 0;
	public: virtual void findHashTags(const de::elo::ix::client::PClientInfo& ci, const PFindHashTagInfo& findInfo, ::std::function< void (PMapStringHashTag, BException ex) > asyncResult)  = 0;
	
	public: virtual de::elo::ix::client::PFindResult findFirstNotification(const de::elo::ix::client::PClientInfo& ci, const PFindNotificationInfo& findInfo, int32_t max)  = 0;
	public: virtual void findFirstNotification(const de::elo::ix::client::PClientInfo& ci, const PFindNotificationInfo& findInfo, int32_t max, ::std::function< void (de::elo::ix::client::PFindResult, BException ex) > asyncResult)  = 0;
	
	public: virtual de::elo::ix::client::PFindResult findNextNotification(const de::elo::ix::client::PClientInfo& ci, const ::std::wstring& searchId, int32_t idx, int32_t max)  = 0;
	public: virtual void findNextNotification(const de::elo::ix::client::PClientInfo& ci, const ::std::wstring& searchId, int32_t idx, int32_t max, ::std::function< void (de::elo::ix::client::PFindResult, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Creates a HashTag Subscription
	/// </summary>
	public: virtual de::elo::ix::client::PSubscription createHashTagSubscription(const de::elo::ix::client::PClientInfo& ci, const ::std::wstring& hashtagGuidOrName, const ::std::wstring& userGuidOrId)  = 0;
	public: virtual void createHashTagSubscription(const de::elo::ix::client::PClientInfo& ci, const ::std::wstring& hashtagGuidOrName, const ::std::wstring& userGuidOrId, ::std::function< void (de::elo::ix::client::PSubscription, BException ex) > asyncResult)  = 0;
	
	
};

}}}}}

//-------------------------------------------------
// FeedServiceAuth

namespace de { namespace elo { namespace ix { namespace client { namespace feed { 

using namespace ::byps;

/// <summary>
/// This interface provides functions to access document feeds.
/// </summary>
class FeedServiceAuth : public virtual BRemote {
	
	/// <summary>
	/// Find actions of document feeds.
	/// </summary>
	/// <remarks>
	/// <p>
	/// In order to receive all actions for a document feed, call this function with {@link FindActionsInfo#objId} set to a Sord ID, GUID, etc.
	/// The results are returned in {@link FindResult#getActions()}. The Feed object associated to the Sord is returned in {@link FindResult#getFeeds()}.
	/// </p><p>
	/// Call IXServicePortIF.findClose to release internal resources when finished.
	/// </p>
	/// </remarks>
	public: virtual de::elo::ix::client::PFindResult findFirstActions(const PFindActionsInfo& findInfo, int32_t max, const PActionZ& actionZ)  = 0;
	public: virtual void findFirstActions(const PFindActionsInfo& findInfo, int32_t max, const PActionZ& actionZ, ::std::function< void (de::elo::ix::client::PFindResult, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Continue reading results from a search started with findFirstActions.
	/// </summary>
	public: virtual de::elo::ix::client::PFindResult findNextActions(const ::std::wstring& searchId, int32_t idx, int32_t max, const PActionZ& actionZ)  = 0;
	public: virtual void findNextActions(const ::std::wstring& searchId, int32_t idx, int32_t max, const PActionZ& actionZ, ::std::function< void (de::elo::ix::client::PFindResult, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Initialize a document feed item object.
	/// </summary>
	/// <remarks>
	/// This function does not store the created action in the database. Use {@link #checkinAction(ClientInfo, Action, ActionZ)}
	/// to make an Action object persistent.
	/// The returned object allows read access for everyone.
	/// </remarks>
	public: virtual PAction createAction(EActionType type, const ::std::wstring& parentGuid)  = 0;
	public: virtual void createAction(EActionType type, const ::std::wstring& parentGuid, ::std::function< void (PAction, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Create or update a document feed entry.
	/// </summary>
	public: virtual ::std::wstring checkinAction(const PAction& action, const PActionZ& actionZ)  = 0;
	public: virtual void checkinAction(const PAction& action, const PActionZ& actionZ, ::std::function< void (::std::wstring, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Read a document feed entry.
	/// </summary>
	public: virtual PAction checkoutAction(const ::std::wstring& actionGuid, const PActionZ& actionZ)  = 0;
	public: virtual void checkoutAction(const ::std::wstring& actionGuid, const PActionZ& actionZ, ::std::function< void (PAction, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Register a callback interface.
	/// </summary>
	/// <remarks>
	/// The server calls functions of this interface if the document feed is modified.
	/// </remarks>
	public: virtual void registerNotify(const ::std::wstring& feedGuid, const PFeedNotification& notify)  = 0;
	public: virtual void registerNotify(const ::std::wstring& feedGuid, const PFeedNotification& notify, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Unregister a callback interface.
	/// </summary>
	/// <remarks>
	/// Remove callback interface from internal list.
	/// </remarks>
	public: virtual void unregisterNotify(const ::std::wstring& feedGuid)  = 0;
	public: virtual void unregisterNotify(const ::std::wstring& feedGuid, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Reserved.
	/// </summary>
	public: virtual PAction internalInsertSystemAction(const PAction& action)  = 0;
	public: virtual void internalInsertSystemAction(const PAction& action, ::std::function< void (PAction, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Read a HashTag Object from Database
	/// </summary>
	public: virtual PHashTag checkoutHashTag(const ::std::wstring& hashtagGuidOrName, const PHashTagZ& hstgZ)  = 0;
	public: virtual void checkoutHashTag(const ::std::wstring& hashtagGuidOrName, const PHashTagZ& hstgZ, ::std::function< void (PHashTag, BException ex) > asyncResult)  = 0;
	
	public: virtual de::elo::ix::client::PFindResult findFirstHashTagRelation(const PFindHashTagInfo& findInfo, int32_t max, const PHashTagZ& hashTagZ)  = 0;
	public: virtual void findFirstHashTagRelation(const PFindHashTagInfo& findInfo, int32_t max, const PHashTagZ& hashTagZ, ::std::function< void (de::elo::ix::client::PFindResult, BException ex) > asyncResult)  = 0;
	
	public: virtual de::elo::ix::client::PFindResult findNextHashTagRelation(const ::std::wstring& searchId, int32_t idx, int32_t max, const PHashTagZ& hashTagZ)  = 0;
	public: virtual void findNextHashTagRelation(const ::std::wstring& searchId, int32_t idx, int32_t max, const PHashTagZ& hashTagZ, ::std::function< void (de::elo::ix::client::PFindResult, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Returns all HashTags which occurs in a given Array of Actions
	/// </summary>
	public: virtual byps_ptr< ::std::set< PHashTag > > findHashTagByActions(const PArrayString& actionGuids, const PHashTagZ& hashTagZ)  = 0;
	public: virtual void findHashTagByActions(const PArrayString& actionGuids, const PHashTagZ& hashTagZ, ::std::function< void (byps_ptr< ::std::set< PHashTag > >, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Returns all HashTags.
	/// </summary>
	/// <remarks>
	/// FindHashTagInfo filter the result by, createDateIso, lastUsedIso and minCount
	/// </remarks>
	public: virtual PMapStringHashTag findHashTags(const PFindHashTagInfo& findInfo)  = 0;
	public: virtual void findHashTags(const PFindHashTagInfo& findInfo, ::std::function< void (PMapStringHashTag, BException ex) > asyncResult)  = 0;
	
	public: virtual de::elo::ix::client::PFindResult findFirstNotification(const PFindNotificationInfo& findInfo, int32_t max)  = 0;
	public: virtual void findFirstNotification(const PFindNotificationInfo& findInfo, int32_t max, ::std::function< void (de::elo::ix::client::PFindResult, BException ex) > asyncResult)  = 0;
	
	public: virtual de::elo::ix::client::PFindResult findNextNotification(const ::std::wstring& searchId, int32_t idx, int32_t max)  = 0;
	public: virtual void findNextNotification(const ::std::wstring& searchId, int32_t idx, int32_t max, ::std::function< void (de::elo::ix::client::PFindResult, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Creates a HashTag Subscription
	/// </summary>
	public: virtual de::elo::ix::client::PSubscription createHashTagSubscription(const ::std::wstring& hashtagGuidOrName, const ::std::wstring& userGuidOrId)  = 0;
	public: virtual void createHashTagSubscription(const ::std::wstring& hashtagGuidOrName, const ::std::wstring& userGuidOrId, ::std::function< void (de::elo::ix::client::PSubscription, BException ex) > asyncResult)  = 0;
	
	
};

}}}}}
//-------------------------------------------------
// Stub class BStub_FeedService

namespace de { namespace elo { namespace ix { namespace client { namespace feed { 

using namespace ::byps;

class BStub_FeedService;
typedef byps_ptr<BStub_FeedService> PStub_FeedService;

class BStub_FeedService : public BStub, public virtual FeedServiceAuth {
	
	public: BStub_FeedService(PTransport transport);	
	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: virtual de::elo::ix::client::PFindResult findFirstActions(const PFindActionsInfo& findInfo, int32_t max, const PActionZ& actionZ) ;
	public: virtual void findFirstActions(const PFindActionsInfo& findInfo, int32_t max, const PActionZ& actionZ, ::std::function< void (de::elo::ix::client::PFindResult, BException ex) > asyncResult) ;
	public: virtual de::elo::ix::client::PFindResult findNextActions(const ::std::wstring& searchId, int32_t idx, int32_t max, const PActionZ& actionZ) ;
	public: virtual void findNextActions(const ::std::wstring& searchId, int32_t idx, int32_t max, const PActionZ& actionZ, ::std::function< void (de::elo::ix::client::PFindResult, BException ex) > asyncResult) ;
	public: virtual PAction createAction(EActionType type, const ::std::wstring& parentGuid) ;
	public: virtual void createAction(EActionType type, const ::std::wstring& parentGuid, ::std::function< void (PAction, BException ex) > asyncResult) ;
	public: virtual ::std::wstring checkinAction(const PAction& action, const PActionZ& actionZ) ;
	public: virtual void checkinAction(const PAction& action, const PActionZ& actionZ, ::std::function< void (::std::wstring, BException ex) > asyncResult) ;
	public: virtual PAction checkoutAction(const ::std::wstring& actionGuid, const PActionZ& actionZ) ;
	public: virtual void checkoutAction(const ::std::wstring& actionGuid, const PActionZ& actionZ, ::std::function< void (PAction, BException ex) > asyncResult) ;
	public: virtual void registerNotify(const ::std::wstring& feedGuid, const PFeedNotification& notify) ;
	public: virtual void registerNotify(const ::std::wstring& feedGuid, const PFeedNotification& notify, ::std::function< void (bool, BException ex) > asyncResult) ;
	public: virtual void unregisterNotify(const ::std::wstring& feedGuid) ;
	public: virtual void unregisterNotify(const ::std::wstring& feedGuid, ::std::function< void (bool, BException ex) > asyncResult) ;
	public: virtual PAction internalInsertSystemAction(const PAction& action) ;
	public: virtual void internalInsertSystemAction(const PAction& action, ::std::function< void (PAction, BException ex) > asyncResult) ;
	public: virtual PHashTag checkoutHashTag(const ::std::wstring& hashtagGuidOrName, const PHashTagZ& hstgZ) ;
	public: virtual void checkoutHashTag(const ::std::wstring& hashtagGuidOrName, const PHashTagZ& hstgZ, ::std::function< void (PHashTag, BException ex) > asyncResult) ;
	public: virtual de::elo::ix::client::PFindResult findFirstHashTagRelation(const PFindHashTagInfo& findInfo, int32_t max, const PHashTagZ& hashTagZ) ;
	public: virtual void findFirstHashTagRelation(const PFindHashTagInfo& findInfo, int32_t max, const PHashTagZ& hashTagZ, ::std::function< void (de::elo::ix::client::PFindResult, BException ex) > asyncResult) ;
	public: virtual de::elo::ix::client::PFindResult findNextHashTagRelation(const ::std::wstring& searchId, int32_t idx, int32_t max, const PHashTagZ& hashTagZ) ;
	public: virtual void findNextHashTagRelation(const ::std::wstring& searchId, int32_t idx, int32_t max, const PHashTagZ& hashTagZ, ::std::function< void (de::elo::ix::client::PFindResult, BException ex) > asyncResult) ;
	public: virtual byps_ptr< ::std::set< PHashTag > > findHashTagByActions(const PArrayString& actionGuids, const PHashTagZ& hashTagZ) ;
	public: virtual void findHashTagByActions(const PArrayString& actionGuids, const PHashTagZ& hashTagZ, ::std::function< void (byps_ptr< ::std::set< PHashTag > >, BException ex) > asyncResult) ;
	public: virtual PMapStringHashTag findHashTags(const PFindHashTagInfo& findInfo) ;
	public: virtual void findHashTags(const PFindHashTagInfo& findInfo, ::std::function< void (PMapStringHashTag, BException ex) > asyncResult) ;
	public: virtual de::elo::ix::client::PFindResult findFirstNotification(const PFindNotificationInfo& findInfo, int32_t max) ;
	public: virtual void findFirstNotification(const PFindNotificationInfo& findInfo, int32_t max, ::std::function< void (de::elo::ix::client::PFindResult, BException ex) > asyncResult) ;
	public: virtual de::elo::ix::client::PFindResult findNextNotification(const ::std::wstring& searchId, int32_t idx, int32_t max) ;
	public: virtual void findNextNotification(const ::std::wstring& searchId, int32_t idx, int32_t max, ::std::function< void (de::elo::ix::client::PFindResult, BException ex) > asyncResult) ;
	public: virtual de::elo::ix::client::PSubscription createHashTagSubscription(const ::std::wstring& hashtagGuidOrName, const ::std::wstring& userGuidOrId) ;
	public: virtual void createHashTagSubscription(const ::std::wstring& hashtagGuidOrName, const ::std::wstring& userGuidOrId, ::std::function< void (de::elo::ix::client::PSubscription, BException ex) > asyncResult) ;
	
};
}}}}}


//-------------------------------------------------
// HealthCheckService

namespace de { namespace elo { namespace ix { namespace client { namespace health { 

using namespace ::byps;

/// <summary>
/// Functions for health check.
/// </summary>
class HealthCheckService : public virtual BRemote {
	
	/// <summary>
	/// Update arithmetic mean.
	/// </summary>
	/// <remarks>
	/// This function adds the given mean value to the
	/// already existing value in the database. The new value is computed as:
	/// (db-meanValue * db-sampleSize + meanValue * sampleSize) / (db-sampleSize +
	/// sampleSize).
	/// Example:
	/// <code><pre>
	/// IXConnection conn = ...
	/// double value = (1.1 + 1.2 + 1.3) / 3;
	/// conn.getHealthCheckService().updateMeanValue("valuename", 1.2, 3);
	/// </pre></code>
	/// </remarks>
	public: virtual void updateMeanValue(const de::elo::ix::client::PClientInfo& ci, const ::std::wstring& name, double meanValue, int64_t sampleSize)  = 0;
	public: virtual void updateMeanValue(const de::elo::ix::client::PClientInfo& ci, const ::std::wstring& name, double meanValue, int64_t sampleSize, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Update one value.
	/// </summary>
	/// <remarks>
	/// This function overwrites an existing value.
	/// Example:
	/// <code><pre>
	/// IXConnection conn = ...
	/// conn.getHealthCheckService().updateDoubleValue("valuename", 1.2);
	/// </pre></code>
	/// </remarks>
	public: virtual void updateDoubleValue(const de::elo::ix::client::PClientInfo& ci, const ::std::wstring& name, double doubleValue)  = 0;
	public: virtual void updateDoubleValue(const de::elo::ix::client::PClientInfo& ci, const ::std::wstring& name, double doubleValue, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Compute value.
	/// </summary>
	/// <remarks>
	/// This function computes a new value using the specified operation.
	/// Example:
	/// <code><pre>
	/// IXConnection conn = ...
	/// conn.getHealthCheckService().computeDoubleValue("valuename", 1.2, HealthCheckValueOperation.ADD);
	/// </pre></code>
	/// </remarks>
	public: virtual void computeDoubleValue(const de::elo::ix::client::PClientInfo& ci, const ::std::wstring& name, double doubleValue, HealthCheckValueOperation operation)  = 0;
	public: virtual void computeDoubleValue(const de::elo::ix::client::PClientInfo& ci, const ::std::wstring& name, double doubleValue, HealthCheckValueOperation operation, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Update one value.
	/// </summary>
	/// <remarks>
	/// Example:
	/// <code><pre>
	/// IXConnection conn = ...
	/// HealthCheckInfo hci = new HealthCheckInfo();
	/// hci.setName("valuename");
	/// hci.setStringValue("string1");
	/// conn.getHealthCheckService().update(hci);
	/// </pre></code>
	/// </remarks>
	public: virtual void update(const de::elo::ix::client::PClientInfo& ci, const PHealthCheckInfo& hci)  = 0;
	public: virtual void update(const de::elo::ix::client::PClientInfo& ci, const PHealthCheckInfo& hci, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Update given values.
	/// </summary>
	public: virtual void updateAll(const de::elo::ix::client::PClientInfo& ci, const PVectorHealthCheckInfo& hcis)  = 0;
	public: virtual void updateAll(const de::elo::ix::client::PClientInfo& ci, const PVectorHealthCheckInfo& hcis, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Force uploading health check data to web service.
	/// </summary>
	/// <remarks>
	/// This function should only be used in test scenarios.
	/// Indexserver automatically uploads health check data one time per month.
	/// </remarks>
	public: virtual PSerializable uploadAll(const de::elo::ix::client::PClientInfo& ci, const PSerializable& reserved)  = 0;
	public: virtual void uploadAll(const de::elo::ix::client::PClientInfo& ci, const PSerializable& reserved, ::std::function< void (PSerializable, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Read given health check values.
	/// </summary>
	public: virtual PHealthCheckInfos read(const de::elo::ix::client::PClientInfo& ci, const byps::PVectorString& names)  = 0;
	public: virtual void read(const de::elo::ix::client::PClientInfo& ci, const byps::PVectorString& names, ::std::function< void (PHealthCheckInfos, BException ex) > asyncResult)  = 0;
	
	
};

}}}}}

//-------------------------------------------------
// HealthCheckServiceAuth

namespace de { namespace elo { namespace ix { namespace client { namespace health { 

using namespace ::byps;

/// <summary>
/// Functions for health check.
/// </summary>
class HealthCheckServiceAuth : public virtual BRemote {
	
	/// <summary>
	/// Update arithmetic mean.
	/// </summary>
	/// <remarks>
	/// This function adds the given mean value to the
	/// already existing value in the database. The new value is computed as:
	/// (db-meanValue * db-sampleSize + meanValue * sampleSize) / (db-sampleSize +
	/// sampleSize).
	/// Example:
	/// <code><pre>
	/// IXConnection conn = ...
	/// double value = (1.1 + 1.2 + 1.3) / 3;
	/// conn.getHealthCheckService().updateMeanValue("valuename", 1.2, 3);
	/// </pre></code>
	/// </remarks>
	public: virtual void updateMeanValue(const ::std::wstring& name, double meanValue, int64_t sampleSize)  = 0;
	public: virtual void updateMeanValue(const ::std::wstring& name, double meanValue, int64_t sampleSize, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Update one value.
	/// </summary>
	/// <remarks>
	/// This function overwrites an existing value.
	/// Example:
	/// <code><pre>
	/// IXConnection conn = ...
	/// conn.getHealthCheckService().updateDoubleValue("valuename", 1.2);
	/// </pre></code>
	/// </remarks>
	public: virtual void updateDoubleValue(const ::std::wstring& name, double doubleValue)  = 0;
	public: virtual void updateDoubleValue(const ::std::wstring& name, double doubleValue, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Compute value.
	/// </summary>
	/// <remarks>
	/// This function computes a new value using the specified operation.
	/// Example:
	/// <code><pre>
	/// IXConnection conn = ...
	/// conn.getHealthCheckService().computeDoubleValue("valuename", 1.2, HealthCheckValueOperation.ADD);
	/// </pre></code>
	/// </remarks>
	public: virtual void computeDoubleValue(const ::std::wstring& name, double doubleValue, HealthCheckValueOperation operation)  = 0;
	public: virtual void computeDoubleValue(const ::std::wstring& name, double doubleValue, HealthCheckValueOperation operation, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Update one value.
	/// </summary>
	/// <remarks>
	/// Example:
	/// <code><pre>
	/// IXConnection conn = ...
	/// HealthCheckInfo hci = new HealthCheckInfo();
	/// hci.setName("valuename");
	/// hci.setStringValue("string1");
	/// conn.getHealthCheckService().update(hci);
	/// </pre></code>
	/// </remarks>
	public: virtual void update(const PHealthCheckInfo& hci)  = 0;
	public: virtual void update(const PHealthCheckInfo& hci, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Update given values.
	/// </summary>
	public: virtual void updateAll(const PVectorHealthCheckInfo& hcis)  = 0;
	public: virtual void updateAll(const PVectorHealthCheckInfo& hcis, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Force uploading health check data to web service.
	/// </summary>
	/// <remarks>
	/// This function should only be used in test scenarios.
	/// Indexserver automatically uploads health check data one time per month.
	/// </remarks>
	public: virtual PSerializable uploadAll(const PSerializable& reserved)  = 0;
	public: virtual void uploadAll(const PSerializable& reserved, ::std::function< void (PSerializable, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Read given health check values.
	/// </summary>
	public: virtual PHealthCheckInfos read(const byps::PVectorString& names)  = 0;
	public: virtual void read(const byps::PVectorString& names, ::std::function< void (PHealthCheckInfos, BException ex) > asyncResult)  = 0;
	
	
};

}}}}}
//-------------------------------------------------
// Stub class BStub_HealthCheckService

namespace de { namespace elo { namespace ix { namespace client { namespace health { 

using namespace ::byps;

class BStub_HealthCheckService;
typedef byps_ptr<BStub_HealthCheckService> PStub_HealthCheckService;

class BStub_HealthCheckService : public BStub, public virtual HealthCheckServiceAuth {
	
	public: BStub_HealthCheckService(PTransport transport);	
	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: virtual void updateMeanValue(const ::std::wstring& name, double meanValue, int64_t sampleSize) ;
	public: virtual void updateMeanValue(const ::std::wstring& name, double meanValue, int64_t sampleSize, ::std::function< void (bool, BException ex) > asyncResult) ;
	public: virtual void updateDoubleValue(const ::std::wstring& name, double doubleValue) ;
	public: virtual void updateDoubleValue(const ::std::wstring& name, double doubleValue, ::std::function< void (bool, BException ex) > asyncResult) ;
	public: virtual void computeDoubleValue(const ::std::wstring& name, double doubleValue, HealthCheckValueOperation operation) ;
	public: virtual void computeDoubleValue(const ::std::wstring& name, double doubleValue, HealthCheckValueOperation operation, ::std::function< void (bool, BException ex) > asyncResult) ;
	public: virtual void update(const PHealthCheckInfo& hci) ;
	public: virtual void update(const PHealthCheckInfo& hci, ::std::function< void (bool, BException ex) > asyncResult) ;
	public: virtual void updateAll(const PVectorHealthCheckInfo& hcis) ;
	public: virtual void updateAll(const PVectorHealthCheckInfo& hcis, ::std::function< void (bool, BException ex) > asyncResult) ;
	public: virtual PSerializable uploadAll(const PSerializable& reserved) ;
	public: virtual void uploadAll(const PSerializable& reserved, ::std::function< void (PSerializable, BException ex) > asyncResult) ;
	public: virtual PHealthCheckInfos read(const byps::PVectorString& names) ;
	public: virtual void read(const byps::PVectorString& names, ::std::function< void (PHealthCheckInfos, BException ex) > asyncResult) ;
	
};
}}}}}


//-------------------------------------------------
// MyELOService

namespace de { namespace elo { namespace ix { namespace client { namespace myelo { 

using namespace ::byps;

/// <summary>
/// This interface provides functions to MyELO page.
/// </summary>
class MyELOService : public virtual BRemote {
	
	public: virtual PMyELOState checkState(const de::elo::ix::client::PClientInfo& ci, const ::std::wstring& userGuidOrID, const ::std::wstring& sinceDateIso)  = 0;
	public: virtual void checkState(const de::elo::ix::client::PClientInfo& ci, const ::std::wstring& userGuidOrID, const ::std::wstring& sinceDateIso, ::std::function< void (PMyELOState, BException ex) > asyncResult)  = 0;
	
	public: virtual PMyELOContent readContent(const de::elo::ix::client::PClientInfo& ci, const PMyELOState& state, const PMyELOInfo& info)  = 0;
	public: virtual void readContent(const de::elo::ix::client::PClientInfo& ci, const PMyELOState& state, const PMyELOInfo& info, ::std::function< void (PMyELOContent, BException ex) > asyncResult)  = 0;
	
	
};

}}}}}

//-------------------------------------------------
// MyELOServiceAuth

namespace de { namespace elo { namespace ix { namespace client { namespace myelo { 

using namespace ::byps;

/// <summary>
/// This interface provides functions to MyELO page.
/// </summary>
class MyELOServiceAuth : public virtual BRemote {
	
	public: virtual PMyELOState checkState(const ::std::wstring& userGuidOrID, const ::std::wstring& sinceDateIso)  = 0;
	public: virtual void checkState(const ::std::wstring& userGuidOrID, const ::std::wstring& sinceDateIso, ::std::function< void (PMyELOState, BException ex) > asyncResult)  = 0;
	
	public: virtual PMyELOContent readContent(const PMyELOState& state, const PMyELOInfo& info)  = 0;
	public: virtual void readContent(const PMyELOState& state, const PMyELOInfo& info, ::std::function< void (PMyELOContent, BException ex) > asyncResult)  = 0;
	
	
};

}}}}}
//-------------------------------------------------
// Stub class BStub_MyELOService

namespace de { namespace elo { namespace ix { namespace client { namespace myelo { 

using namespace ::byps;

class BStub_MyELOService;
typedef byps_ptr<BStub_MyELOService> PStub_MyELOService;

class BStub_MyELOService : public BStub, public virtual MyELOServiceAuth {
	
	public: BStub_MyELOService(PTransport transport);	
	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: virtual PMyELOState checkState(const ::std::wstring& userGuidOrID, const ::std::wstring& sinceDateIso) ;
	public: virtual void checkState(const ::std::wstring& userGuidOrID, const ::std::wstring& sinceDateIso, ::std::function< void (PMyELOState, BException ex) > asyncResult) ;
	public: virtual PMyELOContent readContent(const PMyELOState& state, const PMyELOInfo& info) ;
	public: virtual void readContent(const PMyELOState& state, const PMyELOInfo& info, ::std::function< void (PMyELOContent, BException ex) > asyncResult) ;
	
};
}}}}}


//-------------------------------------------------
// ClientNotification

namespace de { namespace elo { namespace ix { namespace client { namespace notify { 

using namespace ::byps;

/// <summary>
/// Callback interface for server-push notifications.
/// </summary>
class ClientNotification : public virtual BRemote {
	
	/// <summary>
	/// Administration mode was changed.
	/// </summary>
	public: virtual void adminMode(const de::elo::ix::client::PClientInfo& ci, int32_t mode)  = 0;
	public: virtual void adminMode(const de::elo::ix::client::PClientInfo& ci, int32_t mode, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	/// <summary>
	/// Reserved.
	/// </summary>
	public: virtual void updateTask(const de::elo::ix::client::PClientInfo& ci, const de::elo::ix::client::PUserTask& userTask, TaskNotifyType notifyType)  = 0;
	public: virtual void updateTask(const de::elo::ix::client::PClientInfo& ci, const de::elo::ix::client::PUserTask& userTask, TaskNotifyType notifyType, ::std::function< void (bool, BException ex) > asyncResult)  = 0;
	
	
};

}}}}}
//-------------------------------------------------
// Skeleton class BSkeleton_ClientNotification
// Your interface implementation class has to be derived from this skeleton.
// Either provide an asynchronous or a synchronous function in your subclass.

namespace de { namespace elo { namespace ix { namespace client { namespace notify { 

using namespace ::byps;

class BSkeleton_ClientNotification;
typedef byps_ptr<BSkeleton_ClientNotification> PSkeleton_ClientNotification;

class BSkeleton_ClientNotification : public BSkeleton, public virtual ClientNotification {
	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: virtual void adminMode(const de::elo::ix::client::PClientInfo& ci, int32_t mode) ;
	public: virtual void adminMode(const de::elo::ix::client::PClientInfo& ci, int32_t mode, ::std::function< void (bool, BException ex) > asyncResult) ;
	
	public: virtual void updateTask(const de::elo::ix::client::PClientInfo& ci, const de::elo::ix::client::PUserTask& userTask, TaskNotifyType notifyType) ;
	public: virtual void updateTask(const de::elo::ix::client::PClientInfo& ci, const de::elo::ix::client::PUserTask& userTask, TaskNotifyType notifyType, ::std::function< void (bool, BException ex) > asyncResult) ;
	
	
};
}}}}}

//-------------------------------------------------
// Stub class BStub_ClientNotification

namespace de { namespace elo { namespace ix { namespace client { namespace notify { 

using namespace ::byps;

class BStub_ClientNotification;
typedef byps_ptr<BStub_ClientNotification> PStub_ClientNotification;

class BStub_ClientNotification : public BStub, public virtual ClientNotification {
	
	public: BStub_ClientNotification(PTransport transport);	
	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: virtual void adminMode(const de::elo::ix::client::PClientInfo& ci, int32_t mode) ;
	public: virtual void adminMode(const de::elo::ix::client::PClientInfo& ci, int32_t mode, ::std::function< void (bool, BException ex) > asyncResult) ;
	public: virtual void updateTask(const de::elo::ix::client::PClientInfo& ci, const de::elo::ix::client::PUserTask& userTask, TaskNotifyType notifyType) ;
	public: virtual void updateTask(const de::elo::ix::client::PClientInfo& ci, const de::elo::ix::client::PUserTask& userTask, TaskNotifyType notifyType, ::std::function< void (bool, BException ex) > asyncResult) ;
	
};
}}}}}


//-------------------------------------------------
// SystemInformation

namespace de { namespace elo { namespace ix { namespace client { namespace system { 

using namespace ::byps;

class SystemInformation : public virtual BRemote {
	
	public: virtual PArchivReport archivReport(const de::elo::ix::client::PClientInfo& ci, const PSystemInfo& si)  = 0;
	public: virtual void archivReport(const de::elo::ix::client::PClientInfo& ci, const PSystemInfo& si, ::std::function< void (PArchivReport, BException ex) > asyncResult)  = 0;
	
	public: virtual PSystemReport countDocsInStorePath(const de::elo::ix::client::PClientInfo& ci, const PSystemInfo& si)  = 0;
	public: virtual void countDocsInStorePath(const de::elo::ix::client::PClientInfo& ci, const PSystemInfo& si, ::std::function< void (PSystemReport, BException ex) > asyncResult)  = 0;
	
	public: virtual PLicenseReport licenseReport(const de::elo::ix::client::PClientInfo& ci, const PSystemInfo& si)  = 0;
	public: virtual void licenseReport(const de::elo::ix::client::PClientInfo& ci, const PSystemInfo& si, ::std::function< void (PLicenseReport, BException ex) > asyncResult)  = 0;
	
	public: virtual PUserReport userReport(const de::elo::ix::client::PClientInfo& ci, const PSystemInfo& si)  = 0;
	public: virtual void userReport(const de::elo::ix::client::PClientInfo& ci, const PSystemInfo& si, ::std::function< void (PUserReport, BException ex) > asyncResult)  = 0;
	
	
};

}}}}}

//-------------------------------------------------
// SystemInformationAuth

namespace de { namespace elo { namespace ix { namespace client { namespace system { 

using namespace ::byps;

class SystemInformationAuth : public virtual BRemote {
	
	public: virtual PArchivReport archivReport(const PSystemInfo& si)  = 0;
	public: virtual void archivReport(const PSystemInfo& si, ::std::function< void (PArchivReport, BException ex) > asyncResult)  = 0;
	
	public: virtual PSystemReport countDocsInStorePath(const PSystemInfo& si)  = 0;
	public: virtual void countDocsInStorePath(const PSystemInfo& si, ::std::function< void (PSystemReport, BException ex) > asyncResult)  = 0;
	
	public: virtual PLicenseReport licenseReport(const PSystemInfo& si)  = 0;
	public: virtual void licenseReport(const PSystemInfo& si, ::std::function< void (PLicenseReport, BException ex) > asyncResult)  = 0;
	
	public: virtual PUserReport userReport(const PSystemInfo& si)  = 0;
	public: virtual void userReport(const PSystemInfo& si, ::std::function< void (PUserReport, BException ex) > asyncResult)  = 0;
	
	
};

}}}}}
//-------------------------------------------------
// Stub class BStub_SystemInformation

namespace de { namespace elo { namespace ix { namespace client { namespace system { 

using namespace ::byps;

class BStub_SystemInformation;
typedef byps_ptr<BStub_SystemInformation> PStub_SystemInformation;

class BStub_SystemInformation : public BStub, public virtual SystemInformationAuth {
	
	public: BStub_SystemInformation(PTransport transport);	
	
	public: virtual BTYPEID BSerializable_getTypeId();
	public: virtual PArchivReport archivReport(const PSystemInfo& si) ;
	public: virtual void archivReport(const PSystemInfo& si, ::std::function< void (PArchivReport, BException ex) > asyncResult) ;
	public: virtual PSystemReport countDocsInStorePath(const PSystemInfo& si) ;
	public: virtual void countDocsInStorePath(const PSystemInfo& si, ::std::function< void (PSystemReport, BException ex) > asyncResult) ;
	public: virtual PLicenseReport licenseReport(const PSystemInfo& si) ;
	public: virtual void licenseReport(const PSystemInfo& si, ::std::function< void (PLicenseReport, BException ex) > asyncResult) ;
	public: virtual PUserReport userReport(const PSystemInfo& si) ;
	public: virtual void userReport(const PSystemInfo& si, ::std::function< void (PUserReport, BException ex) > asyncResult) ;
	
};
}}}}}


//-------------------------------------------------
namespace de { namespace elo { namespace ix { namespace client { 

class BRegistry_Indexserver : public BRegistry { 
public:
	BRegistry_Indexserver();
	virtual ~BRegistry_Indexserver() {}
};

}}}}

namespace de { namespace elo { namespace ix { namespace client { 
using namespace ::byps;

class BApiDescriptor_Indexserver { 
	/**
	 * API serialisation version: 10.17.80.3
	 */
	public: const static int64_t VERSION = 1000170080000003LL;
	public: static PApiDescriptor instance();
};

}}}}

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

class BClient_Indexserver;
typedef byps_ptr<BClient_Indexserver> PClient_Indexserver;

class BClient_Indexserver : public BClient { 

	public: static PClient_Indexserver createClient(PTransportFactory transportFactory);
	
	public: static PClient_Indexserver createClientR(PTransport transport);
	
	public: void addRemote(PSkeleton_IXEventBusHandler remoteSkeleton);
	
	public: void addRemote(PSkeleton_IXServerEvents remoteSkeleton);
	
	public: void addRemote(de::elo::ix::client::feed::PSkeleton_FeedNotification remoteSkeleton);
	
	public: void addRemote(de::elo::ix::client::notify::PSkeleton_ClientNotification remoteSkeleton);
	
	protected: BClient_Indexserver(PTransportFactory transportFactory); 
	
	protected: BClient_Indexserver(PTransport transport); 
	
	public: virtual ~BClient_Indexserver() {}
	
	virtual de::elo::ix::client::PIXEventBusHandler getIXEventBusHandler();	
	virtual de::elo::ix::client::PIXServerEvents getIXServerEvents();	
	virtual de::elo::ix::client::PIXServicePortIFAuth getIXServicePortIF();	
	virtual de::elo::ix::client::compatibility::PRawStreamServiceAuth getRawStreamService();	
	virtual de::elo::ix::client::compatibility::PWClientServiceAuth getWClientService();	
	virtual de::elo::ix::client::feed::PFeedNotification getFeedNotification();	
	virtual de::elo::ix::client::feed::PFeedServiceAuth getFeedService();	
	virtual de::elo::ix::client::health::PHealthCheckServiceAuth getHealthCheckService();	
	virtual de::elo::ix::client::myelo::PMyELOServiceAuth getMyELOService();	
	virtual de::elo::ix::client::notify::PClientNotification getClientNotification();	
	virtual de::elo::ix::client::system::PSystemInformationAuth getSystemInformation();	
	
	public: virtual PRemote getStub(int remoteId);
	
	protected: de::elo::ix::client::PIXEventBusHandler iXEventBusHandler;
	protected: de::elo::ix::client::PIXServerEvents iXServerEvents;
	protected: de::elo::ix::client::PIXServicePortIFAuth iXServicePortIF;
	protected: de::elo::ix::client::compatibility::PRawStreamServiceAuth rawStreamService;
	protected: de::elo::ix::client::compatibility::PWClientServiceAuth wClientService;
	protected: de::elo::ix::client::feed::PFeedNotification feedNotification;
	protected: de::elo::ix::client::feed::PFeedServiceAuth feedService;
	protected: de::elo::ix::client::health::PHealthCheckServiceAuth healthCheckService;
	protected: de::elo::ix::client::myelo::PMyELOServiceAuth myELOService;
	protected: de::elo::ix::client::notify::PClientNotification clientNotification;
	protected: de::elo::ix::client::system::PSystemInformationAuth systemInformation;
	
	private: void initStubs(PTransport transport);
	
};

}}}}

namespace de { namespace elo { namespace ix { namespace client { 

using namespace ::byps;

class BServer_Indexserver;
typedef byps_ptr<BServer_Indexserver> PServer_Indexserver;

class BServer_Indexserver : public BServer { 

	public: static PServer_Indexserver createServer(PTransportFactory transportFactory);
	
	public: static PServer_Indexserver createServerR(PTransport transport);
	
	public: void addRemote(PSkeleton_IXEventBusHandler remoteSkeleton);
	
	public: void addRemote(PSkeleton_IXServerEvents remoteSkeleton);
	
	public: void addRemote(de::elo::ix::client::feed::PSkeleton_FeedNotification remoteSkeleton);
	
	public: void addRemote(de::elo::ix::client::notify::PSkeleton_ClientNotification remoteSkeleton);
	
	protected: BServer_Indexserver(PTransportFactory transportFactory); 
	
	protected: BServer_Indexserver(PTransport transport); 
	
};

}}}}


#endif
